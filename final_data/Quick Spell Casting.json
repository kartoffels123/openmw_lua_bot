{
  "folder_name": "Quick Spell Casting",
  "lua_files": {
    "QuickSpellCasting 0.5-52130-0-5-1726135710\\QuickSpellCasting_0.5\\scripts\\QuickSpellCast\\global.lua": "local I = require('openmw.interfaces')\n\nI.Settings.registerGroup({\n   key = 'Settings_urm_QuickSpellCast_Gameplay',\n   page = 'urm_QuickSpellCast',\n   l10n = 'urm_QuickSpellCast',\n   name = 'gameplay_group_name',\n   permanentStorage = false,\n   settings = {\n      {\n         key = 'stanceAnimationSpeedup',\n         default = 2.5,\n         name = 'stanceAnimationSpeedup_name',\n         renderer = 'number',\n         argument = {\n            min = 0.01,\n         },\n      },\n   },\n})\n",
    "QuickSpellCasting 0.5-52130-0-5-1726135710\\QuickSpellCasting_0.5\\scripts\\QuickSpellCast\\player.lua": "local core = require('openmw.core')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal input = require('openmw.input')\nlocal animation = require('openmw.animation')\nlocal storage = require('openmw.storage')\n\nlocal I = require('openmw.interfaces')\n\nI.Settings.registerPage({\n   key = 'urm_QuickSpellCast',\n   l10n = 'urm_QuickSpellCast',\n   name = 'name',\n   description = 'description',\n})\n\nI.Settings.registerGroup({\n   key = 'Settings_urm_QuickSpellCast',\n   page = 'urm_QuickSpellCast',\n   l10n = 'urm_QuickSpellCast',\n   name = 'input_group_name',\n   permanentStorage = false,\n   settings = {\n      {\n         key = 'castWithReadyMagick',\n         default = true,\n         renderer = 'checkbox',\n         name = 'castWithReadyMagick_name',\n      },\n      {\n         key = 'castWithQuickKeys',\n         default = true,\n         renderer = 'checkbox',\n         name = 'castWithQuickKeys_name',\n         description = 'castWithQuickKeys_description',\n      },\n      {\n         key = 'debug',\n         default = false,\n         renderer = 'checkbox',\n         name = 'debug_name',\n      },\n   },\n})\n\nlocal settingsGroup = storage.playerSection('Settings_urm_QuickSpellCast')\nlocal gameplaySettings = storage.globalSection('Settings_urm_QuickSpellCast_Gameplay')\n\nlocal function debugOnly(f)\n   if not settingsGroup:get('debug') then return end\n   f()\nend\n\n\nlocal STANCE = types.Actor.STANCE\n\nlocal STAGES = {\n   Idle = 0,\n   SpellStance = 1,\n   WaitForStance = 2,\n   Use = 3,\n   WaitForCast = 4,\n   RevertStance = 5,\n   EnforceStance = 6,\n}\n\nlocal function enumName(value, enum)\n   for name, v in pairs(enum) do\n      if v == value then return name end\n   end\n   error('invalid enum value', value)\nend\n\n\n\n\n\n\n\n\n\n\n\n\nlocal selfObject = self\n\n\nlocal function currentActive()\n   local item = types.Actor.getSelectedEnchantedItem(selfObject)\n   local spell = types.Actor.getSelectedSpell(selfObject)\n   return item and item.id or (spell and spell.id)\nend\nlocal previousActive = currentActive()\n\nlocal stageHandlers = {\n   [STAGES.Idle] = function(state)\n      if state.queuedCast then\n         state.stage = STAGES.WaitForStance\n         state.waitingForSpellStance = true\n      else\n         previousActive = currentActive()\n         state.previousStance = types.Actor.getStance(selfObject)\n      end\n   end,\n   [STAGES.SpellStance] = function(state)\n      state.shouldSpeedUp = true\n      if currentActive() == nil then\n         state.stage = STAGES.EnforceStance\n      elseif types.Actor.getStance(selfObject) ~= STANCE.Spell then\n         types.Actor.setStance(selfObject, STANCE.Spell)\n      else\n         state.stage = STAGES.WaitForStance\n         state.waitingForSpellStance = true\n      end\n   end,\n   [STAGES.WaitForStance] = function(state)\n      if not state.waitingForSpellStance then\n         state.stage = STAGES.Use\n      end\n   end,\n   [STAGES.Use] = function(state)\n      self.controls.use = 1\n      state.stage = STAGES.WaitForCast\n      state.waitingForCast = true\n   end,\n   [STAGES.WaitForCast] = function(state)\n      if\nnot state.waitingForCast or\n         not state.startedCast then\n\n         state.stage = STAGES.RevertStance\n         state.waitingForRevertedStance = true\n         state.waitingForCast = false\n         state.startedCast = false\n      end\n   end,\n   [STAGES.RevertStance] = function(state)\n      if state.previousStance == STANCE.Spell then\n         state.waitingForRevertedStance = false\n      end\n      if types.Actor.getStance(selfObject) ~= state.previousStance then\n         types.Actor.setStance(selfObject, state.previousStance)\n      end\n      if not state.waitingForRevertedStance then\n         state.stage = STAGES.EnforceStance\n      end\n   end,\n   [STAGES.EnforceStance] = function(state)\n\n\n      if types.Actor.getStance(selfObject) ~= state.previousStance then\n         types.Actor.setStance(selfObject, state.previousStance)\n      end\n      state.stage = STAGES.Idle\n      state.shouldSpeedUp = false\n      state.waitingForRevertedStance = false\n      state.queuedCast = false\n   end,\n}\n\nlocal state = {\n   stage = STAGES.Idle,\n   queuedCast = false,\n   previousStance = STANCE.Nothing,\n   waitingForSpellStance = false,\n   waitingForCast = false,\n   waitingForRevertedStance = false,\n   startedCast = false,\n   shouldSpeedUp = false,\n}\n\nlocal spellAnimationTypes = {\n   ['target'] = true,\n   ['self'] = true,\n   ['touch'] = true,\n}\nlocal equipPrefix = 'equip'\nlocal stopSuffix = ' stop'\n\nI.AnimationController.addTextKeyHandler('spellcast', function(groupName, key)\n   local completed = (animation.getCompletion(selfObject, groupName) or 1) == 1\n   if completed and key == 'equip stop' then\n      state.waitingForSpellStance = false\n   else\n      local isSpell = spellAnimationTypes[key:match('[^ ]+')]\n      if state.waitingForCast and isSpell then\n         state.startedCast = true\n      end\n      local isStop = key:sub(-#stopSuffix) == stopSuffix\n      if isSpell and isStop and completed then\n         state.waitingForCast = false\n      end\n   end\n   if state.shouldSpeedUp then\n      local speedChange = gameplaySettings:get('stanceAnimationSpeedup')\n      if speedChange ~= 1 and key:sub(1, #equipPrefix) == equipPrefix then\n         animation.setSpeed(selfObject, groupName, speedChange)\n      end\n   end\nend)\n\nI.AnimationController.addTextKeyHandler('spellcast', function(groupName, key)\n   if state.waitingForRevertedStance then\n      local completed = (animation.getCompletion(selfObject, groupName) or 1) == 1\n      debugOnly(function() print(groupName, key, completed) end)\n      if key == 'unequip stop' and completed then\n         state.waitingForRevertedStance = false\n      end\n   end\nend)\n\nlocal quickKeyActions = {}\nfor i = 1, 10 do\n   quickKeyActions[(input.ACTION)['QuickKey' .. tostring(i)]] = true\nend\n\nlocal function castInput(skipStance)\n   if state.stage ~= STAGES.Idle then\n      state.queuedCast = true\n   elseif skipStance and state.previousStance == STANCE.Spell then\n      state.stage = STAGES.Use\n   else\n      state.stage = STAGES.SpellStance\n   end\nend\n\nlocal previousStage = state.stage\n\nlocal function magicControlSwitch()\n   return types.Player.getControlSwitch(self.object, types.Player.CONTROL_SWITCH.Controls) and\n   types.Player.getControlSwitch(self.object, types.Player.CONTROL_SWITCH.Magic)\nend\n\n\n\nreturn {\n   engineHandlers = {\n      onInputAction = function(action)\n         if not magicControlSwitch() then\n            return\n         end\n         if action == input.ACTION.ToggleSpell and settingsGroup:get('castWithReadyMagick') then\n            castInput(false)\n         elseif quickKeyActions[action] and settingsGroup:get('castWithQuickKeys') then\n\n            if currentActive() ~= previousActive or types.Actor.getStance(selfObject) == STANCE.Spell then\n               castInput(true)\n               previousActive = currentActive()\n            end\n         end\n      end,\n      onFrame = function()\n         if core.isWorldPaused() then return end\n         debugOnly(function()\n            if previousStage ~= state.stage then\n               print('SWITCHED TO', enumName(state.stage, STAGES), 'PREVIOUS STANCE', enumName(state.previousStance, types.Actor.STANCE))\n            end\n            previousStage = state.stage\n         end)\n         stageHandlers[state.stage](state)\n      end,\n      onSave = function()\n         return state\n      end,\n      onLoad = function(savedState)\n         if not savedState then return end\n         state.stage = math.min(savedState.stage, STAGES.Use)\n         state.previousStance = savedState.previousStance\n\n\n         state.waitingForSpellStance = false\n         state.waitingForCast = false\n         state.startedCast = false\n         state.shouldSpeedUp = false\n         state.queuedCast = false\n      end,\n   },\n}\n"
  }
}