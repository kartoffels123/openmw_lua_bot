{
  "folder_name": "Take Cover (OpenMW)",
  "lua_files": {
    "TakeCover-54976-1-2-1726579203\\00 Core\\scripts\\TakeCover\\actor.lua": "local self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal ai = require('openmw.interfaces').AI\n\nlocal S = require('scripts.TakeCover.settings')\nlocal U = require('scripts.TakeCover.util')\n\nlocal interfaceVersion = 1.0\nlocal updateRate = 0.5\nlocal seenUpdateRate = 0.1\nlocal lastUpdateTime = 0\nlocal lastFleeTime = 0\nlocal turnAroundAndSneak = false\n\nlocal selfRecord = U.getRecord(self)\nlocal actorId = selfRecord.id\nlocal actorCanFly = selfRecord.canFly\n\nlocal state = {\n    handled = false,\n    fleeing = false,\n    stopped = false,\n    hidden = false,\n    healthHidden = nil,\n    fleeDuringSec = 0,\n}\n\nlocal target\n\n-- Ensure the actor will flee if he cannot attack the player\nlocal function flee()\n    if state.fleeing then return end\n    U.debugPrint(string.format(\"Actor \\\"%s\\\" is probably fleeing\", actorId))\n    state.fleeing = true\nend\n\nlocal function unFlee()\n    if not state.fleeing then return end\n    U.debugPrint(string.format(\"Actor \\\"%s\\\" has probably stopped fleeing\", actorId))\n    state.fleeing = false\nend\n\nlocal function stop()\n    if state.stopped then return end\n    U.debugPrint(string.format(\"Actor \\\"%s\\\" stops his AI\", actorId))\n    self:enableAI(false)\n    state.stopped = true\nend\n\nlocal function unStop()\n    if not state.stopped then return end\n    U.debugPrint(string.format(\"Actor \\\"%s\\\" resumes his AI\", actorId))\n    self.controls.sneak = false\n    self:enableAI(true)\n    state.stopped = false\nend\n\nlocal function hide()\n    stop()\n    unFlee()\n    if state.hidden then return end\n    U.debugPrint(string.format(\"Actor \\\"%s\\\" hides himself\", actorId))\n    state.healthHidden = types.Actor.stats.dynamic.health(self).current\n    turnAroundAndSneak = true\n    state.hidden = true\nend\n\nlocal function unHide()\n    unStop()\n    if not state.hidden then return end\n    U.debugPrint(string.format(\"Actor \\\"%s\\\" stops hiding himself\", actorId))\n    state.healthHidden = nil\n    state.hidden = false\nend\n\nlocal function isAttackedWhileHidden()\n    if state.healthHidden ~= types.Actor.stats.dynamic.health(self).current then\n        state.fleeDuringSec = 5\n        U.debugPrint(string.format(\"Actor \\\"%s\\\" is attacked while hidden\", actorId))\n        return true\n    end\n    return false\nend\n\nlocal function getCombatTarget()\n    local aiPackage = ai.getActivePackage()\n    return (aiPackage and aiPackage.type == \"Combat\") and aiPackage.target or nil\nend\n\nlocal function crouch(deltaTime)\n    if not turnAroundAndSneak then return end\n    if not target then\n        turnAroundAndSneak = false\n    else\n        turnAroundAndSneak = U.turnAround(self, target, deltaTime)\n        if not turnAroundAndSneak and state.stopped then\n            self.controls.sneak = true\n        end\n    end\nend\n\nlocal function handleFleeing(deltaTime)\n    if not state.fleeing or target == nil then return end\n\n    lastFleeTime = lastFleeTime + deltaTime\n    if lastFleeTime < seenUpdateRate or lastFleeTime < state.fleeDuringSec then return end\n\n    if not U.seenByTarget(self, actorId, target) then\n        hide()\n    end\n    lastFleeTime = 0\n    state.fleeDuringSec = 0\nend\n\nlocal function unHandle()\n    unFlee()\n    unHide()\n    state.handled = false\nend\n\nlocal function onUpdate(deltaTime)\n    if not state.handled then return end\n\n    crouch(deltaTime)\n    handleFleeing(deltaTime)\n\n    lastUpdateTime = lastUpdateTime + deltaTime\n\n    if lastUpdateTime < updateRate then return end\n\n    lastUpdateTime = 0\n\n    if not types.Actor.isInActorsProcessingRange(self) then\n        unHandle()\n        return\n    end\n    if U.isLevitating(self) then\n        U.debugPrint(string.format(\"Actor \\\"%s\\\" is levitating\", actorId))\n        unHandle()\n        return\n    end\n    if actorCanFly then\n        --U.debugPrint(string.format(\"Actor \\\"%s\\\" can fly\", actorId))\n        unHandle()\n        return\n    end\n\n    local prevTarget = target\n\n    target = getCombatTarget()\n\n    if not target then\n        if prevTarget then\n            U.debugPrint(string.format(\"Target %s dropped for actor \\\"%s\\\"\", prevTarget.id, actorId))\n        end\n        unHandle()\n        return\n    end\n\n    if state.hidden and (isAttackedWhileHidden() or U.seenByTarget(self, actorId, target)) then\n        unHide()\n    end\n\n    local targetIsRangedAttack, _ = U.getAttackInfo(target)\n\n    if not targetIsRangedAttack or U.canAttackTarget(self, actorId, target) then\n        unHandle()\n        return\n    end\n\n    if not state.hidden then\n        flee()\n    end\nend\n\nlocal function handle()\n    state.handled = true\nend\n\nlocal function onSave()\n    if state.handled then\n        return {\n            state = state\n        }\n    end\nend\n\nlocal function onLoad(data)\n    state = (data and data.state) and data.state or state\n    if state.stopped then\n        -- Restore lost disabled AI state\n        state.stopped = false\n        stop()\n    end\nend\n\nlocal function IsFleeing()\n    return state.fleeing\nend\n\nlocal function IsHidden()\n    return state.hidden\nend\n\nreturn {\n    engineHandlers = {\n        onUpdate = onUpdate,\n        onSave = onSave,\n        onLoad = onLoad,\n    },\n    eventHandlers = {\n        handle = handle,\n    },\n    interfaceName = S.MOD_NAME,\n    interface = {\n        version = interfaceVersion,\n        IsFleeing = IsFleeing,\n        IsHidden = IsHidden,\n    }\n}\n",
    "TakeCover-54976-1-2-1726579203\\00 Core\\scripts\\TakeCover\\global.lua": "local S = require('scripts.TakeCover.settings')\nS.initSettings()",
    "TakeCover-54976-1-2-1726579203\\00 Core\\scripts\\TakeCover\\player.lua": "local I = require(\"openmw.interfaces\")\nlocal nearby = require('openmw.nearby')\n\nlocal S = require('scripts.TakeCover.settings')\n\nI.Settings.registerPage {\n    key = S.MOD_NAME,\n    l10n = S.MOD_NAME,\n    name = \"name\",\n    description = \"description\",\n}\n\nlocal updateRate = 0.5\nlocal lastUpdateTime = 0\nlocal onUpdate = function(deltaTime)\n    if not S.isLuaApiRecentEnough or not S.globalStorage:get(\"enabled\") then return end\n\n    lastUpdateTime = lastUpdateTime + deltaTime\n    if lastUpdateTime < updateRate then return end\n    lastUpdateTime = 0\n\n    for _, actor in pairs(nearby.actors) do\n        actor:sendEvent(\"handle\")\n    end\nend\n\nreturn {\n    engineHandlers = {\n        onUpdate = onUpdate,\n    },\n}\n",
    "TakeCover-54976-1-2-1726579203\\00 Core\\scripts\\TakeCover\\settings.lua": "local core = require('openmw.core')\nlocal I = require(\"openmw.interfaces\")\nlocal storage = require('openmw.storage')\n\nlocal MOD_NAME = \"TakeCover\"\nlocal isLuaApiRecentEnough = core.API_REVISION >= 68\nlocal isOpenMW049 = core.API_REVISION > 29\n\nlocal globalSettingsKey = \"SettingsGlobal\" .. MOD_NAME\n\nlocal function getDescriptionIfOpenMWTooOld(key)\n    if not isLuaApiRecentEnough then\n        if isOpenMW049 then\n            return \"requiresNewerOpenmw49\"\n        else\n            return \"requiresOpenmw49\"\n        end\n    end\n    return key\nend\n\nlocal settingGroups = {\n    [globalSettingsKey] = {\n        key = globalSettingsKey,\n        l10n = MOD_NAME,\n        name = \"settingsTitle\",\n        page = MOD_NAME,\n        order = 0,\n        description = getDescriptionIfOpenMWTooOld(\"settingsDesc\"),\n        permanentStorage = false,\n        settings = {\n            {\n                key = \"enabled\",\n                name = \"enabled_name\",\n                description = getDescriptionIfOpenMWTooOld(\"\"),\n                default = true,\n                renderer = \"checkbox\",\n                argument = {\n                    disabled = not isLuaApiRecentEnough,\n                }\n            },\n            {\n                key = \"debugMode\",\n                name = \"debugMode_name\",\n                default = false,\n                renderer = \"checkbox\",\n            },\n        },\n    },\n}\n\nlocal function getStorage(key)\n    return storage.globalSection(key)\nend\n\nlocal function getSetting(groupKey, settingKey)\n    local group = settingGroups[groupKey]\n    if group ~= nil then\n        for _, setting in ipairs(group.settings) do\n            if setting.key == settingKey then\n                return setting\n            end\n        end\n    end\n    print(string.format(\"Cannot find setting %s in group %s\", settingKey, groupKey))\n    return nil\nend\n\nlocal function setSetting(groupKey, settingKey, value)\n    local setting = getSetting(groupKey, settingKey)\n    if setting ~= nil then\n        getStorage(groupKey):set(settingKey, value)\n    end\n    return nil\nend\n\nlocal function initSettings()\n    I.Settings.registerGroup(settingGroups[globalSettingsKey])\n\n    if not isLuaApiRecentEnough then\n        setSetting(globalSettingsKey, \"enabled\", false)\n    end\nend\n\nreturn {\n    MOD_NAME = MOD_NAME,\n    isLuaApiRecentEnough = isLuaApiRecentEnough,\n    initSettings = initSettings,\n    -- Storages\n    globalStorage = getStorage(globalSettingsKey),\n}\n",
    "TakeCover-54976-1-2-1726579203\\00 Core\\scripts\\TakeCover\\util.lua": "local core = require('openmw.core')\nlocal types = require('openmw.types')\nlocal util = require(\"openmw.util\")\nlocal nearby = require('openmw.nearby')\n\nlocal S = require('scripts.TakeCover.settings')\n\nlocal pi = math.rad(180)\nlocal fCombatDistance = core.getGMST(\"fCombatDistance\")\nlocal fHandToHandReach = core.getGMST(\"fHandToHandReach\")\n\nlocal function debugPrint(str)\n    if S.globalStorage:get(\"debugMode\") then\n        print(\"DEBUG: \" .. str)\n    end\nend\n\nlocal function getRecord(item)\n    if item.type and item.type.record then\n        return item.type.record(item)\n    end\n    return nil\nend\n\nlocal function getItemEffects(item)\n    local record = getRecord(item)\n    if record and record.enchant then\n        return core.magic.enchantments.records[record.enchant].effects\n    end\n    return nil\nend\n\nlocal function hasTargetEffect(effects)\n    for _, effect in ipairs(effects) do\n        if effect.range == core.magic.RANGE.Target and effect.effect.harmful then\n            return true\n        end\n    end\n    return false\nend\n\nlocal function isLevitating(actor)\n    return types.Actor.activeEffects(actor):getEffect(\"levitate\").magnitude ~= 0\nend\n\n-- Return isRanged, meleeReach\nlocal function getAttackInfo(actor)\n    local stance = types.Actor.getStance(actor)\n\n    if stance == types.Actor.STANCE.Nothing then\n        return false, 0.0\n    end\n\n    if stance == types.Actor.STANCE.Weapon then\n        local item = types.Actor.getEquipment(actor, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n        if item == nil or item.type ~= types.Weapon then\n            return false, fHandToHandReach * fCombatDistance\n        end\n        local weapon = types.Weapon.record(item)\n        return weapon.type == types.Weapon.TYPE.MarksmanBow\n                or weapon.type == types.Weapon.TYPE.MarksmanCrossbow\n                or weapon.type == types.Weapon.TYPE.MarksmanThrown,\n        weapon.reach * fCombatDistance\n    end\n\n    local spell = types.Actor.getSelectedSpell(actor)\n    if spell ~= nil then\n        return hasTargetEffect(spell.effects), fCombatDistance\n    else\n        local item = types.Actor.getSelectedEnchantedItem(actor)\n        if item == nil then\n            return false, 0.0\n        end\n        local effects = getItemEffects(item)\n        return hasTargetEffect(effects), fCombatDistance\n    end\nend\n\nlocal function canAttackTarget(actor, actorId, target)\n    if target == nil then return false end\n\n    local isRanged, meleeReach = getAttackInfo(actor)\n    if isRanged then\n        return true\n    end\n\n    -- Find nearest navigation path to reach to the player\n    local status, path = nearby.findPath(actor.position, target.position, {\n        agentBounds = types.Actor.getPathfindingAgentBounds(actor),\n        destinationTolerance = 0,\n    })\n    if status ~= nearby.FIND_PATH_STATUS.Success or path == nil or #path == 0 then\n        return\n    end\n\n    -- If there is a path, it might not be sufficient to reach the player with a melee attack\n    local actorBounds = types.Actor.getPathfindingAgentBounds(actor)\n    local targetBounds = types.Actor.getPathfindingAgentBounds(target)\n    -- We use the closest point to the player and compute if the actor car hit the player (with a weapon, hands or spell)\n    local boundingDist = (target.position - path[#path]):length() - actorBounds.halfExtents.y - targetBounds.halfExtents.y\n    debugPrint(string.format(\"Actor \\\"%s\\\" could be at distance %s from target, %s to attack\", actorId,\n            boundingDist, boundingDist - meleeReach))\n    return boundingDist - meleeReach <= 0\nend\n\nlocal function castRay(from, to, actor, targetId, target)\n    -- Start ray from distance to the actor to prevent detecting himself\n    local result = nearby.castRay(\n            from,\n            to,\n            {\n                collisionType = nearby.COLLISION_TYPE.AnyPhysical,\n                ignore = actor,\n            }\n    )\n    if result.hitObject == nil then\n        -- Happens, but shouldn't, might be a false negative\n        debugPrint(string.format(\"Actor \\\"%s\\\" sees nothing at all\", actor.id))\n        return true\n    end\n\n    if result.hitObject.id == target.id then\n        debugPrint(string.format(\"Actor \\\"%s\\\" sees his enemy \\\"%s\\\"\", actor.id, targetId))\n        return true\n    else\n        debugPrint(string.format(\"Actor \\\"%s\\\" sees a \\\"%s\\\" with id \\\"%s\\\"\",\n                actor.id, result.hitObject.type, result.hitObject.id))\n        return false\n    end\n\nend\n\nlocal function seenByTarget(actor, actorId, target)\n    local actorBox = actor:getBoundingBox()\n    local actorHead = actorBox.center + util.vector3(0, 0, actorBox.halfSize.z * .8)\n    local targetBox = target:getBoundingBox()\n    local targetHead = targetBox.center + util.vector3(0, 0, targetBox.halfSize.z * .8)\n\n    if castRay(targetHead, actorHead, target, actorId, actor) then\n        return true\n    end\n\n    local actorTorso = actorBox.center + util.vector3(0, 0, actorBox.halfSize.z / 2)\n    local actorLeftShoulder = actorTorso\n            + util.transform.rotateZ(target.rotation:getYaw())\n            * util.vector3(actorBox.halfSize.x * .8, 0, 0)\n\n    if castRay(targetHead, actorLeftShoulder, target, actorId, actor) then\n        return true\n    end\n\n    local actorRightShoulder = actorTorso\n            + util.transform.rotateZ(target.rotation:getYaw() + pi)\n            * util.vector3(actorBox.halfSize.x * .8, 0, 0)\n    if castRay(targetHead, actorRightShoulder, target, actorId, actor) then\n        return true\n    end\n\n    local actorFeet = actorBox.center - util.vector3(0, 0, -actorBox.halfSize.z * .6)\n    return castRay(targetHead, actorFeet, target, actorId, actor)\nend\n\nlocal function turnAround(actor, target, deltaTime)\n    actor.controls.movement = 0\n    actor.controls.sideMovement = 0\n    local deltaPos = target.position - actor.position\n    local destVec = util.vector2(deltaPos.x, deltaPos.y):rotate(actor.rotation:getYaw())\n    local deltaYaw = math.atan2(destVec.x, destVec.y)\n    if math.abs(deltaYaw) > math.rad(30) then\n        actor.controls.yawChange = util.clamp(deltaYaw, -deltaTime * 5, deltaTime * 5)\n        return true\n    else\n        actor.controls.yawChange = 0\n        return false\n    end\nend\n\nreturn {\n    debugPrint = debugPrint,\n    getRecord = getRecord,\n    isLevitating = isLevitating,\n    getAttackInfo = getAttackInfo,\n    canAttackTarget = canAttackTarget,\n    seenByTarget = seenByTarget,\n    turnAround = turnAround,\n}"
  }
}