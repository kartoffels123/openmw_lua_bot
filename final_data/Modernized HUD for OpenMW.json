{
  "folder_name": "Modernized HUD for OpenMW",
  "lua_files": {
    "Modernized HUD for OpenMW 0.49-54468-0-5-1714329658\\Modernized UI\\scripts\\combat.lua": "local AI = require(\"openmw.interfaces\").AI\nlocal Actor = require(\"openmw.types\").Actor\nlocal types = require(\"openmw.types\")\nlocal NPC = require(\"openmw.types\").NPC\nlocal Creature = require(\"openmw.types\").Creature\nlocal self = require(\"openmw.self\")\nlocal nearby = require('openmw.nearby')\nlocal API = require('openmw.core').API_REVISION\nlocal isOpenMW49 = API >= 59\n\nlocal lastHealth = 0\nlocal hasStoppedTargetingPlayer = true\nlocal hasBeenKilled = false\nlocal hasBeenTargeted = false\n\nlocal health = Actor.stats.dynamic.health(self)\nlocal level = Actor.stats.level(self).current\nlocal player\nlocal class, name\nlocal id = self.object.id\nlocal numeric_part = id:match(\"0x([%da-fA-F]+)\")\nid = tonumber(numeric_part, 16)\n\nif NPC.objectIsInstance(self) then\n    name = NPC.record(self).name\n    class = NPC.record(self).class\nelse \n    name = Creature.record(self).name\n    class = nil\nend\n\n\n\nlocal function isDead(actor)\n    if isOpenMW49 then\n        return Actor.isDead(actor)\n    else\n        return Actor.stats.dynamic.health(actor).current <= 0\n    end\nend\n\nlocal function onUpdate()\n    if player == nil then\n        if isOpenMW49 then \n            player = nearby.players[1]\n        elseif player == nil then\n            local actors = nearby.actors\n            for i = 1, #actors do\n                if types.Player.objectIsInstance(actors[i]) then\n                    player = actors[i]\n                    break\n                end\n            end\n        end\n    end\n\n    local package = AI.getActivePackage()\n\n    local damage = lastHealth - health.current\n\n    if package.target == player and hasStoppedTargetingPlayer and (package.type == \"Combat\" or package.type == \"Pursue\") and package.sideWithTarget == false then -- Initial event\n        player:sendEvent('SendCombatData', { \n            object = self.object,\n            id = id,\n            health = health.current, \n            maxHealth = health.base, \n            name = name, \n            level = level, \n            class = class, \n            stoppedTargeting = false,\n            hasBeenHealed = false,\n            debug = \"Initial targeting.\",\n        })\n    end\n\n    if package.target == player and (package.type == \"Combat\" or package.type == \"Pursue\") and package.sideWithTarget == false then\n        hasStoppedTargetingPlayer = false\n        if isDead(self) and hasBeenKilled == false then  -- I am dead and targeting the player.\n            player:sendEvent('SendCombatData', { \n                object = self.object,\n                id = id,\n                health = 0, \n                maxHealth = health.base, \n                name = name, \n                level = level, \n                class = class, \n                stoppedTargeting = true,\n                hasBeenHealed = false,\n                debug = name .. \" was killed and was targeting the player.\"\n            })\n            hasBeenKilled = true\n        elseif damage > 0 then -- I have been damaged while targeting the player and when alive.\n            player:sendEvent('SendCombatData', { \n                object = self.object,\n                id = id,\n                health = health.current, \n                maxHealth = health.base, \n                name = name, \n                level = level, \n                class = class, \n                stoppedTargeting = false,\n                hasBeenHealed = false,\n                damageTaken = damage,\n                debug = \"I have been damaged while targeting the player and when alive.\"\n            })\n        elseif damage < 0 then -- I have been healed while targeting the player and when alive.\n            player:sendEvent('SendCombatData', { \n                object = self.object,\n                id = id,\n                health = health.current, \n                maxHealth = health.base, \n                name = name, \n                level = level, \n                class = class, \n                stoppedTargeting = false,\n                hasBeenHealed = true,\n                debug = \"I have been healed while targeting the player and when alive.\"\n            })\n        else \n            -- I am targeting the player.\n        end\n    elseif not hasStoppedTargetingPlayer then -- I have stopped targeting the player and I am alive.\n        player:sendEvent('SendCombatData', { \n            object = self.object,\n            id = id,\n            health = health.current, \n            maxHealth = health.base, \n            name = name, \n            level = level, \n            class = class, \n            stoppedTargeting = true,\n            hasBeenHealed = false,\n            debug = \"I have stopped targeting the player and I am alive.\"\n        })\n        hasStoppedTargetingPlayer = true\n    end\n    lastHealth = health.current\nend\n\nreturn {\n    engineHandlers = {\n\t\tonUpdate = onUpdate\n    }\n}",
    "Modernized HUD for OpenMW 0.49-54468-0-5-1714329658\\Modernized UI\\scripts\\helpers.lua": "local ui = require(\"openmw.ui\")\nlocal time = require('openmw_aux.time')\nlocal util = require('openmw.util')\nlocal v2 = util.vector2\n\nlocal barWidth = 12\nlocal gap = 3\n\nlocal oscillation = 0\n\n-- Templates\nspacer = { type = ui.TYPE.Widget, props = { size = v2(0, gap) } }\n\n-- Helper functions\nfunction smoothstep(a, b, t)\n    local ft = t * t * (3 - 2 * t)\n    return a + ft * (b - a)\nend\n\n-- Function that checks if value is in range and returns bool\nfunction isInRange(value, min, max)\n    return value >= min and value <= max\nend\n\n-- Make a function that oscillates between black and white based on time\nfunction oscillateBackground(deltaTime)\n    oscillation = oscillation + deltaTime\n    local f = 0.2 + math.sin(oscillation) / 4\n    return util.color.rgb(f * (1), f * (0.2), f * (0.2))\nend\n\nfunction l(length)\n\treturn v2(length, barWidth)\nend",
    "Modernized HUD for OpenMW 0.49-54468-0-5-1714329658\\Modernized UI\\scripts\\settings.lua": "local interfaces = require('openmw.interfaces')\nlocal util = require('openmw.util')\nlocal v2 = util.vector2\n\ninterfaces.Settings.registerPage { -- Modernized UI\n    key = 'ModernizedUI',\n\tl10n = 'ModernizedUI',\n    name = 'Modernized HUD',\n    description = 'Version 0.5\\n\\n - by Xander',\n}\n\ninterfaces.Settings.registerGroup { -- Smooth Transitions\n    key = 'MUISmoothTransitions',\n\tl10n = 'ModernizedUI',\n    page = 'ModernizedUI',\n    name = 'Smooth Transitions',\n\torder = 0,\n\t-- description = 'Integer values are not possible to input at the moment, which is why the number inputs had to be scaled up by a factor of 10.',\n    permanentStorage = true,\n    settings = {\n\t\t{\n\t\t\tkey = 'SmoothTransitions',\n\t\t\trenderer = 'checkbox',\n\t\t\tname = 'Smooth Transitions',\n\t\t\tdescription = 'When toggled on, the bars will smoothly transition. This effect may be prone to unnatural behaviour during lagspikes and when switching cells. It is recommended to turn this off if you experience any issues. May also make the restoration overlay on the bars not quite line up when moving quickly.',\n\t\t\tdefault = true,\n\t\t},\n\t\t{\n\t\t\tkey = 'LerpSpeed',\n\t\t\trenderer = 'number',\n\t\t\tname = 'Smoothness & Drain Speed',\n\t\t\tdescription = 'This value determines the \"smoothness\" and how fast the bars will drain. The default value is 32.',\n\t\t\tdefault = 32,\n\t\t},\n    },\n}\n\ninterfaces.Settings.registerGroup { -- Yellow Remainder\n    key = 'MUIYellowRemainder',\n\tl10n = 'ModernizedUI',\n    page = 'ModernizedUI',\n    name = 'Yellow Remainder',\n\torder = 1,\n\t-- description = 'Configuration of the yellow remainder.',\n    permanentStorage = true,\n    settings = {\n        {\n            key = 'YellowRemainder',\n            renderer = 'checkbox',\n            name = 'Yellow Remainder',\n            description = 'This feature is an indicator of recently spent health, fatigue, and magicka. When toggled on, a yellow segment will lag behind the current values, providing a visual representation of recent spendings.',\n            default = true,\n        },\n\t\t{\n\t\t\tkey = 'YellowRemainderTimer',\n\t\t\trenderer = 'number',\n\t\t\tname = 'Timer',\n\t\t\tdescription = 'This value determines how long the yellow segment will remain visible after the player has spent health, fatigue, or magicka. The default value is 10, which equals 1 second.',\n\t\t\tdefault = 10,\n\t\t},\n\t\t{\n\t\t\tkey = 'YellowRemainderDrainSpeed',\n\t\t\trenderer = 'number',\n\t\t\tname = 'Speed',\n\t\t\tdescription = 'This value determines how fast the yellow segment will drain. The default value is 32.',\n\t\t\tdefault = 32,\n\t\t},\n    },\n}\n\ninterfaces.Settings.registerGroup { -- Enemy healthbar\n    key = 'MUIEnemy',\n\tl10n = 'ModernizedUI',\n    page = 'ModernizedUI',\n    name = 'Enemy Healthbar',\n\torder = 2,\n\t--description = 'Enemy Healthbar.',\n    permanentStorage = true,\n    settings = {\n\t\t{\n\t\t\tkey = 'EnableEnemyHealthbar',\n\t\t\trenderer = 'checkbox',\n\t\t\tname = 'Enable Enemy Healthbar',\n\t\t\tdescription = 'Displays the health of the enemy in combat.',\n\t\t\tdefault = true,\n\t\t},\n        {\n            key = 'ShowEnemyLevels',\n            renderer = 'checkbox',\n            name = 'Show Enemy Levels',\n            description = 'Displays the level of the enemy in combat.',\n            default = true,\n        },\n\t\t{\n\t\t\tkey = 'ShowEnemyClass',\n\t\t\trenderer = 'checkbox',\n\t\t\tname = 'Show Enemy Class',\n\t\t\tdescription = 'Displays the class of the enemy in combat.',\n\t\t\tdefault = false,\n\t\t},\n\t\t{\n\t\t\tkey = 'PositionAnchor',\n\t\t\trenderer = 'checkbox',\n\t\t\tname = 'Anchor Healthbar to Enemy',\n\t\t\tdescription = \"When toggled on, the healthbar will be anchored right over your target's head. Otherwise the healthbar will stay put on the screen.\",\n\t\t\tdefault = false,\n\t\t},\n\t\t{\n\t\t\tkey = 'TargetWithCrosshair',\n\t\t\trenderer = 'checkbox',\n\t\t\tname = 'Target Enemy with Crosshair',\n\t\t\tdescription = \"When toggled on, enemies are targeted using the crosshair. Otherwise, it's lika vanilla Morrowind, where you have to damage the enemy to target it.\",\n\t\t\tdefault = false,\n\t\t},\n\t\t{\n\t\t\tkey = 'VerticalOffset',\n\t\t\trenderer = 'number',\n\t\t\tname = 'Vertical Offset',\n\t\t\tdescription = 'Negative values move the healthbar up, positive values move it down. The default value is 80 / 100.',\n\t\t\tdefault = 80,\n\t\t},\n    },\n}\n\ninterfaces.Settings.registerGroup { -- Miscellaneous\n    key = 'MUIMisc',\n\tl10n = 'ModernizedUI',\n    page = 'ModernizedUI',\n    name = 'Miscellaneous',\n\torder = 3,\n\tdescription = 'General configuration.',\n    permanentStorage = true,\n    settings = {\n\t\t{\n\t\t\tkey = 'ShowValues',\n\t\t\trenderer = 'checkbox',\n\t\t\tname = 'Show Stat Values',\n\t\t\tdescription = 'Displays the current values of health, fatigue, and magicka.',\n\t\t\tdefault = false,\n\t\t},\n        {\n            key = 'FlashWhenLow',\n            renderer = 'checkbox',\n            name = 'Flash When Low',\n            description = 'The background will flash red when the player has low health, fatigue, or magicka. Only applies in combat stance (when holding weapon or spell).',\n            default = true,\n        },\n\t\t{\n\t\t\tkey = 'Position',\n\t\t\tname = 'Place in upper left corner',\n\t\t\trenderer = 'checkbox',\n\t\t\tdescription = 'Places the bars in the upper left corner of the screen.',\n\t\t\tdefault = false,\n\t\t},\n\t\t{\n\t\t\tkey = 'LengthMultiplier',\n\t\t\tname = 'Length Multiplier',\n\t\t\trenderer = 'number',\n\t\t\tdescription = 'Adjust the length of the bars.\\nThe default value is 10, meaning that a value of 5 would correspond to 50% of the default length.',\n\t\t\tdefault = 10,\n\t\t\tinteger = false,\n\t\t\tmin = 1\n\t\t},\n\t\t{\n\t\t\tkey = 'LengthCap',\n\t\t\tname = 'Length Cap',\n\t\t\trenderer = 'number',\n\t\t\tdescription = 'This value determines the maximum length of the bars. Takes priority over Length Multiplier. \\nThe default value is 5000 (essentially uncapped).',\n\t\t\tdefault = 5000,\n\t\t\tinteger = true,\n\t\t\tmin = 1\n\t\t},\n    },\n}\n\ninterfaces.Settings.registerGroup { -- Experimental\n    key = 'MUIExperimental',\n\tl10n = 'ModernizedUI',\n    page = 'ModernizedUI',\n    name = 'Experimental',\n\torder = 4,\n\tdescription = 'WARNING! Experimental features mainly for testing.', \n    permanentStorage = true,\n    settings = {\n\t\t{\n\t\t\tkey = 'SegmentedNotches',\n\t\t\trenderer = 'checkbox',\n\t\t\tname = 'Segmented Notches - OpenMW 0.49 only!',\n\t\t\tdescription = \"Alternative to Stat Values. When toggled on, the bars will have evenly spaced notches for 50 and 100 units of the respective stat.\\n\\nImportant! Does not update/refresh changed values in max HP/FP/MP properly when used in tandem with Length Cap, *unless* you either: \\n1. Temporarily change the Length Cap to another value and then back, OR \\n2. Manually reload the scripts.\\n\\nWorks absolutely fine uncapped, and in tandem with Length Multiplier.\\nAny help debugging would be GREATLY appreciated.\",\n\t\t\tdefault = false,\n\t\t},\n    },\n}",
    "Modernized HUD for OpenMW 0.49-54468-0-5-1714329658\\Modernized UI\\scripts\\ui.lua": "-- Modernized UI\n-- With help from user \"ownlyme\" on Nexus!\n\nlocal interfaces = require('openmw.interfaces')\nlocal ui = require('openmw.ui')\nlocal deepLayoutCopy = require('openmw_aux.ui').deepLayoutCopy\nlocal API = require('openmw.core').API_REVISION\nlocal util = require('openmw.util')\nlocal storage = require('openmw.storage')\nlocal async = require('openmw.async')\nlocal types = require('openmw.types')\nlocal nearby = require('openmw.nearby')\nlocal self = require('openmw.self')\nlocal settings = require('scripts.settings')\nlocal helpers = require('scripts.helpers')\nlocal camera = require('openmw.camera')\nlocal Actor = types.Actor\nlocal Player = types.Player\nlocal v2 = util.vector2\nlocal v3 = util.vector3\n\n-- Player values and their respective names\nlocal stats = {\n \thealth = Player.stats.dynamic.health(self),\n\tfatigue = Player.stats.dynamic.fatigue(self),\n\tmagicka = Player.stats.dynamic.magicka(self),\n}\n\n-- Effects and their respective stat\nlocal effects = {\n\t[\"restorehealth\"] = \"health\",\n\t[\"restorefatigue\"] = \"fatigue\",\n\t[\"restoremagicka\"] = \"magicka\",\n}\n\n-- Gauge colors\nlocal colors = {\n\thealth = util.color.rgb(200/255, 60/255, 30/255),\n\tfatigue = util.color.rgb(0, 150/255, 60/255),\n\tmagicka = util.color.rgb(53/255, 69/255, 159/255),\n}\n\n-- GUI widget properties\nlocal foreground = ui.texture { path = \"textures/menu_bar_gray.tga\" }\nlocal background = ui.texture { path = \"white\" }\nlocal segment = ui.texture { path = \"textures/segment100.tga\" }\nlocal cornerMargin = 12\nlocal horizontalOffset = 80\nlocal verticalOffset = 0\n\n-- Delta time\nlocal dt = 0\n\n-- Combat\nlocal combatTimer = 0\t-- Timer for the combat HUD to fade out\nlocal combatData\t\t-- Data from the combat event\nlocal listOfEnemies = {}-- List of enemies in combat\nlocal targetedEnemyId\t\t-- The enemy currently targeted, holds the id of the enemy\nlocal cachedTarget \t\t-- The enemy that has been removed from combat, to keep updating the HUD\nlocal alpha = 0\t\nlocal barWidth = 12\n\nlocal targetPositionExceptions = {\n\trat = -40,\n\tratblighted = -40,\n\tnixhound = 25,\n\tscamp = 45,\n\talitdiseased = 100,\n\tkagoutidiseased = 75,\n\tguarferal = 75,\n\n\tmudcrabdiseased = 40,\n\n\tcliffracer = 0,\n}\n\n-- Page variables\nlocal MUISmoothTransitions = storage.playerSection('MUISmoothTransitions')\nlocal MUIYellowRemainder = storage.playerSection('MUIYellowRemainder')\nlocal MUIMisc = storage.playerSection('MUIMisc')\nlocal MUIExperimental = storage.playerSection('MUIExperimental')\nlocal MUIEnemy = storage.playerSection('MUIEnemy')\n\n------------------------------------------------------------------------------------- UI elements\n\nlocal bar = {\n    type = ui.TYPE.Container,\n\tprops = {\n\t\tvisible = true,\n\t\talpha = 1,\n\t},\n\tuserData = {\n\t\tlerp = 0,\n\t\tborderLerp = 0,\n\t\tremainder = 0,\n\t\tremainderCap = 0,\n\t\ttimer = 0,\n\t\tcache = 0,\n\t\tincomingRestoration = 0,\n\n\t\t-- For segments\n\t\thistory = {},\n\n\t\t-- For damage taken\n\t\tstatLoss = 0,\n\t\taccumulatedLoss = 0,\n\t\tlastStat = 0,\n\t\tcachedValue = 0,\n\t\tdamageValueTimer = 0,\n\n\t\tenableFlash = true,\n\t\tenableBorderLerp = false,\n\n\t},\n    content = ui.content {\n\t\t{\n\t\t\tname = 'background',\n\t\t\ttype = ui.TYPE.Image,\n\t\t\tprops = {\n\t\t\t\tresource = background,\n\t\t\t\ttileH = true,\n\t\t\t\ttileV = true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname = 'remainder',\n\t\t\ttype = ui.TYPE.Image,\n\t\t\tprops = {\n\t\t\t\tresource = foreground,\n\t\t\t\tposition = v2(2, 0),\n\t\t\t\ttileH = true,\n\t\t\t\ttileV = true,\n\t\t\t\tcolor = util.color.rgb(243/255,237/255,22/255)\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tname = 'foreground',\n\t\t\ttype = ui.TYPE.Image,\n\t\t\tprops = {\n\t\t\t\tresource = foreground,\n\t\t\t\tposition = v2(2, 0),\n\t\t\t\ttileH = true,\n\t\t\t\ttileV = true,\n\t\t\t\tcolor = util.color.rgb(200/255, 60/255, 30/255)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname = 'healing',\n\t\t\ttype = ui.TYPE.Image,\n\t\t\tprops = {\n\t\t\t\tresource = foreground,\n\t\t\t\tposition = v2(2, 0),\n\t\t\t\ttileH = true,\n\t\t\t\ttileV = true,\n\t\t\t\tcolor = util.color.rgb(255/255, 255/255, 255/255),\n\t\t\t\talpha = 1\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname = 'value',\n\t\t\ttype = ui.TYPE.Text,\n\t\t\tprops = {\n\t\t\t\ttext = \"\",\n\t\t\t\ttextColor = util.color.rgba(1, 1, 1, 0.5),\n\t\t\t\tposition = v2(2.5, 6),\n\t\t\t\ttextShadow = true,\n\t\t\t\tanchor = v2(0, 0.5),\n\t\t\t\trelativePosition = v2(0, 0.5),\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tname = 'border',\n\t\t\ttemplate = interfaces.MWUI.templates.borders,\n\t\t\tprops = {\n\t\t\t},\n\t\t},\n\t\t{\t\n\t\t\tname = 'segment50',\n\t\t\ttype = ui.TYPE.Image,\n\t\t\tprops = {\n\t\t\t\tresource = segment,\n\t\t\t\tposition = v2(4, 0),\n\t\t\t\ttileH = true,\n\t\t\t\ttileV = true,\n\t\t\t},\n\t\t},\n\t\t{\t\n\t\t\tname = 'segment100',\n\t\t\ttype = ui.TYPE.Image,\n\t\t\tprops = {\n\t\t\t\tresource = segment,\n\t\t\t\tposition = v2(4, 0),\n\t\t\t\ttileH = true,\n\t\t\t\ttileV = true,\n\t\t\t},\n\t\t},\n\t},\n\tevents = {\n\t\tmouseClick = function()\n\t\t\tprint(\"CLICKED!\")\n\t\t\tinterfaces.UI.setMode('Interface', {windows = {'Map', 'Stats', 'Magic', 'Inventory'}})\n\t\tend\n\t}\n}\n\nlocal bars = { \n\thealth = deepLayoutCopy(bar), \n\tfatigue = deepLayoutCopy(bar), \n\tmagicka = deepLayoutCopy(bar) \n}\n\nlocal targetName = {\n\ttype = ui.TYPE.Text,\n\tprops = {\n\t\ttext = \"\",\n\t\ttextColor = util.color.rgb(1, 1, 1),\n\t\ttextShadow = true,\n\t\ttextSize = 14,\n\t\talpha = 1\n\t}\n}\n\nlocal targetDamage = {\n\ttype = ui.TYPE.Container,\n\tprops = {\n\t\talpha = 1,\n\t\trelativePosition = v2(1, 0),\n\t\tanchor = v2(1, 0),\n\t\tsize = v2(100, 15),\n\t\trelativeSize = v2(1, 1),\n\t},\n}\n\nlocal targetBar = deepLayoutCopy(bar)\ntargetBar.name = \"target\"\n\n-- For loop that assigns the names of the bars\nfor stat, bar in pairs(bars) do\n\tbar.name = stat\nend\n\nlocal screen = {\n\ttype = ui.TYPE.Widget,\n\tlayer = 'HUD',\n\tprops = {\n\t\tposition = v2(0, 0),\n\t\trelativeSize = v2(1, 1),\n\t\tanchor = v2(0, 0),\n\t\trelativePosition = v2(0, 0),\n\t\tvisible = true,\n\t},\n\tcontent = ui.content {\n\t\t{\t\n\t\t\tname = 'flex',\n\t\t\ttype = ui.TYPE.Flex,\n\t\t\tlayer = 'HUD',\n\t\t\tprops = {\n\t\t\t\tposition = v2(cornerMargin + horizontalOffset, -cornerMargin + verticalOffset),\n\t\t\t\tanchor = v2(0, 1),\n\t\t\t\trelativePosition = v2(0, 1),\n\t\t\t\tarrange = ui.ALIGNMENT.Start,\n\t\t\t\thorizontal = false,\n\t\t\t\tvisible = true,\n\n\t\t\t},\n\t\t\tcontent = ui.content {\n\t\t\t\t{\t\n\t\t\t\t\ttemplate = bars['health']\n\t\t\t\t},\n\t\t\t\t{ template = spacer },\n\t\t\t\t{\n\t\t\t\t\ttemplate = bars['fatigue']\n\t\t\t\t},\n\t\t\t\t{ template = spacer },\n\t\t\t\t{\n\t\t\t\t\ttemplate = bars['magicka']\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t{\t\n\t\t\tname = 'TargetWidget',\n\t\t\ttype = ui.TYPE.Flex,\n\t\t\tprops = {\n\t\t\t\tanchor = v2(0.5, 1),\n\t\t\t\trelativePosition = v2(0.5, 0.8),\n\t\t\t\tarrange = ui.ALIGNMENT.Center,\n\t\t\t\thorizontal = false,\n\t\t\t\tvisible = true,\n\t\t\t},\n\t\t\tcontent = ui.content {\n\t\t\t\t{\n\t\t\t\t\ttemplate = targetName\n\t\t\t\t},\n\t\t\t\t{ template = spacer },\n\t\t\t\t{\t\n\t\t\t\t\ttemplate = targetBar\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttemplate = targetDamage,\n\t\t\t\t\tcontent = ui.content {\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype = ui.TYPE.Text,\n\t\t\t\t\t\t\tprops = {\n\t\t\t\t\t\t\t\ttext = \"-34\",\n\t\t\t\t\t\t\t\ttextColor = util.color.rgb(214/255,203/255,166/255),\n\t\t\t\t\t\t\t\ttextShadow = true,\n\t\t\t\t\t\t\t\ttextSize = 12,\n\t\t\t\t\t\t\t\talpha = 1,\n\t\t\t\t\t\t\t\trelativePosition = v2(1, 0),\n\t\t\t\t\t\t\t\tanchor = v2(1, 0),\n\t\t\t\t\t\t\t\trelativeSize = v2(1, 1),\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n}\n\nlocal hud = ui.create(screen)\n\n------------------------------------------------------------------------------------- Handling of elements\nlocal function calculateRemainder(bar)\n\tlocal d = bar.userData\n\tlocal historyLength = 60\n\tlocal normalized\n\tnormalized = d.current / d.base\n\tnormalizedLerp = d.lerp / d.base\n\td.remainderCap = d.remainder\n\n\t\n\ttable.insert(d.history, 1, normalized)\t\t\t\t\t\t\t\t\t\t\t\t-- Record the history\t\t\t\t\t\t\t\t\n\tif #d.history > historyLength then table.remove(d.history) end\t\t\t\t\t\t-- Clear entries older than historyLength frames\n\tif d.history[historyLength] == nil then d.history[historyLength] = normalized end \t-- Prevents nil values\n\tif d.remainder < normalizedLerp then\n\t\td.remainder = normalizedLerp\n\t\td.remainderCap = normalizedLerp\n\t\td.timer = 0\n\telseif d.timer > historyLength/60 then\t\n\t\td.remainder = smoothstep(d.remainder, math.min(math.max(d.history[historyLength], normalized), d.remainderCap), MUIYellowRemainder:get('YellowRemainderDrainSpeed') * ((d.remainder - normalized) + 1) * dt)\n\tend\n\t\n\td.timer = d.timer + dt\n\treturn d.remainder\nend\n\nlocal function setTargetBarPos(a)\n\tlocal verticalOffset = MUIEnemy:get('VerticalOffset') / 100\n\tif MUIEnemy:get('PositionAnchor') == false then\n\t\tscreen.content['TargetWidget'].props.relativePosition = v2(0.5, verticalOffset)\n\t\treturn\n\tend\n\n\tlocal playerPos = self.object.position\n\tlocal barPos = screen.content['TargetWidget'].props\n\tlocal box = a.object:getBoundingBox()\n\tlocal record, raceHeight\n\tif types.NPC.objectIsInstance(a.object) then\n\t\trecord = types.NPC.record(a.object.recordId)\n\t\traceHeight = types.NPC.races.record(record.race).height.male * 135\n\telse \n\t\trecord = types.Creature.record(a.object.recordId)\n\t\traceHeight = box.halfSize.z\n\tend\n\n\t-- Remove spaces and dashes from the record name\n\tlocal id = record.id:gsub(\"%s+\", \"\"):gsub(\"-\", \"\"):gsub(\"_\", \"\")\n\n\tif targetPositionExceptions[id] then\n\t\tif targetPositionExceptions[id] == 0 then\n\t\t\tbarPos.relativePosition = v2(0.5, 0.8)\n\t\t\treturn\n\t\telse \n\t\t\traceHeight = raceHeight + targetPositionExceptions[id]\n\t\tend\n\tend\n\t\n\tlocal top = v3(a.object.position.x, a.object.position.y, a.object.position.z + raceHeight)\n\tlocal pos = camera.worldToViewportVector(top)\n\tlocal screenSize = ui.screenSize() -- Screen size in pixels\n\tnormalized = v2(pos.x / screenSize.x, pos.y / screenSize.y)\n\n\tlocal isInBoundsX = isInRange(normalized.x, 0.05, 0.95)\n\tlocal isInBoundsY = isInRange(normalized.y, 0.05, 0.95)\n\n\t-- Check if the player is facing the enemy\n\tlocal playerDir = camera.getYaw()\n\tlocal enemyDir = math.atan2(top.x - playerPos.x, top.y - playerPos.y)\n\tlocal isFacingEnemy = isInRange(math.abs(playerDir - enemyDir), 0, math.pi / 2)\n\n\tif isInBoundsX and isInBoundsY and (a.object.cell == self.object.cell) then\n\t\tif isFacingEnemy then\n\t\t\tbarPos.relativePosition = v2(normalized.x, normalized.y)\n\t\telse\n\t\t\tbarPos.relativePosition = v2(0.5, verticalOffset)\n\t\tend\n\telse\n\t\tbarPos.relativePosition = v2(0.5, verticalOffset)\n\tend\nend\n\nlocal function sendRay() -- Send ray from camera straight ahead from crosshair\n\tlocal pos = camera.getPosition()\n\tlocal dir = pos + camera.viewportToWorldVector(util.vector2(0.5, 0.5)) * 1000\n\tlocal ray = nearby.castRay(pos, dir, { collisionType = nearby.Actor, ignore = self })\n\tif ray.hit == true and ray.hitObject ~= nil then\n\t\treturn tonumber(ray.hitObject.id)\n    end\nend\n\nlocal function drawSegments(bar, width)\n\tlocal c = bar.content\n\tif not MUIExperimental:get('SegmentedNotches') then \n\t\tc['segment50'].props.visible = false\n\t\tc['segment100'].props.visible = false\n\t\treturn\n\tend\n\n\tlocal barLength = math.min(bar.userData.base * MUIMisc:get('LengthMultiplier') / 10, MUIMisc:get('LengthCap') + 4)\n\tc['segment50'].props.visible = true\n\tc['segment100'].props.visible = true\n\n\t-- 100HP\n\tlocal size = 100 / (bar.userData.base / barLength)\n\tc['segment100'].props.resource = ui.texture {\n\t\tpath = \"textures/segment100.tga\",\n\t\tsize = v2(size, 18),\n\t\toffset = v2(4 - size, 0),\n\t}\n\n\t-- 50HP\n\tif (bar.userData.base / barLength) > 1.2 then size = 0 end\n\tc['segment50'].props.resource = ui.texture {\n\t\tpath = \"textures/segment50.tga\",\n\t\tsize = v2(size, 18),\n\t\toffset = v2(4 - size, 0),\n\t}\n\n\tc['segment50'].props.position = v2(3 - size / 2, 0)\n\tc['segment50'].props.size = v2(barLength + (size / 2) -2, width - 2)\n\n\tc['segment100'].props.position = v2(3, 0)\n\tc['segment100'].props.size = v2(barLength - 5, width - 2)\n\n\thud:update()\nend\n\nlocal function settingsChanged()\n\tlocal f = screen.content['flex']\n\tif(MUIMisc:get('Position')) then\n\t\tf.props.position = v2(cornerMargin, cornerMargin)\n\t\tf.props.anchor = v2(0, 0)\n\t\tf.props.relativePosition = v2(0, 0)\n\telse\n\t\tf.props.position = v2(cornerMargin + horizontalOffset, -cornerMargin + verticalOffset)\n\t\tf.props.anchor = v2(0, 1)\n\t\tf.props.relativePosition = v2(0, 1)\n\tend\n\nend\n\nlocal function calculateLerp(bar)\n\tlocal d = bar.userData\n\tlocal lerpSpeed = MUISmoothTransitions:get('LerpSpeed')\n\td.lerp = smoothstep(d.lerp, d.current, dt * lerpSpeed)\n\n\tlocal clampedLerp = math.min(math.max(d.lerp, 0), d.base)\n\treturn (clampedLerp / d.base)\nend\n\nlocal function calculateRestoration(bar, length) -- Credit to user \"ownlyme\" on Nexus!\n\tlocal timeBand = 3\n\tlocal incomingRestoration = 0\n\n\tfor effect, stat in pairs(effects) do\n\t\tfor a, b in pairs(Actor.activeSpells(self)) do\n\t\t\tfor c, d in pairs(b.effects) do\n\t\t\t\tif d.id == effect and bar.name == stat then\n\t\t\t\t\tlocal duration = d.durationLeft\n\t\t\t\t\tif duration == nil then return 0 end\n\t\t\t\t\tincomingRestoration = incomingRestoration + (d.maxMagnitude + d.minMagnitude) / 2 * duration\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tlocal restoration, size, position\n\tif MUISmoothTransitions:get('SmoothTransitions') then\n\t\trestoration = bar.userData.current + incomingRestoration\n\t\tsize = ((math.floor(restoration) - math.floor(bar.userData.current)) / bar.userData.base) * length\n\t\tposition = v2((math.floor(bar.userData.current) / bar.userData.base) * length + 2, 0)\n\telse\n\t\trestoration = bar.userData.current + incomingRestoration\n\t\tsize = ((math.floor(restoration) - math.floor(bar.userData.current)) / bar.userData.base) * length\n\t\tposition = v2((math.floor(bar.userData.current) / bar.userData.base) * length + 2, 0)\n\tend\n\n\treturn math.min(size, length + 4 - position.x), position\nend\n\nlocal function handleStatValueDisplay(bar)\n\tlocal d = bar.userData\n\tlocal timerLength = MUIYellowRemainder:get('YellowRemainderTimer') / 10\n\tlocal drainSpeed = MUIYellowRemainder:get('YellowRemainderDrainSpeed')\n\tlocal statLoss = d.lastStat - d.current\n\td.accumulatedLoss = d.accumulatedLoss + statLoss\n\tif d.accumulatedLoss < 0 then d.accumulatedLoss = 0 end\n\n\tif statLoss ~= 0 then -- Indicates damage taken\n\t\td.damageValueTimer = 0\n\tend\n\n\tif d.accumulatedLoss < 1 then\n\t\td.damageValueTimer = 0\n\t\td.accumulatedLoss = 0\n\t\treturn tostring(math.floor(d.current))\n\tend\n\n\td.damageValueTimer = d.damageValueTimer + dt\n\n\tif d.damageValueTimer > timerLength then\n\t\td.accumulatedLoss = smoothstep(d.accumulatedLoss, 0, dt * drainSpeed)\n\t\tif d.accumulatedLoss < 0 then d.accumulatedLoss = 0 end\n\tend\n\n\tlocal offset = (d.current + d.accumulatedLoss) % 1\n\n\treturn math.floor(d.current + d.accumulatedLoss), math.ceil(d.accumulatedLoss - offset)\nend\n\nlocal function handleBar(bar, stat, color, width)\n\tlocal d = bar.userData\n\td.current = stat.current\n\td.base = stat.base\n\tbar.content['foreground'].props.color = color\n\tif(stat.base < 1) then \n\t\tbar.props.visible = false\n\telse\t\n\t\tbar.props.visible = true\n\tend\n\n\tlocal normalized = d.current / d.base\n\tlocal borderSize = 4\n\tlocal LengthMultiplier, LengthCap = MUIMisc:get('LengthMultiplier') / 10, MUIMisc:get('LengthCap')\n\n\tlocal length = math.min(d.base * LengthMultiplier, LengthCap)\n\tif d.enableBorderLerp == true and MUISmoothTransitions:get('SmoothTransitions') then\n\t\td.borderLerp = smoothstep(d.borderLerp, length, dt * 48)\n\t\tlength = d.borderLerp\n\telse \n\t\td.borderLerp = length\n\tend\n\t-- Foreground & Remainder\n\tif MUISmoothTransitions:get('SmoothTransitions') then \n\t\tbar.content['foreground'].props.size = v2(calculateLerp(bar) * length, width)\n\telse \n\t\tbar.content['foreground'].props.size = v2(normalized * length, width) \n\tend\n\t--bar.content['remainder'].props.size = l(math.min(calculateYellowRemainder(bar) * length, length))\n\tbar.content['remainder'].props.size = v2(math.min(calculateRemainder(bar) * length, length), width)\n\n\n\t-- Background & Borders\n\tlocal equippedSpell = Actor.getSelectedSpell(self)\n\tlocal equippedSpellCost \n\n\tif equippedSpell == nil then \n\t\tequippedSpellCost = 0 \n\telse \n\t\tequippedSpellCost = equippedSpell.cost\n\tend\n\tlocal flash = oscillateBackground(dt * 7)\n\tlocal stance = Actor.getStance(self)\n\n\tbar.content['background'].props.size = v2(length + borderSize, width)\n\tbar.content['border'].props.size = v2(length + borderSize, width)\n\n\tif d.enableFlash == true then\n\t\tif (stat.current / stat.base < 0.15 or stat.current < 16) and stance > 0 and MUIMisc:get('FlashWhenLow') and bar.name ~= \"magicka\" then \n\t\t\tbar.content['background'].props.color = flash\n\t\telseif bar.name == \"magicka\" and equippedSpellCost > d.current and stance == 2 then\n\t\t\tbar.content['background'].props.color = flash\n\t\telse \n\t\t\tbar.content['background'].props.color = util.color.rgb(0, 0, 0)\n\t\tend\n\tend\n\n\t-- Restoration Effects\n\tlocal size, pos = calculateRestoration(bar, length)\n\tbar.content['healing'].props.size = v2(size, width)\n\tbar.content['healing'].props.position = pos\n\n\t-- Segments\n\tdrawSegments(bar, width)\n\n\tlocal hpTick, accumulatedDamage = handleStatValueDisplay(bar)\n\n\t-- Value overlay\n\tif MUIMisc:get('ShowValues') and bar.name ~= \"target\" then \n\t\tbar.content['value'].props.text = tostring(math.floor(d.current))\n\telse \n\t\tbar.content['value'].props.text = \"\" \n\tend\n\t\n\td.lastStat = stat.current\nend\n\nlocal function handleCombat()\n\tlocal target = sendRay()\n\tif listOfEnemies[target] then \n\t\ttargetedEnemyId = target\n\tend\n\n\tif listOfEnemies[targetedEnemyId] then \n\t\ttarget = listOfEnemies[targetedEnemyId]\n\telse\n\t\ttarget = cachedTarget\n\tend\n\n\tif not target then return end\n\n\tsetTargetBarPos(target)\n\n\t--print(\"Handling combat. Debug: \" .. target.debug)\n\thandleBar(targetBar, { current = target.health, base = target.maxHealth }, colors['health'], barWidth + 2)\n\ttargetBar.userData.enableFlash = false\n\ttargetBar.userData.enableBorderLerp = true\n\n\tlocal name = target.name\n\tif MUIEnemy:get('ShowEnemyLevels') then name = name .. \", \" .. target.level end\n\tif MUIEnemy:get('ShowEnemyClass') and target.class ~= nil then name = name .. \", \" .. target.class end\n\ttargetName.props.text = name\n\n\tif target.health == 0 then targetName.props.textColor = util.color.rgb(200/255, 60/255, 30/255)\n\telse targetName.props.textColor = util.color.rgb(214/255,203/255,166/255) end\nend\n\nlocal function handleCombatTimer()\n\tlocal target = listOfEnemies[targetedEnemyId]\n\tif combatTimer < 3 then \n\t\tcombatTimer = combatTimer + dt\n\t\talpha = math.min(alpha + dt * 6, 1)\n\t\ttargetBar.props.alpha = math.min(targetBar.props.alpha + dt * 6, 1)\n\t\ttargetName.props.alpha = alpha\n\telseif target then\n\t\tif target.health == 0 or target.object.cell ~= self.object.cell then\n\t\t\talpha = math.max(alpha - dt * 6, 0)\n\t\t\ttargetBar.props.alpha = alpha\n\t\t\ttargetName.props.alpha = alpha\n\t\tend\n\telse\n\t\talpha = math.max(alpha - dt * 6, 0)\n\t\ttargetBar.props.alpha = alpha\n\t\ttargetName.props.alpha = alpha\n\tend\n\n\tif alpha > 0 and MUIEnemy:get('EnableEnemyHealthbar') then\n\t\thandleCombat()\n\tend\nend\n\nlocal function sendCombatData(enemy) \n\tlocal id = enemy.id\t\t\t\t\t\t\t-- The enemy source for identification in the list.\n\tif id == nil then return end\n\tif listOfEnemies[id] then \t\t\t\t\t\t\t\t\t\t-- If the enemy is already in combat\n\t\tif enemy.health == 0 or enemy.stoppedTargeting then \t\t\t-- If its dead or has stopped targeting the player\n\t\t\tcachedTarget = enemy\t\t\t\t\t\t\t\t\t\t-- Remove it from the list\n\t\t\tlistOfEnemies[id] = nil\n\t\t\ttargetedEnemyId = next(listOfEnemies)\n\t\telseif targetedEnemyId == id and enemy.hasBeenHealed then \t-- If it already is targeted and is healing, as to not target itself if it heals\n\t\t\tlistOfEnemies[id] = enemy\n\telseif not enemy.hasBeenHealed then\t\t\t\t\t\t\t\t\t-- Else update its stats.\n\t\t\tlistOfEnemies[id] = enemy\n\t\t\ttargetedEnemyId = id\n\t\tend\n\telseif enemy.health > 0 then\t\t\t\t\t\t\t\t\t\t-- If the enemy is not already in combat, add it to the list\n\t\ttable.insert(listOfEnemies, id, enemy)\n\t\tprint(\"Added: \" .. enemy.name .. \" to the list.\")\n\t\ttargetedEnemyId = id\n\tend\n\t\n\tcombatTimer = 0\nend\n\nlocal function updateHud()\n\tfor stat, bar in pairs(bars) do\n\t\thandleBar(bar, stats[stat], colors[stat], barWidth)\n\tend\n\n\thandleCombatTimer()\n\n\thud:update()\nend\n------------------------------------------------------------------------------------- Update cycle\n\n-- Call this once to apply the initial settings\nsettingsChanged()\nMUIMisc:subscribe(async:callback(settingsChanged))\n\nlocal function onFrame(_dt)\n\tdt = _dt\n\tif API >= 59 then\n\t\tif interfaces.UI.isHudVisible() or self.object.cell ~= nil then\n\t\t\tscreen.props.visible = true\n\t\t\tupdateHud()\n\t\telse \n\t\t\tscreen.props.visible = false\n\t\t\thud:update()\n\t\tend\n\telse \n\t\tupdateHud()\n\tend\nend\n\nreturn {\n    engineHandlers = {\n\t\tonFrame = onFrame,\n    },\n\n\teventHandlers = {\n\t\tSendCombatData = sendCombatData,\n\t}\n}"
  }
}