{
  "folder_name": "Quick Action for OpenMW",
  "lua_files": {
    "Quick Action-54969-0-3-3-1721407523\\scripts\\quick_action\\quick_action.lua": "local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local math = _tl_compat and _tl_compat.math or math; local pairs = _tl_compat and _tl_compat.pairs or pairs; local string = _tl_compat and _tl_compat.string or string; local table = _tl_compat and _tl_compat.table or table; local async = require('openmw.async')\nlocal aux_util = require('openmw_aux.util')\nlocal camera = require('openmw.camera')\nlocal core = require('openmw.core')\nlocal input = require('openmw.input')\nlocal I = require(\"openmw.interfaces\")\nlocal MWUI = require('openmw.interfaces').MWUI\nlocal self = require('openmw.self')\nlocal storage = require('openmw.storage')\nlocal types = require('openmw.types')\nlocal ui = require('openmw.ui')\nlocal util = require('openmw.util')\n\nlocal v2 = util.vector2\n\nlocal Actor = types.Actor\nlocal Armor = types.Armor\nlocal Clothing = types.Clothing\nlocal GameObject = core.GameObject\nlocal Enchantment = core.Enchantment\nlocal Player = types.Player\nlocal Spell = core.Spell\nlocal Weapon = types.Weapon\n\nlocal l10n = core.l10n('quick_action')\n\nI.Settings.registerPage({\n   key = 'QuickActionPage',\n   l10n = 'quick_action',\n   name = 'setting_quick_action_page',\n   description = 'setting_quick_action_page_description',\n})\n\nI.Settings.registerGroup({\n   key = 'SettingsQuickAction',\n   page = 'QuickActionPage',\n   l10n = 'quick_action',\n   name = 'setting_quick_action_group',\n   description = 'setting_quick_action_group_description',\n   permanentStorage = false,\n   settings = {\n      {\n         key = 'toggle',\n         name = 'setting_toggle',\n         description = 'setting_toggle_description',\n         renderer = 'textLine',\n         default = 'x',\n      },\n      {\n         key = 'addAction',\n         name = 'setting_add_action',\n         description = 'setting_add_action_description',\n         renderer = 'textLine',\n         default = 'n',\n      },\n      {\n         key = 'delAction',\n         name = 'setting_del_action',\n         description = 'setting_del_action_description',\n         renderer = 'textLine',\n         default = 'delete',\n      },\n      {\n         key = 'moveUpAction',\n         name = 'setting_move_action_up',\n         description = 'setting_move_action_up_description',\n         renderer = 'textLine',\n         default = '\\\\',\n      },\n      {\n         key = 'moveDownAction',\n         name = 'setting_move_action_down',\n         description = 'setting_move_action_down_description',\n         renderer = 'textLine',\n         default = ']',\n      },\n      {\n         key = 'addListing',\n         name = 'setting_add_listing',\n         description = 'setting_add_listing_description',\n         renderer = 'textLine',\n         default = 'm',\n      },\n      {\n         key = 'nextListing',\n         name = 'setting_next_listing',\n         description = 'setting_next_listing_description',\n         renderer = 'textLine',\n         default = 'z',\n      },\n      {\n         key = 'delListing',\n         name = 'setting_del_listing',\n         description = 'setting_del_listing_description',\n         renderer = 'textLine',\n         default = 'end',\n      },\n      {\n         key = 'positionX',\n         name = 'setting_position_x',\n         description = 'setting_position_x_description',\n         renderer = 'number',\n         default = 0.5,\n         argument = {\n            min = 0.0,\n            max = 1.0,\n         },\n      },\n      {\n         key = 'positionY',\n         name = 'setting_position_y',\n         description = 'setting_position_y_description',\n         renderer = 'number',\n         default = 0.5,\n         argument = {\n            min = 0.0,\n            max = 1.0,\n         },\n      },\n      {\n         key = 'radiusMul',\n         name = 'setting_radius_mul',\n         description = 'setting_radius_mul_description',\n         renderer = 'number',\n         default = 0.15,\n      },\n      {\n         key = 'enableInfoBox',\n         name = 'setting_enable_info_box',\n         description = 'setting_enable_info_box_description',\n         renderer = 'checkbox',\n         default = true,\n      },\n      {\n         key = 'enableInfoBoxKeys',\n         name = 'setting_enable_info_box_keys',\n         description = 'setting_enable_info_box_keys_description',\n         renderer = 'checkbox',\n         default = true,\n      },\n      {\n         key = 'showControllerKeysInInfoBox',\n         name = 'setting_show_controller_keys_in_info_box',\n         description = 'setting_show_controller_keys_in_info_box_description',\n         renderer = 'checkbox',\n         default = false,\n      },\n      {\n         key = 'disablePlayerControls',\n         name = 'setting_disable_player_controls',\n         description = 'setting_disable_player_controls_description',\n         renderer = 'checkbox',\n         default = true,\n      },\n      {\n         key = 'resetListings',\n         name = 'reset_listings',\n         description = 'reset_listings_description',\n         renderer = 'checkbox',\n         default = false,\n      },\n   },\n})\n\nI.Settings.registerGroup({\n   key = 'SettingsQuickActionController',\n   page = 'QuickActionPage',\n   l10n = 'quick_action',\n   name = 'setting_quick_action_controller_group',\n   description = 'setting_quick_action_controller_group_description',\n   permanentStorage = false,\n   settings = {\n      {\n         key = 'show',\n         name = 'setting_controller_show',\n         description = 'setting_controller_show_description',\n         renderer = 'textLine',\n         default = 'DPadUp',\n      },\n      {\n         key = 'close',\n         name = 'setting_controller_close',\n         description = 'setting_controller_close_description',\n         renderer = 'textLine',\n         default = 'DPadLeft',\n      },\n      {\n         key = 'select',\n         name = 'setting_controller_select',\n         description = 'setting_controller_select_description',\n         renderer = 'textLine',\n         default = 'A',\n      },\n      {\n         key = 'addAction',\n         name = 'setting_add_action',\n         description = 'setting_add_action_description',\n         renderer = 'textLine',\n         default = 'Y',\n      },\n      {\n         key = 'delAction',\n         name = 'setting_del_action',\n         description = 'setting_del_action_description',\n         renderer = 'textLine',\n         default = 'X',\n      },\n      {\n         key = 'moveUpAction',\n         name = 'setting_move_action_up',\n         description = 'setting_move_action_up_description',\n         renderer = 'textLine',\n         default = '',\n      },\n      {\n         key = 'moveDownAction',\n         name = 'setting_move_action_down',\n         description = 'setting_move_action_down_description',\n         renderer = 'textLine',\n         default = 'RightStick',\n      },\n      {\n         key = 'addListing',\n         name = 'setting_add_listing',\n         description = 'setting_add_listing_description',\n         renderer = 'textLine',\n         default = 'LeftStick',\n      },\n      {\n         key = 'nextListing',\n         name = 'setting_next_listing',\n         description = 'setting_next_listing_description',\n         renderer = 'textLine',\n         default = 'DPadRight',\n      },\n      {\n         key = 'delListing',\n         name = 'setting_del_listing',\n         description = 'setting_del_listing_description',\n         renderer = 'textLine',\n         default = 'Back',\n      },\n      {\n         key = 'switchToNext',\n         name = 'setting_controller_switch_to_next',\n         description = 'setting_controller_switch_to_next_description',\n         renderer = 'textLine',\n         default = 'DPadUp',\n      },\n      {\n         key = 'switchToPrev',\n         name = 'setting_controller_switch_to_prev',\n         description = 'setting_controller_switch_to_prev_description',\n         renderer = 'textLine',\n         default = 'DPadDown',\n      },\n   },\n})\n\nlocal settings = storage.playerSection('SettingsQuickAction')\n\nlocal function checkbox(settingKey)\n   return settings:get(settingKey)\nend\n\nlocal function keyBindingNameFor(settingKey)\n   return settings:get(settingKey)\nend\n\nlocal controllerSettings = storage.playerSection('SettingsQuickActionController')\n\nlocal function controllerButtonNameFor(settingKey)\n   return controllerSettings:get(settingKey)\nend\n\nlocal function controllerButtonFor(settingKey)\n   local button_name = controllerButtonNameFor(settingKey)\n   if button_name == '' then return nil end\n   return (input.CONTROLLER_BUTTON)[button_name]\nend\n\nlocal function infoBoxHelper()\n   local lookupBindingFor = checkbox('showControllerKeysInInfoBox') and controllerButtonNameFor or keyBindingNameFor\n\n   return lookupBindingFor('addAction') .. ': ' .. l10n('add_action') .. '  ' ..\n   lookupBindingFor('delAction') .. ': ' .. l10n('del_action') .. '  ' ..\n   lookupBindingFor('addListing') .. ': ' .. l10n('add_list') .. '  ' ..\n   lookupBindingFor('delListing') .. ': ' .. l10n('del_list') .. '  ' ..\n   lookupBindingFor('nextListing') .. ': ' .. l10n('next_list')\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal Listing = {}\n\n\n\n\nfunction Listing:modifiable(items)\n   return { isModifiable = true, items = items }\nend\n\nfunction Listing:unmodifiable(items)\n   return { isModifiable = false, items = items }\nend\n\nlocal State = {}\n\n\n\n\n\n\n\n\n\n\nfunction State:new()\n   local self = setmetatable({}, { __index = State })\n   self.listings = {}\n   self.currentId = '1'\n   self.listings[self.currentId] = Listing:modifiable({})\n   self.listingsTitles = {}\n   table.insert(self.listingsTitles, '1')\n   self.selectedItemIndex = nil\n   return self\nend\n\nfunction State:from(state)\n   local self = State:new()\n   self.listingsTitles = state.listingsTitles\n   self.listings = state.listings\n   self.currentId = state.currentId\n   self.selectedItemIndex = state.selectedItemIndex\n   return self\nend\n\nfunction State:newListing(title, listing)\n   self.listings[title] = listing\n   if self.listings[title].isModifiable then\n      table.insert(self.listingsTitles, title)\n   end\nend\n\nfunction State:setListing(id)\n   self.currentId = id\n   self.selectedItemIndex = #self.listings[id].items == 0 and nil or 1\nend\n\nfunction State:setFirstListing()\n   self:setListing(self.listingsTitles[1])\nend\n\nfunction State:newAndSetListing(title, listing)\n   self:newListing(title, listing)\n   self:setListing(title)\nend\n\nfunction State:addNextListing()\n   local nextTitle = tostring(#self.listingsTitles + 1)\n   self:newAndSetListing(nextTitle, Listing:modifiable({}))\n   return nextTitle\nend\n\nfunction State:nextListing()\n   local nextTitle = self.listingsTitles[1]\n   for i, title in ipairs(self.listingsTitles) do\n      if title == self.currentId and i + 1 <= #self.listingsTitles then\n         nextTitle = self.listingsTitles[i + 1]\n         break\n      end\n   end\n   self:setListing(nextTitle)\nend\n\nfunction State:delListing()\n   if not self.listings[self.currentId].isModifiable or #self.listingsTitles == 1 then return end\n   local removedId = self.currentId\n   self:nextListing()\n   self.listings[removedId] = nil\n   for i = 1, #self.listingsTitles do\n      if self.listingsTitles[i] == removedId then\n         table.remove(self.listingsTitles, i)\n         break\n      end\n   end\nend\n\nlocal Current = {}\n\n\n\n\n\nfunction Current:new(title,\n   selectedItemIndex,\n   listing)\n\n   local self = setmetatable({}, { __index = Current })\n   self.title = title\n   self.selectedItemIndex = selectedItemIndex\n   self.listing = listing\n   return self\nend\n\nfunction Current:selectedItem()\n   if self.selectedItemIndex == nil or #self.listing.items < self.selectedItemIndex then\n      return nil\n   else\n      return self.listing.items[self.selectedItemIndex]\n   end\nend\n\nfunction State:current()\n   return Current:new(\n   self.currentId,\n   self.selectedItemIndex,\n   self.listings[self.currentId])\n\nend\n\nfunction State:select(selectedItemIndex)\n   local current = self:current()\n   local numItems = #current.listing.items\n   if selectedItemIndex ~= nil and (selectedItemIndex < 1 or selectedItemIndex > numItems) then\n      error('selectedItemIndex:' .. tostring(selectedItemIndex) ..\n      ' is outside the valid range [' .. tostring(1) ..\n      ',' .. tostring(numItems) .. '] of listing ' ..\n      current.title)\n   end\n   self.selectedItemIndex = selectedItemIndex\nend\n\nfunction State:addItemTo(title, item)\n   local listing = self.listings[title]\n   if not listing then\n      print('Warn: attempted to add an item to non existing listing ' .. title)\n      return\n   end\n   if not listing.isModifiable then\n      print('Warn: attempted to add an item to non modifiable listing ' .. title)\n      return\n   end\n   table.insert(listing.items, item)\nend\n\n\n\nfunction State:removeSelected()\n   local current = self:current()\n   if not current.listing.isModifiable or\n      current.selectedItemIndex == nil or\n      #current.listing.items < current.selectedItemIndex then\n      return nil\n   end\n   if #current.listing.items < current.selectedItemIndex then\n      print(string.format('Warn: trying to remove ' ..\n      'selectedItemIndex:%d from current listing which has only %d items',\n      current.selectedItemIndex, #current.listing.items))\n\n      return nil\n   end\n   local removed = current.listing.items[current.selectedItemIndex]\n   table.remove(current.listing.items, current.selectedItemIndex)\n   if #current.listing.items == 0 then\n      self:select(nil)\n   elseif #current.listing.items < current.selectedItemIndex then\n      self:select(1)\n   end\n   return removed\nend\n\nfunction State:moveCurrentUp()\n   if self.selectedItemIndex == nil or not self.listings[self.currentId].isModifiable then return end\n   local oldPosition = self.selectedItemIndex\n   local removed = self:removeSelected()\n   if removed == nil then return end\n\n   local position = oldPosition - 1\n   if position <= 0 then\n      position = #self.listings[self.currentId].items + 1\n   end\n   table.insert(self.listings[self.currentId].items, position, removed)\n\n   self:select(position)\nend\n\nfunction State:moveCurrentDown()\n   if self.selectedItemIndex == nil or not self.listings[self.currentId].isModifiable then return end\n   local oldPosition = self.selectedItemIndex\n   local removed = self:removeSelected()\n   if removed == nil then return end\n\n   local position = oldPosition + 1\n   if position > #self.listings[self.currentId].items + 1 then\n      position = 1\n   end\n   table.insert(self.listings[self.currentId].items, position, removed)\n\n   self:select(position)\nend\n\n\n\n\n\nlocal textSize = MWUI.templates.textNormal.props.textSize\nlocal iconSize = textSize * 2\n\nlocal state = State:new()\n\nlocal inputWidget = nil\n\n\nlocal function resetListingsIfRequested()\n   if checkbox('resetListings') then\n      inputWidget = nil\n      state = State:new()\n      settings:set('resetListings', false)\n   end\nend\n\ninput.bindAction('Zoom3rdPerson', async:callback(function(_, scroll)\n   if inputWidget then return 0 else return scroll end\nend), {})\n\ninput.bindAction('Use', async:callback(function(_, use)\n   if inputWidget then return false else return use end\nend), {})\n\nlocal function disablePlayerControl()\n   if checkbox('disablePlayerControls') then\n      Player.setControlSwitch(self, Player.CONTROL_SWITCH.Controls, false)\n      Player.setControlSwitch(self, Player.CONTROL_SWITCH.Fighting, false)\n      Player.setControlSwitch(self, Player.CONTROL_SWITCH.Jumping, false)\n      Player.setControlSwitch(self, Player.CONTROL_SWITCH.Magic, false)\n      Player.setControlSwitch(self, Player.CONTROL_SWITCH.ViewMode, false)\n   end\nend\n\nlocal function enablePlayerControl()\n   Player.setControlSwitch(self, Player.CONTROL_SWITCH.Controls, true)\n   Player.setControlSwitch(self, Player.CONTROL_SWITCH.Fighting, true)\n   Player.setControlSwitch(self, Player.CONTROL_SWITCH.Jumping, true)\n   Player.setControlSwitch(self, Player.CONTROL_SWITCH.Magic, true)\n   Player.setControlSwitch(self, Player.CONTROL_SWITCH.ViewMode, true)\nend\n\nlocal function closeQuickAction()\n   if inputWidget and not core.isWorldPaused() then\n      inputWidget:destroy()\n      inputWidget = nil\n   end\n   enablePlayerControl()\nend\n\n\n\n\n\n\nlocal function background(options)\n   return {\n      type = ui.TYPE.Container,\n      content = ui.content({\n         {\n            type = ui.TYPE.Image,\n            props = {\n               alpha = options.alpha,\n               color = options.color,\n               resource = ui.texture({ path = 'white' }),\n               relativeSize = v2(1, 1),\n               size = v2(1, 1) * 2,\n            },\n         },\n         {\n            external = { slot = true },\n            props = {\n               relativeSize = v2(1, 1),\n            },\n         },\n      }),\n   }\nend\n\nlocal function padding(paddingSize)\n   return {\n      type = ui.TYPE.Container,\n      content = ui.content({\n         {\n            props = {\n               size = paddingSize,\n            },\n         },\n         {\n            external = { slot = true },\n            props = {\n               position = paddingSize,\n               relativeSize = util.vector2(1, 1),\n            },\n         },\n         {\n            props = {\n               position = paddingSize,\n               relativePosition = util.vector2(1, 1),\n               size = paddingSize,\n            },\n         },\n      }),\n   }\nend\n\nlocal selectedItemBackgroundColor = MWUI.templates.textHeader.props.textColor\nlocal itemBackgroundColor = util.color.rgb(0, 0, 0)\n\nlocal function showQuickAction()\n   resetListingsIfRequested()\n\n   if core.isWorldPaused() then return end\n\n   closeQuickAction()\n\n   local current = state:current()\n\n\n   local relativePosition = v2(settings:get('positionX'), settings:get('positionY'))\n   local screenSize = ui.layers[ui.layers.indexOf(\"HUD\")].size\n\n   local radius = math.min(screenSize.x, screenSize.y) * settings:get('radiusMul')\n   local angle = 2 * math.pi / #current.listing.items\n   local content = ui.content({})\n   for i = 1, #current.listing.items do\n      local iAngle = i * angle - angle / 2\n\n      local boxContent = ui.content({})\n      if current.listing.items[i].texturePath then\n         boxContent:add({\n            type = ui.TYPE.Image,\n            props = {\n               alpha = 1,\n               color = util.color.rgb(1, 1, 1),\n               resource = ui.texture({ path = current.listing.items[i].texturePath }),\n               size = v2(iconSize, iconSize),\n            },\n         })\n      else\n         boxContent:add({\n            type = ui.TYPE.Widget,\n            props = {\n               size = v2(iconSize, iconSize),\n            },\n         })\n      end\n\n      local position = v2(radius * math.cos(iAngle), radius * math.sin(iAngle))\n      local backgroundColor = i == current.selectedItemIndex and selectedItemBackgroundColor or itemBackgroundColor\n      content:add({\n         template = MWUI.templates.boxSolidThick,\n         name = tostring(i),\n         props = {\n            anchor = v2(0.5, 0.5),\n            position = position,\n            relativePosition = relativePosition,\n         },\n         content = ui.content({\n            {\n               template = background({\n                  alpha = 0.5,\n                  color = backgroundColor,\n               }),\n               name = 'background',\n               content = ui.content({\n                  {\n                     template = padding(v2(5, 5)),\n                     content = boxContent,\n                  },\n               }),\n            },\n         }),\n      })\n   end\n\n   local flexContent = ui.content({})\n   flexContent:add({\n      template = MWUI.templates.textNormal,\n      props = {\n         text = current.title,\n         textAlignV = ui.ALIGNMENT.Center,\n         textAlignH = ui.ALIGNMENT.Center,\n      },\n   })\n   flexContent:add({\n      template = MWUI.templates.horizontalLineThick,\n   })\n   local item = current:selectedItem()\n   flexContent:add({\n      name = 'text',\n      template = MWUI.templates.textHeader,\n      props = {\n         text = item and item.name or \" \",\n         textAlignV = ui.ALIGNMENT.Center,\n         textAlignH = ui.ALIGNMENT.Center,\n      },\n   })\n   if current.listing.isModifiable and checkbox('enableInfoBoxKeys') then\n      flexContent:add({\n         template = MWUI.templates.horizontalLineThick,\n      })\n      flexContent:add({\n         template = MWUI.templates.textNormal,\n         props = {\n            text = infoBoxHelper(),\n            textAlignV = ui.ALIGNMENT.Center,\n            textAlignH = ui.ALIGNMENT.Center,\n         },\n      })\n   end\n\n   if checkbox('enableInfoBox') then\n      content:add({\n         template = MWUI.templates.boxTransparentThick,\n         name = 'infoBackground',\n         props = {\n            anchor = v2(0.5, 0.5),\n            position = v2(0, radius + iconSize * 3),\n            relativePosition = relativePosition,\n         },\n         content = ui.content({\n            {\n               template = padding(v2(5, 5)),\n               name = 'padding',\n               content = ui.content({\n                  {\n                     type = ui.TYPE.Flex,\n                     name = 'info',\n                     content = flexContent,\n                     props = {\n                        align = ui.ALIGNMENT.Center,\n                        arrange = ui.ALIGNMENT.Center,\n                     },\n                  },\n               }),\n            },\n         }),\n      })\n   end\n\n   inputWidget = ui.create({\n      layer = 'HUD',\n      type = ui.TYPE.Widget,\n      content = content,\n      props = {\n         relativeSize = v2(1, 1),\n      },\n   })\n\n   disablePlayerControl()\nend\n\nlocal function lookupLayout(widget, names)\n   local currentWidget = widget.layout\n   for _, name in ipairs(names) do\n      if not currentWidget then break end\n      currentWidget = currentWidget.content[name]\n   end\n   return currentWidget\nend\n\nlocal function changeSelection(index)\n   if not inputWidget then return end\n   local current = state:current()\n   if #current.listing.items == 0 then return end\n   if index > #current.listing.items then\n      print(string.format('Cannot change selection to %d ' ..\n      'because it is outside the valid range [1,%d]',\n      index,\n      #current.listing.items))\n      return\n   end\n\n   if state.selectedItemIndex ~= nil then\n      local oldSelectedLayout = lookupLayout(inputWidget, { tostring(state.selectedItemIndex), 'background' })\n      oldSelectedLayout.template = background({ alpha = 0.5, color = itemBackgroundColor })\n   end\n\n   local selectedLayout = lookupLayout(inputWidget, { tostring(index), 'background' })\n   selectedLayout.template = background({ alpha = 0.5, color = selectedItemBackgroundColor })\n\n   state:select(index)\n   current = state:current()\n\n   if checkbox('enableInfoBox') then\n      local textLayout = lookupLayout(inputWidget, { 'infoBackground', 'padding', 'info', 'text' })\n      textLayout.props.text = current.listing.items[current.selectedItemIndex].name\n   end\n\n   inputWidget:update()\nend\n\nlocal function toggleQuickAction()\n   if inputWidget then\n      closeQuickAction()\n      state:setFirstListing()\n   else\n      showQuickAction()\n   end\nend\n\nlocal function getWeaponsInSelfInvectory()\n   local res = {}\n   for _, weapon in ipairs(Actor.inventory(self):getAll(Weapon)) do\n      local weapon_type = Weapon.record(weapon).type\n      if weapon_type ~= Weapon.TYPE.Arrow and\n         weapon_type ~= Weapon.TYPE.Bolt then\n         table.insert(res, weapon)\n      end\n   end\n   return res\nend\n\nlocal function listAddEquipWeaponActions(listingTitle)\n   local res = {}\n   for _, weapon in ipairs(getWeaponsInSelfInvectory()) do\n      table.insert(res, {\n         name = Weapon.record(weapon).name,\n         texturePath = Weapon.record(weapon).icon,\n         action = { type = 'ADD_EQUIP_WEAPON_ACTION', args = Weapon.record(weapon).id },\n         listingTitle = listingTitle,\n      })\n   end\n   return res\nend\n\nlocal function listAddEquipSpellActions(listingTitle)\n   local res = {}\n   for _, spell in pairs(Actor.spells(self)) do\n      if spell.type == core.magic.SPELL_TYPE.Power or\n         spell.type == core.magic.SPELL_TYPE.Spell then\n         table.insert(res, {\n            name = spell.name,\n            texturePath = spell.effects[1].effect.icon,\n            action = { type = 'ADD_EQUIP_SPELL_ACTION', args = spell.id },\n            listingTitle = listingTitle,\n         })\n      end\n   end\n   return res\nend\n\n\n\n\n\n\n\nlocal function itemNameAndEnchant(item)\n   if Armor.objectIsInstance(item) and Armor.record(item).enchant ~= \"\" then\n      local armor = Armor.record(item)\n      return {\n         name = armor.name,\n         texturePath = armor.icon,\n         enchant = armor.enchant,\n      }\n   elseif Clothing.objectIsInstance(item) and Clothing.record(item).enchant ~= \"\" then\n      local clothing = Clothing.record(item)\n      return {\n         name = clothing.name,\n         texturePath = clothing.icon,\n         enchant = clothing.enchant,\n      }\n   elseif Weapon.objectIsInstance(item) and Weapon.record(item).enchant ~= \"\" then\n      local weapon = Weapon.record(item)\n      return {\n         name = weapon.name,\n         texturePath = weapon.icon,\n         enchant = weapon.enchant,\n      }\n   else\n      return nil\n   end\nend\n\nlocal function listAddEquipEnchantedActions(listingTitle)\n   local res = {}\n   for _, item in ipairs(Actor.inventory(self):getAll()) do\n      local name_and_enchant = itemNameAndEnchant(item)\n      if name_and_enchant == nil then goto continue end\n      name_and_enchant = name_and_enchant\n      local enchantment = (core.magic.enchantments.records)[name_and_enchant.enchant]\n      if enchantment.type == core.magic.ENCHANTMENT_TYPE.CastOnUse then\n         table.insert(res, {\n            name = '* ' .. name_and_enchant.name,\n            texturePath = name_and_enchant.texturePath,\n            action = { type = \"ADD_EQUIP_ENCHANTED_ACTION\", args = item.recordId },\n            listingTitle = listingTitle,\n         })\n      end\n      ::continue::\n   end\n   return res\nend\n\nlocal function listBasicActions(listingTitle)\n   return {\n      {\n         name = 'add equip weapon action',\n         texturePath = 'icons/w/tx_iron_longsword.dds',\n         action = { type = \"SHOW_EQUIP_WEAPON_ACTIONS\", args = nil },\n         listingTitle = listingTitle,\n      },\n      {\n         name = 'add equip magic action',\n         texturePath = 'icons/k/magicka.dds',\n         action = { type = \"SHOW_EQUIP_SPELL_ACTIONS\", args = nil },\n         listingTitle = listingTitle,\n      },\n      {\n         name = 'add equip enchanted item action',\n         texturePath = 'icons/k/magic_enchant.dds',\n         action = { type = \"SHOW_EQUIP_ENCHANTED_ACTIONS\", args = nil },\n         listingTitle = listingTitle,\n      },\n      {\n         name = 'add switch to hand-to-hand',\n         texturePath = 'icons/k/stealth_handtohand.dds',\n         action = { type = \"ADD_SWITCH_TO_HAND2HAND\", args = nil },\n         listingTitle = listingTitle,\n      },\n   }\nend\n\nlocal function select()\n   if not inputWidget or core.isWorldPaused() then return end\n\n   local current = state:current()\n   local selectedItem = current:selectedItem()\n   if selectedItem == nil then return end\n\n   if selectedItem.action.type == \"SHOW_EQUIP_WEAPON_ACTIONS\" then\n      local title = 'Select Weapon to add:'\n      state:newAndSetListing(title, Listing:unmodifiable(listAddEquipWeaponActions(selectedItem.listingTitle)))\n      showQuickAction()\n\n   elseif selectedItem.action.type == \"ADD_EQUIP_WEAPON_ACTION\" then\n      local weaponId = selectedItem.action.args\n      state:addItemTo(selectedItem.listingTitle, {\n         name = selectedItem.name,\n         texturePath = selectedItem.texturePath,\n         action = { type = \"EQUIP_TO_RIGHT_HAND\", args = weaponId },\n      })\n      state:setListing(selectedItem.listingTitle)\n      showQuickAction()\n\n   elseif selectedItem.action.type == \"EQUIP_TO_RIGHT_HAND\" then\n      local weaponId = selectedItem.action.args\n      local weapon = Actor.inventory(self):find(weaponId)\n\n      if weapon == nil then\n         print('Selected weapon ' .. selectedItem.name .. ' could not be found (id:' .. tostring(weaponId) .. ')')\n      else\n         local equipment = Actor.getEquipment(self)\n         print('Equipping ' .. selectedItem.name)\n         equipment[Actor.EQUIPMENT_SLOT.CarriedRight] = weapon\n         Actor.setEquipment(self, equipment)\n         Actor.setStance(self, Actor.STANCE.Weapon)\n      end\n      closeQuickAction()\n      state:setFirstListing()\n\n   elseif selectedItem.action.type == \"SHOW_EQUIP_SPELL_ACTIONS\" then\n      local title = 'Select Spell to add:'\n      state:newAndSetListing(title, Listing:unmodifiable(listAddEquipSpellActions(selectedItem.listingTitle)))\n      showQuickAction()\n\n   elseif selectedItem.action.type == \"ADD_EQUIP_SPELL_ACTION\" then\n      local spellId = selectedItem.action.args\n      state:addItemTo(selectedItem.listingTitle, {\n         name = selectedItem.name,\n         texturePath = selectedItem.texturePath,\n         action = { type = \"EQUIP_SPELL\", args = spellId },\n      })\n      state:setListing(selectedItem.listingTitle)\n      showQuickAction()\n\n   elseif selectedItem.action.type == \"EQUIP_SPELL\" then\n      local spellId = selectedItem.action.args\n      local spell = (core.magic.spells.records)[spellId]\n\n      if spell == nil then\n         print('Selected Spell ' .. selectedItem.name .. ' could not be found (spellId:' .. tostring(spellId) .. ')')\n      else\n         print('Equipping ' .. spell.name)\n         Actor.clearSelectedCastable(self)\n         Actor.setSelectedSpell(self, spell)\n\n         async:newUnsavableGameTimer(10, function()\n            Actor.setStance(self, Actor.STANCE.Spell)\n         end)\n      end\n      closeQuickAction()\n      state:setFirstListing()\n\n\n   elseif selectedItem.action.type == \"SHOW_EQUIP_ENCHANTED_ACTIONS\" then\n      local title = 'Select Enchantment to add:'\n      state:newAndSetListing(title, Listing:unmodifiable(listAddEquipEnchantedActions(selectedItem.listingTitle)))\n      showQuickAction()\n\n   elseif selectedItem.action.type == \"ADD_EQUIP_ENCHANTED_ACTION\" then\n      local itemId = selectedItem.action.args\n      state:addItemTo(selectedItem.listingTitle, {\n         name = selectedItem.name,\n         texturePath = selectedItem.texturePath,\n         action = { type = \"EQUIP_ENCHANTED_ITEM\", args = itemId },\n      })\n      state:setListing(selectedItem.listingTitle)\n      showQuickAction()\n\n   elseif selectedItem.action.type == \"EQUIP_ENCHANTED_ITEM\" then\n      local itemId = selectedItem.action.args\n      local item = Actor.inventory(self):find(itemId)\n\n      if item == nil then\n         print('Selected Enchanted Item ' .. selectedItem.name .. ' could not be found (id:' .. tostring(itemId) .. ')')\n      else\n         Actor.clearSelectedCastable(self)\n         Actor.setSelectedEnchantedItem(self, item)\n\n         async:newUnsavableGameTimer(10, function()\n            Actor.setStance(self, Actor.STANCE.Spell)\n         end)\n      end\n      closeQuickAction()\n      state:setFirstListing()\n\n   elseif selectedItem.action.type == 'ADD_SWITCH_TO_HAND2HAND' then\n      state:addItemTo(selectedItem.listingTitle, {\n         name = selectedItem.name,\n         texturePath = selectedItem.texturePath,\n         action = { type = \"SWITCH_TO_HAND2HAND\", args = nil },\n      })\n      state:setListing(selectedItem.listingTitle)\n      showQuickAction()\n\n   elseif selectedItem.action.type == 'SWITCH_TO_HAND2HAND' then\n      local equipment = Actor.getEquipment(self)\n      equipment[Actor.EQUIPMENT_SLOT.CarriedRight] = nil\n      Actor.setEquipment(self, equipment)\n      Actor.setStance(self, Actor.STANCE.Weapon)\n      closeQuickAction()\n      state:setFirstListing()\n\n   else\n      error('Unknown action type ' .. tostring(selectedItem.action.type))\n      closeQuickAction()\n   end\nend\n\nlocal function handleAddAction()\n   if not inputWidget or core.isWorldPaused() or not state:current().listing.isModifiable then return end\n   local title = 'Select the action to add:'\n   state:newAndSetListing(title, Listing:unmodifiable(listBasicActions(state:current().title)))\n   showQuickAction()\nend\n\nlocal function handleDelAction()\n   if not inputWidget or core.isWorldPaused() or not state:current().listing.isModifiable then return end\n   state:removeSelected()\n   showQuickAction()\nend\n\nlocal function handleMoveUpAction()\n   if not inputWidget or core.isWorldPaused() or not state:current().listing.isModifiable then return end\n   state:moveCurrentUp()\n   showQuickAction()\nend\n\nlocal function handleMoveDownAction()\n   if not inputWidget or core.isWorldPaused() or not state:current().listing.isModifiable then return end\n   state:moveCurrentDown()\n   showQuickAction()\nend\n\nlocal function handleAddListing()\n   if not inputWidget or core.isWorldPaused() or not state:current().listing.isModifiable then return end\n   state:addNextListing()\n   showQuickAction()\nend\n\nlocal function handleNextListing()\n   if not inputWidget or core.isWorldPaused() or not state:current().listing.isModifiable then return end\n   state:nextListing()\n   showQuickAction()\nend\n\nlocal function handleDelListing()\n   if not inputWidget or core.isWorldPaused() or not state:current().listing.isModifiable then return end\n   state:delListing()\n   showQuickAction()\nend\n\nlocal function handleSequentialSelection(offset)\n   if not inputWidget or core.isWorldPaused() then return end\n   local current = state:current()\n   local numItems = #current.listing.items\n   if numItems == 0 then return end\n   offset = math.max(math.min(offset, 1), -1)\n   local selected = current.selectedItemIndex or 1\n   local newSelected = math.fmod(selected + offset, numItems + 1)\n   if newSelected == 0 then\n      if offset < 0 then\n         newSelected = numItems\n      else\n         newSelected = 1\n      end\n   end\n   changeSelection(newSelected)\nend\n\nlocal function onControllerButtonPress(ctrl)\n\n   if inputWidget == nil and ctrl == controllerButtonFor('show') then\n      showQuickAction()\n\n   elseif ctrl == controllerButtonFor('select') then\n      select()\n\n   elseif ctrl == controllerButtonFor('close') then\n      closeQuickAction()\n\n   elseif ctrl == controllerButtonFor('addAction') then\n      handleAddAction()\n\n   elseif ctrl == controllerButtonFor('delAction') then\n      handleDelAction()\n\n   elseif ctrl == controllerButtonFor('moveUpAction') then\n      handleMoveUpAction()\n\n   elseif ctrl == controllerButtonFor('moveDownAction') then\n      handleMoveDownAction()\n\n   elseif ctrl == controllerButtonFor('addListing') then\n      handleAddListing()\n\n   elseif ctrl == controllerButtonFor('nextListing') then\n      handleNextListing()\n\n   elseif ctrl == controllerButtonFor('delListing') then\n      handleDelListing()\n\n   elseif ctrl == controllerButtonFor('switchToNext') then\n      handleSequentialSelection(1)\n\n   elseif ctrl == controllerButtonFor('switchToPrev') then\n      handleSequentialSelection(-1)\n\n   end\nend\n\nlocal function onKeyPress(key)\n\n   local keyName = input.getKeyName(key.code):lower()\n\n   if keyName == keyBindingNameFor('toggle') then\n      toggleQuickAction()\n\n   elseif keyName == keyBindingNameFor('addAction') then\n      handleAddAction()\n\n   elseif keyName == keyBindingNameFor('delAction') then\n      handleDelAction()\n\n   elseif keyName == keyBindingNameFor('moveUpAction') then\n      handleMoveUpAction()\n\n   elseif keyName == keyBindingNameFor('moveDownAction') then\n      handleMoveDownAction()\n\n   elseif keyName == keyBindingNameFor('addListing') then\n      handleAddListing()\n\n   elseif keyName == keyBindingNameFor('nextListing') then\n      handleNextListing()\n\n   elseif keyName == keyBindingNameFor('delListing') then\n      handleDelListing()\n\n   end\nend\n\nlocal function onMouseButtonRelease(button)\n   if button == 1 then\n      select()\n\n   elseif button == 3 then\n      closeQuickAction()\n\n   end\nend\n\nlocal function onLoad(savedData, _)\n   if savedData then\n      state = State:from(savedData)\n   end\nend\n\nlocal function onSave()\n   if state then\n      return state\n   end\nend\n\nlocal function onFrame(_)\n   if not inputWidget or core.isWorldPaused() then return end\n   local current = state:current()\n   local y = input.getMouseMoveY()\n   local x = input.getMouseMoveX()\n   if math.abs(x) + math.abs(y) <= 5 then return end\n   local angle = 2 * math.pi / #current.listing.items\n   local pointAngle = math.atan(y / x)\n   if pointAngle < 0 then\n      if y < 0 then\n         pointAngle = 2 * math.pi + pointAngle\n      else\n         pointAngle = math.pi + pointAngle\n      end\n   elseif x < 0 and y < 0 then\n      pointAngle = math.pi + pointAngle\n   end\n   changeSelection(1 + math.floor(pointAngle / angle))\nend\n\nlocal function onMouseWheel(vertical, _)\n   handleSequentialSelection(vertical)\nend\n\nreturn {\n   engineHandlers = {\n      onControllerButtonPress = onControllerButtonPress,\n      onMouseButtonRelease = onMouseButtonRelease,\n      onMouseWheel = onMouseWheel,\n      onKeyPress = onKeyPress,\n      onFrame = onFrame,\n      onLoad = onLoad,\n      onSave = onSave,\n   },\n}\n"
  }
}