{
  "folder_name": "Inspect It",
  "lua_files": {
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\config.lua": "local settings = require(\"InspectIt.settings\")\nlocal config = nil ---@type Config\n\n---@return Config\nlocal function Load()\n    config = config or mwse.loadConfig(settings.configPath, settings.defaultConfig)\n    return config\nend\n\nreturn Load()\n",
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\logger.lua": "local config = require(\"InspectIt.config\")\n\nlocal logger = require(\"logging.logger\").new({\n    name = \"Inspect It!\",\n    logLevel = config.development.logLevel,\n    logToConsole = config.development.logToConsole,\n    includeTimestamp = false,\n})\n\nreturn logger\n",
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\main.lua": "local config = require(\"InspectIt.config\")\nlocal logger = require(\"InspectIt.logger\")\nlocal settings = require(\"InspectIt.settings\")\n\n---@type IController[]\nlocal controllers = {\n    require(\"InspectIt.controller.renderer\").new(),\n    require(\"InspectIt.controller.bokeh\").new(),\n    require(\"InspectIt.controller.visibility\").new(),\n    require(\"InspectIt.controller.guide\").new(),\n    require(\"InspectIt.controller.menumode\").new(),\n    require(\"InspectIt.controller.inspector\").new(),\n}\n\n ---@param object tes3activator|tes3alchemy|tes3apparatus|tes3armor|tes3bodyPart|tes3book|tes3clothing|tes3container|tes3containerInstance|tes3creature|tes3creatureInstance|tes3door|tes3ingredient|tes3leveledCreature|tes3leveledItem|tes3light|tes3lockpick|tes3misc|tes3npc|tes3npcInstance|tes3probe|tes3repairTool|tes3static|tes3weapon\n ---@param itemData tes3itemData?\n ---@return string?\n local function FindSoulName(object, itemData)\n    if object.objectType == tes3.objectType.miscItem then\n        ---@cast object tes3misc\n        if object.isSoulGem and itemData and itemData.soul and itemData.soul.id then\n            logger:debug(\"Find soul in item: %s\", itemData.soul.name)\n            return itemData.soul.name\n        end\n    end\n    return nil\nend\n\n ---@param object tes3activator|tes3alchemy|tes3apparatus|tes3armor|tes3bodyPart|tes3book|tes3clothing|tes3container|tes3containerInstance|tes3creature|tes3creatureInstance|tes3door|tes3ingredient|tes3leveledCreature|tes3leveledItem|tes3light|tes3lockpick|tes3misc|tes3npc|tes3npcInstance|tes3probe|tes3repairTool|tes3static|tes3weapon\n ---@return AnotherLookType? type\n ---@return BodyPartData|WeaponSheathingData? data\nlocal function FindAnotherLook(object)\n    if object.objectType == tes3.objectType.armor or object.objectType == tes3.objectType.clothing then\n        -- Body Parts\n        -- FIXME Sometimes it crashes at skinInstance reference or delayed release or something. So, until the cause of it is found, experimental\n        ---@cast object tes3armor|tes3clothing\n        if config.development.experimental and tes3.player and tes3.player.object and object.parts then\n            local female = tes3.player.object.female -- depends on player\n            local parts = object.parts\n            local bodyParts = {} ---@type BodyPart[]\n            for _, ware in ipairs(parts) do\n                local part = ware.male\n                if female and ware.female then\n                    part = ware.female\n                end\n                if part then\n                    local data = { type = ware.type, part = part }\n                    table.insert(bodyParts, data)\n                end\n            end\n            local count = table.size(bodyParts)\n            if count > 0 then\n                -- just shield, helms\n                if object.objectType == tes3.objectType.armor and (object.slot == tes3.armorSlot.helmet or object.slot == tes3.armorSlot.shield) then\n                    if count == 1 and bodyParts[1].part.mesh == object.mesh then\n                        logger:debug(\"A bodypart is same mesh as object: %s\", object.mesh)\n                        return nil, nil\n                    end\n                end\n                logger:debug(\"Find bodyparts %d\", count)\n                local data = { parts = bodyParts } ---@type BodyPartData\n                return settings.anotherLookType.BodyParts, data\n            end\n        end\n    elseif object.objectType == tes3.objectType.weapon then\n        -- Weapon Sheathing\n        local sheathMesh = require(\"InspectIt.mod\").FindWeaponSheathingMesh(object.mesh)\n        if sheathMesh then\n            logger:info(\"Find weapon sheathing mesh: %s\", sheathMesh)\n            local data = { path = sheathMesh } ---@type WeaponSheathingData\n            return settings.anotherLookType.WeaponSheathing, data\n        end\n    elseif object.objectType == tes3.objectType.book then\n        -- Book or Scroll\n        ---@cast object tes3book\n        -- Books with scripts are excluded because scripts are not executed when the book is opened.\n        if not object.script then\n            if object.text then\n                -- exclude in barter? check owner?\n                logger:debug(\"Find book or scroll contents\")\n                local data = { type = object.type, text = object.text }\n                return settings.anotherLookType.Book, data\n            end\n        else\n            tes3.messageBox(settings.i18n(\"messageBox.bookRequirement.text\", { name = object.name }))\n            logger:debug(\"book has a script id: %s sourceMod: %s, scirpt id: %s, sourceMod: %s\", object.id, object.sourceMod, object.script.id, object.script.sourceMod)\n        end\n    end\n    return nil, nil\nend\n\n\n---@param params EnterParams\n---@return niBillboardNode|niCollisionSwitch|niNode|niSortAdjustNode|niSwitchNode?\nlocal function FindReferenceNode(params)\n    -- only npc\n    -- TODO allow creature?\n    if params.reference and params.object.objectType == tes3.objectType.npc then\n        return params.reference.sceneNode\n    end\n    return nil\nend\n\n ---@param object tes3activator|tes3alchemy|tes3apparatus|tes3armor|tes3bodyPart|tes3book|tes3clothing|tes3container|tes3containerInstance|tes3creature|tes3creatureInstance|tes3door|tes3ingredient|tes3leveledCreature|tes3leveledItem|tes3light|tes3lockpick|tes3misc|tes3npc|tes3npcInstance|tes3probe|tes3repairTool|tes3static|tes3weapon?\n ---@return boolean? can nil is implicitly NO.\nlocal function CanInspection(object)\n    if not object then\n        return nil\n    end\n    if config.development.experimental then\n        return true\n    end\n\n    local enabled = {\n        [tes3.objectType.activator] = true,\n        [tes3.objectType.alchemy] = true,\n        [tes3.objectType.ammunition] = true,\n        [tes3.objectType.apparatus] = true,\n        [tes3.objectType.armor] = true,\n        -- [tes3.objectType.bodyPart] = true,\n        [tes3.objectType.book] = true,\n        -- [tes3.objectType.cell] = true,\n        [tes3.objectType.clothing] = true,\n        [tes3.objectType.container] = true,\n        [tes3.objectType.creature] = true,\n        [tes3.objectType.door] = true,\n        -- [tes3.objectType.enchantment] = true,\n        [tes3.objectType.ingredient] = true,\n        -- [tes3.objectType.land] = true,\n        -- [tes3.objectType.landTexture] = true,\n        -- [tes3.objectType.leveledCreature] = true,\n        -- [tes3.objectType.leveledItem] = true,\n        [tes3.objectType.light] = true,\n        [tes3.objectType.lockpick] = true,\n        -- [tes3.objectType.magicEffect] = true,\n        [tes3.objectType.miscItem] = true,\n        -- [tes3.objectType.mobileActor] = true,\n        -- [tes3.objectType.mobileCreature] = true,\n        -- [tes3.objectType.mobileNPC] = true,\n        -- [tes3.objectType.mobilePlayer] = true,\n        -- [tes3.objectType.mobileProjectile] = true,\n        -- [tes3.objectType.mobileSpellProjectile] = true,\n        [tes3.objectType.npc] = true,\n        [tes3.objectType.probe] = true,\n        -- [tes3.objectType.reference] = true,\n        -- [tes3.objectType.region] = true,\n        [tes3.objectType.repairItem] = true,\n        -- [tes3.objectType.spell] = true,\n        -- [tes3.objectType.static] = true,\n        [tes3.objectType.weapon] = true,\n    }\n\n    return enabled[object.objectType]\nend\n\n---@param menuExit boolean\nlocal function LeaveInspection(menuExit)\n    for _, controller in ipairs(controllers) do\n        controller:Deactivate({ menuExit = menuExit })\n    end\n    logger:info(\"Leave Inspection\")\nend\n\n---@class EnterParams\n---@field object tes3activator|tes3alchemy|tes3apparatus|tes3armor|tes3bodyPart|tes3book|tes3clothing|tes3container|tes3containerInstance|tes3creature|tes3creatureInstance|tes3door|tes3ingredient|tes3leveledCreature|tes3leveledItem|tes3light|tes3lockpick|tes3misc|tes3npc|tes3npcInstance|tes3probe|tes3repairTool|tes3static|tes3weapon?\n---@field itemData tes3itemData?\n---@field reference tes3reference?\n\n---@param params EnterParams\n---@return boolean\nlocal function EnterInspection(params)\n    if not params.object then\n        return false\n    end\n    -- when picking a item\n    local cursor = tes3ui.findHelpLayerMenu(\"CursorIcon\")\n    if cursor then\n        local tile = cursor:getPropertyObject(\"MenuInventory_Thing\", \"tes3inventoryTile\")\n        if tile then\n            return false\n        end\n    end\n\n    local can = CanInspection(params.object)\n    if not can then\n        logger:info(\"Unsupported Inspection: %s\", params.object.name)\n        if can == false then\n            tes3.messageBox(settings.i18n(\"messageBox.unsupport.text\"))\n        end\n        return false\n    end\n\n    local name = params.object.name\n    -- resolve soul suffix or can get anywhere?\n    local soul = FindSoulName(params.object, params.itemData)\n    if soul then\n        name = string.format(\"%s (%s)\", name, soul)\n    end\n\n    local another, data = FindAnotherLook(params.object)\n    local status, description = pcall(function() return require(\"InspectIt.mod\").FindTooltipsComplete(params.object, params.itemData) end)\n    if not status then\n        logger:error(\"Failed to call Tooltips Complete: %s\", tostring(description))\n        description = nil\n    elseif description then\n        if type(description) == \"string\" then\n            logger:debug(\"Find description from Tooltips Complete\")\n        else\n            logger:warn(\"Invalid data from Tooltips Complete\")\n            description = nil\n        end\n    end\n\n    local referenceNode = FindReferenceNode(params)\n\n    logger:info(\"Enter Inspection name: %s, id: %s, sourceMod: %s\", params.object.name, params.object.id, settings.GetSourceMod(params.object))\n\n    ---@type Activate.Params\n    local args = { object = params.object, offset = 20, another = { type = another, data = data }, description = description, name = name, referenceNode = referenceNode }\n    for _, controller in ipairs(controllers) do\n        controller:Activate(args)\n    end\n    return true\nend\n\n---@param e keyDownEventData\n---@param key mwseKeyCombo\n---@return boolean\nlocal function TestInput(e, key)\n    if key.keyCode ~= e.keyCode then\n        return false\n    end\n    if key.isAltDown and not e.isAltDown then\n        return false\n    end\n    if key.isControlDown and not e.isControlDown then\n        return false\n    end\n    if key.isShiftDown and not e.isShiftDown then\n        return false\n    end\n    return true\nend\n\n-- Only when it is possible to activate outside objects with the cursor on the inventory screen.\n-- Right-click menu, containers\nlocal allowedMenus = {\n    [tes3ui.registerID(\"MenuContents\")] = true, -- Container/NPC inventory\n    [tes3ui.registerID(\"MenuInventory\")] = true, -- Player inventory\n    [tes3ui.registerID(\"MenuMulti\")] = true, -- Status bars, current weapon/magic, active effects and minimap\n    [tes3ui.registerID(\"MenuMagic\")] = true, -- Spell/enchanted item selector\n    [tes3ui.registerID(\"MenuMap\")] = true, --\n    [tes3ui.registerID(\"MenuStat\")] = true, -- Player attributes, skills, factions etc.\n}\n-- focus may come to the inventory, but it is impossible.\nlocal deniedMenus = {\n    tes3ui.registerID(\"MenuBarter\"),\n}\n\n-- FIXME I'm sure there's a smarter way, but I can't find a way.\n---@return boolean\nlocal function CanSelectByCursor()\n    local top = tes3ui.getMenuOnTop()\n    if top and top.visible and allowedMenus[top.id] == true then\n        for _, id in ipairs(deniedMenus) do\n            if tes3ui.findMenu(id) ~= nil then\n                logger:debug(\"Cursor selection blocked.\")\n                return false\n            end\n        end\n        logger:debug(\"Cursor selection allowed.\")\n        return true\n    end\n    logger:debug(\"Cursor selection not available.\")\n    return false\nend\n\n--- listener\n---@class Context\nlocal context = {\n    enable = false,\n    object = nil, ---@type tes3activator|tes3alchemy|tes3apparatus|tes3armor|tes3bodyPart|tes3book|tes3clothing|tes3container|tes3containerInstance|tes3creature|tes3creatureInstance|tes3door|tes3ingredient|tes3leveledCreature|tes3leveledItem|tes3light|tes3lockpick|tes3misc|tes3npc|tes3npcInstance|tes3probe|tes3repairTool|tes3static|tes3weapon?\n    itemData = nil, ---@type tes3itemData?\n    isPlayer = false,\n}\n\nlocal function ResetContext()\n    context.object = nil\n    context.itemData = nil\n    context.isPlayer = false\nend\n\n---@type {[number]: number}\nlocal bookMenus = {\n    [tes3ui.registerID(\"MenuBook\")] = tes3ui.registerID(\"MenuBook_button_close\"),\n    [tes3ui.registerID(\"MenuScroll\")] = tes3ui.registerID(\"MenuScroll_Close\"),\n}\n\n---@return boolean\nlocal function CloseBookMenu()\n    local top = tes3ui.getMenuOnTop()\n    if top then\n        local menu = bookMenus[top.id]\n        if menu then\n            local close = top:findChild(menu)\n            if close and close.visible then\n                logger:debug(\"Close book/scroll menu\")\n                close:triggerEvent(tes3.uiEvent.mouseClick)\n                return true\n            end\n        end\n    end\n    return false\nend\n\n---@param e keyDownEventData\nlocal function OnKeyDown(e)\n    if tes3.onMainMenu() then\n        return\n    end\n\n    if context.enable then\n        if settings.OnOtherMenu() then\n            -- pause\n\n            -- When a book is open, it can be closed and finished\n            -- FIXME Here's where I'd like to delegate because I don't know the state inside the controller...\n            if TestInput(e, config.input.inspect) then\n                if CloseBookMenu() then\n                    context.enable = false\n                    LeaveInspection(false) -- FIXME won't play up/down both sound... separate flags?\n                    tes3.worldController.menuClickSound:play()\n                end\n            elseif TestInput(e, config.input.another) then\n                CloseBookMenu()\n            end\n        else\n            if TestInput(e, config.input.inspect) then\n                context.enable = false\n                LeaveInspection(false)\n                tes3.worldController.menuClickSound:play()\n            elseif TestInput(e, config.input.another) then\n                -- Sound is played even when another does not exist.\n                event.trigger(settings.switchAnotherLookEventName)\n            elseif TestInput(e, config.input.lighting) then\n                event.trigger(settings.switchLightingEventName)\n                tes3.worldController.menuClickSound:play()\n            elseif TestInput(e, config.input.reset) then\n                event.trigger(settings.resetPoseEventName)\n                tes3.worldController.menuClickSound:play()\n            end\n        end\n    else\n        if TestInput(e, config.input.inspect) then\n            local reference = nil ---@type tes3reference?\n            if not context.object then\n                if tes3.menuMode() then\n                    if context.isPlayer then\n                        -- When FPV, it seems there is no full body reference.\n                        if tes3.is3rdPerson() then\n                            reference = tes3.player\n                            context.object = reference.object\n                        elseif config.development.experimental then\n                            reference = tes3.player1stPerson\n                            context.object = reference.object\n                        else\n                            tes3.messageBox(settings.i18n(\"messageBox.playerRequirement.text\"))\n                        end\n                        context.itemData = nil\n                    elseif config.inspection.cursorOver and CanSelectByCursor() then\n                        -- cursor to world\n                        local cursor = tes3.getCursorPosition()\n                        local camera = tes3.worldController.worldCamera.cameraData.camera\n                        local position, direction = camera:windowPointToRay({ cursor.x, cursor.y })\n                        local maxDistance = tes3.getPlayerActivationDistance()\n                        if tes3.is3rdPerson() then\n                            -- Too short, so add more distance, Is there any way to get the correct distance?\n                            maxDistance = maxDistance + tes3.getCameraPosition():distance(tes3.getPlayerEyePosition())\n                        end\n\n                        local hit = tes3.rayTest({\n                            position = position,\n                            direction = direction,\n                            --ignore = { tes3.player },\n                            maxDistance = maxDistance ,\n                        })\n                        -- hit non activatable objects...\n                        if hit and hit.reference then\n                            logger:debug(\"Hit: %s\", hit.reference.id)\n                            reference = hit.reference\n                            context.object = reference.object\n                            context.itemData = tes3.getAttachment(reference, \"itemData\") --[[@as tes3itemData?]]\n                        end\n                    end\n                else\n                    if config.inspection.activatable then\n                        -- in game\n                        local ref = tes3.getPlayerTarget()\n                        if ref and ref.object then\n                            reference = ref\n                            context.object = reference.object\n                            context.itemData = tes3.getAttachment(reference, \"itemData\") --[[@as tes3itemData?]]\n                        elseif config.development.experimental then\n                            local maxDistance = tes3.getPlayerActivationDistance()\n                            if tes3.is3rdPerson() then\n                                maxDistance = maxDistance +\n                                tes3.getCameraPosition():distance(tes3.getPlayerEyePosition())\n                            end\n                            local hit = tes3.rayTest({\n                                position = tes3.getPlayerEyePosition(),\n                                direction = tes3.getPlayerEyeVector(),\n                                ignore = { tes3.player }, -- for no offseted TPV\n                                maxDistance = maxDistance,\n                            })\n                            if hit and hit.reference then\n                                logger:debug(\"Hit: %s\", hit.reference.id)\n                                reference = hit.reference\n                                context.object = reference.object\n                                context.itemData = tes3.getAttachment(reference, \"itemData\") --[[@as tes3itemData?]]\n                            end\n                        end\n                    end\n                end\n            end\n            if EnterInspection({ object = context.object, itemData = context.itemData, reference = reference }) then\n                context.enable = true\n                tes3.worldController.menuClickSound:play()\n            end\n            ResetContext()\n        end\n        if context.enable then\n            --e.claim = true\n        end\n    end\nend\n\n---@param e itemTileUpdatedEventData\nlocal function OnItemTileUpdated(e)\n    if not e.menu then\n        return\n    end\n    local allowed = {\n        [\"MenuInventory\"] = config.inspection.inventory,\n        [\"MenuBarter\"] = config.inspection.barter,\n        [\"MenuContents\"] = config.inspection.contents,\n    }\n    if not allowed[e.menu.name] then\n        -- Selector does not seem to trigger, but even if it does not exist, it is ignored.\n        return\n    end\n\n    e.element:registerAfter(tes3.uiEvent.mouseOver,\n        ---@param ev tes3uiEventData\n        function(ev)\n            ResetContext()\n            context.object = e.item\n            context.itemData = e.itemData\n        end)\n    e.element:registerAfter(tes3.uiEvent.mouseLeave,\n        ---@param ev tes3uiEventData\n        function(ev)\n            ResetContext()\n        end)\nend\n\n---@param e menuExitEventData\nlocal function OnMenuExit(e)\n    -- fail-safe\n    if context.enable then\n        logger:error(\"Inspection was not terminated\")\n        context.enable = false\n        LeaveInspection(true)\n    end\n    ResetContext()\nend\n\n---@param e loadEventData\nlocal function OnLoad(e)\n    if context.enable then\n        context.enable = false\n        LeaveInspection(true)\n    end\n    -- or deallocate\n    for _, controller in ipairs(controllers) do\n        controller:Reset()\n    end\n    ResetContext()\nend\n\n--- @param e uiActivatedEventData\nlocal function OnUIActivated(e)\n    if not e.newlyCreated then\n\t\treturn\n\tend\n    local image = e.element:findChild(\"MenuInventory_CharacterImage\")\n    if image then\n        image:registerAfter(tes3.uiEvent.mouseOver,\n            ---@param ev tes3uiEventData\n            function(ev)\n                local accept = config.inspection.inventory\n                -- find menu mode\n                local allowed = {\n                    [\"MenuBarter\"] = config.inspection.barter,\n                    [\"MenuContents\"] = config.inspection.contents,\n                }\n                for key, value in pairs(allowed) do\n                    local menu = tes3ui.findMenu(key)\n                    if menu and menu.visible then\n                        accept = value\n                        break\n                    end\n                end\n                if accept then\n                    ResetContext()\n                    context.isPlayer = true\n                end\n            end)\n        image:registerAfter(tes3.uiEvent.mouseLeave,\n            ---@param ev tes3uiEventData\n            function(ev)\n                ResetContext()\n            end)\n    end\nend\n\nlocal function OnInitialized()\n    event.register(tes3.event.itemTileUpdated, OnItemTileUpdated)\n    event.register(tes3.event.keyDown, OnKeyDown, { priority = 0 })\n    event.register(tes3.event.menuExit, OnMenuExit)\n    event.register(tes3.event.load, OnLoad)\n    event.register(tes3.event.uiActivated, OnUIActivated)\n\n    -- menu event\n    event.register(settings.returnEventName,\n    function(_)\n        if context.enable then\n            context.enable = false\n            LeaveInspection(false)\n        end\n    end)\n\n    require(\"InspectIt.mod\").RegisterRightClickMenuExit()\nend\n\nif mge.enabled() then\n    event.register(tes3.event.initialized, OnInitialized)\nelse\n    logger:error(\"This mod requires MGE XE to be enabled.\")\nend\n\nrequire(\"InspectIt.mcm\")\n\n--- @class tes3scriptVariables\n",
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\mcm.lua": "--- @param e modConfigReadyEventData\nlocal function OnModConfigReady(e)\n    local config = require(\"InspectIt.config\")\n    local settings = require(\"InspectIt.settings\")\n    local template = mwse.mcm.createTemplate(settings.modName)\n    template:saveOnClose(settings.configPath, config)\n    template:register()\n\n    local page = template:createSideBarPage({\n        label = settings.i18n(\"mcm.page.label\")\n    })\n    local info = page.sidebar:createInfo({\n        label = string.format(\"%s %s\",settings.modName, settings.version),\n        text = settings.i18n(\"mcm.sidebar.info\")\n    })\n    page.sidebar:createHyperlink({\n        text = settings.metadata.package.homepage,\n        url = settings.metadata.package.homepage,\n    })\n    page.sidebar:createHyperlink({\n        text = settings.metadata.package.repository,\n        url = settings.metadata.package.repository,\n    })\n\n    do\n        local input = page:createCategory({\n            label = settings.i18n(\"mcm.input.category.label\"),\n            description = settings.i18n(\"mcm.input.category.description\"),\n        })\n        input:createKeyBinder({\n            label = settings.i18n(\"mcm.input.inspect.label\"),\n            description = settings.i18n(\"mcm.input.inspect.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"inspect\",\n                table = config.input,\n            }),\n            allowCombinations = true,\n            allowMouse = false,\n        })\n        input:createKeyBinder({\n            label = settings.i18n(\"mcm.input.another.label\"),\n            description = settings.i18n(\"mcm.input.another.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"another\",\n                table = config.input,\n            }),\n            allowCombinations = true,\n            allowMouse = false,\n        })\n        input:createKeyBinder({\n            label = settings.i18n(\"mcm.input.lighting.label\"),\n            description = settings.i18n(\"mcm.input.lighting.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"lighting\",\n                table = config.input,\n            }),\n            allowCombinations = true,\n            allowMouse = false,\n        })\n        input:createKeyBinder({\n            label = settings.i18n(\"mcm.input.reset.label\"),\n            description = settings.i18n(\"mcm.input.reset.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"reset\",\n                table = config.input,\n            }),\n            allowCombinations = true,\n            allowMouse = false,\n        })\n\n        input:createSlider({\n            label = settings.i18n(\"mcm.input.sensitivityX.label\"),\n            description = settings.i18n(\"mcm.input.sensitivityX.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"sensitivityX\",\n                table = config.input,\n            }),\n            min = 0,\n            max = 2,\n            step = 0.01,\n            jump = 0.05,\n            decimalPlaces = 2,\n        })\n        input:createSlider({\n            label = settings.i18n(\"mcm.input.sensitivityY.label\"),\n            description = settings.i18n(\"mcm.input.sensitivityY.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"sensitivityY\",\n                table = config.input,\n            }),\n            min = 0,\n            max = 2,\n            step = 0.01,\n            jump = 0.05,\n            decimalPlaces = 2,\n        })\n        input:createSlider({\n            label = settings.i18n(\"mcm.input.sensitivityZ.label\"),\n            description = settings.i18n(\"mcm.input.sensitivityZ.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"sensitivityZ\",\n                table = config.input,\n            }),\n            min = 0,\n            max = 2,\n            step = 0.01,\n            jump = 0.05,\n            decimalPlaces = 2,\n        })\n        input:createOnOffButton({\n            label = settings.i18n(\"mcm.input.inversionX.label\"),\n            description = settings.i18n(\"mcm.input.inversionX.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"inversionX\",\n                table = config.input,\n            }),\n        })\n        input:createOnOffButton({\n            label = settings.i18n(\"mcm.input.inversionY.label\"),\n            description = settings.i18n(\"mcm.input.inversionY.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"inversionY\",\n                table = config.input,\n            }),\n        })\n        input:createOnOffButton({\n            label = settings.i18n(\"mcm.input.inversionZ.label\"),\n            description = settings.i18n(\"mcm.input.inversionZ.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"inversionZ\",\n                table = config.input,\n            }),\n        })\n    end\n    do\n        local inspection = page:createCategory({\n            label = settings.i18n(\"mcm.inspection.category.label\"),\n            description = settings.i18n(\"mcm.inspection.category.description\"),\n        })\n        inspection:createOnOffButton({\n            label = settings.i18n(\"mcm.inspection.inventory.label\"),\n            description = settings.i18n(\"mcm.inspection.inventory.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"inventory\",\n                table = config.inspection,\n            }),\n        })\n        inspection:createOnOffButton({\n            label = settings.i18n(\"mcm.inspection.barter.label\"),\n            description = settings.i18n(\"mcm.inspection.barter.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"barter\",\n                table = config.inspection,\n            }),\n        })\n        inspection:createOnOffButton({\n            label = settings.i18n(\"mcm.inspection.contents.label\"),\n            description = settings.i18n(\"mcm.inspection.contents.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"contents\",\n                table = config.inspection,\n            }),\n        })\n        inspection:createOnOffButton({\n            label = settings.i18n(\"mcm.inspection.cursorOver.label\"),\n            description = settings.i18n(\"mcm.inspection.cursorOver.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"cursorOver\",\n                table = config.inspection,\n            }),\n        })\n        inspection:createOnOffButton({\n            label = settings.i18n(\"mcm.inspection.activatable.label\"),\n            description = settings.i18n(\"mcm.inspection.activatable.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"activatable\",\n                table = config.inspection,\n            }),\n        })\n        inspection:createOnOffButton({\n            label = settings.i18n(\"mcm.inspection.playSound.label\"),\n            description = settings.i18n(\"mcm.inspection.playSound.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"playSound\",\n                table = config.inspection,\n            }),\n        })\n    end\n    do\n        local display = page:createCategory({\n            label = settings.i18n(\"mcm.display.category.label\"),\n            description = settings.i18n(\"mcm.display.category.description\"),\n        })\n        display:createOnOffButton({\n            label = settings.i18n(\"mcm.display.instruction.label\"),\n            description = settings.i18n(\"mcm.display.instruction.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"instruction\",\n                table = config.display,\n            }),\n        })\n        display:createOnOffButton({\n            label = settings.i18n(\"mcm.display.bokeh.label\"),\n            description = settings.i18n(\"mcm.display.bokeh.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"bokeh\",\n                table = config.display,\n            }),\n        })\n        display:createOnOffButton({\n            label = settings.i18n(\"mcm.display.leftPart.label\"),\n            description = settings.i18n(\"mcm.display.leftPart.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"leftPart\",\n                table = config.display,\n            }),\n        })\n        display:createOnOffButton({\n            label = settings.i18n(\"mcm.display.recalculateBounds.label\"),\n            description = settings.i18n(\"mcm.display.recalculateBounds.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"recalculateBounds\",\n                table = config.display,\n            }),\n        })\n        display:createOnOffButton({\n            label = settings.i18n(\"mcm.display.tooltipsComplete.label\"),\n            description = settings.i18n(\"mcm.display.tooltipsComplete.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"tooltipsComplete\",\n                table = config.display,\n            }),\n        })\n        display:createOnOffButton({\n            label = settings.i18n(\"mcm.display.objectId.label\"),\n            description = settings.i18n(\"mcm.display.objectId.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"objectId\",\n                table = config.display,\n            }),\n        })\n        display:createOnOffButton({\n            label = settings.i18n(\"mcm.display.sourceMod.label\"),\n            description = settings.i18n(\"mcm.display.sourceMod.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"sourceMod\",\n                table = config.display,\n            }),\n        })\n    end\n    do\n        local dev = page:createCategory({\n            label = settings.i18n(\"mcm.development.category.label\"),\n            description = settings.i18n(\"mcm.development.category.description\"),\n        })\n        dev:createOnOffButton({\n            label = settings.i18n(\"mcm.development.experimental.label\"),\n            description = settings.i18n(\"mcm.development.experimental.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"experimental\",\n                table = config.development,\n            }),\n        })\n        dev:createDropdown({\n            label = settings.i18n(\"mcm.development.logLevel.label\"),\n            description = settings.i18n(\"mcm.development.logLevel.description\"),\n            options = {\n                { label = \"TRACE\", value = \"TRACE\" },\n                { label = \"DEBUG\", value = \"DEBUG\" },\n                { label = \"INFO\",  value = \"INFO\" },\n                { label = \"WARN\",  value = \"WARN\" },\n                { label = \"ERROR\", value = \"ERROR\" },\n                { label = \"NONE\",  value = \"NONE\" },\n            },\n            variable = mwse.mcm.createTableVariable({\n                id = \"logLevel\",\n                table = config.development,\n            }),\n            callback = function(self)\n                local logger = require(\"InspectIt.logger\")\n                logger:setLogLevel(self.variable.value)\n            end\n        })\n        dev:createOnOffButton({\n            label = settings.i18n(\"mcm.development.logToConsole.label\"),\n            description = settings.i18n(\"mcm.development.logToConsole.description\"),\n            variable = mwse.mcm.createTableVariable({\n                id = \"logToConsole\",\n                table = config.development,\n            }),\n            callback = function(self)\n                local logger = require(\"InspectIt.logger\")\n                logger.logToConsole = config.development.logToConsole\n            end\n        })\n    end\n\n    template:createExclusionsPage({\n        label = settings.i18n(\"mcm.leftPartFilter.page.label\"),\n        description = settings.i18n(\"mcm.leftPartFilter.page.description\"),\n        leftListLabel = settings.i18n(\"mcm.leftPartFilter.page.normal\"),\n        rightListLabel = settings.i18n(\"mcm.leftPartFilter.page.mirror\"),\n        showHeader = true,\n        variable = mwse.mcm.createTableVariable({\n            id = \"leftPartFilter\",\n            table = config,\n        }),\n        filters = {\n            {\n                label = settings.i18n(\"mcm.leftPartFilter.armor.label\"),\n                type = \"Object\",\n                objectType = tes3.objectType.armor,\n                objectFilters = {\n                    isLeftPart = true,\n                },\n            },\n            {\n                label = settings.i18n(\"mcm.leftPartFilter.clothing.label\"),\n                type = \"Object\",\n                objectType = tes3.objectType.clothing,\n                objectFilters = {\n                    isLeftPart = true,\n                },\n            },\n            {\n                label = settings.i18n(\"mcm.leftPartFilter.sameArmor.label\"),\n                callback = function()\n                    return require(\"InspectIt.component.mesh\").GetArmorSameMeshAsRightPart()\n                end\n            },\n            {\n                label = settings.i18n(\"mcm.leftPartFilter.sameClothing.label\"),\n                callback = function()\n                    return require(\"InspectIt.component.mesh\").GetClothingSameMeshAsRightPart()\n                end\n            },\n            {\n                label = settings.i18n(\"mcm.leftPartFilter.plugin.label\"),\n                type = \"Plugin\",\n            },\n        }\n    })\nend\nevent.register(tes3.event.modConfigReady, OnModConfigReady)\n",
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\mod.lua": "\n---@class ModAssistance\nlocal this = {}\n\nlocal settings = require(\"InspectIt.settings\")\n\n--- Right Click Menu Exit https://www.nexusmods.com/morrowind/mods/48458\nfunction this.RegisterRightClickMenuExit()\n    local RightClickMenuExit = include(\"mer.RightClickMenuExit\")\n    if RightClickMenuExit and RightClickMenuExit.registerMenu then\n        RightClickMenuExit.registerMenu({\n            menuId = settings.guideMenu,\n            buttonId = settings.returnButtonName,\n        })\n    end\nend\n\n-- Weapon Sheathing https://www.nexusmods.com/morrowind/mods/46069\n---@param mesh string\n---@return string?\nfunction this.FindWeaponSheathingMesh(mesh)\n    if mesh then\n        local sheathMesh = mesh:sub(1, -5) .. \"_sh.nif\"\n        if tes3.getFileExists(\"meshes\\\\\" .. sheathMesh) then\n            return sheathMesh\n        end\n    end\n    return nil\nend\n\n--- Tooltips Complete https://www.nexusmods.com/morrowind/mods/46842\n---@param object tes3activator|tes3alchemy|tes3apparatus|tes3armor|tes3bodyPart|tes3book|tes3clothing|tes3container|tes3containerInstance|tes3creature|tes3creatureInstance|tes3door|tes3ingredient|tes3leveledCreature|tes3leveledItem|tes3light|tes3lockpick|tes3misc|tes3npc|tes3npcInstance|tes3probe|tes3repairTool|tes3static|tes3weapon\n---@param itemData tes3itemData?\n---@return string?\nfunction this.FindTooltipsComplete(object, itemData)\n    local tooltipData = include(\"Tooltips Complete.data\")\n    if not tooltipData then\n        return nil\n    end\n    -- If this is run here before the original mod the first time, an invalid config will be generated.\n    -- But since it is executed in the original mod's main, it is usually not in that order.\n    local config = mwse.loadConfig(\"tooltipsComplete\")\n    if not config then\n        return nil\n    end\n    local mcmMapping = {\n        { descriptionTable = tooltipData.keyTable,        mcm = \"keyTooltips\" },\n        { descriptionTable = tooltipData.questTable,      mcm = \"questTooltips\" },\n        { descriptionTable = tooltipData.uniqueTable,     mcm = \"uniqueTooltips\" },\n        { descriptionTable = tooltipData.artifactTable,   mcm = \"artifactTooltips\" },\n        { descriptionTable = tooltipData.armorTable,      mcm = \"armorTooltips\" },\n        { descriptionTable = tooltipData.weaponTable,     mcm = \"weaponTooltips\" },\n        { descriptionTable = tooltipData.toolTable,       mcm = \"toolTooltips\" },\n        { descriptionTable = tooltipData.miscTable,       mcm = \"miscTooltips\" },\n        { descriptionTable = tooltipData.bookTable,       mcm = \"bookTooltips\" },\n        { descriptionTable = tooltipData.clothingTable,   mcm = \"clothingTooltips\" },\n        { descriptionTable = tooltipData.soulgemTable,    mcm = \"soulgemTooltips\" },\n        { descriptionTable = tooltipData.lightTable,      mcm = \"lightTooltips\" },\n        { descriptionTable = tooltipData.potionTable,     mcm = \"potionTooltips\" },\n        { descriptionTable = tooltipData.ingredientTable, mcm = \"ingredientTooltips\" },\n        { descriptionTable = tooltipData.scrollTable,     mcm = \"scrollTooltips\" },\n    }\n    if config.menuOnly then\n        -- return nil\n    end\n\n    local file = object.sourceMod\n    if file and config.blocked[file:lower()] then\n        return\n    elseif config.blocked[object.id:lower()] then\n        return\n    end\n\n    for _, data in ipairs(mcmMapping) do\n        local description = data.descriptionTable[object.id:lower()]\n        if config[data.mcm] and description then\n            --soul gem item data\n            if (object.isSoulGem and itemData and itemData.soul) then\n                if config.blocked[itemData.soul.id:lower()] then\n                    return description\n                end\n                if (itemData.soul.id == nil) then\n                    return description\n                end\n                description = tooltipData.filledTable[itemData.soul.id:lower()] or \"\"\n            end\n            return description\n        end\n    end\n    return nil\nend\n\nreturn this\n",
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\settings.lua": "local this = {}\nthis.metadata = toml.loadFile(\"Data Files\\\\InspectIt-metadata.toml\") ---@type MWSE.Metadata?\nthis.modName = this.metadata.package.name\nthis.version = this.metadata.package.version\nthis.configPath = \"InspectIt\"\nthis.guideMenu = \"InspectIt:MenuInspection\"\nthis.guideMenuID = tes3ui.registerID(this.guideMenu)\nthis.returnButtonName = \"InspectIt:ReturnButton\"\nthis.returnEventName = \"InspectIt:ReturnEvent\"\nthis.switchAnotherLookEventName = \"InspectIt:SwitchAnotherLookEvent\"\nthis.changedAnotherLookEventName = \"InspectIt:ChangedAnotherLookEvent\"\nthis.switchLightingEventName = \"InspectIt:SwitchLightingEvent\"\nthis.toggleMirroringEventName = \"InspectIt:ToggleMirroringEvent\"\nthis.resetPoseEventName = \"InspectIt:ResetPoseEvent\"\nthis.i18n = mwse.loadTranslations(\"InspectIt\")\n\n---@class BodyPart\n---@field type tes3.activeBodyPart\n---@field part tes3bodyPart\n\n---@class BodyPartData\n---@field parts BodyPart[]\n\n---@class WeaponSheathingData\n---@field path string\n\n---@class BookData\n---@field type tes3.bookType\n---@field text string\n\n---@class AnotherLookData\n---@field type AnotherLookType?\n---@field data BodyPartData|WeaponSheathingData|BookData?\n\n---@class ChangedAnotherLookEventData\n---@field another boolean\n\n---@return boolean\nfunction this.OnOtherMenu()\n    local top = tes3ui.getMenuOnTop()\n    if top and top.id ~= this.guideMenuID then\n        return true\n    end\n    return false\nend\n\n---@param object tes3activator|tes3alchemy|tes3apparatus|tes3armor|tes3bodyPart|tes3book|tes3clothing|tes3container|tes3containerInstance|tes3creature|tes3creatureInstance|tes3door|tes3ingredient|tes3leveledCreature|tes3leveledItem|tes3light|tes3lockpick|tes3misc|tes3npc|tes3npcInstance|tes3probe|tes3repairTool|tes3static|tes3weapon?\n---@return string?\nfunction this.GetSourceMod(object)\n    if object then\n        if object.sourceMod then\n            return object.sourceMod\n        end\n        if object.isInstance and object.baseObject then\n            return object.baseObject.sourceMod\n        end\n    end\n    return nil\nend\n\n---@enum AnotherLookType\nthis.anotherLookType = {\n    BodyParts = 1,\n    WeaponSheathing = 2,\n    Book = 3,\n}\n\n---@enum LightingType\nthis.lightingType = {\n    Default = 1,\n    Constant = 2,\n}\n\n---@class Config\nthis.defaultConfig = {\n    input = {\n        ---@type mwseKeyCombo\n        inspect = {\n            keyCode = tes3.scanCode.F2 --[[@as tes3.scanCode]],\n            isShiftDown = false,\n            isAltDown = false,\n            isControlDown = false,\n        },\n        ---@type mwseKeyCombo\n        another = {\n            keyCode = tes3.scanCode.s --[[@as tes3.scanCode]],\n            isShiftDown = false,\n            isAltDown = false,\n            isControlDown = false,\n        },\n        ---@type mwseKeyCombo\n        lighting = {\n            keyCode = tes3.scanCode.f --[[@as tes3.scanCode]],\n            isShiftDown = false,\n            isAltDown = false,\n            isControlDown = false,\n        },\n        ---@type mwseKeyCombo\n        reset = {\n            keyCode = tes3.scanCode.r --[[@as tes3.scanCode]],\n            isShiftDown = false,\n            isAltDown = false,\n            isControlDown = false,\n        },\n        sensitivityX = 1,\n        sensitivityY = 1,\n        sensitivityZ = 1,\n        inversionX = false,\n        inversionY = false,\n        inversionZ = false,\n    },\n    inspection = {\n        inventory = true,\n        barter = true,\n        contents = true,\n        cursorOver = true,\n        activatable = true,\n        playSound = true,\n    },\n    display = {\n        instruction = true,\n        objectId = false,\n        sourceMod = false,\n        bokeh = true,\n        leftPart = true,\n        recalculateBounds = true,\n        tooltipsComplete = true,\n    },\n    leftPartFilter = {}, ---@type { [string] : boolean }\n    ---@class Config.Development\n    development = {\n        experimental = false,\n        logLevel = \"INFO\",\n        logToConsole = false,\n    }\n}\n\nreturn this\n",
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\component\\bodypart.lua": "---@class BodyPartResolver\nlocal this = {}\nlocal mesh = require(\"InspectIt.component.mesh\")\nlocal logger = require(\"InspectIt.logger\")\n\n---@class Socket\n---@field name string?\n---@field isLeft boolean?\n\n---@type {[tes3.activeBodyPart] : Socket }\nlocal sockets = {\n    [tes3.activeBodyPart.head]          = { name = \"Head\", },\n    [tes3.activeBodyPart.hair]          = { name = \"Head\", },\n    [tes3.activeBodyPart.neck]          = { name = \"Neck\", },\n    [tes3.activeBodyPart.chest]         = { name = \"Chest\", },\n    [tes3.activeBodyPart.groin]         = { name = \"Groin\", },\n    [tes3.activeBodyPart.skirt]         = { name = \"Groin\", },\n    [tes3.activeBodyPart.rightHand]     = { name = \"Right Hand\", isLeft = false },\n    [tes3.activeBodyPart.leftHand]      = { name = \"Left Hand\", isLeft = true },\n    [tes3.activeBodyPart.rightWrist]    = { name = \"Right Wrist\", isLeft = false },\n    [tes3.activeBodyPart.leftWrist]     = { name = \"Left Wrist\", isLeft = true },\n    [tes3.activeBodyPart.shield]        = { name = \"Shield Bone\", },\n    [tes3.activeBodyPart.rightForearm]  = { name = \"Right Forearm\", isLeft = false },\n    [tes3.activeBodyPart.leftForearm]   = { name = \"Left Forearm\", isLeft = true },\n    [tes3.activeBodyPart.rightUpperArm] = { name = \"Right Upper Arm\", isLeft = false },\n    [tes3.activeBodyPart.leftUpperArm]  = { name = \"Left Upper Arm\", isLeft = true },\n    [tes3.activeBodyPart.rightFoot]     = { name = \"Right Foot\", isLeft = false },\n    [tes3.activeBodyPart.leftFoot]      = { name = \"Left Foot\", isLeft = true },\n    [tes3.activeBodyPart.rightAnkle]    = { name = \"Right Ankle\", isLeft = false },\n    [tes3.activeBodyPart.leftAnkle]     = { name = \"Left Ankle\", isLeft = true },\n    [tes3.activeBodyPart.rightKnee]     = { name = \"Right Knee\", isLeft = false },\n    [tes3.activeBodyPart.leftKnee]      = { name = \"Left Knee\", isLeft = true },\n    [tes3.activeBodyPart.rightUpperLeg] = { name = \"Right Upper Leg\", isLeft = false },\n    [tes3.activeBodyPart.leftUpperLeg]  = { name = \"Left Upper Leg\", isLeft = true },\n    [tes3.activeBodyPart.rightPauldron] = { name = \"Right Clavicle\", isLeft = false },\n    [tes3.activeBodyPart.leftPauldron]  = { name = \"Left Clavicle\", isLeft = true },\n    [tes3.activeBodyPart.weapon]        = { name = \"Weapon Bone\", }, -- the real node name depends on the current weapon type.\n    [tes3.activeBodyPart.tail]          = { name = \"Tail\" },\n}\n\n---@param bodypart BodyPart\n---@param root niBillboardNode|niCollisionSwitch|niNode|niSortAdjustNode|niSwitchNode\nfunction this.BuildBodyPart(bodypart, root)\n    local part = bodypart.part\n    local socket = sockets[bodypart.type]\n    if not socket then\n        logger:error(\"Failed to find activeBodyPart %d: %s\", bodypart.type, bodypart.part.id)\n        return\n    end\n    local to = root:getObjectByName(socket.name) --[[@as niNode]]\n    if not to then\n        logger:error(\"Failed to find to attach to %s\", socket.name)\n        return\n    end\n\n    if not part.mesh or not tes3.getFileExists(string.format(\"Meshes\\\\%s\", part.mesh)) then\n        logger:error(\"Missing bodypart id: %s, mesh: %s, sourceMod: %s\", part.id, part.mesh, part.sourceMod)\n        return\n    end\n    logger:debug(\"Load bodypart id: %s, mesh: %s, sourceMod: %s\", part.id, part.mesh, part.sourceMod)\n    -- remaining skin instance with cache?\n    local model = tes3.loadMesh(part.mesh, false) --[[@as niBillboardNode|niCollisionSwitch|niNode|niSortAdjustNode|niSwitchNode]]\n    if not model.name then\n        model.name = string.format(\"%s\", part.mesh)\n    end\n    -- NOTE: If the root doesn't niNode (like niTriShape), it seems to create.\n    -- NOTE: Worst of all, \"a\\A_Daedric_Skins.nif\"'s bone naming convention is ridiculous and non-standard. It even has a niNode with Tri prefix name. That will be removed on loading.\n    logger:trace(\"%s\", mesh.Dump(model))\n\n    -- case-senstive?\n    local bip01 = model:getObjectByName(\"Bip01\") --[[@as niNode]]\n    local rootbone = model:getObjectByName(\"Root Bone\") --[[@as niNode]] -- maybe creature only\n    local skeleton = bip01 ~= nil or rootbone ~= nil\n\n    if skeleton then\n        -- place root children\n        local parent = niNode.new()\n        parent.name = socket.name -- sometime, skirt name is \"Skirt\", but ok\n        root:attachChild(parent)\n        to.parent:detachChild(to)\n\n        local prefix = \"tri \" .. socket.name:lower()\n        logger:trace(\"NiTriShape prefix: %s\", prefix)\n        mesh.foreach(model, function(node, _)\n            if node:isInstanceOfType(ni.type.NiTriShape) then\n                if node.name and node.name:lower():startswith(prefix) ~= true then\n                    -- ignore unmatched part\n                    logger:trace(\"Ignored: %s\", node.name)\n                    return\n                end\n                parent:attachChild(node)\n                -- retarget\n                if node.skinInstance then\n                    -- It seems to crash if you try to check nil\n                    node.skinInstance.root = parent\n                    for index, bone in ipairs(node.skinInstance.bones) do\n                        node.skinInstance.bones[index] = root:getObjectByName(bone.name)\n                    end\n                end\n            end\n        end)\n    else\n        -- use root node\n        local parent = model\n        parent.name = socket.name\n        parent:copyTransforms(to)\n\n        -- bone offset\n        -- untest: In the case of vanilla, this seems to be fine without it because it is used as light sources...\n        local offset = model:getObjectByName(\"BoneOffset\")\n        if offset then\n            logger:trace(\"BoneOffset: %s\", offset.translation)\n            parent.translation = parent.translation:copy() + offset.translation:copy()\n        end\n\n        -- mirror\n        if socket.isLeft == true then\n            -- BSMirroredNode\n            local mirror = niNode.new()\n            mirror.name = \"Mirrored\"\n            mirror.rotation = tes3matrix33.new(\n                -1, 0, 0,\n                0, 1, 0,\n                0, 0, 1\n            )\n            -- add stencil property\n            for _, child in ipairs(parent.children) do\n                mirror:attachChild(child)\n            end\n            parent:detachAllChildren()\n            parent:attachChild(mirror)\n        end\n\n        -- replace\n        to.parent:attachChild(parent)\n        to.parent:detachChild(to)\n\n    end\n\nend\n\nreturn this\n",
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\component\\mesh.lua": "---@class MeshProcessor\nlocal this = {}\nlocal logger = require(\"InspectIt.logger\")\nlocal config = require(\"InspectIt.config\")\nlocal settings = require(\"InspectIt.settings\")\n\nlocal sameArmor = nil ---@type string[]\nlocal sameClothing = nil ---@type string[]\n\n---@param node niAmbientLight|niBillboardNode|niCamera|niCollisionSwitch|niDirectionalLight|niNode|niParticles|niPointLight|niRotatingParticles|niSortAdjustNode|niSpotLight|niSwitchNode|niTextureEffect|niTriShape\n---@param func fun(node : niAmbientLight|niBillboardNode|niCamera|niCollisionSwitch|niDirectionalLight|niNode|niParticles|niPointLight|niRotatingParticles|niSortAdjustNode|niSpotLight|niSwitchNode|niTextureEffect|niTriShape, depth : number)\n---@param depth integer?\nfunction this.foreach(node, func, depth)\n    depth = depth or 0\n    func(node, depth)\n    if node.children then\n        local d = depth + 1\n        for _, child in ipairs(node.children) do\n            if child then\n                this.foreach(child, func, d)\n            end\n        end\n    end\nend\n\n---@param path string?\n---@return string?\nfunction this.ResolvePath(path)\n    if not path then\n        return nil\n    end\n    -- split directory and filename\n    local dir, name = path:match(\"^(.-)([^\\\\/]-%.([^\\\\/%.]-))$\")\n    logger:trace(\"dir: %s, name: %s\", dir, name)\n    local xpath = string.format(\"%sx%s\", dir, name)\n    if tes3.getFileExists(string.format(\"Meshes\\\\%s\", xpath)) then\n        logger:debug(\"Find xnif: %s\", xpath)\n        return xpath\n    end\n    if tes3.getFileExists(string.format(\"Meshes\\\\%s\", path)) then\n        logger:debug(\"Find nif: %s\", path)\n        return path\n    end\n    return nil\nend\n\n-- FIXME Usually, this is not a problem, but if the same mesh is diverted from the armor, even if it is not from the left or right side, it will not work.\n-- We need more information to record in the memo.\n---@param objectType tes3.objectType\n---@return string[] ids\nlocal function CollectSameMeshAsRightPart(objectType)\n    local result = {} ---@type {[string]: boolean}\n    local memo = {} ---@type {[string]: string|boolean}\n    for o in tes3.iterateObjects(objectType) do\n        ---@cast o tes3armor|tes3clothing\n        if o.mesh then\n            local mesh = o.mesh:lower()\n            if o.isLeftPart then\n                local id = o.id:lower()\n                if memo[mesh] == true then -- contain boolean\n                    result[id] = true\n                    logger:trace(\"same mesh: %s, %s, %s\", id, o.sourceMod, mesh)\n                else\n                    memo[mesh] = id\n                end\n            else -- right or normal\n                if memo[mesh] and memo[mesh] ~= true then -- contain id\n                    result[memo[mesh]] = true\n                    logger:trace(\"same mesh: %s, %s, %s\", memo[mesh], o.sourceMod, mesh)\n                end\n                memo[mesh] = true\n            end\n        end\n    end\n    return table.keys(result, true)\nend\n\n---@return string[]\nfunction this.GetArmorSameMeshAsRightPart()\n    if not sameArmor then\n        sameArmor = CollectSameMeshAsRightPart(tes3.objectType.armor)\n        logger:debug(\"same mesh armor count: %d\", table.size(sameArmor))\n    end\n    return sameArmor\nend\n\n---@return string[]\nfunction this.GetClothingSameMeshAsRightPart()\n    if not sameClothing then\n        sameClothing = CollectSameMeshAsRightPart(tes3.objectType.clothing)\n        logger:debug(\"same mesh clothing count: %d\", table.size(sameClothing))\n    end\n    return sameClothing\nend\n\n---@param id string\n---@return boolean\nfunction this.CanMirrorById(id)\n    if config.leftPartFilter[id:lower()] == true then\n        logger:debug(\"Exclude mirror the left part by id: %s\", id)\n        return false\n    end\n    return true\nend\n\n---@param sourceMod string?\n---@return boolean\nfunction this.CanMirrorBySourceMod(sourceMod)\n    if sourceMod and config.leftPartFilter[sourceMod:lower()] == true then\n        logger:debug(\"Exclude mirror the left part by plugin: %s\", sourceMod)\n        return false\n    end\n    return true\nend\n\n---@param object tes3activator|tes3alchemy|tes3apparatus|tes3armor|tes3bodyPart|tes3book|tes3clothing|tes3container|tes3containerInstance|tes3creature|tes3creatureInstance|tes3door|tes3ingredient|tes3leveledCreature|tes3leveledItem|tes3light|tes3lockpick|tes3misc|tes3npc|tes3npcInstance|tes3probe|tes3repairTool|tes3static|tes3weapon\n---@return boolean\nfunction this.CanMirror(object)\n    if object.isLeftPart and config.display.leftPart then\n        if this.CanMirrorBySourceMod(object.sourceMod) == false then\n            return false\n        end\n        if this.CanMirrorById(object.id) == false then\n            return false\n        end\n        return true\n    end\n    return false\nend\n\n---@param key string\n---@return boolean\nfunction this.ToggleMirror(key)\n    key = key:lower()\n    if config.leftPartFilter[key] == true then\n        config.leftPartFilter[key] = false\n    else\n        config.leftPartFilter[key] = true\n    end\n    mwse.saveConfig(settings.configPath, config)\n    return config.leftPartFilter[key]\nend\n\n\nfunction this.CalculateBounds(model)\n    local bounds = model:createBoundingBox():copy()\n    if config.display.recalculateBounds then\n        local backup = bounds:copy()\n        -- vertex only bounds\n        -- more tight bounds, but possible too heavy.\n        logger:debug(\"MWSE bounds: %s\", bounds)\n        bounds.max = tes3vector3.new(-math.fhuge, -math.fhuge, -math.fhuge)\n        bounds.min = tes3vector3.new(math.fhuge, math.fhuge, math.fhuge)\n        local accept = false\n        -- local pointCloud = {}\n        this.foreach(model, function(node)\n            if node:isOfType(ni.type.NiTriShape) then\n                ---@cast node niTriShape\n                local data = node.data\n                if data.vertexCount == 0 then\n                    logger:warn(\"NiTriShape has no geometry: %s\", node.name)\n                    return\n                end\n\n                local max = tes3vector3.new(-math.fhuge, -math.fhuge, -math.fhuge)\n                local min = tes3vector3.new(math.fhuge, math.fhuge, math.fhuge)\n\n                if node.skinInstance then\n                    -- They are raw vertices that have not been transformed in any way, so software skinning must be computed.\n                    -- If I could access niBounds, generally that is fine, but it is loose and also MWSE cannot do it.\n                    local vertices = table.new(data.vertexCount, 0) ---@type tes3vector3[]\n                    -- fill zero\n                    for i = 1, data.vertexCount, 1 do\n                        vertices[i] = tes3vector3.new(0, 0, 0)\n                    end\n                    local skin = node.skinInstance.data\n                    local bindPose = skin.transform -- tes3transform:new(skin.rotation, skin.translation, skin.scale)\n                    local root = node.skinInstance.root.worldTransform\n                    local skeleton = node.worldTransform:copy() * bindPose:copy() * root:copy():invert()\n                    local boneCount = table.size(skin.boneData)\n                    for boneIndex, boneData in ipairs(skin.boneData) do\n                        if boneIndex > boneCount then\n                            logger:debug(\"Workaround: ipairs(skin.boneData) sometimes iterates over table size %d\", boneCount)\n                            break\n                        end\n                        local bone = node.skinInstance.bones[boneIndex]\n                        local boneSpace = boneData.transform:copy() -- tes3transform:new(boneData.rotation, boneData.translation, boneData.scale) -- why self required?\n                        -- I guess morrowind's skinning animation transform without HW skinning.\n                        -- node local space -> bone sopace -> world animation space (no bind pose has been applied yet) ->\n                        -- skeleton root (parent of the root bone) space -> bind pose space -> node world space\n                        local m = skeleton * bone.worldTransform:copy() * boneSpace\n                        for _, w in ipairs(boneData.weights) do\n                            local index = w.index + 1 -- 0 start\n                            local p = data.vertices[index]\n                            local a = m * p:copy() * w.weight\n                            local b = vertices[index]\n                            vertices[index] = b:copy() + a:copy()\n                        end\n                    end\n                    for _, vert in ipairs(vertices) do\n                        local v = vert\n                        max.x = math.max(max.x, v.x);\n                        max.y = math.max(max.y, v.y);\n                        max.z = math.max(max.z, v.z);\n                        min.x = math.min(min.x, v.x);\n                        min.y = math.min(min.y, v.y);\n                        min.z = math.min(min.z, v.z);\n                        -- mwse.log(\"%f, %f, %f\",v.x, v.y,  v.z)\n                        -- table.insert(pointCloud, string.format(\"%f, %f, %f\", v.x, v.y, v.z))\n                    end\n                else\n                    local vertices = data.vertices\n                    local m = node.worldTransform:copy()\n                    for _, vert in ipairs(vertices) do\n                        local v = m * vert:copy()\n                        max.x = math.max(max.x, v.x);\n                        max.y = math.max(max.y, v.y);\n                        max.z = math.max(max.z, v.z);\n                        min.x = math.min(min.x, v.x);\n                        min.y = math.min(min.y, v.y);\n                        min.z = math.min(min.z, v.z);\n                        -- mwse.log(\"%f, %f, %f\",v.x, v.y,  v.z)\n                        -- table.insert(pointCloud, string.format(\"%f, %f, %f\", v.x, v.y, v.z))\n                    end\n                end\n\n                -- merge\n                bounds.max.x = math.max(bounds.max.x, max.x);\n                bounds.max.y = math.max(bounds.max.y, max.y);\n                bounds.max.z = math.max(bounds.max.z, max.z);\n                bounds.min.x = math.min(bounds.min.x, min.x);\n                bounds.min.y = math.min(bounds.min.y, min.y);\n                bounds.min.z = math.min(bounds.min.z, min.z);\n                accept = true\n            end\n        end)\n\n        -- export point cloud data for debugging\n        --[[\n        local f = assert(io.open(string.format(\"%s.csv\", (model.name:gsub(\"[/\\\\]\", \"-\") or \"bounds\")), \"w\"))\n        f:write(table.concat(pointCloud, \"\\n\"))\n        f:close()\n        --]]\n\n        -- no geometry\n        if not accept then\n            bounds = backup\n            -- original may also be incorrect?\n            logger:warn(\"There was no geometry, MWSE bounds will be used.\")\n        end\n    end\n\n    return bounds\nend\n\n---@param model niBillboardNode|niCollisionSwitch|niNode|niSortAdjustNode|niSwitchNode\n---@param scale number\nfunction this.RescaleParticle(model, scale)\n    -- rescale particle\n    -- It seems that the scale is roughly doubly applied to the size of particles. Positions are correct. Is this a specification?\n    -- Apply the scale of counterparts\n    -- Works well in most cases, but does not seem to work well for non-following types of particles, etc.\n    -- Torch, Mace of Aevar Stone-Singer\n    -- This requires setting the 'trailer' to 0 in niParticleSystemController , which cannot be changed from MWSE.\n    this.foreach(model, function(node, _)\n        if node:isInstanceOfType(ni.type.NiParticles) then\n            ---@cast node niParticles\n            for index, value in ipairs(node.data.sizes) do\n                node.data.sizes[index] = value * scale\n            end\n            node.data:markAsChanged()\n            node.data:updateModelBound() -- need?\n        end\n    end)\nend\n\n--- removeunnecessary node\n---@param model niBillboardNode|niCollisionSwitch|niNode|niSortAdjustNode|niSwitchNode\nfunction this.CleanMesh(model)\n    local bit = require(\"bit\")\n    this.foreach(model, function(node, _)\n        if not node.parent then\n            return\n        end\n        local remove = false\n        -- In OpenMW only except for creature, but is it bad for creature?\n        -- If it is because the animation changes the visibility, then it should be removed if there is no animation.\n        -- if not isCreature then\n        if bit.band(node.flags, 0x1) == 0x1 then -- invisible\n            remove = true\n            logger:trace(\"Removed by visibility: %s\", node.name)\n        elseif node:isInstanceOfType(ni.type.RootCollisionNode) then -- collision\n            remove = true\n            logger:trace(\"Removed by collision: %s\", node.name)\n        elseif node:isOfType(ni.type.NiTriShape) then\n            if node.name then\n                local n = node.name:lower()\n                -- https://morrowind-nif.github.io/Notes_EN/module_2_3_1_3_2_1.htm\n                if n:startswith(\"tri shadow\") then -- shadow\n                    remove = true\n                    logger:trace(\"Removed by Tri Shadow: %s\", node.name)\n                elseif n:startswith(\"tri bip\") then -- dummy\n                    remove = true\n                    logger:trace(\"Removed by Tri Bip: %s\", node.name)\n                end\n            end\n        end\n        if remove then\n            node.parent:detachChild(node)\n        end\n    end)\nend\n\n--- The player is affected by the same effects as the player,\n--- which is not a problem during FPV since they are almost in the same position,\n--- but may be unnatural during TPV if the distance is too far apart.\n--- But we do not want to probe which effects are affected.\n---@param node niBillboardNode|niCollisionSwitch|niNode|niSortAdjustNode|niSwitchNode\nfunction this.AttachDynamicEffect(node)\n    local src = tes3.player1stPerson.sceneNode\n    if tes3.is3rdPerson() then\n        src = tes3.player.sceneNode\n    end\n    if src then\n        local effects = src.effectList\n        while effects do\n            if effects.data then\n                local effect = effects.data --[[@as niAmbientLight|niDirectionalLight|niPointLight|niSpotLight|niTextureEffect]]\n                if effect:isInstanceOfType(ni.type.NiLight) then -- only light or point\n                    logger:debug(\"Attach effect: %s\", effect)\n                    node:attachEffect(effect)\n                    effect:attachAffectedNode(node)\n                    effect:updateEffects()\n                end\n            end\n            effects = effects.next\n        end\n    end\nend\n\n---@param node niBillboardNode|niCollisionSwitch|niNode|niSortAdjustNode|niSwitchNode\n---@param recursive boolean\nfunction this.DetachDynamicEffect(node, recursive)\n    local list = {} -- Detaching and then iterating seems to cause linked list to shrink and crash?\n    local effects = node.effectList\n    while effects do\n        if effects.data then\n            -- logger:trace(\"effect: %s\", effects.data)\n            table.insert(list, effects.data)\n        end\n        effects = effects.next\n    end\n    for _, effect in ipairs(list) do\n        logger:debug(\"Dettach effect: %s\", effect)\n        effect:detachAffectedNode(node)\n        effect:updateEffects()\n    end\n    if node.detachAllEffects then\n        node:detachAllEffects()\n    end\n    list = nil\n\n    if recursive and node.children then\n        for _, child in ipairs(node.children) do\n            if child then\n                ---@cast child niBillboardNode|niCollisionSwitch|niNode|niSortAdjustNode|niSwitchNode\n                this.DetachDynamicEffect(child, recursive)\n            end\n        end\n    end\nend\n\n---@diagnostic disable-next-line: undefined-doc-name\n---@param prop niAlphaProperty|niDitherProperty|niFogProperty|niMaterialProperty|niRendererSpecificProperty|niShadeProperty|niSpecularProperty|niStencilProperty|niTexturingProperty|niVertexColorProperty|niWireframeProperty|niZBufferProperty\n---@return string?\nlocal function DumpProperty(prop)\n    ---@type { [string] : fun() :string? }\n    local func = {\n        [\"NiAlphaProperty\"] = function()\n            ---@cast prop niAlphaProperty\n            return string.format(\"alphaTestRef: %f\", prop.alphaTestRef)\n        end,\n        [\"NiDitherProperty\"] = function() end,\n        [\"NiFogProperty\"] = function() end,\n        [\"NiMaterialProperty\"] = function()\n            ---@cast prop niMaterialProperty\n            return string.format(\"alpha: %f, ambient: %s, diffuse: %s, emissive: %s, shininess: %f, specular: %s\",\n                prop.alpha,\n                prop.ambient:toVector3(),\n                prop.diffuse:toVector3(),\n                prop.emissive:toVector3(),\n                prop.shininess,\n                prop.specular:toVector3())\n        end,\n        [\"NiRendererSpecificProperty\"] = function() end,\n        [\"NiShadeProperty\"] = function() end,\n        [\"NiSpecularProperty\"] = function()end,\n        [\"NiStencilProperty\"] = function()\n            ---@cast prop niStencilProperty\n            return string.format(\"drawMode: %d\", prop.drawMode)\n        end,\n        [\"NiTexturingProperty\"] = function()end,\n        [\"NiVertexColorProperty\"] = function()\n            ---@cast prop niVertexColorProperty\n            return string.format(\"lighting: %d, source: %d\", prop.lighting, prop.source)\n        end,\n        [\"NiWireframeProperty\"] = function()end,\n        [\"NiZBufferProperty\"] = function()\n            ---@cast prop niZBufferProperty\n            return string.format(\"testFunction: %d\", prop.testFunction)\n        end,\n    }\n    local f = func[prop.RTTI.name]\n    if f then\n        return f()\n    end\n    return nil\nend\n\n---@param effect niAmbientLight|niDirectionalLight|niPointLight|niSpotLight|niTextureEffect\n---@return string?\nlocal function DumpDynamicEffect(effect)\n    ---@type { [string] : fun() :string? }\n    local func = {\n        [\"NiAmbientLight\"] = function()\n        end,\n        [\"NiDirectionalLight\"] = function()\n        end,\n        [\"NiPointLight\"] = function()\n            -- local affected = {}\n            -- ---@cast effect niPointLight\n            -- local node = effect.affectedNodes\n            -- while node do\n            --     if node.data then\n            --         table.insert(affected, node.data.name)\n            --     end\n            --     node = node.next\n            -- end\n            -- return table.concat(affected)\n        end,\n        [\"NiSpotLight\"] = function()\n        end,\n        [\"NiTextureEffect\"] = function()\n        end,\n    }\n    local f = func[effect.RTTI.name]\n    if f then\n        return f()\n    end\n    return nil\nend\n\n---@param root niAmbientLight|niBillboardNode|niCamera|niCollisionSwitch|niDirectionalLight|niNode|niParticles|niPointLight|niRotatingParticles|niSortAdjustNode|niSpotLight|niSwitchNode|niTextureEffect|niTriShape\n---@return string\nfunction this.Dump(root)\n    if not config.development.experimental then\n        return \"Enable experimental to dump the scene graph.\"\n    end\n    -- TODO json format\n    local str = {}\n    this.foreach(root,\n        function(node, depth)\n            local indent = string.rep(\"    \", depth)\n            if node then\n                local out = string.format(\"%s:%s\", node.RTTI.name, tostring(node.name))\n                if node.translation and node.rotation and node.scale then\n                    out = out .. \"\\n\" .. indent .. string.format(\"  local trans %s, rot %s, scale %f\", node.translation, node.rotation, node.scale)\n                end\n                if node.worldTransform then\n                    out = out .. \"\\n\" .. indent .. string.format(\"  world trans %s, rot %s, scale %f\", node.worldTransform.translation, node.worldTransform.rotation, node.worldTransform.scale)\n                end\n                -- out = out .. \"\\n\" .. indent .. string.format(\"  flags: %x\", node.flags)\n                local controller = node.controller\n                while controller do\n                    out = out .. \"\\n\" .. indent .. string.format(\"  controller: %s\", controller.RTTI.name)\n                    --[[\n                    out = out .. \"\\n\" .. indent .. string.format(\"    active %s, timing %d, target %s\", tostring(controller.active), controller.animTimingType, controller.target)\n                    --]]\n                    controller = controller.nextController\n                end\n                local props = node.properties\n                while props and props.data do\n                    out = out .. \"\\n\" .. indent .. string.format(\"  prop: %s\", props.data.RTTI.name)\n                    --[[\n                    local p = DumpProperty(props.data)\n                    if p then\n                        out = out .. \"\\n\" .. p .. string.format(\" propertyFlags: %d\", props.data.propertyFlags or 0)\n                    end\n                    --]]\n                    props = props.next\n                end\n                local effect = node.effectList\n                while effect and effect.data do\n                    out = out .. \"\\n\" .. indent .. string.format(\"  effect: %s\", effect.data.RTTI.name)\n                    --[[\n                    local p = DumpDynamicEffect(effect.data)\n                    if p then\n                        out = out .. \"\\n\" .. p\n                    end\n                    --]]\n                    effect = effect.next\n                end\n                table.insert(str, indent .. \"- \" .. out)\n            else\n                table.insert(str, indent .. \"- \" .. \"nil\")\n            end\n        end)\n    -- return str\n    return \"\\n\" .. table.concat(str, \"\\n\")\nend\n\nreturn this\n",
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\component\\orientation.lua": "---@class OrientationResolver\nlocal this = {}\nlocal logger = require(\"InspectIt.logger\")\n\nlocal fixedOrientations = {\n    -- [tes3.objectType.activator] = tes3vector3.new(0, 0, 0),\n    [tes3.objectType.alchemy] = tes3vector3.new(0, 0, 0),\n    [tes3.objectType.ammunition] = tes3vector3.new(-90, 0, -90),\n    [tes3.objectType.apparatus] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.armor] = tes3vector3.new(0, 0, 0), -- It's not aligned. It's a mess.\n    [tes3.objectType.bodyPart] = tes3vector3.new(0, 0, -180),\n    -- [tes3.objectType.book] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.cell] = tes3vector3.new(0, 0, 0),\n    --[tes3.objectType.clothing] = tes3vector3.new(0, 0, 0),\n    [tes3.objectType.container] = tes3vector3.new(0, 0, 0),\n    [tes3.objectType.creature] = tes3vector3.new(0, 0, -180),\n    -- [tes3.objectType.door] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.enchantment] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.ingredient] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.land] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.landTexture] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.leveledCreature] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.leveledItem] = tes3vector3.new(0, 0, 0),\n    [tes3.objectType.light] = tes3vector3.new(0, 0, 0),\n    [tes3.objectType.lockpick] = tes3vector3.new(-90, 0, -90),\n    -- [tes3.objectType.magicEffect] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.miscItem] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.mobileActor] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.mobileCreature] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.mobileNPC] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.mobilePlayer] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.mobileProjectile] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.mobileSpellProjectile] = tes3vector3.new(0, 0, 0),\n    [tes3.objectType.npc] = tes3vector3.new(0, 0, -180),\n    [tes3.objectType.probe] = tes3vector3.new(-90, 0, -90),\n    -- [tes3.objectType.reference] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.region] = tes3vector3.new(0, 0, 0),\n    [tes3.objectType.repairItem] = tes3vector3.new(-90, 0, -90),\n    -- [tes3.objectType.spell] = tes3vector3.new(0, 0, 0),\n    -- [tes3.objectType.static] = tes3vector3.new(0, 0, 0),\n    [tes3.objectType.weapon] = tes3vector3.new(-90, 0, -90),\n}\n\nlocal armorSlot = {\n    [tes3.armorSlot.boots] = tes3vector3.new(0, 0, 0),\n    [tes3.armorSlot.cuirass] = tes3vector3.new(-90, 0, 0),\n    [tes3.armorSlot.greaves] = tes3vector3.new(-90, 0, 0),\n    [tes3.armorSlot.helmet] = tes3vector3.new(0, 0, 0),\n    [tes3.armorSlot.leftBracer] = tes3vector3.new(0, 0, 180),\n    [tes3.armorSlot.leftGauntlet] = tes3vector3.new(0, 0, 180),\n    [tes3.armorSlot.leftPauldron] = tes3vector3.new(0, 0, 180),\n    [tes3.armorSlot.rightBracer] = tes3vector3.new(0, 0, 0),\n    [tes3.armorSlot.rightGauntlet] = tes3vector3.new(0, 0, 0),\n    [tes3.armorSlot.rightPauldron] = tes3vector3.new(0, 0, 0),\n    [tes3.armorSlot.shield] = tes3vector3.new(-90, 0, 0),\n}\n\nlocal clothSlot = {\n    [tes3.clothingSlot.amulet] = tes3vector3.new(-90, 0, 0),\n    [tes3.clothingSlot.belt] = tes3vector3.new(-90, 0, 0),\n    [tes3.clothingSlot.leftGlove] = tes3vector3.new(-90, 0, 180),\n    [tes3.clothingSlot.pants] = tes3vector3.new(-90, 0, 0),\n    [tes3.clothingSlot.rightGlove] = tes3vector3.new(-90, 0, 0),\n    [tes3.clothingSlot.ring] = tes3vector3.new(0, 0, 0),\n    [tes3.clothingSlot.robe] = tes3vector3.new(-90, 0, 0),\n    [tes3.clothingSlot.shirt] = tes3vector3.new(-90, 0, 0),\n    [tes3.clothingSlot.shoes] = tes3vector3.new(0, 0, 0),\n    [tes3.clothingSlot.skirt] = tes3vector3.new(-90, 0, 0),\n}\n\nlocal weaponType = {\n    [tes3.weaponType.marksmanCrossbow] = tes3vector3.new(0, 0, -90),\n}\n\n---@param object tes3activator|tes3alchemy|tes3apparatus|tes3armor|tes3bodyPart|tes3book|tes3clothing|tes3container|tes3containerInstance|tes3creature|tes3creatureInstance|tes3door|tes3ingredient|tes3leveledCreature|tes3leveledItem|tes3light|tes3lockpick|tes3misc|tes3npc|tes3npcInstance|tes3probe|tes3repairTool|tes3static|tes3weapon\n---@param bounds tes3boundingBox\n---@return tes3vector3? degree\nfunction this.GetOrientation(object, bounds)\n    -- from table\n    local orientation = fixedOrientations[object.objectType]\n    if orientation then\n        return orientation\n    end\n\n    -- unique type\n    if object.objectType == tes3.objectType.armor then\n        ---@cast object tes3armor\n        local o = armorSlot[object.slot]\n        if o then\n            return o\n        end\n    elseif object.objectType == tes3.objectType.clothing then\n        ---@cast object tes3clothing\n        local o = clothSlot[object.slot]\n        if o then\n            return o\n        end\n    elseif object.objectType == tes3.objectType.weapon then\n        ---@cast object tes3weapon\n        local o = weaponType[object.type]\n        if o then\n            return o\n        end\n    elseif object.objectType == tes3.objectType.book then\n        local size = bounds.max - bounds.min\n        local ratio = size.y / math.max(size.x, math.fepsilon)\n        logger:debug(\"book ratio %f / %f = %f\", size.y, size.x, ratio)\n        ---@cast object tes3book\n        if object.type == tes3.bookType.book then\n            -- FIXME The Third Door (BookSkill_Axe1) bounds.x wrong\n            -- opened or closed\n            if ratio > 1.75 then -- opened and rotation\n                return tes3vector3.new(-90, 0, 90)\n            end\n            return tes3vector3.new(-90, 0, 0) -- closed\n        else\n            if ratio < 0.35 then -- rolled scroll?\n                return tes3vector3.new(0, 0, 0)\n            end\n            if size.z < 3 then\n                return tes3vector3.new(-90, 0, 0)\n            end\n            return tes3vector3.new(-90, 0, 0)\n        end\n    elseif object.objectType == tes3.objectType.door then\n        -- expect axis aligned, almost centered\n        local size = bounds.max - bounds.min\n        if size.x > size.y then\n            -- whitch bold thickness? face has handles?\n            logger:debug(\"y-face %f, %f\", bounds.max.y, bounds.min.y)\n            if math.abs(bounds.max.y) - math.abs(bounds.min.y) >= 0 then\n                return tes3vector3.new(0, 0, 0)\n            else\n                return tes3vector3.new(0, 0, 0) -- same face is front?\n            end\n        else\n            logger:debug(\"x-face %f, %f\", bounds.max.x, bounds.min.x)\n            if math.abs(bounds.max.x) - math.abs(bounds.min.x) >= 0 then\n                return tes3vector3.new(0, 0, -90)\n            else\n                return tes3vector3.new(0, 0, 90)\n            end\n        end\n        -- TODO trap door\n    end\n\n    -- auto rotation\n    -- dominant axis based\n    -- TODO more better algorithm\n    local size = bounds.max - bounds.min\n    logger:debug(\"bounds size: %s\", size)\n    local my = 0\n    if size.x < size.y and size.z < size.y then\n        my = 1\n    end\n    local mz = 0\n    if size.x < size.z and size.y < size.z then\n        mz = 2\n    end\n    local imax = my + mz;\n    my = 0\n    if size.x > size.y and size.z > size.y then\n        my = 1\n    end\n    mz = 0\n    if size.x > size.z and size.y > size.z then\n        mz = 2\n    end\n    local imin = my + mz;\n    logger:debug(\"axis: max %d, min %d\", imax, imin)\n    if imax == 1 or imin == 2 then     -- depth is maximum or height is minimum, y-up\n        -- if imax == 1 then -- just depth is maximum\n        -- it seems that area ratio would be a better result.\n        return tes3vector3.new(-60, 0, 0)\n    end\n\n    return nil -- tes3vector3.new(0, 0, 0) -- default\nend\n\n---@param object tes3activator|tes3alchemy|tes3apparatus|tes3armor|tes3bodyPart|tes3book|tes3clothing|tes3container|tes3containerInstance|tes3creature|tes3creatureInstance|tes3door|tes3ingredient|tes3leveledCreature|tes3leveledItem|tes3light|tes3lockpick|tes3misc|tes3npc|tes3npcInstance|tes3probe|tes3repairTool|tes3static|tes3weapon\n---@return tes3vector3 degree\nfunction this.GetBodyPartOrientation(object)\n    return fixedOrientations[tes3.objectType.bodyPart];\nend\nreturn this\n",
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\controller\\base.lua": "---@class IController\n---@field logger mwseLogger\nlocal this = {}\n\n---@class Activate.Params\n---@field object tes3activator|tes3alchemy|tes3apparatus|tes3armor|tes3bodyPart|tes3book|tes3clothing|tes3container|tes3containerInstance|tes3creature|tes3creatureInstance|tes3door|tes3ingredient|tes3leveledCreature|tes3leveledItem|tes3light|tes3lockpick|tes3misc|tes3npc|tes3npcInstance|tes3probe|tes3repairTool|tes3static|tes3weapon\n---@field offset number\n---@field another AnotherLookData\n---@field description string?\n---@field name string?\n---@field referenceNode niBillboardNode|niCollisionSwitch|niNode|niSortAdjustNode|niSwitchNode?\n\n---@class Deactivate.Params\n---@field menuExit boolean\n\n---@protected\n---@param params table?\n---@return IController\nfunction this.new(params)\n    ---@type IController\n    local instance = {\n        logger = require(\"InspectIt.logger\"),\n    }\n    if params then\n        table.copymissing(instance, table.deepcopy(params))\n    end\n    setmetatable(instance, { __index = this })\n    return instance\nend\n\n---@param self IController\n---@param params Activate.Params\nfunction this.Activate(self, params)\nend\n\n---@param self IController\n---@param params Deactivate.Params\nfunction this.Deactivate(self, params)\nend\n\n---@param self IController\nfunction this.Reset(self)\nend\n\nreturn this\n",
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\controller\\bokeh.lua": "local base = require(\"InspectIt.controller.base\")\nlocal config = require(\"InspectIt.config\").display\nlocal unit2m = 1.0 / 70.0 -- 1units/70meters\n\n---@class Bokeh : IController\n---@field shader mgeShaderHandle?\n---@field focalLength number\nlocal this = {}\nsetmetatable(this, { __index = base })\n\n---@type Bokeh\nlocal defaults = {\n    focalLength = 1,\n}\n\nlocal fx = \"InspectIt/Bokeh\"\nlocal disabledShaders = { \"Depth of Field\" }\n\n---@return Bokeh\nfunction this.new()\n    local instance = base.new(defaults)\n    setmetatable(instance, { __index = this })\n    ---@cast instance Bokeh\n\n    return instance\nend\n\n---@param self Bokeh\n---@param value number\nfunction this.SetFocalLength(self, value)\n    self.focalLength = math.clamp(value, 0, 2)\n    self.shader[\"focal_length\"] = self.focalLength\nend\n\n---@param self Bokeh\n---@param params Activate.Params\nfunction this.Activate(self, params)\n    if not config.bokeh then\n        return\n    end\n    if not self.shader then\n        self.shader = mge.shaders.load({ name = fx })\n        if self.shader then\n            self.logger:info(\"Loaded shader: %s\", fx)\n        else\n            self.logger:error(\"Failed to load shader: %s\", fx)\n        end\n    end\n    if self.shader then\n        self.shader.enabled = true\n        self.shader[\"focus_distance\"] = params.offset * unit2m\n        self:SetFocalLength(1.0)\n    end\nend\n\n---@param self Bokeh\n---@param params Deactivate.Params\nfunction this.Deactivate(self, params)\n    if self.shader then\n        self.shader.enabled = false\n    end\nend\n\n---@param self Bokeh\nfunction this.Reset(self)\nend\n\nreturn this\n",
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\controller\\guide.lua": "local base = require(\"InspectIt.controller.base\")\nlocal config = require(\"InspectIt.config\")\nlocal settings = require(\"InspectIt.settings\")\nlocal mesh = require(\"InspectIt.component.mesh\")\nlocal helpLayerMenu = tes3ui.registerID(\"InspectIt:MenuInspectionDescription\")\n\n---@class Guide : IController\n---@field object tes3activator|tes3alchemy|tes3apparatus|tes3armor|tes3bodyPart|tes3book|tes3clothing|tes3container|tes3containerInstance|tes3creature|tes3creatureInstance|tes3door|tes3ingredient|tes3leveledCreature|tes3leveledItem|tes3light|tes3lockpick|tes3misc|tes3npc|tes3npcInstance|tes3probe|tes3repairTool|tes3static|tes3weapon?\n---@field changedAnotherLookCallback fun(e:ChangedAnotherLookEventData)?\nlocal this = {}\nsetmetatable(this, { __index = base })\n\n---@type Guide\nlocal defaults = {\n}\n\n---@return Guide\nfunction this.new()\n    local instance = base.new(defaults)\n    setmetatable(instance, { __index = this })\n    ---@cast instance Guide\n\n    return instance\nend\n\n--- @param keyCombo mwseKeyCombo\n--- @return string result\nlocal function GetComboString(keyCombo)\n    local comboText = mwse.mcm.getKeyComboName(keyCombo)\n    if not comboText then\n        comboText = string.format(\"{%s}\", mwse.mcm.i18n(\"unknown key\"))\n    end\n    return comboText\nend\n\n---@param e enterFrameEventData\nlocal function OnEnterFrame(e)\n    local help = tes3ui.findHelpLayerMenu(helpLayerMenu)\n    if help then\n        if settings.OnOtherMenu() then\n            help.visible = false\n            return\n        end\n        if config.display.tooltipsComplete then\n            help.visible = true\n        end\n    end\nend\n\n---@param self Guide\nfunction this.Destroy(self)\n    self.object = nil\n    local menu = tes3ui.findMenu(settings.guideMenuID)\n    if menu then\n        menu:destroy()\n    end\n    local help = tes3ui.findHelpLayerMenu(helpLayerMenu)\n    if help then\n        help:destroy()\n    end\n    if event.isRegistered(tes3.event.enterFrame, OnEnterFrame) then\n        event.unregister(tes3.event.enterFrame, OnEnterFrame)\n    end\n    if self.changedAnotherLookCallback then\n        event.unregister(settings.changedAnotherLookEventName, self.changedAnotherLookCallback)\n        self.changedAnotherLookCallback = nil\n    end\nend\n\n---@param parent tes3uiElement\n---@param text string button text\n---@param label string label text\n---@param buttonId string|number|nil label text\n---@returns tes3uiElement button\n---@returns tes3uiElement block\n---@returns tes3uiElement label\nlocal function CreateButton(parent, text, label, buttonId)\n    local row = parent:createBlock()\n    row.flowDirection = tes3.flowDirection.leftToRight\n    row.autoWidth = true\n    row.autoHeight = true\n    row.childAlignY = 0.5\n    local button = row:createButton({ id = buttonId, text = text })\n    local text = row:createLabel({ text = label })\n    return button, row, text\nend\n\n---@param self Guide\n---@param params Activate.Params\nfunction this.Activate(self, params)\n    self:Destroy()\n    self.object = params.object\n\n    local name = params.name or params.object.name\n    if not name or name == \"\" then -- fallback\n        name = params.object.id\n    end\n\n    local width, height = tes3ui.getViewportSize()\n    local aspectRatio = width/height\n    local offset = 0.02\n\n    -- This modal menu is a must. If there is not a single modal menu visible on the screen, right-clicking will cause all menus to close and return.\n    -- This causes unexpected screen transitions and glitches. Especially in Barter.\n    local menu = tes3ui.createMenu({ id = settings.guideMenuID, dragFrame = false, fixedFrame = true, modal = true })\n    menu:destroyChildren()\n    menu.flowDirection = tes3.flowDirection.topToBottom\n    menu.absolutePosAlignX = 1.0 - offset\n    menu.absolutePosAlignY = offset * aspectRatio\n    menu.autoWidth = true\n    menu.autoHeight = true\n    menu.minWidth = 0 -- or tooltip size?\n    menu.minHeight = 0\n    --menu.alpha = 0\n    local border = menu:createThinBorder()\n    border.flowDirection = tes3.flowDirection.topToBottom\n    border.autoWidth = true\n    border.autoHeight = true\n    border.paddingAllSides = 8\n    border.childAlignX = 0.5\n\n    -- name\n    do\n        local block = border:createBlock()\n        block.flowDirection = tes3.flowDirection.topToBottom\n        block.autoWidth = true\n        block.autoHeight = true\n        block.borderAllSides = 4\n        block.childAlignX = 0.5\n        -- name\n        do\n            local label = block:createLabel({ text = name })\n            label.color = tes3ui.getPalette(tes3.palette.headerColor)\n        end\n        -- id\n        if config.display.objectId then\n            local objectId = params.object.id\n            -- ID is used as is to indicate whether it is an instance or not, unlike sourceMod.\n            local label = block:createLabel({ text = objectId })\n            label.color = tes3ui.getPalette(tes3.palette.headerColor)\n        end\n        -- sourceMod\n        if config.display.sourceMod then\n            local sourceMod = params.object.sourceMod\n            -- instances are sourceless and refer to the base object. always?\n            if not sourceMod and params.object.isInstance then\n                sourceMod = params.object.baseObject.sourceMod\n            end\n            local label = block:createLabel({ text = sourceMod or settings.i18n(\"guide.sourceless.text\") })\n            label.color = tes3ui.getPalette(tes3.palette.headerColor)\n        end\n    end\n\n    -- if guided\n    do\n        local block = border:createBlock()\n        if not config.display.instruction then\n            block.visible = false\n        end\n        block.flowDirection = tes3.flowDirection.topToBottom\n        block.widthProportional = 1.0\n        block.autoWidth = true\n        block.autoHeight = true\n        block.childAlignX = 0.5\n        block.paddingLeft = 2\n        block.paddingRight = 2\n\n        block:createDivider().widthProportional = 1.0\n        block:createLabel({ text = settings.i18n(\"guide.rotate.text\") })\n        block:createLabel({ text = settings.i18n(\"guide.translate.text\") })\n        block:createLabel({ text = settings.i18n(\"guide.zoom.text\") })\n\n        -- mirror the left part\n        if config.display.leftPart and self.object.isLeftPart then\n            local button, leftPartBlock, label = CreateButton(block, settings.i18n(\"guide.leftPart.text\"), \"placeholder\")\n            local function FilterChanged()\n                if mesh.CanMirrorBySourceMod(self.object.sourceMod) == false then\n                    button.disabled = true\n                    button.widget.state = tes3.uiState.disabled\n                    label.text = settings.i18n(\"guide.leftPart.plugin\")\n                    label.color = tes3ui.getPalette(tes3.palette.disabledColor)\n                else\n                    button.disabled = false\n                    button.widget.state = tes3.uiState.normal\n                    label.text = mesh.CanMirrorById(self.object.id) and settings.i18n(\"guide.leftPart.mirror\") or settings.i18n(\"guide.leftPart.normal\")\n                    label.color = tes3ui.getPalette(tes3.palette.normalColor)\n                end\n            end\n            FilterChanged()\n            button:register(tes3.uiEvent.mouseClick, function(e)\n                local after = mesh.ToggleMirror(self.object.id)\n                self.logger:info(\"%s left part filter id: %s, plugin: %s\", (after and \"Add\" or \"Remove\"), self.object.id:lower(), self.object.sourceMod)\n                FilterChanged()\n                event.trigger(settings.toggleMirroringEventName)\n            end)\n            -- another look always no need mirroring\n            self.changedAnotherLookCallback = function (e)\n                -- Avoid manipulating the same state as FilterChanged(). To make it easier to maintain consistency.\n                if e.another then\n                    leftPartBlock.visible = false\n                else\n                    leftPartBlock.visible = true\n                end\n            end\n            event.register(settings.changedAnotherLookEventName, self.changedAnotherLookCallback)\n        end\n        -- another/activate\n        if params.another.type ~= nil then\n            local button = CreateButton(block, settings.i18n(\"guide.another.text\"), \": \" .. GetComboString(config.input.another))\n            button:register(tes3.uiEvent.mouseClick, function(e)\n                event.trigger(settings.switchAnotherLookEventName)\n            end)\n        end\n        -- lighting\n        do\n            local button = CreateButton(block, settings.i18n(\"guide.lighting.text\"), \": \" .. GetComboString(config.input.lighting))\n            button:register(tes3.uiEvent.mouseClick, function(e)\n                event.trigger(settings.switchLightingEventName)\n            end)\n        end\n        -- reset\n        do\n            local button = CreateButton(block, settings.i18n(\"guide.reset.text\"), \": \" .. GetComboString(config.input.reset))\n            button:register(tes3.uiEvent.mouseClick, function(e)\n                event.trigger(settings.resetPoseEventName)\n            end)\n        end\n        -- return\n        do\n            local button = CreateButton(block, settings.i18n(\"guide.return.text\"), \": \" .. GetComboString(config.input.inspect), settings.returnButtonName)\n            button:register(tes3.uiEvent.mouseClick, function(e)\n                event.trigger(settings.returnEventName)\n            end)\n        end\n    end\n\n    menu:updateLayout()\n\n    -- on mouse fade? help layer does not trigger over, leave event\n    if config.display.tooltipsComplete and params.description then\n        self.logger:debug(\"Create description\")\n        local help = tes3ui.createHelpLayerMenu({ id = helpLayerMenu })\n        help:destroyChildren()\n        help.flowDirection = tes3.flowDirection.topToBottom\n        help.absolutePosAlignX = offset\n        help.absolutePosAlignY = 0.5\n        help.autoWidth = true\n        help.autoHeight = true\n        help.minWidth = 0\n        help.minHeight = 0\n        help.alpha = 0.4\n        local block = help:createBlock()\n        block.flowDirection = tes3.flowDirection.topToBottom\n        block.widthProportional = 1.0\n        block.minWidth = 0\n        block.maxWidth = 320\n        block.autoWidth = true\n        block.autoHeight = true\n        block.paddingAllSides = 8\n        --block.childAlignX = 0.5\n        local label = block:createLabel({ text = params.description })\n        -- label.color = tes3ui.getPalette(tes3.palette.headerColor)\n        label.alpha = 0.95 -- .borderAllSides = 2\n        help:updateLayout()\n\n        event.register(tes3.event.enterFrame, OnEnterFrame)\n    end\nend\n\n---@param self Guide\n---@param params Deactivate.Params\nfunction this.Deactivate(self, params)\n    self:Destroy()\nend\n\n---@param self Guide\nfunction this.Reset(self)\n    self:Destroy()\nend\n\nreturn this\n",
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\controller\\inspector.lua": "local base = require(\"InspectIt.controller.base\")\nlocal config = require(\"InspectIt.config\")\nlocal settings = require(\"InspectIt.settings\")\nlocal ori = require(\"InspectIt.component.orientation\")\nlocal mesh = require(\"InspectIt.component.mesh\")\nlocal bit = require(\"bit\")\nlocal zoomThreshold = 0  -- delta\nlocal zoomDuration = 0.4 -- second\nlocal angleThreshold = 0 -- pixel\nlocal velocityEpsilon = 0.000001\nlocal velocityThreshold = 0 -- pixel\nlocal frictionRotation = 0.1     -- Attenuation with respect to velocity\nlocal resistanceRotation = 3.0   -- Attenuation with respect to time\nlocal frictionTranslation = 0.00001     -- Attenuation with respect to velocity\nlocal resistanceTranslation = 9.0   -- Attenuation with respect to time\nlocal fittingRatio = 0.5 -- Ratio to fit the screen\n\n---@class ModelData\n---@field root niNode?\n---@field bounds tes3boundingBox?\n\n-- scene graph struestue\n--  - cameraRoot\n--      (- Some nodes possibly added by the mod)\n--          - niCamera: It can't have children. Normally it is identity, but it can be moved as we press the tab key.\n--      - self.cameraJoint: It faces the same direction as niCamera. But it is not converted to y-up, it remains z-up.\n--          -  self.root\n--              - model node\n\n---@class Inspector : IController\n---@field root niNode? inspection root node\n---@field cameraJoint niNode? camera facing node\n---@field enterFrameCallback fun(e : enterFrameEventData)?\n---@field activateCallback fun(e : activateEventData)?\n---@field switchAnotherLookCallback fun()?\n---@field switchLightingCallback fun()?\n---@field toggleMirroringCallback fun()?\n---@field resetPosecCallback fun()?\n---@field angularVelocity tes3vector3 -- vec2 doesnt have dot\n---@field velocity tes3vector3 -- vec2 doesnt have dot\n---@field baseRotation tes3matrix33\n---@field baseScale number\n---@field zoomStart number\n---@field zoomEnd number\n---@field zoomTime number\n---@field zoomMax number\n---@field baseModel ModelData\n---@field anotherModel ModelData\n---@field anotherData? AnotherLookData\n---@field anotherLook boolean\n---@field lighting LightingType\n---@field distance tes3vector3 half width, distance, half height\n---@field object tes3activator|tes3alchemy|tes3apparatus|tes3armor|tes3bodyPart|tes3book|tes3clothing|tes3container|tes3containerInstance|tes3creature|tes3creatureInstance|tes3door|tes3ingredient|tes3leveledCreature|tes3leveledItem|tes3light|tes3lockpick|tes3misc|tes3npc|tes3npcInstance|tes3probe|tes3repairTool|tes3static|tes3weapon?\n---@field mirrored boolean\nlocal this = {}\nsetmetatable(this, { __index = base })\n\n---@type Inspector\nlocal defaults = {\n    enterFrame = nil,\n    angularVelocity = tes3vector3.new(0, 0, 0),\n    velocity = tes3vector3.new(0, 0, 0),\n    baseRotation = tes3matrix33.new(),\n    baseScale = 1,\n    zoomStart = 1,\n    zoomEnd = 1,\n    zoomTime = 0,\n    zoomMax = 2,\n    anotherData = nil,\n    anotherLook = false,\n    lighting = settings.lightingType.Default,\n    distance = tes3vector3.new(20, 20, 20),\n    mirrored = false,\n    baseModel = {\n    },\n    anotherModel = {\n    },\n}\n\n---@return Inspector\nfunction this.new()\n    local instance = base.new(defaults)\n    setmetatable(instance, { __index = this })\n    ---@cast instance Inspector\n\n    return instance\nend\n\n--- Normally it is identity, but it can be moved as we press the tab key.\n---@return tes3matrix33\nlocal function CalculateCameraRelativeRotation()\n    if tes3.worldController and tes3.worldController.worldCamera then\n        local camera = tes3.worldController.worldCamera.cameraData.camera\n        local view = tes3matrix33.new(camera.worldRight, camera.worldDirection, camera.worldUp):transpose() -- keep z-up lookat\n        local baseView = tes3.worldController.worldCamera.cameraRoot.worldTransform.rotation:copy()\n        local relative = baseView:transpose() * view\n        return relative\n    end\n    return tes3matrix33.new(1, 0, 0, 0, 1, 0, 0, 0, 1)\nend\n\n---@param lighting LightingType\n---@return tes3worldControllerRenderCamera|tes3worldControllerRenderTarget? camera\n---@return number fovX\n---@return tes3matrix33\nlocal function GetCamera(lighting)\n    local fovX = mge.camera.fov\n    if tes3.worldController then\n        if lighting == settings.lightingType.Constant then\n            local camera = tes3.worldController.menuCamera\n            if camera and camera.cameraData then\n                fovX = camera.cameraData.fov\n            end\n            -- The menu camera does not seem to be affected by niCamera rotation\n            return tes3.worldController.menuCamera, fovX, tes3matrix33.new(1, 0, 0, 0, 1, 0, 0, 0, 1)\n        end\n        return tes3.worldController.armCamera, fovX, CalculateCameraRelativeRotation() -- default\n    end\n    return nil, fovX, tes3matrix33.new(1, 0, 0, 0, 1, 0, 0, 0, 1)\nend\n\n---@param parent niNode\n---@param node niNode\n---@param first boolean\nlocal function AttachChild(parent, node, first)\n    -- Add to the top of the list.\n    if first then\n        local children = table.new(table.size(parent.children), 0)\n        for _, child in ipairs(parent.children) do\n            table.insert(children, child)\n        end\n        parent:detachAllChildren()\n        parent:attachChild(node, true)\n        for _, child in ipairs(children) do\n            parent:attachChild(child, true)\n        end\n    else\n        parent:attachChild(node)\n    end\nend\n\n---@param node niNode\n---@param add boolean\nlocal function AddOrRemoveZBufferProperty(node, add)\n    local name =  \"InspectIt:NoDepth\"\n    local p = node:getProperty(ni.propertyType.zBuffer)\n    if add then\n        if not p then\n            local zBufferProperty = niZBufferProperty.new()\n            zBufferProperty.name = name\n            zBufferProperty:setFlag(false, 0) -- test\n            zBufferProperty:setFlag(false, 1) -- write\n            node:attachProperty(zBufferProperty)\n            node:updateProperties()\n        end\n    elseif p and p.name == name then\n        node:detachProperty(ni.propertyType.zBuffer)\n        node:updateProperties()\n    end\nend\n\n---@param t number [0,1]\n---@return number [0,1]\nlocal function EaseOutQuad(t)\n    local ix = 1.0 - t\n    return 1.0 - ix * ix\nend\n\n---@param t number [0,1]\n---@return number [0,1]\nlocal function EaseOutCubic(t)\n    local ix = 1.0 - t\n    ix = ix * ix * ix\n    return 1.0 - ix\nend\n\n---@param t number [0,1]\n---@return number [0,1]\nlocal function EaseOutQuart(t)\n    local ix = 1.0 - t\n    ix = ix * ix\n    ix = ix * ix\n    return 1.0 - ix\nend\n\n---@param ratio number\n---@param estart number\n---@param eend number\n---@return number\nlocal function Ease(ratio, estart, eend)\n    local t = EaseOutCubic(ratio)\n    local v = math.lerp(estart, eend, t)\n    return v\nend\n\n---@param self Inspector\n---@param scale number\nfunction this.SetScale(self, scale)\n    local root = self.root\n    if root then\n        local prev = root.scale\n        local newScale = math.max(self.baseScale * scale, math.fepsilon)\n        root.scale = newScale\n        -- self.logger:trace(\"Zoom %f -> %f\", prev, scale)\n        mesh.RescaleParticle(root, prev / newScale)\n    end\nend\n\n\n---@param self Inspector\n---@param pickup boolean\nfunction this.PlaySound(self, pickup)\n    if config.inspection.playSound and self.object then\n        -- TODO NPC says greeting, but finding the voiceline is hard.\n        local volume = 0.5 -- Usually the volume is low to sound on the 3D.\n        if self.object.objectType == tes3.objectType.door then\n            local object = self.object ---@cast object tes3door\n            local sound = pickup and object.openSound or object.closeSound\n            if sound then\n                sound:play(nil, volume)\n            end\n            return\n        elseif self.object.objectType == tes3.objectType.creature then\n            if config.development.experimental then\n                local object = self.object ---@cast object tes3creature|tes3creatureInstance\n                if object.isInstance then\n                    object = object.baseObject\n                end\n                while object.soundCreature do\n                    object = object.soundCreature\n                end\n                local soundGen = pickup and tes3.soundGenType.moan or tes3.soundGenType.roar\n                local gen = tes3.getSoundGenerator(object.id, soundGen)\n                if gen then\n                    gen.sound:play(nil, volume)\n                end\n            end\n            return\n        end\n        tes3.playItemPickupSound({ item = self.object.id, pickup = pickup })\n    end\nend\n\n---@param self Inspector\n---@param e enterFrameEventData\nfunction this.OnEnterFrame(self, e)\n    if settings.OnOtherMenu() then\n        -- pause\n        return\n    end\n    local root = self.root\n    if root then\n        -- tes3ui.captureMouseDrag may be better?\n\n        local wc = tes3.worldController\n        local ic = wc.inputController\n\n        -- scale\n        local zoom = ic.mouseState.z\n        if math.abs(zoom) > zoomThreshold then\n            zoom = zoom * 0.001 * config.input.sensitivityZ * (config.input.inversionZ and -1 or 1)\n            -- self.logger:trace(\"Wheel: %f, wheel velocity %f\", ic.mouseState.z, zoom)\n            -- update current zooming\n            local scale = Ease(self.zoomTime / zoomDuration, self.zoomStart, self.zoomEnd)\n            self.zoomStart = scale\n            local limit = math.max(self.zoomMax / self.baseScale, 1)\n            self.zoomEnd = math.clamp(self.zoomEnd + zoom, 0.5, limit)\n            self.zoomTime = 0\n        end\n\n        if self.zoomTime < zoomDuration then\n            self.zoomTime = math.min(self.zoomTime + e.delta, zoomDuration)\n            local scale = Ease(self.zoomTime / zoomDuration, self.zoomStart, self.zoomEnd)\n\n            self:SetScale(scale)\n        end\n\n        if ic:isMouseButtonDown(0) then -- left click\n            -- rotate\n            local zAngle = ic.mouseState.x\n            local xAngle = ic.mouseState.y\n\n            if math.abs(zAngle) <= angleThreshold then\n                zAngle = 0\n            end\n            if math.abs(xAngle) <= angleThreshold then\n                xAngle = 0\n            end\n            zAngle = zAngle * wc.mouseSensitivityX * config.input.sensitivityX * (config.input.inversionX and -1 or 1)\n            xAngle = xAngle * wc.mouseSensitivityY * config.input.sensitivityY * (config.input.inversionY and -1 or 1)\n            -- self.logger:trace(\"Mouse %f, %f, Angular velocity %f, %f\", ic.mouseState.x, ic.mouseState.y, zAngle, xAngle)\n\n            self.angularVelocity.z = zAngle\n            self.angularVelocity.x = xAngle\n        elseif ic:isMouseButtonDown(2) then -- middle click\n            -- translate\n            local modifier = self.distance.y * 0.5\n            local horizontal = ic.mouseState.x * modifier\n            local vertical = ic.mouseState.y * -modifier\n            if math.abs(horizontal) <= velocityThreshold then\n                horizontal = 0\n            end\n            if math.abs(vertical) <= velocityThreshold then\n                vertical = 0\n            end\n            -- need inversion? another sensitivity and inversion config?\n            horizontal = horizontal * wc.mouseSensitivityX * config.input.sensitivityX * (config.input.inversionX and -1 or 1)\n            vertical = vertical * wc.mouseSensitivityY * config.input.sensitivityY * (config.input.inversionY and -1 or 1)\n            self.velocity.x = horizontal\n            self.velocity.z = vertical\n        end\n\n        if self.angularVelocity:dot(self.angularVelocity) > velocityEpsilon then\n            local zAxis = tes3vector3.new(0, 0, 1) -- Y\n            local xAxis = tes3vector3.new(1, 0, 0)\n\n            local zRot = niQuaternion.new()\n            local xRot = niQuaternion.new()\n\n            zRot:fromAngleAxis(self.angularVelocity.z, zAxis)\n            xRot:fromAngleAxis(self.angularVelocity.x, xAxis)\n\n            local q = niQuaternion.new()\n            q:fromRotation(root.rotation:copy())\n\n            local dest = zRot * xRot * q\n            local m = tes3matrix33.new()\n            m:fromQuaternion(dest)\n            root.rotation = m:copy()\n\n            -- No basis in physics.\n            self.angularVelocity = self.angularVelocity:lerp(self.angularVelocity * frictionRotation,\n                math.clamp(e.delta * resistanceRotation, 0, 1))\n        end\n        if self.velocity:dot(self.velocity) > velocityEpsilon then\n            -- center vs corners\n            local dest = root.translation:copy() + self.velocity:copy()\n            dest.x = math.clamp(dest.x, -self.distance.x, self.distance.x)\n            dest.z = math.clamp(dest.z, -self.distance.z, self.distance.z)\n            root.translation = dest\n            self.velocity = self.velocity:lerp(self.velocity * frictionTranslation,\n                math.clamp(e.delta * resistanceTranslation, 0, 1))\n        end\n        -- local euler = root.rotation:toEulerXYZ():copy()\n        -- tes3.messageBox(string.format(\"%f, %f, %f\", math.deg(euler.x), math.deg(euler.y), math.deg(euler.z)))\n\n        -- TODO play controllers, but those does not work.\n        -- updateTime = updateTime  + e.delta\n        -- root:update({ controllers = true })\n        root:update()\n    end\nend\n\n---@param self Inspector\n--- @param e activateEventData\nfunction this.OnActivate(self, e)\n    -- block picking up items\n    self.logger:trace(\"Block to Activate\")\n    e.block = true\nend\n\n---@param self Inspector\nfunction this.SwitchAnotherLook(self)\n    self.logger:debug(\"Switch another look\")\n    local root = self.root\n    if root and self.anotherData and self.anotherData.data and self.anotherData.type ~= nil then\n        local another = self.anotherModel\n\n        if self.anotherData.type == settings.anotherLookType.BodyParts then\n            if not another.root then\n\n                local data = self.anotherData.data ---@cast data BodyPartData\n\n                -- base\n                local path = mesh.ResolvePath(tes3.player.object.mesh)\n                if not path then\n                    self.logger:error(\"Missing base anim %s id: %s, mesh: %s, sourceMod: %s\", path, tes3.player.object.id, tes3.player.object.mesh, settings.GetSourceMod(tes3.player.object))\n                    return\n                end\n                self.logger:debug(\"Load base anim %s id: %s, mesh: %s, sourceMod: %s\", path, tes3.player.object.id, tes3.player.object.mesh, settings.GetSourceMod(tes3.player.object))\n                -- remaining any state with cache?\n                local baseanim = tes3.loadMesh(path, false) --[[@as niNode]]\n\n                -- remove unnecessary nodes\n                mesh.CleanMesh(baseanim)\n\n                -- -- reset\n                baseanim.translation = tes3vector3.new(0,0,0)\n                baseanim.scale = 1\n                baseanim:update() -- transform\n\n                another.root = baseanim\n\n                local bp = require(\"InspectIt.component.bodypart\")\n                for _, part in ipairs(data.parts) do\n                    bp.BuildBodyPart(part, baseanim)\n                end\n\n                -- rotate to base object relative\n                local orientation = ori.GetBodyPartOrientation(self.object)\n                local rot = tes3matrix33.new()\n                rot:fromEulerXYZ(math.rad(orientation.x), math.rad(orientation.y), math.rad(orientation.z))\n                another.root.rotation = self.baseRotation:copy():transpose() * rot:copy()\n\n                -- TODO apply race width, height scaling if need\n                another.root:update()\n\n                local bounds = mesh.CalculateBounds(another.root)\n                another.bounds = bounds\n                local offset =  (bounds.max + bounds.min) * -0.5\n                self.logger:debug(\"another bounds: %s\", bounds)\n                self.logger:debug(\"another offset: %s\", offset)\n                self.logger:trace(\"%s\", mesh.Dump(another.root))\n                another.root.translation = offset:copy()\n            end\n\n            if self.anotherLook then\n                self.logger:debug(\"Body parts to Item\")\n                root:detachChild(self.anotherModel.root)\n                root:attachChild(self.baseModel.root)\n            else\n                self.logger:debug(\"Item to Body parts\")\n                root:detachChild(self.baseModel.root)\n                root:attachChild(self.anotherModel.root)\n            end\n\n            self.anotherLook = not self.anotherLook\n            -- Rotation is not a problem in the relative orientation.\n            -- But if the scales are in similar proportions, relative scales are fine, but if they aren't, I guess they're may be cliped...\n            -- So adjust the appropriate scale and zoom amount\n            -- This doesn't have to be computed for each time, just have double the data.\n            -- There are also multiple cameras, so the number of cameras increases for the combination.\n            self:AdjustScale(self.lighting, self.anotherLook)\n\n            root:updateEffects()\n            root:update()\n            self:PlaySound(self.anotherLook)\n\n            -- notify disabling mirroring option\n            local payload = { another = self.anotherLook } ---@type ChangedAnotherLookEventData\n            event.trigger(settings.changedAnotherLookEventName, payload)\n        end\n\n        if self.anotherData.type == settings.anotherLookType.WeaponSheathing then\n\n            if not another.root then\n                local data = self.anotherData.data ---@cast data WeaponSheathingData\n                if not data.path or not tes3.getFileExists(string.format(\"Meshes\\\\%s\", data.path)) then\n                    self.logger:error(\"Missing weapon sheathing mesh: %s\", data.path)\n                    return\n                end\n                self.logger:debug(\"Load weapon sheathing mesh: %s\", data.path)\n                another.root = tes3.loadMesh(data.path, true):clone() --[[@as niBillboardNode|niCollisionSwitch|niNode|niSortAdjustNode|niSwitchNode]]\n\n                -- use base offet, no adjust centering\n                local offset = (self.baseModel.bounds.max + self.baseModel.bounds.min) * -0.5\n                another.root.translation = offset:copy()\n            end\n\n            if self.anotherLook then\n                self.logger:debug(\"Sheathed Weapon\")\n                root:detachChild(self.anotherModel.root)\n                root:attachChild(self.baseModel.root)\n            else\n                self.logger:debug(\"Drawn Weapon\")\n                root:detachChild(self.baseModel.root)\n                root:attachChild(self.anotherModel.root)\n            end\n\n            self.anotherLook = not self.anotherLook\n\n            -- apply same scale for particle\n            local scale = Ease(self.zoomTime / zoomDuration, self.zoomStart, self.zoomEnd)\n            self:SetScale(scale)\n            root:updateEffects()\n            root:update()\n            self:PlaySound(not self.anotherLook)\n        end\n\n        if self.anotherData.type == settings.anotherLookType.Book and self.anotherData.data.text then\n            -- Currently, when there is no lighting, it is rendered after menus and is in front of the book menu, which is disturbing, so it should be hidden in some way.\n\n            root.flags = bit.bor(root.flags, 0x1)     -- hidden flags\n            root:update()\n            self.logger:debug(\"Hide the object for book menu\")\n            local menu = nil ---@type tes3uiElement?\n\n            if self.anotherData.data.type == tes3.bookType.book then\n                self.logger:debug(\"Show book menu\")\n                tes3ui.showBookMenu(self.anotherData.data.text)\n                menu = tes3ui.findMenu(\"MenuBook\")\n            elseif self.anotherData.data.type == tes3.bookType.scroll then\n                self.logger:debug(\"Show scroll menu\")\n                tes3ui.showScrollMenu(self.anotherData.data.text)\n                menu = tes3ui.findMenu(\"MenuScroll\")\n            end\n\n            if menu then\n                -- Return to visibility when book/scroll is closed\n                menu:registerAfter(tes3.uiEvent.destroy, -- or close mouseClick\n                    function(_)\n                        if self.root then\n                            self.root.flags = bit.band(self.root.flags, bit.bnot(0x1))\n                            self.root:update()\n                            self.logger:debug(\"Show again the object for book menu\")\n                        end\n                    end)\n            else\n                self.logger:error(\"Not find book/scroll menu\")\n                -- revert\n                root.flags = bit.band(root.flags, bit.bnot(0x1))\n                root:update()\n            end\n        end\n    end\n\nend\n\n---@param self Inspector\n---@param bounds tes3boundingBox\n---@param distance number\n---@param nearPlaneDistance number\n---@return number limitScale\nfunction this.CalculateZoomMax(self, bounds, distance, nearPlaneDistance)\n    -- zoom limitation\n    local extents = (bounds.max - bounds.min) * 0.5 -- * self.baseScale\n    self.logger:debug(\"bounds extents %s\", extents)\n    local halfLength = extents:length()\n    -- halfLength = math.max(extents.x, extents.y, extents.z, 0)\n    -- Offset because it is clipped before the near clip for some reason.\n    local clipOffset = 3\n    -- I would expect the near to be the same even if the camera is different, and it is.\n    local limitScale = math.max(distance - (nearPlaneDistance + clipOffset), nearPlaneDistance) / math.max(halfLength, math.fepsilon)\n    self.logger:debug(\"halfLength %f, limitScale %f (%f)\", halfLength, limitScale, limitScale / self.baseScale)\n    return limitScale -- relative scale, apply base scale after\n    -- self.zoomMax = math.max(limitScale / self.baseScale, 1)\n    -- self.zoomMax = 2\nend\n\n---@param self Inspector\n---@param lighting LightingType\n---@param anotherLook boolean\nfunction this.AdjustScale(self, lighting, anotherLook)\n    local camera, fovX, _ = GetCamera(lighting)\n    if camera then\n        -- recalculate base scale, fov changed\n        -- but different perspective due to changes in angle of view will occur.\n        local cameraData = camera.cameraData\n        local bounds = self.baseModel.bounds\n        if anotherLook then\n            bounds = self.anotherModel.bounds\n        end\n        if bounds then\n            local baseScale, distanceWidth, distanceHeight = self:ComputeFittingScale(bounds, cameraData, self.distance.y, fovX, fittingRatio)\n            self.baseScale = baseScale\n\n            self.zoomMax = self:CalculateZoomMax(bounds, self.distance.y, cameraData.nearPlaneDistance)\n\n            -- rescale limit\n            -- Or always use the camera with the widest field of view of those you plan to use.\n            local limit = math.max(self.zoomMax / self.baseScale, 1)\n            self.zoomEnd = math.clamp(self.zoomEnd, 0.5, limit)\n\n            local scale = Ease(self.zoomTime / zoomDuration, self.zoomStart, self.zoomEnd)\n            self:SetScale(scale)\n\n            -- clamp translation\n            local root = self.root\n            if root then\n                local dest = root.translation:copy()\n                dest.x = dest.x / self.distance.x  -- to ratio\n                dest.z = dest.z / self.distance.z  -- to ratio\n                self.distance = tes3vector3.new(distanceWidth * 0.5, self.distance.y, distanceHeight * 0.5)\n                dest.x = math.clamp(dest.x * self.distance.x, -self.distance.x, self.distance.x)\n                dest.z = math.clamp(dest.z * self.distance.z, -self.distance.z, self.distance.z)\n                root.translation = dest\n            end\n        end\n    end\nend\n\n---@param self Inspector\nfunction this.SwitchLighting(self)\n    -- next type\n    local lighting = self.lighting + 1\n    if lighting > table.size(settings.lightingType) then -- mod, avoid floor\n       lighting = 1\n    end\n    ---@cast lighting LightingType\n    local prev = GetCamera(self.lighting)\n    local next, fovX, cameraFacing = GetCamera(lighting)\n    if prev and next then\n        self.logger:debug(\"Switch lighting: %d -> %d\", self.lighting, lighting)\n        -- Currently the only difference in lighting is the camera\n\n        self:AdjustScale(lighting, self.anotherLook)\n\n        prev.cameraRoot:detachChild(self.cameraJoint)\n\n        if lighting == settings.lightingType.Constant then\n            self.cameraJoint.rotation = cameraFacing -- identity\n            -- Almost UIs do not have a ZBuffer property. And for some reason the menu camera does not have it either, with depth test enabled. So Disable it.\n            AddOrRemoveZBufferProperty(next.cameraRoot, true)\n            AttachChild(next.cameraRoot, self.cameraJoint, true)\n        else\n            self.cameraJoint.rotation = cameraFacing\n            AttachChild(next.cameraRoot, self.cameraJoint, false)\n        end\n\n        prev.cameraRoot:updateEffects()\n        prev.cameraRoot:update()\n        next.cameraRoot:updateEffects()\n        next.cameraRoot:update()\n        self.lighting = lighting\n    else\n        self.logger:error(\"Failed to find camera for switching lighting.\")\n    end\nend\n\nfunction this.ToggleMirroring(self)\n    local model = self.baseModel.root\n    if self.object and self.object.isLeftPart and model then\n        if self.anotherLook then\n            self.logger:warn(\"No mirroring is necessary.\")\n            return\n        end\n        local after = false\n        if mesh.CanMirror(self.object) then\n            self.logger:debug(\"Mirror the left part\")\n            -- item is Y-mirrored\n            local mirror = tes3matrix33.new(\n                1, 0, 0,\n                0, -1, 0,\n                0, 0, 1\n            )\n            model.rotation = mirror:copy()\n            after = true\n        else\n            self.logger:debug(\"Normal the left part\")\n            local identity = tes3matrix33.new()\n            identity:toIdentity()\n            model.rotation = identity:copy()\n            after = false\n        end\n        -- There is a situation where changing the sourceMod from config and changing the ID with the button results in the same state.\n        if self.mirrored ~= after then\n            -- adjust centering offset, simply flip Y\n            -- no need zoom re-fitting. center point changes, but the size should remain the same.\n            model.translation = tes3vector3.new(model.translation.x, -model.translation.y, model.translation.z)\n            self.logger:debug(\"Flipped offset: %s\", model.translation)\n        end\n        self.mirrored = after\n\n        -- enabled no cull\n        -- currently armor, cloth are always no cull\n        -- local props = self.root:getProperty(ni.propertyType.stencil)\n        -- if props then\n        --     props.drawMode = 3 -- DRAW_BOTH\n        -- end\n        self.root:update()\n    end\nend\n\nfunction this.ResetPose(self)\n    self.logger:debug(\"Reset pose\")\n    local root = self.root\n    if root then\n        self.angularVelocity = tes3vector3.new(0, 0, 0)\n        self.velocity = tes3vector3.new(0, 0, 0)\n        self.zoomStart = 1\n        self.zoomEnd = 1\n        self.zoomTime = zoomDuration\n        root.rotation = self.baseRotation:copy()\n        self:SetScale(1)\n        root.translation = tes3vector3.new(0, self.distance.y, 0)\n        root:update()\n    end\nend\n\n---@param offset number\n---@return niNode\nlocal function SetupNode(offset)\n    -- local root = niNode.new()\n\n    ---@diagnostic disable-next-line: undefined-global\n    -- local root = niSortAdjustNode.new()\n    -- root.sortingMode = 1 -- ni.sortAdjustMode.off\n\n    -- Unfortunately, it is not possible to create an accumulator from MWSE, so we use the asset.\n    -- If not sorted by subsort, the alpha mesh in the object may become inconsistent.\n    -- NiSortAdjustNode: sortingMode = ni.sortAdjustMode.subsort, accumulator = NiAlphaAccumulator\n    local root = tes3.loadMesh(\"InspectIt/root.nif\", false)\n    root.name = \"InspectIt:Root\"\n    root.translation = tes3vector3.new(0, offset, 0)\n    root.appCulled = false\n\n    -- If transparency is included, it may not work unless it is specified on a per material.\n    local zBufferProperty = niZBufferProperty.new()\n    zBufferProperty.name = \"InspectIt:DepthTestWrite\"\n    zBufferProperty:setFlag(true, 0) -- test\n    zBufferProperty:setFlag(true, 1) -- write\n    root:attachProperty(zBufferProperty)\n    -- No culling on the back face because the geometry of the part to be placed on the ground does not exist.\n    local stencilProperty = niStencilProperty.new()\n    stencilProperty.name = \"InspectIt:CullFace\"\n    stencilProperty.drawMode = 3 -- DRAW_BOTH\n    root:attachProperty(stencilProperty)\n    local vertexColorProperty = niVertexColorProperty.new()\n    vertexColorProperty.name = \"InspectIt:emiAmbDif\"\n    vertexColorProperty.lighting = 1 -- ni.lightingMode.emiAmbDif\n    vertexColorProperty.source = 2 -- ni.sourceVertexMode.ambDiff\n    root:attachProperty(vertexColorProperty)\n    local alphaProperty = niAlphaProperty.new()\n    alphaProperty.name = \"InspectIt:Opaque\"\n    alphaProperty.alphaTestRef = 0\n    alphaProperty.propertyFlags = 236 -- 0x1 enable tranparency, so 0 or player reference's default(236)\n    root:attachProperty(alphaProperty)\n    root:updateProperties()\n    -- NiMaterialProperty can't be created. If necessary, clone.\n    return root\nend\n\n---@param self Inspector\n---@param bounds tes3boundingBox\n---@param cameraData tes3worldControllerRenderCameraData\n---@param distance number\n---@param fovX number\n---@param ratio number\n---@return number scale\n---@return number width\n---@return number height\nfunction this.ComputeFittingScale(self, bounds, cameraData, distance, fovX, ratio)\n    local aspectRatio = cameraData.viewportHeight / cameraData.viewportWidth\n    local tan = math.tan(math.rad(fovX) * 0.5)\n    local width = tan * math.max(distance, cameraData.nearPlaneDistance + 1) * 2.0\n    local height = width * aspectRatio\n    -- The cubes like the wooden box should be a perfect fit, but for some reason they don't match.\n    -- conservative\n    local screenSize = math.min(width, height) * ratio\n    local size = bounds.max - bounds.min\n    local boundsSize = math.max(size.x, size.y, size.z, math.fepsilon)\n\n    -- diagonal\n    -- boundsSize = size:length() -- 3d or dominant 2d\n    -- screenSize = math.sqrt(width * width + height * height)\n\n    -- moderation\n    -- boundsSize = size:length() -- 3d diagonal\n    -- screenSize = math.max(width, height)\n\n    local scale = screenSize / boundsSize\n\n    self.logger:debug(\"fovX: %f, MGE near: %f\", fovX, mge.camera.nearRenderDistance)\n    self.logger:debug(\"Camera near: %f, far: %f, fov: %f\", cameraData.nearPlaneDistance, cameraData.farPlaneDistance,\n        cameraData.fov)\n    self.logger:debug(\"Camera viewport width: %d, height: %d\", cameraData.viewportWidth, cameraData.viewportHeight)\n    self.logger:debug(\"Distant width: %f, height: %f, fovX: %f\", width, height, fovX)\n    self.logger:debug(\"Fitting scale: %f\", scale)\n    return scale, width , height\nend\n\n---@param self Inspector\n---@param params Activate.Params\nfunction this.Activate(self, params)\n    self.logger:debug(\"[Activate] Inspector\")\n\n    local object = params.object\n    if not object then\n        self.logger:error(\"No Object\")\n        return\n    end\n\n    -- Examine how the node remains in the effect\n    if config.development.experimental then\n        local src = tes3.player1stPerson.sceneNode\n        if tes3.is3rdPerson() then\n            src = tes3.player.sceneNode\n        end\n        if src then\n            local total = 0\n            local effects = src.effectList\n            while effects do\n                local pereffect = 0\n                if effects.data then\n                    --[[\n                    local effect = effects.data\n                    if effect:isInstanceOfType(ni.type.NiLight) then -- only light or point\n                        local affects = effect.affectedNodes\n                        while affects do\n                            if affects.data then\n                                self.logger:trace(\"%s\", affects.data)\n                                pereffect = pereffect + 1\n                            end\n                            affects = affects.next\n                        end\n                    end\n                    --]]\n                    self.logger:debug(\"Affected by %s: %d\", effects.data, pereffect)\n                end\n                effects = effects.next\n                total = total + pereffect\n            end\n            self.logger:debug(\"Total Affected: %d\", total)\n        end\n    end\n\n    local model = nil\n    if params.referenceNode then\n        self.logger:debug(\"Use reference: %s\", params.referenceNode)\n        model = params.referenceNode:clone() --[[@as niBillboardNode|niCollisionSwitch|niNode|niSortAdjustNode|niSwitchNode]]\n        self.logger:trace(\"%s\", mesh.Dump(model))\n        -- This clone also seems to retarget skinInstance.bones and skinInstance.root by deep copying.\n        -- So, retargeting like bodypart is not necessary.\n\n        -- TODO reset animation or switching another, if need\n\n        -- remove rotation, but including race scale\n        if object.race and object.race.height and object.race.weight then\n            -- or extract from rotation matrix\n            -- can be done by more than just NPCs. but negative scale is difficult.\n            -- row-major\n            -- local x = model.rotation.x:length()\n            -- local y = model.rotation.y:length()\n            -- local z = model.rotation.z:length()\n\n            local s = tes3vector2.new(object.race.weight.male, object.race.height.male)\n            if object.female then\n                s = tes3vector2.new(object.race.weight.female, object.race.height.female)\n            end\n            -- race sacale with identity\n            local raceScale = tes3matrix33.new(\n                s.x, 0, 0,\n                0, s.x, 0,\n                0, 0, s.y\n            )\n            model.rotation = raceScale:copy()\n        else\n            local identity = tes3matrix33.new()\n            identity:toIdentity()\n            model.rotation = identity:copy()\n        end\n\n    else\n        local path = mesh.ResolvePath(object.mesh)\n        if not path then\n            self.logger:error(\"Missing %s id: %s, mesh: %s, sourceMod: %s\", path, object.id, object.mesh, settings.GetSourceMod(object))\n            return\n        end\n        self.logger:debug(\"Load %s id: %s, mesh: %s, sourceMod: %s\", path, object.id, object.mesh, settings.GetSourceMod(object))\n        model = tes3.loadMesh(path, true):clone() --[[@as niBillboardNode|niCollisionSwitch|niNode|niSortAdjustNode|niSwitchNode]]\n        if not model.name then\n            model.name = string.format(\"%s\", path)\n        end\n        self.logger:trace(\"%s\", mesh.Dump(model))\n        -- reset\n        model:clearTransforms()\n    end\n\n    -- clean\n    mesh.CleanMesh(model)\n\n    model.translation = tes3vector3.new(0,0,0)\n    model.scale = 1\n\n    -- When there are separate polygons on both sides, such as papers,\n    -- without backface culling, the back side seems to appear in the foreground depending on both position.\n    local backface = object.objectType ~= tes3.objectType.book and object.objectType ~= tes3.objectType.weapon\n    self.mirrored = false\n    if mesh.CanMirror(object) then\n        self.logger:debug(\"Mirror the left part\")\n        -- item is Y-mirrored\n        local mirror = tes3matrix33.new(\n            1, 0, 0,\n            0, -1, 0,\n            0, 0, 1\n        )\n        model.rotation = mirror:copy()\n        backface = true -- must\n        self.mirrored = true\n    end\n\n    model:update() -- trailer partiles gone. but currently thoses are glitched, so its ok.\n    -- self.logger:trace(\"%s\", mesh.Dump(model))\n\n    local bounds = mesh.CalculateBounds(model)\n\n    -- initial scaling\n    local camera, fovX, cameraFacing = GetCamera(self.lighting)\n    if not camera then\n        self.logger:error(\"Camera not found\")\n        return\n    end\n\n    local distance = params.offset\n\n    -- centering\n    local offset = (bounds.max + bounds.min) * -0.5\n    self.logger:debug(\"bounds: %s\", bounds)\n    self.logger:debug(\"bounds offset: %s\", offset)\n    local root = SetupNode(distance)\n    model.translation = offset\n    root:attachChild(model)\n\n    if backface and not self.mirrored then\n        -- When there are separate polygons on both sides, such as papers,\n        -- without backface culling, the back side seems to appear in the foreground depending on both position.\n        -- Here for modding resources, the thickness is used to determine the thin, just as it is used to determine the paper.\n        local size = bounds.max - bounds.min\n        local thickness = math.min(size.x, size.y, size.z)\n        if thickness < 1.5 then\n            backface = false\n            self.logger:debug(\"Enable culling backface, thickness: %f\", thickness)\n        end\n    end\n\n    if not backface then\n        local props = root:getProperty(ni.propertyType.stencil)\n        if props then\n            props.drawMode = 0-- DRAW_CCW_OR_BOTH\n        end\n    end\n\n    -- initial rotation\n    local findKey = function(o)\n        for key, value in pairs(tes3.objectType) do\n            if o == value then\n                return key\n            end\n        end\n        return \"unknown\"\n    end\n    self.logger:debug(\"objectType: %s\", findKey(object.objectType))\n    local orientation = ori.GetOrientation(object, bounds)\n    if orientation then\n        local rot = tes3matrix33.new()\n        rot:fromEulerXYZ(math.rad(orientation.x), math.rad(orientation.y), math.rad(orientation.z))\n        root.rotation = root.rotation * rot:copy()\n    end\n\n    -- cloned reference is also cloned the effect list\n    if not params.referenceNode then\n        mesh.AttachDynamicEffect(root)\n    end\n\n    self.root = root\n    self.baseModel.root = model\n    self.baseModel.bounds = bounds:copy()\n    self.anotherModel.bounds = bounds:copy() -- later\n    self.anotherModel.root = nil\n    self.anotherLook = false\n    self.anotherData = params.another\n    -- self.lighting = settings.lightingType.Default -- Probably more convenient to carry over previous values\n\n    local cameraRoot = camera.cameraRoot\n    local cameraData = camera.cameraData\n    local scale, distanceWidth, distanceHeight = self:ComputeFittingScale(bounds, cameraData, distance, fovX, fittingRatio)\n    self.distance = tes3vector3.new(distanceWidth * 0.5, distance, distanceHeight * 0.5)\n\n    self.baseScale = root.scale\n    self:SetScale(scale)\n\n    self.angularVelocity = tes3vector3.new(0, 0, 0)\n    self.velocity = tes3vector3.new(0, 0, 0)\n    self.baseRotation = root.rotation:copy()\n    self.baseScale = scale\n    self.zoomStart = 1\n    self.zoomEnd = 1\n    self.zoomTime = zoomDuration\n\n    self.zoomMax = self:CalculateZoomMax(bounds, distance,cameraData.nearPlaneDistance)\n\n    local cameraJoint = niNode.new()\n    cameraJoint.name = \"InspectIt:CameraJoint\"\n    cameraJoint.rotation = cameraFacing\n    cameraJoint:attachChild(root)\n    self.cameraJoint = cameraJoint\n\n    AttachChild(cameraRoot, self.cameraJoint, self.lighting == settings.lightingType.Constant)\n    if self.lighting == settings.lightingType.Constant then\n        AddOrRemoveZBufferProperty(cameraRoot, true)\n    end\n    cameraRoot:updateEffects()\n    cameraRoot:update()\n\n    --- subscribe events\n    self.enterFrameCallback = function(e)\n        self:OnEnterFrame(e)\n    end\n    self.activateCallback = function(e)\n        self:OnActivate(e)\n    end\n    self.switchAnotherLookCallback = function()\n        self:SwitchAnotherLook()\n    end\n    self.switchLightingCallback = function()\n        self:SwitchLighting()\n    end\n    self.toggleMirroringCallback = function()\n        self:ToggleMirroring()\n    end\n    self.resetPosecCallback = function()\n        self:ResetPose()\n    end\n    event.register(tes3.event.enterFrame, self.enterFrameCallback)\n    event.register(tes3.event.activate, self.activateCallback)\n    event.register(settings.switchAnotherLookEventName, self.switchAnotherLookCallback)\n    event.register(settings.switchLightingEventName, self.switchLightingCallback)\n    event.register(settings.toggleMirroringEventName, self.toggleMirroringCallback)\n    event.register(settings.resetPoseEventName, self.resetPosecCallback)\n\n    -- It is better to play the sound in another controller, but it is easy to depend on the inspector's state, so run it in that.\n    -- it seems it doesn't matter if the ID is not from tes3item.\n    self.object = object\n    self:PlaySound(true)\n\nend\n\n---@param self Inspector\n---@param params Deactivate.Params\nfunction this.Deactivate(self, params)\n    if self.root then\n        self.logger:debug(\"[Deactivate] Inspector\")\n\n        -- If reference is cloned, it has a dynamic effect on it, so it is detached recursively.\n        -- Dynamic effect is cleaned up as the cell is unloaded without detaching it, but until then it seems to remain as an affected object.\n        mesh.DetachDynamicEffect(self.root, true)\n        self.root:updateEffects()\n\n        local camera = GetCamera(self.lighting)\n        if camera and self.cameraJoint then\n            local cameraRoot = camera.cameraRoot\n            cameraRoot:detachChild(self.cameraJoint)\n            cameraRoot:updateEffects()\n            cameraRoot:update()\n        end\n        camera = GetCamera(settings.lightingType.Constant)\n        if camera then\n            AddOrRemoveZBufferProperty(camera.cameraRoot, false)\n        end\n\n        event.unregister(tes3.event.enterFrame, self.enterFrameCallback)\n        event.unregister(tes3.event.activate, self.activateCallback)\n        event.unregister(settings.switchAnotherLookEventName, self.switchAnotherLookCallback)\n        event.unregister(settings.switchLightingEventName, self.switchLightingCallback)\n        event.unregister(settings.toggleMirroringEventName, self.toggleMirroringCallback)\n        event.unregister(settings.resetPoseEventName, self.resetPosecCallback)\n        self.enterFrameCallback = nil\n        self.activateCallback = nil\n        self.switchAnotherLookCallback = nil\n        self.switchLightingCallback = nil\n        self.toggleMirroringCallback = nil\n        self.resetPosecCallback = nil\n\n        if not params.menuExit then\n            self:PlaySound(false)\n        end\n    end\n    self.root = nil\n    self.cameraJoint = nil\n    self.baseModel.root = nil\n    self.baseModel.bounds = nil\n    self.anotherModel.root = nil\n    self.anotherModel.bounds = nil\n    self.anotherData = nil\n    self.object = nil\nend\n\n---@param self Inspector\nfunction this.Reset(self)\n    self.root = nil\n    self.cameraJoint = nil\n    self.baseModel.root = nil\n    self.baseModel.bounds = nil\n    self.anotherModel.root = nil\n    self.anotherModel.bounds = nil\n    self.anotherData = nil\n    self.object = nil\n    self.lighting = settings.lightingType.Default\nend\n\nreturn this\n",
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\controller\\menumode.lua": "local base = require(\"InspectIt.controller.base\")\n\n---@class MenuMode : IController\n---@field entered boolean\nlocal this = {}\nsetmetatable(this, { __index = base })\n\n---@type MenuMode\nlocal defaults = {\n    entered = false,\n}\n\n---@return MenuMode\nfunction this.new()\n    local instance = base.new(defaults)\n    setmetatable(instance, { __index = this })\n    ---@cast instance MenuMode\n    return instance\nend\n\n---@param self MenuMode\n---@param params Activate.Params\nfunction this.Activate(self, params)\n    -- or counter is better\n    if not self.entered then\n        if not tes3ui.menuMode() then\n            self.logger:debug(\"[Activate] enterMenuMode\")\n            tes3ui.enterMenuMode(\"InspectIt\")\n            self.entered = true\n        end\n    else\n        self.logger:error(\"[Activate] Previous deactivation is not successful?\")\n    end\nend\n\n---@param self MenuMode\n---@param params Deactivate.Params\nfunction this.Deactivate(self, params)\n    if self.entered then\n        self.entered = false\n        tes3ui.leaveMenuMode()\n        self.logger:debug(\"[Deactivate] leaveMenuMode\")\n    end\nend\n\n---@param self MenuMode\nfunction this.Reset(self)\n    self.entered = false\nend\n\nreturn this\n",
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\controller\\renderer.lua": "local base = require(\"InspectIt.controller.base\")\n\n---@class Renderer : IController\n---@field pauseRenderingInMenus boolean\nlocal this = {}\nsetmetatable(this, { __index = base })\n\n---@type Renderer\nlocal defaults = {\n    pauseRenderingInMenus = true,\n}\n\n---@return Renderer\nfunction this.new()\n    local instance = base.new(defaults)\n    setmetatable(instance, { __index = this })\n    ---@cast instance Renderer\n\n    instance.logger:debug(\"Initial pauseRenderingInMenus: %s\", tostring(mge.render.pauseRenderingInMenus))\n    instance.pauseRenderingInMenus = mge.render.pauseRenderingInMenus\n\n    return instance\nend\n\n---@param self Renderer\n---@param params Activate.Params\nfunction this.Activate(self, params)\n    self.logger:debug(\"[Activate] pauseRenderingInMenus: %s\", tostring(mge.render.pauseRenderingInMenus))\n    self.pauseRenderingInMenus = mge.render.pauseRenderingInMenus\n    mge.render.pauseRenderingInMenus = false\nend\n\n---@param self Renderer\n---@param params Deactivate.Params\nfunction this.Deactivate(self, params)\n    -- Inconsistency if switched from options when enabled\n    self.logger:debug(\"[Deactivate] pauseRenderingInMenus: %s\", tostring(mge.render.pauseRenderingInMenus))\n    mge.render.pauseRenderingInMenus = self.pauseRenderingInMenus\nend\n\n---@param self Renderer\nfunction this.Reset(self)\nend\n\nreturn this\n",
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\controller\\visibility.lua": "local base = require(\"InspectIt.controller.base\")\n\n---@class Visibility : IController\n---@field visibility {[integer] : boolean}\nlocal this = {}\nsetmetatable(this, { __index = base })\n\n---@type Visibility\nlocal defaults = {\n    visibility = {},\n}\n\nlocal menus = {\n    tes3ui.registerID(\"MenuAlchemy\"), --\n    -- tes3ui.registerID(\"MenuAttributes\"), --\n    -- tes3ui.registerID(\"MenuAttributesList\"), -- Enchanting/spellmaking effect attribute\n    tes3ui.registerID(\"MenuBarter\"), --\n    -- tes3ui.registerID(\"MenuBirthSign\"), --\n    -- tes3ui.registerID(\"MenuBook\"), --\n    -- tes3ui.registerID(\"MenuChooseClass\"), --\n    -- tes3ui.registerID(\"MenuClassChoice\"), --\n    -- tes3ui.registerID(\"MenuClassMessage\"), --\n    -- tes3ui.registerID(\"MenuConsole\"), --\n    tes3ui.registerID(\"MenuContents\"), -- Container/NPC inventory\n    -- tes3ui.registerID(\"MenuDialog\"), --\n    tes3ui.registerID(\"MenuEnchantment\"), --\n    -- tes3ui.registerID(\"MenuInput\"), --\n    -- tes3ui.registerID(\"MenuInputSave\"), --\n    tes3ui.registerID(\"MenuInventory\"), -- Player inventory\n    tes3ui.registerID(\"MenuInventorySelect\"), -- Item selector\n    -- tes3ui.registerID(\"MenuJournal\"), --\n    tes3ui.registerID(\"MenuMagic\"), -- Spell/enchanted item selector\n    -- tes3ui.registerID(\"MenuMagicSelect\"), --\n    tes3ui.registerID(\"MenuMap\"), --\n    -- tes3ui.registerID(\"MenuMapNoteEdit\"), --\n    -- tes3ui.registerID(\"MenuMessage\"), --\n    -- tes3ui.registerID(\"MenuMulti\"), -- Status bars, current weapon/magic, active effects and minimap\n    -- tes3ui.registerID(\"MenuName\"), --\n    -- tes3ui.registerID(\"MenuQuick\"), -- Quick keys\n    tes3ui.registerID(\"MenuRepair\"), --\n    -- tes3ui.registerID(\"MenuRestWait\"), --\n    -- tes3ui.registerID(\"MenuSave\"), --\n    -- tes3ui.registerID(\"MenuScroll\"), --\n    tes3ui.registerID(\"MenuServiceRepair\"), --\n    tes3ui.registerID(\"MenuServiceSpells\"), --\n    -- tes3ui.registerID(\"MenuServiceTraining\"), --\n    -- tes3ui.registerID(\"MenuServiceTravel\"), --\n    -- tes3ui.registerID(\"MenuSetValues\"), -- Enchanting/spellmaking effect values\n    -- tes3ui.registerID(\"MenuSkills\"), --\n    -- tes3ui.registerID(\"MenuSkillsList\"), -- Enchanting/spellmaking effect skill\n    -- tes3ui.registerID(\"MenuSpecialization\"), --\n    tes3ui.registerID(\"MenuSpellmaking\"), --\n    tes3ui.registerID(\"MenuStat\"), -- Player attributes, skills, factions etc.\n    -- tes3ui.registerID(\"MenuSwimFillBar\"), --\n    -- tes3ui.registerID(\"MenuTimePass\"), --\n    -- tes3ui.registerID(\"MenuTopic\"), --\n}\n\n---@return Visibility\nfunction this.new()\n    local instance = base.new(defaults)\n    setmetatable(instance, { __index = this })\n    ---@cast instance Visibility\n\n    return instance\nend\n\n---@param self Visibility\n---@param params Activate.Params\nfunction this.Activate(self, params)\n    tes3ui.suppressTooltip(true)\n    for _, menu in ipairs(menus) do\n        local element = tes3ui.findMenu(menu)\n        if element and element.visible == true then\n            self.logger:debug(\"[Activate] Menu %s visibility %s to false\", element.name, tostring(element.visible))\n            element.visible = false\n            self.visibility[menu] = true\n        else\n            self.visibility[menu] = false\n        end\n    end\nend\n\n---@param self Visibility\n---@param params Deactivate.Params\nfunction this.Deactivate(self, params)\n    tes3ui.suppressTooltip(false)\n    if not params.menuExit then\n        for menu, value in pairs(self.visibility) do\n            if value then\n                local element = tes3ui.findMenu(menu)\n                if element then\n                    self.logger:debug(\"[Deactivate] Menu %s visibility %s to true\", element.name, tostring(element.visible))\n                    element.visible = true\n                end\n            end\n        end\n    end\nend\n\n---@param self Visibility\nfunction this.Reset(self)\n    self.visibility = {}\nend\n\nreturn this\n",
    "Inspect It-54636-1-7-1725378854\\Data Files\\MWSE\\mods\\InspectIt\\i18n\\eng.lua": "return {\n    [\"messageBox.unsupport.text\"] = \"It is not yet supported for inspection.\",\n    [\"messageBox.playerRequirement.text\"] = \"When inspecting the player character, use third person view.\",\n    [\"messageBox.bookRequirement.text\"] = \"'%{name}' cannot be opened inside because something will happen to it.\",\n    [\"guide.rotate.text\"] = \"Rotate: Mouse left drag\",\n    [\"guide.translate.text\"] = \"Move: Mouse middle drag\",\n    [\"guide.zoom.text\"] = \"Zoom: Mouse wheel\",\n    [\"guide.another.text\"] = \"Switch another\",\n    [\"guide.lighting.text\"] = \"Switch lighting\",\n    [\"guide.leftPart.text\"] = \"Toggle left part\",\n    [\"guide.leftPart.normal\"] = \"Normal\",\n    [\"guide.leftPart.mirror\"] = \"Mirrored\",\n    [\"guide.leftPart.plugin\"] = \"Plugin\",\n    [\"guide.reset.text\"] = \"Reset pose\",\n    [\"guide.return.text\"] = \"Return\",\n    [\"guide.sourceless.text\"] = \"Sourceless\",\n    [\"mcm.page.label\"] = \"Config\",\n    [\"mcm.sidebar.info\"] = \"You can inspect an object by pressing the assigned key binding when you mouseover an item in the inventory and an activatable object in the world with the cursor. Or you look at an activatable object with the crosshair.\",\n    [\"mcm.input.category.label\"] = \"Input\",\n    [\"mcm.input.category.description\"] = \"Configure settings for input.\",\n    [\"mcm.input.inspect.label\"] = \"Inspect\",\n    [\"mcm.input.inspect.description\"] = \"Key binding for inspecting an object.\",\n    [\"mcm.input.another.label\"] = \"Switch Another\",\n    [\"mcm.input.another.description\"] = \"If another look exists, key binding for switching to it during inspection.\",\n    [\"mcm.input.lighting.label\"] = \"Switch Lighting\",\n    [\"mcm.input.lighting.description\"] = \"Key bindings for switching lighting during inspection.\\nCurrently, when it is not lit, it is rendered in front of the UI. Also field of view probably be different.\",\n    [\"mcm.input.reset.label\"] = \"Reset Pose\",\n    [\"mcm.input.reset.description\"] = \"Key bindings for resetting the pose during inspection.\",\n    [\"mcm.input.sensitivityX.label\"] = \"Horizontal Sensitivity\",\n    [\"mcm.input.sensitivityX.description\"] = \"Horizontal sensitivity during inspection. It is further multiplied from the sensitivity of the game options.\",\n    [\"mcm.input.sensitivityY.label\"] = \"Vertical Sensitivity\",\n    [\"mcm.input.sensitivityY.description\"] = \"Vertical sensitivity during inspection. It is further multiplied from the sensitivity of the game options.\",\n    [\"mcm.input.sensitivityZ.label\"] = \"Zoom Sensitivity\",\n    [\"mcm.input.sensitivityZ.description\"] = \"Zoom sensitivity with mouse wheel during inspection.\",\n    [\"mcm.input.inversionX.label\"] = \"Horizontal Inversion\",\n    [\"mcm.input.inversionX.description\"] = \"Invert horizontal dragging.\",\n    [\"mcm.input.inversionY.label\"] = \"Vertical Inversion\",\n    [\"mcm.input.inversionY.description\"] = \"Invert vertical dragging.\",\n    [\"mcm.input.inversionZ.label\"] = \"Zoom Inversion\",\n    [\"mcm.input.inversionZ.description\"] = \"Invert mouse wheel in zooming.\",\n    [\"mcm.inspection.category.label\"] = \"Inspection\",\n    [\"mcm.inspection.category.description\"] = \"Configure settings for inspection.\",\n    [\"mcm.inspection.inventory.label\"] = \"Mouseover an Item in Inventory\",\n    [\"mcm.inspection.inventory.description\"] = \"When you mouseover an item in your inventory, you can inspect it.\",\n    [\"mcm.inspection.barter.label\"] = \"Mouseover an Item in Barter\",\n    [\"mcm.inspection.barter.description\"] = \"When you mouseover an item being bartered, you can inspect it.\",\n    [\"mcm.inspection.contents.label\"] = \"Mouseover an Item in Container\",\n    [\"mcm.inspection.contents.description\"] = \"When you mouseover an item in a container or pickpocketing, you can inspect it.\",\n    [\"mcm.inspection.cursorOver.label\"] = \"Mouseover an Activatable Object in the World\",\n    [\"mcm.inspection.cursorOver.description\"] = \"When you mouseover an activatable object in the world with the cursor, you can inspect it.\",\n    [\"mcm.inspection.activatable.label\"] = \"Look at an Activatable Object\",\n    [\"mcm.inspection.activatable.description\"] = \"When you are looking at an activatable object with the crosshair, you can inspect it.\",\n    [\"mcm.inspection.playSound.label\"] = \"Play Sound\",\n    [\"mcm.inspection.playSound.description\"] = \"Play the sound effect set for the object.\",\n    [\"mcm.display.category.label\"] = \"Display\",\n    [\"mcm.display.category.description\"] = \"Configure elements to be displayed on the screen.\",\n    [\"mcm.display.instruction.label\"] = \"Instruction\",\n    [\"mcm.display.instruction.description\"] = \"Display key instructions. Key bindings are always enabled.\",\n    [\"mcm.display.bokeh.label\"] = \"Focus Effect\",\n    [\"mcm.display.bokeh.description\"] = \"Display the effect of blurring the background during inspection. 'Enable shaders' in MGE XE must be enabled to use this feature.\",\n    [\"mcm.display.leftPart.label\"] = \"Mirror the Left Part\",\n    [\"mcm.display.leftPart.description\"] = \"Mirror the left part of armor or clothing. Most of the left part of armor or clothing is the same as the right part, so the left hand is the right hand.\\nExclusion settings for each item or plugin can be configured from 'Mirror the Left Part' tab.\",\n    [\"mcm.display.recalculateBounds.label\"] = \"Recalculate Bounding Box\",\n    [\"mcm.display.recalculateBounds.description\"] = \"The object to be inspected may fit more efficiently on the screen. But it requires heavy load when starting the inspection.\",\n    [\"mcm.display.tooltipsComplete.label\"] = \"Tooltips Complete\",\n    [\"mcm.display.tooltipsComplete.description\"] = \"If Tooltips Complete is installed, its description is displayed during the inspection. That mod's config also be applied.\",\n    [\"mcm.display.objectId.label\"] = \"Object ID\",\n    [\"mcm.display.objectId.description\"] = \"Display the object ID.\",\n    [\"mcm.display.sourceMod.label\"] = \"Source Mod\",\n    [\"mcm.display.sourceMod.description\"] = \"Display the source mod.\",\n    [\"mcm.development.category.label\"] = \"Development\",\n    [\"mcm.development.category.description\"] = \"Features for development.\",\n    [\"mcm.development.experimental.label\"] = \"Experimental\",\n    [\"mcm.development.experimental.description\"] = \"Enable experimental features. Glitches may occur. It probably spoil the immersion.\\nIn addition to activatable objects, most other objects can be inspected.\",\n    [\"mcm.development.logLevel.label\"] = \"Logging Level\",\n    [\"mcm.development.logLevel.description\"] = \"Set the log level.\",\n    [\"mcm.development.logToConsole.label\"] = \"Log to Console\",\n    [\"mcm.development.logToConsole.description\"] = \"Output the log to console.\",\n    [\"mcm.leftPartFilter.page.label\"] = \"Mirror the Left Part\",\n    [\"mcm.leftPartFilter.page.description\"] = \"Most of the left part of armor or clothing is the same as the right part, so the left hand is the right hand.\\nIt is recommended that they be mirrored, as you can filter the left part, which uses the same mesh as the right part. This can be done by setting all items to 'Normal' once and then setting items of the same mesh to 'Mirrored'.\\nAlso Plugins take priority over item IDs.\\nThis setting can be toggled for that item during the inspection.\",\n    [\"mcm.leftPartFilter.page.normal\"] = \"Normal\",\n    [\"mcm.leftPartFilter.page.mirror\"] = \"Mirrored\",\n    [\"mcm.leftPartFilter.armor.label\"] = \"Armor\",\n    [\"mcm.leftPartFilter.clothing.label\"] = \"Clothing\",\n    [\"mcm.leftPartFilter.sameArmor.label\"] = \"Armor (Same Mesh)\",\n    [\"mcm.leftPartFilter.sameClothing.label\"] = \"Clothing (Same Mesh)\",\n    [\"mcm.leftPartFilter.plugin.label\"] = \"Plugin\",\n}\n"
  }
}