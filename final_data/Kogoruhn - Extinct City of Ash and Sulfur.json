{
  "folder_name": "Kogoruhn - Extinct City of Ash and Sulfur",
  "lua_files": {
    "Kogoruhn - Extinct City of Ash and Sulfur-51615-2-9-1-1713559270\\Kogoruhn - Extinct City of Ash and Sulfur\\scripts\\Kogoruhn - Extinct City of Ash and Sulfur\\activator.lua": "local self = require(\"openmw.self\")\nlocal types = require(\"openmw.types\")\nlocal nearby = require(\"openmw.nearby\")\n\nreturn {\n    engineHandlers = {\n        onActive = function()\n            if self.recordId ~= \"dm_k_qk_camera\" then\n                return\n            end\n\n            local duration = 6.0\n            local strength = 0.3\n\n            for _, actor in ipairs(nearby.actors) do\n                if actor.type == types.Player then\n                    actor:sendEvent(\"dm_k_qk_shake\", {duration, strength})\n                end\n            end\n        end\n    }\n}\n",
    "Kogoruhn - Extinct City of Ash and Sulfur-51615-2-9-1-1713559270\\Kogoruhn - Extinct City of Ash and Sulfur\\scripts\\Kogoruhn - Extinct City of Ash and Sulfur\\perlin.lua": "local this = {}\nthis.__index = this\n\nlocal defaultSeed = 1337\n\nlocal dotProduct = {\n    [0x0] = function(x, y, z) return x + y end,\n    [0x1] = function(x, y, z) return -x + y end,\n    [0x2] = function(x, y, z) return x - y end,\n    [0x3] = function(x, y, z) return -x - y end,\n    [0x4] = function(x, y, z) return x + z end,\n    [0x5] = function(x, y, z) return -x + z end,\n    [0x6] = function(x, y, z) return x - z end,\n    [0x7] = function(x, y, z) return -x - z end,\n    [0x8] = function(x, y, z) return y + z end,\n    [0x9] = function(x, y, z) return -y + z end,\n    [0xA] = function(x, y, z) return y - z end,\n    [0xB] = function(x, y, z) return -y - z end,\n    [0xC] = function(x, y, z) return y + x end,\n    [0xD] = function(x, y, z) return -y + z end,\n    [0xE] = function(x, y, z) return y - x end,\n    [0xF] = function(x, y, z) return -y - z end,\n}\n\nlocal function grad(hash, x, y, z)\n    return dotProduct[hash % 0x10](x, y, z)\nend\n\nlocal function fade(t)\n    return t * t * t * (t * (t * 6 - 15) + 10)\nend\n\nlocal function lerp(t, a, b)\n    return a + t * (b - a)\nend\n\nlocal function generatePermutation(seed)\n    math.randomseed(seed)\n\n    local permutation = { 0 }\n\n    for i = 1, 255 do\n        table.insert(permutation, math.random(1, #permutation + 1), i)\n    end\n\n    local p = {}\n\n    for i = 0, 255 do\n        p[i] = permutation[i + 1]\n        p[i + 256] = permutation[i + 1]\n    end\n\n    return p\nend\n\nfunction this.noise(self, x, y, z)\n    y = y or 0\n    z = z or 0\n\n    local xi = math.floor(x) % 0x100\n    local yi = math.floor(y) % 0x100\n    local zi = math.floor(z) % 0x100\n\n    x = x - math.floor(x)\n    y = y - math.floor(y)\n    z = z - math.floor(z)\n\n    local u = fade(x)\n    local v = fade(y)\n    local w = fade(z)\n\n    local A, AA, AB, AAA, ABA, AAB, ABB, B, BA, BB, BAA, BBA, BAB, BBB\n    A   = self.p[xi] + yi\n    AA  = self.p[A] + zi\n    AB  = self.p[A + 1] + zi\n    AAA = self.p[AA]\n    ABA = self.p[AB]\n    AAB = self.p[AA + 1]\n    ABB = self.p[AB + 1]\n\n    B   = self.p[xi + 1] + yi\n    BA  = self.p[B] + zi\n    BB  = self.p[B + 1] + zi\n    BAA = self.p[BA]\n    BBA = self.p[BB]\n    BAB = self.p[BA + 1]\n    BBB = self.p[BB + 1]\n\n    return lerp(w,\n        lerp(v,\n            lerp(u,\n                grad(AAA, x, y, z),\n                grad(BAA, x - 1, y, z)\n            ),\n            lerp(u,\n                grad(ABA, x, y - 1, z),\n                grad(BBA, x - 1, y - 1, z)\n            )\n        ),\n        lerp(v,\n            lerp(u,\n                grad(AAB, x, y, z - 1), grad(BAB, x - 1, y, z - 1)\n            ),\n            lerp(u,\n                grad(ABB, x, y - 1, z - 1), grad(BBB, x - 1, y - 1, z - 1)\n            )\n        )\n    )\nend\n\nsetmetatable(this, {\n    __call = function(self, seed)\n        seed = seed or defaultSeed\n        return setmetatable({\n            seed = seed,\n            p = generatePermutation(seed),\n        }, self)\n    end,\n})\n\nreturn this\n",
    "Kogoruhn - Extinct City of Ash and Sulfur-51615-2-9-1-1713559270\\Kogoruhn - Extinct City of Ash and Sulfur\\scripts\\Kogoruhn - Extinct City of Ash and Sulfur\\player.lua": "local ui = require(\"openmw.ui\")\nlocal core = require(\"openmw.core\")\nlocal camera = require(\"openmw.camera\")\nlocal util = require(\"openmw.util\")\n\nlocal perlin = require(\"scripts.Kogoruhn - Extinct City of Ash and Sulfur.perlin\")\nlocal px = perlin(2 ^ 4)\nlocal py = perlin(2 ^ 5)\nlocal pz = perlin(2 ^ 6)\n\nlocal function updateRotation(strength, time)\n    -- maximum horizontal/vertical angles\n    local maxHorz = math.rad(10)\n    local maxVert = math.rad(10)\n\n    local x = maxHorz * strength * px:noise(time) * 2\n    local y = maxHorz * strength * py:noise(time) * 2\n    local z = maxVert * strength * pz:noise(time) * 2\n\n    camera.setExtraYaw(x)\n    camera.setExtraPitch(y)\n    camera.setRoll(z)\nend\n\nlocal function updatePosition(strength, time)\n    -- maximum horizontal/vertical offsets\n    local maxHorz = 20\n    local maxVert = 10\n\n    local x = maxHorz * strength * px:noise(time) * 2\n    local y = maxHorz * strength * py:noise(time) * 2\n    local z = maxVert * strength * pz:noise(time) * 2\n\n    camera.setFirstPersonOffset(util.vector3(x, y, z))\n    -- camera.setFocalPreferredOffset(util.vector2(x, y))\nend\n\nlocal function smoothstep(a, b, t)\n    local x = math.max(0, math.min(1, (t - a) / (b - a)))\n    return x * x * (3 - 2 * x)\nend\n\nlocal function lerp(a, b, t)\n    return a + t * (b - a)\nend\n\nlocal duration = 0.0\nlocal strength = 0.0\nlocal remaining = 0.0\n\nreturn {\n    eventHandlers = {\n        dm_k_qk_shake = function(args)\n            duration, strength = unpack(args)\n            -- ui.showMessage(string.format(\"duration: %.2f, strength: %.2f\", duration, strength))\n            remaining = duration\n        end\n    },\n    engineHandlers = {\n        onUpdate = function(dt)\n            if remaining <= 0 then\n                return\n            end\n\n            remaining = remaining - dt\n\n            -- Calculate shake strength as a function of the remaining time\n            local t = smoothstep(0, 1, math.abs(2 * remaining / duration - 1))\n            local s = lerp(strength, 0, t)\n\n            local time = core.getSimulationTime()\n            updateRotation(s, time)\n            updatePosition(s, time)\n        end,\n    }\n}\n"
  }
}