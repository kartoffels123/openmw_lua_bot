{
  "folder_name": "Animation Blending - OpenMW",
  "lua_files": {
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\lua_api\\openmw\\ambient.lua": "---\n-- `openmw.ambient` controls background sounds, specific to given player (2D-sounds).\n-- Can be used only by local scripts, that are attached to a player.\n-- @module ambient\n-- @usage local ambient = require('openmw.ambient')\n\n\n\n---\n-- Play a 2D sound\n-- @function [parent=#ambient] playSound\n-- @param #string soundId ID of Sound record to play\n-- @param #table options An optional table with additional optional arguments. Can contain:\n--\n--   * `timeOffset` - a floating point number >= 0, to some time (in second) from beginning of sound file (default: 0);\n--   * `volume` - a floating point number >= 0, to set a sound volume (default: 1);\n--   * `pitch` - a floating point number >= 0, to set a sound pitch (default: 1);\n--   * `scale` - a boolean, to set if sound pitch should be scaled by simulation time scaling (default: true);\n--   * `loop` - a boolean, to set if sound should be repeated when it ends (default: false);\n-- @usage local params = {\n--    timeOffset=0.1\n--    volume=0.3,\n--    scale=false,\n--    pitch=1.0,\n--    loop=true\n-- };\n-- ambient.playSound(\"shock bolt\", params)\n\n---\n-- Play a 2D sound file\n-- @function [parent=#ambient] playSoundFile\n-- @param #string fileName Path to sound file in VFS\n-- @param #table options An optional table with additional optional arguments. Can contain:\n--\n--   * `timeOffset` - a floating point number >= 0, to some time (in second) from beginning of sound file (default: 0);\n--   * `volume` - a floating point number >= 0, to set a sound volume (default: 1);\n--   * `pitch` - a floating point number >= 0, to set a sound pitch (default: 1);\n--   * `scale` - a boolean, to set if sound pitch should be scaled by simulation time scaling (default: true);\n--   * `loop` - a boolean, to set if sound should be repeated when it ends (default: false);\n-- @usage local params = {\n--    timeOffset=0.1\n--    volume=0.3,\n--    scale=false,\n--    pitch=1.0,\n--    loop=true\n-- };\n-- ambient.playSoundFile(\"Sound\\\\test.mp3\", params)\n\n---\n-- Stop a sound\n-- @function [parent=#ambient] stopSound\n-- @param #string soundId ID of Sound record to stop\n-- @usage ambient.stopSound(\"shock bolt\");\n\n---\n-- Stop a sound file\n-- @function [parent=#ambient] stopSoundFile\n-- @param #string fileName Path to sound file in VFS\n-- @usage ambient.stopSoundFile(\"Sound\\\\test.mp3\");\n\n---\n-- Check if sound is playing\n-- @function [parent=#ambient] isSoundPlaying\n-- @param #string soundId ID of Sound record to check\n-- @return #boolean\n-- @usage local isPlaying = ambient.isSoundPlaying(\"shock bolt\");\n\n---\n-- Check if sound file is playing\n-- @function [parent=#ambient] isSoundFilePlaying\n-- @param #string fileName Path to sound file in VFS\n-- @return #boolean\n-- @usage local isPlaying = ambient.isSoundFilePlaying(\"Sound\\\\test.mp3\");\n\n---\n-- Play a sound file as a music track\n-- @function [parent=#ambient] streamMusic\n-- @param #string fileName Path to file in VFS\n-- @usage ambient.streamMusic(\"Music\\\\Test\\\\Test.mp3\");\n\n---\n-- Stop to play current music\n-- @function [parent=#ambient] stopMusic\n-- @usage ambient.stopMusic();\n\n---\n-- Check if music is playing\n-- @function [parent=#ambient] isMusicPlaying\n-- @return #boolean\n-- @usage local isPlaying = ambient.isMusicPlaying();\n\nreturn nil\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\lua_api\\openmw\\async.lua": "---\n-- `openmw.async` contains timers and coroutine utils. All functions require\n-- the package itself as a first argument.\n-- @module async\n-- @usage local async = require('openmw.async')\n\n\n\n---\n-- Register a function as a timer callback.\n-- @function [parent=#async] registerTimerCallback\n-- @param self\n-- @param #string name\n-- @param #function func\n-- @return #TimerCallback\n\n---\n-- Calls callback(arg) in `delay` simulation seconds.\n-- Callback must be registered in advance.\n-- @function [parent=#async] newSimulationTimer\n-- @param self\n-- @param #number delay\n-- @param #TimerCallback callback A callback returned by `registerTimerCallback`\n-- @param arg An argument for `callback`; can be `nil`.\n\n---\n-- Calls callback(arg) in `delay` game seconds.\n-- Callback must be registered in advance.\n-- @function [parent=#async] newGameTimer\n-- @param self\n-- @param #number delay\n-- @param #TimerCallback callback A callback returned by `registerTimerCallback`\n-- @param arg An argument for `callback`; can be `nil`.\n\n---\n-- Calls `func()` in `delay` simulation seconds.\n-- The timer will be lost if the game is saved and loaded.\n-- @function [parent=#async] newUnsavableSimulationTimer\n-- @param self\n-- @param #number delay\n-- @param #function func\n\n---\n-- Calls `func()` in `delay` game seconds.\n-- The timer will be lost if the game is saved and loaded.\n-- @function [parent=#async] newUnsavableGameTimer\n-- @param self\n-- @param #number delay\n-- @param #function func\n\n---\n-- Wraps Lua function with `Callback` object that can be used in async API calls.\n-- @function [parent=#async] callback\n-- @param self\n-- @param #function func\n-- @return #Callback\n\nreturn nil\n\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\lua_api\\openmw\\core.lua": "---\n-- `openmw.core` defines functions and types that are available in both local\n-- and global scripts.\n-- @module core\n-- @usage local core = require('openmw.core')\n\n\n\n---\n-- The revision of OpenMW Lua API. It is an integer that is incremented every time the API is changed. See the actual value at the top of the page.\n-- @field [parent=#core] #number API_REVISION\n\n---\n-- A read-only list of all @{#FactionRecord}s in the world database.\n-- @field [parent=#core] #list<#FactionRecord> factions\n\n---\n-- Terminates the game and quits to the OS. Should be used only for testing purposes.\n-- @function [parent=#core] quit\n\n---\n-- Send an event to global scripts.\n-- @function [parent=#core] sendGlobalEvent\n-- @param #string eventName\n-- @param eventData\n\n---\n-- Simulation time in seconds.\n-- The number of simulation seconds passed in the game world since starting a new game.\n-- @function [parent=#core] getSimulationTime\n-- @return #number\n\n---\n-- The scale of simulation time relative to real time.\n-- @function [parent=#core] getSimulationTimeScale\n-- @return #number\n\n---\n-- Game time in seconds.\n-- @function [parent=#core] getGameTime\n-- @return #number\n\n---\n-- The scale of game time relative to simulation time.\n-- @function [parent=#core] getGameTimeScale\n-- @return #number\n\n---\n-- Whether the world is paused (onUpdate doesn't work when the world is paused).\n-- @function [parent=#core] isWorldPaused\n-- @return #boolean\n\n---\n-- Real time in seconds; starting point is not fixed (can be time since last reboot), use only for measuring intervals. For Unix time use `os.time()`.\n-- @function [parent=#core] getRealTime\n-- @return #number\n\n---\n-- Get a GMST setting from content files.\n-- @function [parent=#core] getGMST\n-- @param #string setting Setting name\n-- @return #any\n\n---\n-- Return l10n formatting function for the given context.\n-- Localisation files (containing the message names and translations) should be stored in\n-- VFS as files of the form `l10n/<ContextName>/<Locale>.yaml`.\n--\n-- See [Localisation](../modding/localisation.html) for details of the localisation file structure.\n--\n-- When calling the l10n formatting function, if no localisation can be found for any of the requested locales then\n-- the message key will be returned instead (and formatted, if possible).\n-- This makes it possible to use the source strings as message identifiers.\n--\n-- If you do not use the source string as a message identifier you should instead make certain to include\n-- a fallback locale with a complete set of messages.\n--\n-- @function [parent=#core] l10n\n-- @param #string context l10n context; recommended to use the name of the mod.\n--                This must match the <ContextName> directory in the VFS which stores the localisation files.\n-- @param #string fallbackLocale The source locale containing the default messages\n--                               If omitted defaults to \"en\".\n-- @return #function\n-- @usage\n-- # DataFiles/l10n/MyMod/en.yaml\n-- good_morning: 'Good morning.'\n-- you_have_arrows: |-\n--   {count, plural,\n--     one {You have one arrow.}\n--     other {You have {count} arrows.}\n--   }\n-- @usage\n-- # DataFiles/l10n/MyMod/de.yaml\n-- good_morning: \"Guten Morgen.\"\n-- you_have_arrows: |-\n--   {count, plural,\n--     one {Du hast ein Pfeil.}\n--     other {Du hast {count} Pfeile.}\n--   }\n-- \"Hello {name}!\": \"Hallo {name}!\"\n-- @usage\n-- -- Usage in Lua\n-- local myMsg = core.l10n('MyMod', 'en')\n-- print( myMsg('good_morning') )\n-- print( myMsg('you_have_arrows', {count=5}) )\n-- print( myMsg('Hello {name}!', {name='World'}) )\n\n\n---\n-- @{#ContentFiles}: functions working with the list of currently loaded content files.\n-- @field [parent=#core] #ContentFiles contentFiles\n\n---\n-- Functions working with the list of currently loaded content files.\n-- @type ContentFiles\n-- @field #list<#string> list The current load order (list of content file names).\n\n---\n-- Return the index of a specific content file in the load order (or `nil` if there is no such content file).\n-- @function [parent=#ContentFiles] indexOf\n-- @param #string contentFile\n-- @return #number\n\n---\n-- Check if the content file with given name present in the load order.\n-- @function [parent=#ContentFiles] has\n-- @param #string contentFile\n-- @return #boolean\n\n---\n-- Construct FormId string from content file name and the index in the file.\n-- In ESM3 games (e.g. Morrowind) FormIds are used to reference game objects.\n-- In ESM4 games (e.g. Skyrim) FormIds are used both for game objects and as record ids.\n-- @function [parent=#core] getFormId\n-- @param #string contentFile\n-- @param #number index\n-- @return #string\n-- @usage if obj.recordId == core.getFormId('Skyrim.esm', 0x4d7da) then ... end\n-- @usage -- In ESM3 content files (e.g. Morrowind) ids are human-readable strings\n-- obj.ownerFactionId = 'blades'\n-- -- In ESM4 (e.g. Skyrim) ids should be constructed using `core.getFormId`:\n-- obj.ownerFactionId = core.getFormId('Skyrim.esm', 0x72834)\n-- @usage -- local scripts\n-- local obj = nearby.getObjectByFormId(core.getFormId('Morrowind.esm', 128964))\n-- @usage -- global scripts\n-- local obj = world.getObjectByFormId(core.getFormId('Morrowind.esm', 128964))\n\n\n---\n-- Any object that exists in the game world and has a specific location.\n-- Player, actors, items, and statics are game objects.\n-- @type GameObject\n-- @extends #userdata\n-- @field #string id A unique id of this object (not record id), can be used as a key in a table.\n-- @field #string contentFile Lower cased file name of the content file that defines this object; nil for dynamically created objects.\n-- @field #boolean enabled Whether the object is enabled or disabled. Global scripts can set the value. Items in containers or inventories can't be disabled.\n-- @field openmw.util#Vector3 position Object position.\n-- @field #number scale Object scale.\n-- @field openmw.util#Transform rotation Object rotation.\n-- @field openmw.util#Vector3 startingPosition The object original position\n-- @field openmw.util#Transform startingRotation The object original rotation\n-- @field #string ownerRecordId NPC who owns the object (nil if missing). Global and self scripts can set the value.\n-- @field #string ownerFactionId Faction who owns the object (nil if missing). Global and self scripts can set the value.\n-- @field #number ownerFactionRank Rank required to be allowed to pick up the object (`nil` if any rank is allowed). Global and self scripts can set the value.\n-- @field #Cell cell The cell where the object currently is. During loading a game and for objects in an inventory or a container `cell` is nil.\n-- @field #GameObject parentContainer Container or actor that contains (or has in inventory) this object. It is nil if the object is in a cell.\n-- @field #any type Type of the object (one of the tables from the package @{openmw.types#types}).\n-- @field #number count Count (>1 means a stack of objects).\n-- @field #string recordId Returns record ID of the object in lowercase.\n-- @field #string globalVariable Global Variable associated with this object(read only).\n\n---\n-- Does the object still exist and is available.\n-- Returns true if the object exists and loaded, and false otherwise. If false, then every\n-- access to the object will raise an error.\n-- @function [parent=#GameObject] isValid\n-- @param self\n-- @return #boolean\n\n---\n-- Send local event to the object.\n-- @function [parent=#GameObject] sendEvent\n-- @param self\n-- @param #string eventName\n-- @param eventData\n\n---\n-- Activate the object.\n-- @function [parent=#GameObject] activateBy\n-- @param self\n-- @param #GameObject actor The actor who activates the object\n-- @usage local self = require('openmw.self')\n-- object:activateBy(self)\n\n---\n-- Add new local script to the object.\n-- Can be called only from a global script. Script should be specified in a content\n-- file (omwgame/omwaddon/omwscripts) with a CUSTOM flag. Scripts can not be attached to Statics.\n-- @function [parent=#GameObject] addScript\n-- @param self\n-- @param #string scriptPath Path to the script in OpenMW virtual filesystem.\n-- @param #table initData (optional) Initialization data to be passed to onInit. If missed then Lua initialization data from content files will be used (if exists for this script).\n\n---\n-- Whether a script with given path is attached to this object.\n-- Can be called only from a global script.\n-- @function [parent=#GameObject] hasScript\n-- @param self\n-- @param #string scriptPath Path to the script in OpenMW virtual filesystem.\n-- @return #boolean\n\n---\n-- Removes script that was attached by `addScript`\n-- Can be called only from a global script.\n-- @function [parent=#GameObject] removeScript\n-- @param self\n-- @param #string scriptPath Path to the script in OpenMW virtual filesystem.\n\n---\n-- Sets the object's scale.\n-- Can be called only from a global script.\n-- @function [parent=#GameObject] setScale\n-- @param self\n-- @param #number scale Scale desired in game.\n\n---\n-- Moves object to given cell and position.\n-- Can be called only from a global script.\n-- The effect is not immediate: the position will be updated only in the next\n-- frame. Can be called only from a global script. Enables object if it was disabled.\n-- Can be used to move objects from an inventory or a container to the world.\n-- @function [parent=#GameObject] teleport\n-- @param self\n-- @param #any cellOrName A cell to define the destination worldspace; can be either #Cell, or cell name, or an empty string (empty string means the default exterior worldspace).\n-- If the worldspace has multiple cells (i.e. an exterior), the destination cell is calculated using `position`.\n-- @param openmw.util#Vector3 position New position.\n-- @param #TeleportOptions options (optional) Either table @{#TeleportOptions} or @{openmw.util#Transform} rotation.\n\n---\n-- Either table with options or @{openmw.util#Vector3} rotation.\n-- @type TeleportOptions\n-- @field openmw.util#Transform rotation New rotation; if missing, then the current rotation is used.\n-- @field #boolean onGround If true, adjust destination position to the ground.\n\n---\n-- Moves object into a container or an inventory. Enables if was disabled.\n-- Can be called only from a global script.\n-- @function [parent=#GameObject] moveInto\n-- @param self\n-- @param #any dest @{#Inventory} or @{#GameObject}\n-- @usage item:moveInto(types.Actor.inventory(actor))\n-- @usage item:moveInto(types.Container.content(container))\n-- @usage item:moveInto(container)\n\n---\n-- Removes an object or reduces a stack of objects.\n-- Can be called only from a global script.\n-- @function [parent=#GameObject] remove\n-- @param self\n-- @param #number count (optional) the number of items to remove (if not specified then the whole stack)\n\n---\n-- Splits a stack of items. Original stack is reduced by `count`. Returns a new stack with `count` items.\n-- Can be called only from a global script.\n-- @function [parent=#GameObject] split\n-- @param self\n-- @param #number count The number of items to return.\n-- @return #GameObject\n-- @usage -- take 50 coins from `money` and put to the container `cont`\n-- money:split(50):moveInto(types.Container.content(cont))\n\n---\n-- The axis aligned bounding box in local coordinates.\n-- @function [parent=#GameObject] getBoundingBox\n-- @param self\n-- @return openmw.util#Box\n\n---\n-- List of GameObjects. Implements [iterables#List](iterables.html#List) of #GameObject\n-- @type ObjectList\n-- @list <#GameObject>\n\n\n---\n-- A cell of the game world.\n-- @type Cell\n-- @field #string name Name of the cell (can be empty string).\n-- @field #string region Region of the cell.\n-- @field #boolean isExterior Whether the cell is an exterior cell. \"Exterior\" means grid of cells where the player can seamless walk from one cell to another without teleports. QuasiExterior (interior with sky) is not an exterior.\n-- @field #boolean isQuasiExterior (DEPRECATED, use `hasTag(\"QuasiExterior\")`) Whether the cell is a quasi exterior (like interior but with the sky and the wheather).\n-- @field #number gridX Index of the cell by X (only for exteriors).\n-- @field #number gridY Index of the cell by Y (only for exteriors).\n-- @field #string worldSpaceId Id of the world space.\n-- @field #boolean hasWater True if the cell contains water.\n-- @field #boolean hasSky True if in this cell sky should be rendered.\n\n---\n-- Returns true if the cell has given tag.\n-- @function [parent=#Cell] hasTag\n-- @param self\n-- @param #string tag One of \"QuasiExterior\", \"NoSleep\".\n-- @return #boolean\n\n---\n-- Returns true either if the cell contains the object or if the cell is an exterior and the object is also in an exterior.\n-- @function [parent=#Cell] isInSameSpace\n-- @param self\n-- @param #GameObject object\n-- @return #boolean\n-- @usage\n-- if obj1.cell:isInSameSpace(obj2) then\n--     dist = (obj1.position - obj2.position):length()\n-- else\n--     -- the distance can't be calculated because the coordinates are in different spaces\n-- end\n\n---\n-- Get all objects of given type from the cell; Only available from global scripts.\n-- @function [parent=#Cell] getAll\n-- @param self\n-- @param type (optional) object type (see @{openmw.types#types})\n-- @return #ObjectList\n-- @usage\n-- local type = require('openmw.types')\n-- local all = cell:getAll()\n-- local weapons = cell:getAll(types.Weapon)\n\n---\n-- @type ActiveSpell\n-- @field #string name The spell or item display name\n-- @field #string id Record id of the spell or item used to cast the spell\n-- @field #GameObject item The enchanted item used to cast the spell, or nil if the spell was not cast from an enchanted item. Note that if the spell was cast for a single-use enchantment such as a scroll, this will be nil.\n-- @field #GameObject caster The caster object, or nil if the spell has no defined caster\n-- @field #list<#ActiveSpellEffect> effects The active effects (@{#ActiveSpellEffect}) of this spell.\n\n---\n-- @type ActiveSpellEffect\n-- @field #string affectedSkill Optional skill ID\n-- @field #string affectedAttribute Optional attribute ID\n-- @field #string id Magic effect id\n-- @field #string name Localized name of the effect\n-- @field #number magnitudeThisFrame The magnitude of the effect in the current frame. This will be a new random number between minMagnitude and maxMagnitude every frame. Or nil if the effect has no magnitude.\n-- @field #number minMagnitude The minimum magnitude of this effect, or nil if the effect has no magnitude.\n-- @field #number maxMagnitude The maximum magnitude of this effect, or nil if the effect has no magnitude.\n-- @field #number duration Total duration in seconds of this spell effect, should not be confused with remaining duration. Or nil if the effect is not temporary.\n-- @field #number durationLeft Remaining duration in seconds of this spell effect, or nil if the effect is not temporary.\n\n\n--- Possible @{#EnchantmentType} values\n-- @field [parent=#Magic] #EnchantmentType ENCHANTMENT_TYPE\n\n--- `core.magic.ENCHANTMENT_TYPE`\n-- @type EnchantmentType\n-- @field #number CastOnce Enchantment can be cast once, destroying the enchanted item.\n-- @field #number CastOnStrike Enchantment is cast on strike, if there is enough charge.\n-- @field #number CastOnUse Enchantment is cast when used, if there is enough charge.\n-- @field #number ConstantEffect Enchantment is always active when equipped.\n\n\n---\n-- @type Enchantment\n-- @field #string id Enchantment id\n-- @field #number type @{#EnchantmentType}\n-- @field #number autocalcFlag If set, the casting cost should be computer rather than reading the cost field\n-- @field #number cost\n-- @field #number charge Charge capacity. Should not be confused with current charge.\n-- @field #list<#MagicEffectWithParams> effects The effects (@{#MagicEffectWithParams}) of the enchantment\n-- @usage -- Getting the enchantment of an arbitrary item, if it has one\n-- local function getRecord(item)\n--     if item.type and item.type.record then\n--         return item.type.record(item)\n--     end\n--     return nil\n-- end\n-- local function getEnchantment(item)\n--     local record = getRecord(item)\n--     if record and record.enchant then\n--         return core.magic.enchantments[record.enchant]\n--     end\n--     return nil\n-- end\n\n\n---\n-- Inventory of a player/NPC or a content of a container.\n-- @type Inventory\n\n---\n-- The number of items with given recordId.\n-- @function [parent=#Inventory] countOf\n-- @param self\n-- @param #string recordId\n-- @return #number\n\n---\n-- Get all items of given type from the inventory.\n-- @function [parent=#Inventory] getAll\n-- @param self\n-- @param type (optional) items type (see @{openmw.types#types})\n-- @return #ObjectList\n-- @usage\n-- local types = require('openmw.types')\n-- local self = require('openmw.self')\n-- local playerInventory = types.Actor.inventory(self.object)\n-- local all = playerInventory:getAll()\n-- local weapons = playerInventory:getAll(types.Weapon)\n\n---\n-- Get first item with given recordId from the inventory. Returns nil if not found.\n-- @function [parent=#Inventory] find\n-- @param self\n-- @param #string recordId\n-- @return #GameObject\n-- @usage inventory:find('gold_001')\n\n---\n-- Will resolve the inventory, filling it with levelled items if applicable, making its contents permanent. Must be used in a global script.\n-- @function [parent=#Inventory] resolve\n-- @param self\n-- @usage inventory:resolve()\n\n---\n-- Checks if the inventory has a resolved item list.\n-- @function [parent=#Inventory] isResolved\n-- @param self\n-- @return #boolean\n-- @usage inventory:isResolved()\n\n---\n-- Get all items with given recordId from the inventory.\n-- @function [parent=#Inventory] findAll\n-- @param self\n-- @param #string recordId\n-- @return #ObjectList\n-- @usage for _, item in ipairs(inventory:findAll('common_shirt_01')) do ... end\n\n\n--- @{#Magic}: spells and spell effects\n-- @field [parent=#core] #Magic magic\n\n\n--- Possible @{#SpellRange} values\n-- @field [parent=#Magic] #SpellRange RANGE\n\n--- `core.magic.RANGE`\n-- @type SpellRange\n-- @field #number Self Applied on self\n-- @field #number Touch On touch\n-- @field #number Target Ranged spell\n\n\n--- Possible @{#MagicEffectId} values\n-- @field [parent=#Magic] #MagicEffectId EFFECT_TYPE\n\n--- `core.magic.EFFECT_TYPE`\n-- @type MagicEffectId\n-- @field #number WaterBreathing \"waterbreathing\"\n-- @field #number SwiftSwim \"swiftswim\"\n-- @field #number WaterWalking \"waterwalking\"\n-- @field #number Shield \"shield\"\n-- @field #number FireShield \"fireshield\"\n-- @field #number LightningShield \"lightningshield\"\n-- @field #number FrostShield \"frostshield\"\n-- @field #number Burden \"burden\"\n-- @field #number Feather \"feather\"\n-- @field #number Jump \"jump\"\n-- @field #number Levitate \"levitate\"\n-- @field #number SlowFall \"slowfall\"\n-- @field #number Lock \"lock\"\n-- @field #number Open \"open\"\n-- @field #number FireDamage \"firedamage\"\n-- @field #number ShockDamage \"shockdamage\"\n-- @field #number FrostDamage \"frostdamage\"\n-- @field #number DrainAttribute \"drainattribute\"\n-- @field #number DrainHealth \"drainhealth\"\n-- @field #number DrainMagicka \"drainmagicka\"\n-- @field #number DrainFatigue \"drainfatigue\"\n-- @field #number DrainSkill \"drainskill\"\n-- @field #number DamageAttribute \"damageattribute\"\n-- @field #number DamageHealth \"damagehealth\"\n-- @field #number DamageMagicka \"damagemagicka\"\n-- @field #number DamageFatigue \"damagefatigue\"\n-- @field #number DamageSkill \"damageskill\"\n-- @field #number Poison \"poison\"\n-- @field #number WeaknessToFire \"weaknesstofire\"\n-- @field #number WeaknessToFrost \"weaknesstofrost\"\n-- @field #number WeaknessToShock \"weaknesstoshock\"\n-- @field #number WeaknessToMagicka \"weaknesstomagicka\"\n-- @field #number WeaknessToCommonDisease \"weaknesstocommondisease\"\n-- @field #number WeaknessToBlightDisease \"weaknesstoblightdisease\"\n-- @field #number WeaknessToCorprusDisease \"weaknesstocorprusdisease\"\n-- @field #number WeaknessToPoison \"weaknesstopoison\"\n-- @field #number WeaknessToNormalWeapons \"weaknesstonormalweapons\"\n-- @field #number DisintegrateWeapon \"disintegrateweapon\"\n-- @field #number DisintegrateArmor \"disintegratearmor\"\n-- @field #number Invisibility \"invisibility\"\n-- @field #number Chameleon \"chameleon\"\n-- @field #number Light \"light\"\n-- @field #number Sanctuary \"sanctuary\"\n-- @field #number NightEye \"nighteye\"\n-- @field #number Charm \"charm\"\n-- @field #number Paralyze \"paralyze\"\n-- @field #number Silence \"silence\"\n-- @field #number Blind \"blind\"\n-- @field #number Sound \"sound\"\n-- @field #number CalmHumanoid \"calmhumanoid\"\n-- @field #number CalmCreature \"calmcreature\"\n-- @field #number FrenzyHumanoid \"frenzyhumanoid\"\n-- @field #number FrenzyCreature \"frenzycreature\"\n-- @field #number DemoralizeHumanoid \"demoralizehumanoid\"\n-- @field #number DemoralizeCreature \"demoralizecreature\"\n-- @field #number RallyHumanoid \"rallyhumanoid\"\n-- @field #number RallyCreature \"rallycreature\"\n-- @field #number Dispel \"dispel\"\n-- @field #number Soultrap \"soultrap\"\n-- @field #number Telekinesis \"telekinesis\"\n-- @field #number Mark \"mark\"\n-- @field #number Recall \"recall\"\n-- @field #number DivineIntervention \"divineintervention\"\n-- @field #number AlmsiviIntervention \"almsiviintervention\"\n-- @field #number DetectAnimal \"detectanimal\"\n-- @field #number DetectEnchantment \"detectenchantment\"\n-- @field #number DetectKey \"detectkey\"\n-- @field #number SpellAbsorption \"spellabsorption\"\n-- @field #number Reflect \"reflect\"\n-- @field #number CureCommonDisease \"curecommondisease\"\n-- @field #number CureBlightDisease \"cureblightdisease\"\n-- @field #number CureCorprusDisease \"curecorprusdisease\"\n-- @field #number CurePoison \"curepoison\"\n-- @field #number CureParalyzation \"cureparalyzation\"\n-- @field #number RestoreAttribute \"restoreattribute\"\n-- @field #number RestoreHealth \"restorehealth\"\n-- @field #number RestoreMagicka \"restoremagicka\"\n-- @field #number RestoreFatigue \"restorefatigue\"\n-- @field #number RestoreSkill \"restoreskill\"\n-- @field #number FortifyAttribute \"fortifyattribute\"\n-- @field #number FortifyHealth \"fortifyhealth\"\n-- @field #number FortifyMagicka \"fortifymagicka\"\n-- @field #number FortifyFatigue \"fortifyfatigue\"\n-- @field #number FortifySkill \"fortifyskill\"\n-- @field #number FortifyMaximumMagicka \"fortifymaximummagicka\"\n-- @field #number AbsorbAttribute \"absorbattribute\"\n-- @field #number AbsorbHealth \"absorbhealth\"\n-- @field #number AbsorbMagicka \"absorbmagicka\"\n-- @field #number AbsorbFatigue \"absorbfatigue\"\n-- @field #number AbsorbSkill \"absorbskill\"\n-- @field #number ResistFire \"resistfire\"\n-- @field #number ResistFrost \"resistfrost\"\n-- @field #number ResistShock \"resistshock\"\n-- @field #number ResistMagicka \"resistmagicka\"\n-- @field #number ResistCommonDisease \"resistcommondisease\"\n-- @field #number ResistBlightDisease \"resistblightdisease\"\n-- @field #number ResistCorprusDisease \"resistcorprusdisease\"\n-- @field #number ResistPoison \"resistpoison\"\n-- @field #number ResistNormalWeapons \"resistnormalweapons\"\n-- @field #number ResistParalysis \"resistparalysis\"\n-- @field #number RemoveCurse \"removecurse\"\n-- @field #number TurnUndead \"turnundead\"\n-- @field #number SummonScamp \"summonscamp\"\n-- @field #number SummonClannfear \"summonclannfear\"\n-- @field #number SummonDaedroth \"summondaedroth\"\n-- @field #number SummonDremora \"summondremora\"\n-- @field #number SummonAncestralGhost \"summonancestralghost\"\n-- @field #number SummonSkeletalMinion \"summonskeletalminion\"\n-- @field #number SummonBonewalker \"summonbonewalker\"\n-- @field #number SummonGreaterBonewalker \"summongreaterbonewalker\"\n-- @field #number SummonBonelord \"summonbonelord\"\n-- @field #number SummonWingedTwilight \"summonwingedtwilight\"\n-- @field #number SummonHunger \"summonhunger\"\n-- @field #number SummonGoldenSaint \"summongoldensaint\"\n-- @field #number SummonFlameAtronach \"summonflameatronach\"\n-- @field #number SummonFrostAtronach \"summonfrostatronach\"\n-- @field #number SummonStormAtronach \"summonstormatronach\"\n-- @field #number FortifyAttack \"fortifyattack\"\n-- @field #number CommandCreature \"commandcreature\"\n-- @field #number CommandHumanoid \"commandhumanoid\"\n-- @field #number BoundDagger \"bounddagger\"\n-- @field #number BoundLongsword \"boundlongsword\"\n-- @field #number BoundMace \"boundmace\"\n-- @field #number BoundBattleAxe \"boundbattleaxe\"\n-- @field #number BoundSpear \"boundspear\"\n-- @field #number BoundLongbow \"boundlongbow\"\n-- @field #number ExtraSpell \"extraspell\"\n-- @field #number BoundCuirass \"boundcuirass\"\n-- @field #number BoundHelm \"boundhelm\"\n-- @field #number BoundBoots \"boundboots\"\n-- @field #number BoundShield \"boundshield\"\n-- @field #number BoundGloves \"boundgloves\"\n-- @field #number Corprus \"corprus\"\n-- @field #number Vampirism \"vampirism\"\n-- @field #number SummonCenturionSphere \"summoncenturionsphere\"\n-- @field #number SunDamage \"sundamage\"\n-- @field #number StuntedMagicka \"stuntedmagicka\"\n-- @field #number SummonFabricant \"summonfabricant\"\n-- @field #number SummonWolf \"summonwolf\"\n-- @field #number SummonBear \"summonbear\"\n-- @field #number SummonBonewolf \"summonbonewolf\"\n-- @field #number SummonCreature04 \"summoncreature04\"\n-- @field #number SummonCreature05 \"summoncreature05\"\n\n--- Possible @{#SpellType} values\n-- @field [parent=#Magic] #SpellType SPELL_TYPE\n\n--- `core.magic.SPELL_TYPE`\n-- @type SpellType\n-- @field #number Spell Normal spell, must be cast and costs mana\n-- @field #number Ability Innate ability, always in effect\n-- @field #number Blight Blight disease\n-- @field #number Disease Common disease\n-- @field #number Curse Curse\n-- @field #number Power Power, can be used once a day\n\n\n--- List of all @{#Spell}s.\n-- @field [parent=#Magic] #list<#Spell> spells\n-- @usage local spell = core.magic.spells['thunder fist']  -- get by id\n-- @usage local spell = core.magic.spells[1]  -- get by index\n-- @usage -- Print all powers\n-- for _, spell in pairs(core.magic.spells) do\n--     if spell.types == core.magic.SPELL_TYPE.Power then\n--         print(spell.name)\n--     end\n-- end\n\n--- Map from @{#MagicEffectId} to @{#MagicEffect}\n-- @field [parent=#Magic] #map<#number, #MagicEffect> effects\n-- @usage -- Print all harmful effects\n-- for _, effect in pairs(core.magic.effects) do\n--     if effect.harmful then\n--         print(effect.name)\n--     end\n-- end\n-- @usage -- Look up the record of a specific effect and print its icon\n-- local mgef = core.magic.effects[core.magic.EFFECT_TYPE.Reflect]\n-- print('Reflect Icon: '..tostring(mgef.icon))\n\n--- List of all @{#Enchantment}s.\n-- @field [parent=#Magic] #list<#Enchantment> enchantments\n-- @usage local enchantment = core.magic.enchantments['marara's boon']  -- get by id\n-- @usage local enchantment = core.magic.enchantments[1]  -- get by index\n-- @usage -- Print all enchantments with constant effect\n-- for _, ench in pairs(core.magic.enchantments) do\n--     if ench.type == core.magic.ENCHANTMENT_TYPE.ConstantEffect then\n--         print(ench.id)\n--     end\n-- end\n\n---\n-- @type Spell\n-- @field #string id Spell id\n-- @field #string name Spell name\n-- @field #number type @{#SpellType}\n-- @field #number cost\n-- @field #list<#MagicEffectWithParams> effects The effects (@{#MagicEffectWithParams}) of the spell\n\n---\n-- @type MagicEffect\n-- @field #string id Effect ID\n-- @field #string icon Effect Icon Path\n-- @field #string name Localized name of the effect\n-- @field #string school Skill ID that is this effect's school\n-- @field #number baseCost\n-- @field openmw.util#Color color\n-- @field #boolean harmful\n\n---\n-- @type MagicEffectWithParams\n-- @field #MagicEffect effect @{#MagicEffect}\n-- @field #string affectedSkill Optional skill ID\n-- @field #string affectedAttribute Optional attribute ID\n-- @field #number range\n-- @field #number area\n-- @field #number magnitudeMin\n-- @field #number magnitudeMax\n-- @field #number duration\n\n---\n-- @type ActiveEffect\n-- Magic effect that is currently active on an actor.\n-- Note that when this effect expires or is removed, it will remain temporarily. Magnitude will be set to 0 for effects that expire.\n-- @field #string affectedSkill Optional skill ID\n-- @field #string affectedAttribute Optional attribute ID\n-- @field #string id Effect id string\n-- @field #string name Localized name of the effect\n-- @field #number magnitude current magnitude of the effect. Will be set to 0 when effect is removed or expires.\n-- @field #number magnitudeBase\n-- @field #number magnitudeModifier\n\n--- @{#Sound}: Sounds and Speech\n-- @field [parent=#core] #Sound sound\n\n---\n-- Checks if sound system is enabled (any functions to play sounds are no-ops when it is disabled).\n-- It can not be enabled or disabled during runtime.\n-- @function [parent=#Sound] isEnabled\n-- @return #boolean\n-- @usage local enabled = core.sound.isEnabled();\n\n---\n-- Play a 3D sound, attached to object\n-- @function [parent=#Sound] playSound3d\n-- @param #string soundId ID of Sound record to play\n-- @param #GameObject object Object to which we attach the sound\n-- @param #table options An optional table with additional optional arguments. Can contain:\n--\n--   * `timeOffset` - a floating point number >= 0, to some time (in second) from beginning of sound file (default: 0);\n--   * `volume` - a floating point number >= 0, to set a sound volume (default: 1);\n--   * `pitch` - a floating point number >= 0, to set a sound pitch (default: 1);\n--   * `loop` - a boolean, to set if sound should be repeated when it ends (default: false);\n-- @usage local params = {\n--    timeOffset=0.1\n--    volume=0.3,\n--    loop=false,\n--    pitch=1.0\n-- };\n-- core.sound.playSound3d(\"shock bolt\", object, params)\n\n---\n-- Play a 3D sound file, attached to object\n-- @function [parent=#Sound] playSoundFile3d\n-- @param #string fileName Path to sound file in VFS\n-- @param #GameObject object Object to which we attach the sound\n-- @param #table options An optional table with additional optional arguments. Can contain:\n--\n--   * `timeOffset` - a floating point number >= 0, to some time (in second) from beginning of sound file (default: 0);\n--   * `volume` - a floating point number >= 0, to set a sound volume (default: 1);\n--   * `pitch` - a floating point number >= 0, to set a sound pitch (default: 1);\n--   * `loop` - a boolean, to set if sound should be repeated when it ends (default: false);\n-- @usage local params = {\n--    timeOffset=0.1\n--    volume=0.3,\n--    loop=false,\n--    pitch=1.0\n-- };\n-- core.sound.playSoundFile3d(\"Sound\\\\test.mp3\", object, params)\n\n---\n-- Stop a 3D sound, attached to object\n-- @function [parent=#Sound] stopSound3d\n-- @param #string soundId ID of Sound record to stop\n-- @param #GameObject object Object on which we want to stop sound\n-- @usage core.sound.stopSound(\"shock bolt\", object);\n\n---\n-- Stop a 3D sound file, attached to object\n-- @function [parent=#Sound] stopSoundFile3d\n-- @param #string fileName Path to sound file in VFS\n-- @param #GameObject object Object on which we want to stop sound\n-- @usage core.sound.stopSoundFile(\"Sound\\\\test.mp3\", object);\n\n---\n-- Check if sound is playing on given object\n-- @function [parent=#Sound] isSoundPlaying\n-- @param #string soundId ID of Sound record to check\n-- @param #GameObject object Object on which we want to check sound\n-- @return #boolean\n-- @usage local isPlaying = core.sound.isSoundPlaying(\"shock bolt\", object);\n\n---\n-- Check if sound file is playing on given object\n-- @function [parent=#Sound] isSoundFilePlaying\n-- @param #string fileName Path to sound file in VFS\n-- @param #GameObject object Object on which we want to check sound\n-- @return #boolean\n-- @usage local isPlaying = core.sound.isSoundFilePlaying(\"Sound\\\\test.mp3\", object);\n\n---\n-- Play an animated voiceover. Has two overloads:\n--\n--   * With an \"object\" argument: play sound for given object, with speaking animation if possible\n--   * Without an \"object\" argument: play sound globally, without object\n-- @function [parent=#Sound] say\n-- @param #string fileName Path to sound file in VFS\n-- @param #GameObject object Object on which we want to play an animated voiceover (optional)\n-- @param #string text Subtitle text (optional)\n-- @usage -- play voiceover for object and print messagebox\n-- core.sound.say(\"Sound\\\\Vo\\\\Misc\\\\voice.mp3\", object, \"Subtitle text\")\n-- @usage -- play voiceover globally and print messagebox\n-- core.sound.say(\"Sound\\\\Vo\\\\Misc\\\\voice.mp3\", \"Subtitle text\")\n-- @usage -- play voiceover for object without messagebox\n-- core.sound.say(\"Sound\\\\Vo\\\\Misc\\\\voice.mp3\", object)\n-- @usage -- play voiceover globally without messagebox\n-- core.sound.say(\"Sound\\\\Vo\\\\Misc\\\\voice.mp3\")\n\n---\n-- Stop animated voiceover\n-- @function [parent=#Sound] stopSay\n-- @param #string fileName Path to sound file in VFS\n-- @param #GameObject object Object on which we want to stop an animated voiceover (optional)\n-- @usage -- stop voice for given object\n-- core.sound.stopSay(object);\n-- @usage -- stop global voice\n-- core.sound.stopSay();\n\n---\n-- Check if animated voiceover is playing\n-- @function [parent=#Sound] isSayActive\n-- @param #GameObject object Object on which we want to check an animated voiceover (optional)\n-- @return #boolean\n-- @usage -- check voice for given object\n-- local isActive = isSayActive(object);\n-- @usage -- check global voice\n-- local isActive = isSayActive();\n\n---\n-- @type SoundRecord\n-- @field #string id Sound id\n-- @field #string fileName Normalized path to sound file in VFS\n-- @field #number volume Raw sound volume, from 0 to 255\n-- @field #number minRange Raw minimal range value, from 0 to 255\n-- @field #number maxRange Raw maximal range value, from 0 to 255\n\n--- List of all @{#SoundRecord}s.\n-- @field [parent=#Sound] #list<#SoundRecord> sounds\n-- @usage local sound = core.sound.sounds['Ashstorm']  -- get by id\n-- @usage local sound = core.sound.sounds[1]  -- get by index\n-- @usage -- Print all sound files paths\n-- for _, sound in pairs(core.sound.sounds) do\n--     print(sound.fileName)\n-- end\n\n--- @{#Stats}: stats\n-- @field [parent=#core] #Stats stats\n\n\n--- @{#Attribute} functions\n-- @field [parent=#Stats] #Attribute Attribute\n\n--- `core.stats.Attribute`\n-- @type Attribute\n-- @field #list<#AttributeRecord> records A read-only list of all @{#AttributeRecord}s in the world database.\n\n---\n-- Returns a read-only @{#AttributeRecord}\n-- @function [parent=#Attribute] record\n-- @param #string recordId\n-- @return #AttributeRecord\n\n--- @{#Skill} functions\n-- @field [parent=#Stats] #Skill Skill\n\n--- `core.stats.Skill`\n-- @type Skill\n-- @field #list<#SkillRecord> records A read-only list of all @{#SkillRecord}s in the world database.\n\n---\n-- Returns a read-only @{#SkillRecord}\n-- @function [parent=#Skill] record\n-- @param #string recordId\n-- @return #SkillRecord\n\n---\n-- @type AttributeRecord\n-- @field #string id Record id\n-- @field #string name Human-readable name\n-- @field #string description Human-readable description\n-- @field #string icon VFS path to the icon\n\n---\n-- @type SkillRecord\n-- @field #string id Record id\n-- @field #string name Human-readable name\n-- @field #string description Human-readable description\n-- @field #string icon VFS path to the icon\n-- @field #string specialization Skill specialization. Either combat, magic, or stealth.\n-- @field #MagicSchoolData school Optional magic school\n-- @field #string attribute The id of the skill's governing attribute\n\n-- @type MagicSchoolData\n-- @field #string name Human-readable name\n-- @field #string areaSound VFS path to the area sound\n-- @field #string boltSound VFS path to the bolt sound\n-- @field #string castSound VFS path to the cast sound\n-- @field #string failureSound VFS path to the failure sound\n-- @field #string hitSound VFS path to the hit sound\n\n---\n-- Faction data record\n-- @type FactionRecord\n-- @field #string id Faction id\n-- @field #string name Faction name\n-- @field #list<#FactionRank> ranks A read-only list containing data for all ranks in the faction, in order.\n-- @field #map<#string, #number> reactions A read-only map containing reactions of other factions to this faction.\n-- @field #list<#string> attributes A read-only list containing IDs of attributes to advance ranks in the faction.\n-- @field #list<#string> skills A read-only list containing IDs of skills to advance ranks in the faction.\n\n---\n-- Faction rank data record\n-- @type FactionRank\n-- @field #string name Faction name Rank display name\n-- @field #list<#number> attributeValues Attributes values required to get this rank.\n-- @field #number primarySkillValue Primary skill value required to get this rank.\n-- @field #number favouredSkillValue Secondary skill value required to get this rank.\n-- @field #number factionReaction Reaction of faction members if player is in this faction.\n\nreturn nil\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\lua_api\\openmw\\debug.lua": "---\n-- `openmw.debug` is an interface to the engine debug utils.\n-- Can be used only by local scripts, that are attached to a player.\n-- @module Debug\n-- @usage local debug = require('openmw.debug')\n\n\n---\n-- Rendering modes\n-- @type RENDER_MODE\n-- @field [parent=#RENDER_MODE] #number CollisionDebug\n-- @field [parent=#RENDER_MODE] #number Wireframe\n-- @field [parent=#RENDER_MODE] #number Pathgrid\n-- @field [parent=#RENDER_MODE] #number Water\n-- @field [parent=#RENDER_MODE] #number Scene\n-- @field [parent=#RENDER_MODE] #number NavMesh\n-- @field [parent=#RENDER_MODE] #number ActorsPaths\n-- @field [parent=#RENDER_MODE] #number RecastMesh\n\n---\n-- Rendering mode values\n-- @field [parent=#Debug] #RENDER_MODE RENDER_MODE\n\n---\n-- Toggles rendering mode\n-- @function [parent=#Debug] toggleRenderMode\n-- @param #RENDER_MODE value\n\n---\n-- Toggles god mode\n-- @function [parent=#Debug] toggleGodMode\n\n---\n-- Is god mode enabled\n-- @function [parent=#Debug] isGodMode\n-- @return #boolean\n\n---\n-- Toggles AI\n-- @function [parent=#Debug] toggleAI\n\n---\n-- Is AI enabled\n-- @function [parent=#Debug] isAIEnabled\n-- @return #boolean\n\n---\n-- Toggles collisions\n-- @function [parent=#Debug] toggleCollision\n\n---\n-- Is player collision enabled\n-- @function [parent=#Debug] isCollisionEnabled\n-- @return #boolean\n\n---\n-- Toggles MWScripts\n-- @function [parent=#Debug] toggleMWScript\n\n---\n-- Is MWScripts enabled\n-- @function [parent=#Debug] isMWScriptEnabled\n-- @return #boolean\n\n---\n-- Reloads all Lua scripts\n-- @function [parent=#Debug] reloadLua\n\n---\n-- Navigation mesh rendering modes\n-- @type NAV_MESH_RENDER_MODE\n-- @field [parent=#NAV_MESH_RENDER_MODE] #number AreaType\n-- @field [parent=#NAV_MESH_RENDER_MODE] #number UpdateFrequency\n\n---\n-- Navigation mesh rendering mode values\n-- @field [parent=#Debug] #NAV_MESH_RENDER_MODE NAV_MESH_RENDER_MODE\n\n---\n-- Sets navigation mesh rendering mode\n-- @function [parent=#Debug] setNavMeshRenderMode\n-- @param #NAV_MESH_RENDER_MODE value\n\n---\n-- Enable/disable automatic reload of modified shaders\n-- @function [parent=#Debug] setShaderHotReloadEnabled\n-- @param #bool value\n\n---\n-- To reload modified shaders\n-- @function [parent=#Debug] triggerShaderReload\nreturn nil\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\lua_api\\openmw\\nearby.lua": "---\n-- `openmw.nearby` provides read-only access to the nearest area of the game world.\n-- Can be used only from local scripts.\n-- @module nearby\n-- @usage local nearby = require('openmw.nearby')\n\n\n\n---\n-- List of nearby activators.\n-- @field [parent=#nearby] openmw.core#ObjectList activators\n\n---\n-- List of nearby actors.\n-- @field [parent=#nearby] openmw.core#ObjectList actors\n\n---\n-- List of nearby containers.\n-- @field [parent=#nearby] openmw.core#ObjectList containers\n\n---\n-- List of nearby doors.\n-- @field [parent=#nearby] openmw.core#ObjectList doors\n\n---\n-- Everything nearby that is derived from @{openmw.types#Item}.\n-- @field [parent=#nearby] openmw.core#ObjectList items\n\n---\n-- List of nearby players. Currently (since multiplayer is not yet implemented) always has one element.\n-- @field [parent=#nearby] openmw.core#ObjectList players\n\n---\n-- Return an object by RefNum/FormId.\n-- Note: the function always returns @{openmw.core#GameObject} and doesn't validate that\n-- the object exists in the game world. If it doesn't exist or not yet loaded to memory),\n-- then `obj:isValid()` will be `false`.\n-- @function [parent=#nearby] getObjectByFormId\n-- @param #string formId String returned by `core.getFormId`\n-- @return openmw.core#GameObject\n-- @usage local obj = nearby.getObjectByFormId(core.getFormId('Morrowind.esm', 128964))\n\n---\n-- @type COLLISION_TYPE\n-- @field [parent=#COLLISION_TYPE] #number World\n-- @field [parent=#COLLISION_TYPE] #number Door\n-- @field [parent=#COLLISION_TYPE] #number Actor\n-- @field [parent=#COLLISION_TYPE] #number HeightMap\n-- @field [parent=#COLLISION_TYPE] #number Projectile\n-- @field [parent=#COLLISION_TYPE] #number Water\n-- @field [parent=#COLLISION_TYPE] #number Default Used by default: World+Door+Actor+HeightMap\n-- @field [parent=#COLLISION_TYPE] #number AnyPhysical World+Door+Actor+HeightMap+Projectile+Water\n-- @field [parent=#COLLISION_TYPE] #number Camera Objects that should collide only with camera\n-- @field [parent=#COLLISION_TYPE] #number VisualOnly Objects that were not intended to be part of the physics world\n\n---\n-- Collision types that are used in `castRay`.\n-- Several types can be combined with @{openmw_util#util.bitOr}.\n-- @field [parent=#nearby] #COLLISION_TYPE COLLISION_TYPE\n\n---\n-- Result of raycasing\n-- @type RayCastingResult\n-- @field [parent=#RayCastingResult] #boolean hit Is there a collision? (true/false)\n-- @field [parent=#RayCastingResult] openmw.util#Vector3 hitPos Position of the collision point (nil if no collision)\n-- @field [parent=#RayCastingResult] openmw.util#Vector3 hitNormal Normal to the surface in the collision point (nil if no collision)\n-- @field [parent=#RayCastingResult] openmw.core#GameObject hitObject The object the ray has collided with (can be nil)\n\n---\n-- A table of parameters for @{#nearby.castRay}\n-- @type CastRayOptions\n-- @field openmw.core#GameObject ignore An object to ignore (specify here the source of the ray)\n-- @field #number collisionType Object types to work with (see @{openmw.nearby#COLLISION_TYPE})\n-- @field #number radius The radius of the ray (zero by default). If not zero then castRay actually casts a sphere with given radius.\n--  NOTE: currently `ignore` is not supported if `radius>0`.\n\n---\n-- Cast ray from one point to another and return the first collision.\n-- @function [parent=#nearby] castRay\n-- @param openmw.util#Vector3 from Start point of the ray.\n-- @param openmw.util#Vector3 to End point of the ray.\n-- @param #CastRayOptions options An optional table with additional optional arguments\n-- @return #RayCastingResult\n-- @usage if nearby.castRay(pointA, pointB).hit then print('obstacle between A and B') end\n-- @usage local res = nearby.castRay(self.position, enemy.position, {ignore=self})\n-- if res.hitObject and res.hitObject ~= enemy then obstacle = res.hitObject end\n-- @usage local res = nearby.castRay(self.position, targetPos, {\n--     collisionType=nearby.COLLISION_TYPE.HeightMap + nearby.COLLISION_TYPE.Water,\n--     radius = 10,\n-- })\n\n---\n-- Cast ray from one point to another and find the first visual intersection with anything in the scene.\n-- As opposite to `castRay` can find an intersection with an object without collisions.\n-- In order to avoid threading issues can be used only in player scripts only in `onFrame` or\n-- in engine handlers for user input. In other cases use `asyncCastRenderingRay` instead.\n-- @function [parent=#nearby] castRenderingRay\n-- @param openmw.util#Vector3 from Start point of the ray.\n-- @param openmw.util#Vector3 to End point of the ray.\n-- @return #RayCastingResult\n\n---\n-- Asynchronously cast ray from one point to another and find the first visual intersection with anything in the scene.\n-- @function [parent=#nearby] asyncCastRenderingRay\n-- @param openmw.async#Callback callback The callback to pass the result to (should accept a single argument @{openmw.nearby#RayCastingResult}).\n-- @param openmw.util#Vector3 from Start point of the ray.\n-- @param openmw.util#Vector3 to End point of the ray.\n\n---\n-- @type NAVIGATOR_FLAGS\n-- @field [parent=#NAVIGATOR_FLAGS] #number Walk Allow agent to walk on the ground area.\n-- @field [parent=#NAVIGATOR_FLAGS] #number Swim Allow agent to swim on the water surface.\n-- @field [parent=#NAVIGATOR_FLAGS] #number OpenDoor Allow agent to open doors on the way.\n-- @field [parent=#NAVIGATOR_FLAGS] #number UsePathgrid Allow agent to use predefined pathgrid imported from ESM files.\n\n---\n-- @type COLLISION_SHAPE_TYPE\n-- @field [parent=#COLLISION_SHAPE_TYPE] #number Aabb Axis-Aligned Bounding Box is used for NPC and symmetric\n-- Creatures.\n-- @field [parent=#COLLISION_SHAPE_TYPE] #number RotatingBox is used for Creatures with big difference in width and\n-- height.\n-- @field [parent=#COLLISION_SHAPE_TYPE] #number Cylinder is used for NPC and symmetric Creatures.\n\n---\n-- @type FIND_PATH_STATUS\n-- @field [parent=#FIND_PATH_STATUS] #number Success Path is found.\n-- @field [parent=#FIND_PATH_STATUS] #number PartialPath Last path point is not a destination but a nearest position\n-- among found;\n-- @field [parent=#FIND_PATH_STATUS] #number NavMeshNotFound Provided `agentBounds` don't have corresponding navigation\n-- mesh. For interior cells it means an agent with such `agentBounds` is present on the scene. For exterior cells only\n-- default `agentBounds` is supported;\n-- @field [parent=#FIND_PATH_STATUS] #number StartPolygonNotFound `source` position is too far from available\n-- navigation mesh. The status may appear when navigation mesh is not fully generated or position is outside of covered\n-- area;\n-- @field [parent=#FIND_PATH_STATUS] #number EndPolygonNotFound `destination` position is too far from available\n-- navigation mesh. The status may appear when navigation mesh is not fully generated or position is outside of covered\n-- area;\n-- @field [parent=#FIND_PATH_STATUS] #number TargetPolygonNotFound adjusted `destination` position is too far from\n-- available navigation mesh. The status may appear when navigation mesh is not fully generated or position is outside\n-- of covered area;\n-- @field [parent=#FIND_PATH_STATUS] #number MoveAlongSurfaceFailed Found path couldn't be smoothed due to imperfect\n-- algorithm implementation or bad navigation mesh data;\n-- @field [parent=#FIND_PATH_STATUS] #number FindPathOverPolygonsFailed Path over navigation mesh from `source` to\n-- `destination` does not exist or navigation mesh is not fully generated to provide the path;\n-- @field [parent=#FIND_PATH_STATUS] #number InitNavMeshQueryFailed Couldn't initialize required data due to bad input\n-- or bad navigation mesh data.\n-- @field [parent=#FIND_PATH_STATUS] #number FindStraightPathFailed Couldn't map path over polygons into world\n-- coordinates.\n\n---\n-- A table of parameters identifying navmesh\n-- @type AgentBounds\n-- @field [parent=#AgentBounds] #COLLISION_SHAPE_TYPE shapeType.\n-- @field [parent=#AgentBounds] openmw.util#Vector3 halfExtents.\n\n---\n-- A table of parameters to specify relative path cost per each area type\n-- @type AreaCosts\n-- @field [parent=#AreaCosts] #number ground Value >= 0, used in combination with @{#NAVIGATOR_FLAGS.Walk} (default: 1).\n-- @field [parent=#AreaCosts] #number water Value >= 0, used in combination with @{#NAVIGATOR_FLAGS.Swim} (default: 1).\n-- @field [parent=#AreaCosts] #number door Value >= 0, used in combination with @{#NAVIGATOR_FLAGS.OpenDoor}\n-- (default: 2).\n-- @field [parent=#AreaCosts] #number pathgrid Value >= 0, used in combination with @{#NAVIGATOR_FLAGS.UsePathgrid}\n-- (default: 1).\n\n---\n-- A table of parameters for @{#nearby.findPath}\n-- @type FindPathOptions\n-- @field [parent=#FindPathOptions] #AgentBounds agentBounds identifies which navmesh to use.\n-- @field [parent=#FindPathOptions] #number includeFlags allowed areas for agent to move, a sum of @{#NAVIGATOR_FLAGS}\n-- values (default: @{#NAVIGATOR_FLAGS.Walk} + @{#NAVIGATOR_FLAGS.Swim} + @{#NAVIGATOR_FLAGS.OpenDoor}\n-- + @{#NAVIGATOR_FLAGS.UsePathgrid}).\n-- @field [parent=#FindPathOptions] #AreaCosts areaCosts a table defining relative cost for each type of area.\n-- @field [parent=#FindPathOptions] #number destinationTolerance a floating point number representing maximum allowed\n-- distance between destination and a nearest point on the navigation mesh in addition to agent size (default: 1).\n\n---\n-- A table of parameters for @{#nearby.findRandomPointAroundCircle} and @{#nearby.castNavigationRay}\n-- @type NavMeshOptions\n-- @field [parent=#NavMeshOptions] #AgentBounds agentBounds Identifies which navmesh to use.\n-- @field [parent=#NavMeshOptions] #number includeFlags Allowed areas for agent to move, a sum of @{#NAVIGATOR_FLAGS}\n-- values (default: @{#NAVIGATOR_FLAGS.Walk} + @{#NAVIGATOR_FLAGS.Swim} + @{#NAVIGATOR_FLAGS.OpenDoor}\n-- + @{#NAVIGATOR_FLAGS.UsePathgrid}).\n\n---\n-- A table of parameters for @{#nearby.findNearestNavMeshPosition}\n-- @type FindNearestNavMeshPositionOptions\n-- @field [parent=#NavMeshOptions] #AgentBounds agentBounds Identifies which navmesh to use.\n-- @field [parent=#NavMeshOptions] #number includeFlags Allowed areas for agent to move, a sum of @{#NAVIGATOR_FLAGS}\n-- values (default: @{#NAVIGATOR_FLAGS.Walk} + @{#NAVIGATOR_FLAGS.Swim} + @{#NAVIGATOR_FLAGS.OpenDoor}\n-- + @{#NAVIGATOR_FLAGS.UsePathgrid}).\n-- @field [parent=#NavMeshOptions] openmw.util#Vector3 searchAreaHalfExtents Defines AABB like area half extents around\n-- given position (default: (1 + 2 * CellGridRadius) * CellSize * (1, 1, 1) where CellGridRadius and depends on cell\n-- type to cover the whole active grid).\n\n---\n-- Find path over navigation mesh from source to destination with given options. Result is unstable since navigation\n-- mesh generation is asynchronous.\n-- @function [parent=#nearby] findPath\n-- @param openmw.util#Vector3 source Initial path position.\n-- @param openmw.util#Vector3 destination Final path position.\n-- @param #FindPathOptions options An optional table with additional optional arguments.\n-- @return #FIND_PATH_STATUS\n-- @return #list<openmw.util#Vector3>\n-- @usage local status, path = nearby.findPath(source, destination)\n-- @usage local status, path = nearby.findPath(source, destination, {\n--     includeFlags = nearby.NAVIGATOR_FLAGS.Walk + nearby.NAVIGATOR_FLAGS.OpenDoor,\n--     areaCosts = {\n--         door = 1.5,\n--     },\n-- })\n-- @usage local status, path = nearby.findPath(source, destination, {\n--     agentBounds = Actor.getPathfindingAgentBounds(self),\n-- })\n\n---\n-- Returns random location on navigation mesh within the reach of specified location.\n-- The location is not exactly constrained by the circle, but it limits the area.\n-- @function [parent=#nearby] findRandomPointAroundCircle\n-- @param openmw.util#Vector3 position Center of the search circle.\n-- @param #number maxRadius Approximate maximum search distance.\n-- @param #NavMeshOptions options An optional table with additional optional arguments.\n-- @return openmw.util#Vector3, #nil\n-- @usage local position = nearby.findRandomPointAroundCircle(position, maxRadius)\n-- @usage local position = nearby.findRandomPointAroundCircle(position, maxRadius, {\n--     includeFlags = nearby.NAVIGATOR_FLAGS.Walk,\n-- })\n-- @usage local position = nearby.findRandomPointAroundCircle(position, maxRadius, {\n--     agentBounds = Actor.getPathfindingAgentBounds(self),\n-- })\n\n---\n-- Finds a nearest to the ray target position starting from the initial position with resulting curve drawn on the\n-- navigation mesh surface.\n-- @function [parent=#nearby] castNavigationRay\n-- @param openmw.util#Vector3 from Initial ray position.\n-- @param openmw.util#Vector3 to Target ray position.\n-- @param #NavMeshOptions options An optional table with additional optional arguments.\n-- @return openmw.util#Vector3, #nil\n-- @usage local position = nearby.castNavigationRay(from, to)\n-- @usage local position = nearby.castNavigationRay(from, to, {\n--     includeFlags = nearby.NAVIGATOR_FLAGS.Swim,\n-- })\n-- @usage local position = nearby.castNavigationRay(from, to, {\n--     agentBounds = Actor.getPathfindingAgentBounds(self),\n-- })\n\n---\n-- Finds a nearest position on navigation mesh to the given position within given search area.\n-- @function [parent=#nearby] findNearestNavMeshPosition\n-- @param openmw.util#Vector3 position Search area center.\n-- @param #FindNearestNavMeshPositionOptions options An optional table with additional optional arguments.\n-- @return openmw.util#Vector3, #nil\n-- @usage local navMeshPosition = nearby.findNearestNavMeshPosition(position)\n-- @usage local navMeshPosition = nearby.findNearestNavMeshPosition(position, {\n--     includeFlags = nearby.NAVIGATOR_FLAGS.Swim,\n-- })\n-- @usage local navMeshPosition = nearby.findNearestNavMeshPosition(position, {\n--     agentBounds = Actor.getPathfindingAgentBounds(self),\n-- })\n-- @usage local navMeshPosition = nearby.findNearestNavMeshPosition(position, {\n--     searchAreaHalfExtents = util.vector3(1000, 1000, 1000),\n--     includeFlags = nearby.NAVIGATOR_FLAGS.Walk,\n-- })\n\nreturn nil\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\lua_api\\openmw\\postprocessing.lua": "---\n-- `openmw.postprocessing` is an interface to postprocessing shaders.\n-- Can be used only by local scripts, that are attached to a player.\n-- @module postprocessing\n-- @usage local postprocessing = require('openmw.postprocessing')\n\n\n---\n-- Load a shader and return its handle.\n-- @function [parent=#postprocessing] load\n-- @param #string name Name of the shader without its extension\n-- @return #Shader\n-- @usage\n-- -- If the shader exists and compiles, the shader will still be off by default.\n-- -- It must be enabled to see its effect.\n-- local vignetteShader = postprocessing.load('vignette')\n\n---\n-- Enable the shader. Has no effect if the shader is already enabled or does\n-- not exist. Will not apply until the next frame.\n-- @function [parent=#Shader] enable Enable the shader\n-- @param self\n-- @param #number position optional position to place the shader. If left out the shader will be inserted at the end of the chain.\n-- @usage\n-- -- Load shader\n-- local vignetteShader = postprocessing.load('vignette')\n-- -- Toggle shader on\n-- vignetteShader:enable()\n\n---\n-- Deactivate the shader. Has no effect if the shader is already deactivated or does not exist.\n-- Will not apply until the next frame.\n-- @function [parent=#Shader] disable Disable the shader\n-- @param self\n-- @usage\n-- local vignetteShader = shader.postprocessing('vignette')\n-- vignetteShader:disable() -- shader will be toggled off\n\n---\n-- Check if the shader is enabled.\n-- @function [parent=#Shader] isEnabled\n-- @param self\n-- @return #boolean True if shader is enabled and was compiled successfully.\n-- @usage\n-- local vignetteShader = shader.postprocessing('vignette')\n-- vignetteShader:enable() -- shader will be toggled on\n\n---\n-- Set a non static bool shader variable.\n-- @function [parent=#Shader] setBool\n-- @param self\n-- @param #string name Name of uniform\n-- @param #boolean value Value of uniform.\n\n---\n-- Set a non static integer shader variable.\n-- @function [parent=#Shader] setInt\n-- @param self\n-- @param #string name Name of uniform\n-- @param #number value Value of uniform.\n\n---\n-- Set a non static float shader variable.\n-- @function [parent=#Shader] setFloat\n-- @param self\n-- @param #string name Name of uniform\n-- @param #number value Value of uniform.\n\n---\n-- Set a non static Vector2 shader variable.\n-- @function [parent=#Shader] setVector2\n-- @param self\n-- @param #string name Name of uniform\n-- @param openmw.util#Vector2 value Value of uniform.\n\n---\n-- Set a non static Vector3 shader variable.\n-- @function [parent=#Shader] setVector3\n-- @param self\n-- @param #string name Name of uniform\n-- @param openmw.util#Vector3 value Value of uniform.\n\n---\n-- Set a non static Vector4 shader variable.\n-- @function [parent=#Shader] setVector4\n-- @param self\n-- @param #string name Name of uniform\n-- @param openmw.util#Vector4 value Value of uniform.\n\n---\n-- Set a non static integer array shader variable.\n-- @function [parent=#Shader] setIntArray\n-- @param self\n-- @param #string name Name of uniform\n-- @param #table array Contains equal number of #number elements as the uniform array.\n\n---\n-- Set a non static float array shader variable.\n-- @function [parent=#Shader] setFloatArray\n-- @param self\n-- @param #string name Name of uniform\n-- @param #table array Contains equal number of #number elements as the uniform array.\n\n---\n-- Set a non static Vector2 array shader variable.\n-- @function [parent=#Shader] setVector2Array\n-- @param self\n-- @param #string name Name of uniform\n-- @param #table array Contains equal number of @{openmw.util#Vector2} elements as the uniform array.\n\n---\n-- Set a non static Vector3 array shader variable.\n-- @function [parent=#Shader] setVector3Array\n-- @param self\n-- @param #string name Name of uniform\n-- @param #table array Contains equal number of @{openmw.util#Vector3} elements as the uniform array.\n\n---\n-- Set a non static Vector4 array shader variable.\n-- @function [parent=#Shader] setVector4Array\n-- @param self\n-- @param #string name Name of uniform\n-- @param #table array Contains equal number of @{openmw.util#Vector4} elements as the uniform array.\n-- @usage\n-- -- Setting an array\n-- local shader = postprocessing.load('godrays')\n-- -- Toggle shader on\n-- shader:enable()\n-- -- Set new array uniform which was defined with length 2\n-- shader:setVector4Array('myArray', { util.vector4(1,0,0,1), util.vector4(1,0,1,1) })\n\nreturn nil\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\lua_api\\openmw\\self.lua": "---\n-- `openmw.self` provides full access to the object the script is attached to.\n-- Can be used only from local scripts. All fields and function of `GameObject` are also available for `openmw.self`.\n-- @module self\n-- @extends openmw.core#GameObject\n-- @usage local self = require('openmw.self')\n-- local types = require('openmw.types')\n-- if self.type == types.Player then  -- All fields and functions of `GameObject` are available.\n--     self:sendEvent(\"something\", self.position)\n-- end\n\n\n\n---\n-- Returns true if the script isActive (the object it is attached to is in an active cell).\n-- If it is not active, then `openmw.nearby` can not be used.\n-- @function [parent=#self] isActive\n-- @param self\n-- @return #boolean\n\n---\n-- The object the script is attached to (readonly)\n-- @field [parent=#self] openmw.core#GameObject object\n\n--- NPC who owns the object or `nil` (mutable).\n-- @field [parent=#self] #string ownerRecordId\n\n--- Faction who owns the object or `nil` (mutable).\n-- @field [parent=#self] #string ownerFactionId\n\n--- Rank required to be allowed to pick up the object (mutable).\n-- @field [parent=#self] #number ownerFactionRank\n\n\n---\n-- Movement controls (only for actors)\n-- @field [parent=#self] #ActorControls controls\n\n---\n-- Allows to view and/or modify controls of an actor. All fields are mutable.\n-- @type ActorControls\n-- @field [parent=#ActorControls] #number movement +1 - move forward, -1 - move backward\n-- @field [parent=#ActorControls] #number sideMovement +1 - move right, -1 - move left\n-- @field [parent=#ActorControls] #number yawChange Turn right (radians); if negative - turn left\n-- @field [parent=#ActorControls] #number pitchChange Look down (radians); if negative - look up\n-- @field [parent=#ActorControls] #boolean run true - run, false - walk\n-- @field [parent=#ActorControls] #boolean sneak If true - sneak\n-- @field [parent=#ActorControls] #boolean jump If true - initiate a jump\n-- @field [parent=#ActorControls] #number use if 1 - activates the readied weapon/spell. For weapons, keeping at 1 will charge the attack until set to 0.\n\n---\n-- Enables or disables standard AI (enabled by default).\n-- @function [parent=#self] enableAI\n-- @param self\n-- @param #boolean v\n\nreturn nil\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\lua_api\\openmw\\types.lua": "---\n-- `openmw.types` defines functions for specific types of game objects.\n-- @module types\n-- @usage local types = require('openmw.types')\n\n--- Common @{#Actor} functions for Creature, NPC, and Player.\n-- @field [parent=#types] #Actor Actor\n\n--- Common functions for Creature, NPC, and Player.\n-- @type Actor\n\n---\n-- Get the total weight of everything the actor is carrying, plus modifications from magic effects.\n-- @function [parent=#Actor] getEncumbrance\n-- @param openmw.core#GameObject actor\n-- @return #number\n\n---\n-- Check if the given actor is dead.\n-- @function [parent=#Actor] isDead\n-- @param openmw.core#GameObject actor\n-- @return #boolean\n\n---\n-- Agent bounds to be used for pathfinding functions.\n-- @function [parent=#Actor] getPathfindingAgentBounds\n-- @param openmw.core#GameObject actor\n-- @return #table with `shapeType` and `halfExtents`\n\n---\n-- Check if given actor is in the actors processing range.\n-- @function [parent=#Actor] isInActorsProcessingRange\n-- @param openmw.core#GameObject actor\n-- @return #boolean\n\n---\n-- Whether the object is an actor.\n-- @function [parent=#Actor] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Actor inventory.\n-- @function [parent=#Actor] inventory\n-- @param openmw.core#GameObject actor\n-- @return openmw.core#Inventory\n\n---\n-- @type EQUIPMENT_SLOT\n-- @field #number Helmet\n-- @field #number Cuirass\n-- @field #number Greaves\n-- @field #number LeftPauldron\n-- @field #number RightPauldron\n-- @field #number LeftGauntlet\n-- @field #number RightGauntlet\n-- @field #number Boots\n-- @field #number Shirt\n-- @field #number Pants\n-- @field #number Skirt\n-- @field #number Robe\n-- @field #number LeftRing\n-- @field #number RightRing\n-- @field #number Amulet\n-- @field #number Belt\n-- @field #number CarriedRight\n-- @field #number CarriedLeft\n-- @field #number Ammunition\n\n---\n-- Available @{#EQUIPMENT_SLOT} values. Used in `Actor.equipment(obj)` and `Actor.setEquipment(obj, eqp)`.\n-- @field [parent=#Actor] #EQUIPMENT_SLOT EQUIPMENT_SLOT\n\n---\n-- @type STANCE\n-- @field #number Nothing Default stance\n-- @field #number Weapon Weapon stance\n-- @field #number Spell Magic stance\n\n--- @{#STANCE}\n-- @field [parent=#Actor] #STANCE STANCE\n\n---\n-- Returns true if the object is an actor and is able to move. For dead, paralyzed,\n-- or knocked down actors it returns false.\n-- @function [parent=#Actor] canMove\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Speed of running. For dead actors it still returns a positive value.\n-- @function [parent=#Actor] getRunSpeed\n-- @param openmw.core#GameObject actor\n-- @return #number\n\n---\n-- Speed of walking. For dead actors it still returns a positive value.\n-- @function [parent=#Actor] getWalkSpeed\n-- @param openmw.core#GameObject actor\n-- @return #number\n\n---\n-- Current speed.\n-- @function [parent=#Actor] getCurrentSpeed\n-- @param openmw.core#GameObject actor\n-- @return #number\n\n---\n-- Is the actor standing on ground. Can be called only from a local script.\n-- @function [parent=#Actor] isOnGround\n-- @param openmw.core#GameObject actor\n-- @return #boolean\n\n---\n-- Is the actor in water. Can be called only from a local script.\n-- @function [parent=#Actor] isSwimming\n-- @param openmw.core#GameObject actor\n-- @return #boolean\n\n---\n-- Returns the current stance (whether a weapon/spell is readied), see the list of @{#STANCE} values.\n-- @function [parent=#Actor] getStance\n-- @param openmw.core#GameObject actor\n-- @return #number\n\n---\n-- Sets the current stance (whether a weapon/spell is readied), see the list of @{#STANCE} values.\n-- Can be used only in local scripts on self.\n-- @function [parent=#Actor] setStance\n-- @param openmw.core#GameObject actor\n-- @param #number stance\n\n---\n-- Returns `true` if the item is equipped on the actor.\n-- @function [parent=#Actor] hasEquipped\n-- @param openmw.core#GameObject actor\n-- @param openmw.core#GameObject item\n-- @return #boolean\n\n---\n-- Map from values of @{#EQUIPMENT_SLOT} to items @{openmw.core#GameObject}s\n-- @type EquipmentTable\n-- @map <#number, openmw.core#GameObject>\n\n---\n-- Get equipment.\n-- Has two overloads:\n--\n--   * With a single argument: returns a table `slot` -> @{openmw.core#GameObject} of currently equipped items.\n-- See @{#EQUIPMENT_SLOT}. Returns empty table if the actor doesn't have equipment slots.\n--   * With two arguments: returns an item equipped to the given slot.\n-- @function [parent=#Actor] getEquipment\n-- @param openmw.core#GameObject actor\n-- @param #number slot Optional number of the equipment slot\n-- @return #EquipmentTable, openmw.core#GameObject\n\n---\n-- Set equipment.\n-- Keys in the table are equipment slots (see @{#EQUIPMENT_SLOT}). Each\n-- value can be either a `GameObject` or recordId. Raises an error if\n-- the actor doesn't have equipment slots and table is not empty. Can be\n-- used only in local scripts and only on self.\n-- @function [parent=#Actor] setEquipment\n-- @param openmw.core#GameObject actor\n-- @param #EquipmentTable equipment\n-- @usage local self = require('openmw.self')\n-- local Actor = require('openmw.types').Actor\n-- Actor.setEquipment(self, {}) -- unequip all\n\n---\n-- Get currently selected spell\n-- @function [parent=#Actor] getSelectedSpell\n-- @param openmw.core#GameObject actor\n-- @return openmw.core#Spell, nil\n\n---\n-- Set selected spell\n-- @function [parent=#Actor] setSelectedSpell\n-- @param openmw.core#GameObject actor\n-- @param openmw.core#Spell spell Spell (can be nil)\n\n---\n-- Clears the actor's selected castable(spell or enchanted item)\n-- @function [parent=#Actor] clearSelectedCastable\n-- @param openmw.core#GameObject actor\n\n---\n-- Get currently selected enchanted item\n-- @function [parent=#Actor] getSelectedEnchantedItem\n-- @param openmw.core#GameObject actor\n-- @return openmw.core#GameObject, nil enchanted item or nil\n\n---\n-- Set currently selected enchanted item, equipping it if applicable\n-- @function [parent=#Actor] setSelectedEnchantedItem\n-- @param openmw.core#GameObject actor\n-- @param openmw.core#GameObject item enchanted item\n\n---\n-- Return the active magic effects (@{#ActorActiveEffects}) currently affecting the given actor.\n-- @function [parent=#Actor] activeEffects\n-- @param openmw.core#GameObject actor\n-- @return #ActorActiveEffects\n\n--- Read-only list of effects currently affecting the actor.\n-- @type ActorActiveEffects\n-- @usage -- print active effects\n-- for _, effect in pairs(Actor.activeEffects(self)) do\n--     print('Active Effect: '..effect.id..', attribute='..tostring(effect.affectedAttribute)..', skill='..tostring(effect.affectedSkill)..', magnitude='..tostring(effect.magnitude))\n-- end\n-- @usage -- Check for a specific effect\n-- local effect = Actor.activeEffects(self):getEffect(core.magic.EFFECT_TYPE.Telekinesis)\n-- if effect then\n--     print(effect.id..', attribute='..tostring(effect.affectedAttribute)..', skill='..tostring(effect.affectedSkill)..', magnitude='..tostring(effect.magnitude))\n-- else\n--     print('No Telekinesis effect')\n-- end\n-- @usage -- Check for a specific effect targeting a specific attribute.\n-- local effect = Actor.activeEffects(self):getEffect(core.magic.EFFECT_TYPE.FortifyAttribute, core.ATTRIBUTE.Luck)\n-- if effect then\n--     print(effect.id..', attribute='..tostring(effect.affectedAttribute)..', skill='..tostring(effect.affectedSkill)..', magnitude='..tostring(effect.magnitude))\n-- else\n--     print('No Fortify Luck effect')\n-- end\n\n---\n-- Get a specific active effect on the actor.\n-- @function [parent=#ActorActiveEffects] getEffect\n-- @param self\n-- @param #string effectId effect ID\n-- @param #string extraParam Optional skill or attribute ID\n-- @return openmw.core#ActiveEffect if such an effect is active, nil otherwise\n\n---\n-- Completely removes the active effect from the actor.\n-- @function [parent=#ActorActiveEffects] remove\n-- @param self\n-- @param #string effectId effect ID\n-- @param #string extraParam Optional skill or attribute ID\n\n---\n-- Permanently modifies the magnitude of an active effect to be exactly equal to the provided value. This adds the effect to the list of active effects if not already active.\n-- Note that although the modification is permanent, the magnitude will not stay equal to the value if any active spells with this effects are added/removed.\n-- @function [parent=#ActorActiveEffects] set\n-- @param self\n-- @param #number value\n-- @param #string effectId effect ID\n-- @param #string extraParam Optional skill or attribute ID\n\n---\n-- Permanently modifies the magnitude of an active effect by increasing it by the provided value. This adds the effect to the list of active effects if not already active.\n-- @function [parent=#ActorActiveEffects] modify\n-- @param self\n-- @param #number value\n-- @param #string effectId effect ID\n-- @param #string extraParam Optional skill or attribute ID\n\n---\n-- Return the active spells (@{#ActorActiveSpells}) currently affecting the given actor.\n-- @function [parent=#Actor] activeSpells\n-- @param openmw.core#GameObject actor\n-- @return #ActorActiveSpells\n\n--- Read-only list of spells currently affecting the actor. Can be iterated over for a list of @{openmw.core#ActiveSpell}\n-- @type ActorActiveSpells\n-- @usage -- print active spells\n-- for _, spell in pairs(Actor.activeSpells(self)) do\n--     print('Active Spell: '..tostring(spell))\n-- end\n-- @usage -- Check for a specific spell\n-- if Actor.activeSpells(self):isSpellActive('bound longbow') then\n--     print('Player has bound longbow')\n-- else\n--     print('Player does not have bound longbow')\n-- end\n-- @usage -- Print all information about active spells\n-- for id, params in pairs(Actor.activeSpells(self)) do\n--     print('active spell '..tostring(id)..':')\n--     print('  name: '..tostring(params.name))\n--     print('  id: '..tostring(params.id))\n--     print('  item: '..tostring(params.item))\n--     print('  caster: '..tostring(params.caster))\n--     print('  effects: '..tostring(params.effects))\n--     for _, effect in pairs(params.effects) do\n--         print('  -> effects['..tostring(effect)..']:')\n--         print('       id: '..tostring(effect.id))\n--         print('       name: '..tostring(effect.name))\n--         print('       affectedSkill: '..tostring(effect.affectedSkill))\n--         print('       affectedAttribute: '..tostring(effect.affectedAttribute))\n--         print('       magnitudeThisFrame: '..tostring(effect.magnitudeThisFrame))\n--         print('       minMagnitude: '..tostring(effect.minMagnitude))\n--         print('       maxMagnitude: '..tostring(effect.maxMagnitude))\n--         print('       duration: '..tostring(effect.duration))\n--         print('       durationLeft: '..tostring(effect.durationLeft))\n--     end\n-- end\n\n---\n-- Get whether a specific spell is active on the actor.\n-- @function [parent=#ActorActiveSpells] isSpellActive\n-- @param self\n-- @param #any recordOrId record or string record ID of the active spell's source. valid records are @{openmw.core#Spell}, @{openmw.core#Enchantment}, #IngredientRecord, or #PotionRecord\n-- @return true if spell is active, false otherwise\n\n---\n-- Remove the given spell and all its effects from the given actor's active spells.\n-- @function [parent=#ActorActiveSpells] remove\n-- @param self\n-- @param #any spellOrId @{openmw.core#Spell} or string spell id\n\n---\n-- Return the spells (@{#ActorSpells}) of the given actor.\n-- @function [parent=#Actor] spells\n-- @param openmw.core#GameObject actor\n-- @return #ActorSpells\n\n--- List of spells with additional functions add/remove/clear (modification are allowed only in global scripts or on self).\n-- @type ActorSpells\n-- @usage -- print available spells\n-- local mySpells = types.Actor.spells(self)\n-- for _, spell in pairs(mySpells) do print(spell.id) end\n-- @usage -- print available spells (equivalent)\n-- local mySpells = types.Actor.spells(self)\n-- for i = 1, #mySpells do print(mySpells[i].id) end\n-- @usage -- add ALL spells that exist in the world\n-- local mySpells = types.Actor.spells(self)\n-- for _, spell in pairs(core.magic.spells) do\n--     if spell.type == core.magic.SPELL_TYPE.Spell then\n--         mySpells:add(spell)\n--     end\n-- end\n-- @usage -- add specific spell\n-- types.Actor.spells(self):add('thunder fist')\n-- @usage -- check specific spell\n-- local mySpells = types.Actor.spells(self)\n-- if mySpells['thunder fist'] then print('I have thunder fist') end\n\n---\n-- Add spell (only in global scripts or on self).\n-- @function [parent=#ActorSpells] add\n-- @param self\n-- @param #any spellOrId @{openmw.core#Spell} or string spell id\n\n---\n-- Remove spell (only in global scripts or on self).\n-- @function [parent=#ActorSpells] remove\n-- @param self\n-- @param #any spellOrId @{openmw.core#Spell} or string spell id\n\n---\n-- Remove all spells (only in global scripts or on self).\n-- @function [parent=#ActorSpells] clear\n-- @param self\n\n---\n-- @type LevelStat\n-- @field #number current The actor's current level.\n-- @field #number progress The NPC's level progress (read-only.)\n\n---\n-- @type DynamicStat\n-- @field #number base\n-- @field #number current\n-- @field #number modifier\n\n---\n-- @type AttributeStat\n-- @field #number base The actor's base attribute value.\n-- @field #number damage The amount the attribute has been damaged.\n-- @field #number modified The actor's current attribute value (read-only.)\n-- @field #number modifier The attribute's modifier.\n\n---\n-- @type SkillStat\n-- @field #number base The NPC's base skill value.\n-- @field #number damage The amount the skill has been damaged.\n-- @field #number modified The NPC's current skill value (read-only.)\n-- @field #number modifier The skill's modifier.\n-- @field #number progress [0-1] The NPC's skill progress.\n\n---\n-- @type DynamicStats\n\n---\n-- Health (returns @{#DynamicStat})\n-- @function [parent=#DynamicStats] health\n-- @param openmw.core#GameObject actor\n-- @return #DynamicStat\n\n---\n-- Magicka (returns @{#DynamicStat})\n-- @function [parent=#DynamicStats] magicka\n-- @param openmw.core#GameObject actor\n-- @return #DynamicStat\n\n---\n-- Fatigue (returns @{#DynamicStat})\n-- @function [parent=#DynamicStats] fatigue\n-- @param openmw.core#GameObject actor\n-- @return #DynamicStat\n\n---\n-- @type AttributeStats\n\n---\n-- Strength (returns @{#AttributeStat})\n-- @function [parent=#AttributeStats] strength\n-- @param openmw.core#GameObject actor\n-- @return #AttributeStat\n\n---\n-- Intelligence (returns @{#AttributeStat})\n-- @function [parent=#AttributeStats] intelligence\n-- @param openmw.core#GameObject actor\n-- @return #AttributeStat\n\n---\n-- Willpower (returns @{#AttributeStat})\n-- @function [parent=#AttributeStats] willpower\n-- @param openmw.core#GameObject actor\n-- @return #AttributeStat\n\n---\n-- Agility (returns @{#AttributeStat})\n-- @function [parent=#AttributeStats] agility\n-- @param openmw.core#GameObject actor\n-- @return #AttributeStat\n\n---\n-- Speed (returns @{#AttributeStat})\n-- @function [parent=#AttributeStats] speed\n-- @param openmw.core#GameObject actor\n-- @return #AttributeStat\n\n---\n-- Endurance (returns @{#AttributeStat})\n-- @function [parent=#AttributeStats] endurance\n-- @param openmw.core#GameObject actor\n-- @return #AttributeStat\n\n---\n-- Personality (returns @{#AttributeStat})\n-- @function [parent=#AttributeStats] personality\n-- @param openmw.core#GameObject actor\n-- @return #AttributeStat\n\n---\n-- Luck (returns @{#AttributeStat})\n-- @function [parent=#AttributeStats] luck\n-- @param openmw.core#GameObject actor\n-- @return #AttributeStat\n\n---\n-- @type SkillStats\n\n---\n-- Block (returns @{#SkillStat})\n-- @function [parent=#SkillStats] block\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Armorer (returns @{#SkillStat})\n-- @function [parent=#SkillStats] armorer\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Medium Armor (returns @{#SkillStat})\n-- @function [parent=#SkillStats] mediumarmor\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Heavy Armor (returns @{#SkillStat})\n-- @function [parent=#SkillStats] heavyarmor\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Blunt Weapon (returns @{#SkillStat})\n-- @function [parent=#SkillStats] bluntweapon\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Long Blade (returns @{#SkillStat})\n-- @function [parent=#SkillStats] longblade\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Axe (returns @{#SkillStat})\n-- @function [parent=#SkillStats] axe\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Spear (returns @{#SkillStat})\n-- @function [parent=#SkillStats] spear\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Athletics (returns @{#SkillStat})\n-- @function [parent=#SkillStats] athletics\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Enchant (returns @{#SkillStat})\n-- @function [parent=#SkillStats] enchant\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Destruction (returns @{#SkillStat})\n-- @function [parent=#SkillStats] destruction\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Alteration (returns @{#SkillStat})\n-- @function [parent=#SkillStats] alteration\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Illusion (returns @{#SkillStat})\n-- @function [parent=#SkillStats] illusion\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Conjuration (returns @{#SkillStat})\n-- @function [parent=#SkillStats] conjuration\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Mysticism (returns @{#SkillStat})\n-- @function [parent=#SkillStats] mysticism\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Restoration (returns @{#SkillStat})\n-- @function [parent=#SkillStats] restoration\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Alchemy (returns @{#SkillStat})\n-- @function [parent=#SkillStats] alchemy\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Unarmored (returns @{#SkillStat})\n-- @function [parent=#SkillStats] unarmored\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Security (returns @{#SkillStat})\n-- @function [parent=#SkillStats] security\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Sneak (returns @{#SkillStat})\n-- @function [parent=#SkillStats] sneak\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Acrobatics (returns @{#SkillStat})\n-- @function [parent=#SkillStats] acrobatics\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Light Armor (returns @{#SkillStat})\n-- @function [parent=#SkillStats] lightarmor\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Short Blade (returns @{#SkillStat})\n-- @function [parent=#SkillStats] shortblade\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Marksman (returns @{#SkillStat})\n-- @function [parent=#SkillStats] marksman\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Mercantile (returns @{#SkillStat})\n-- @function [parent=#SkillStats] mercantile\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Speechcraft (returns @{#SkillStat})\n-- @function [parent=#SkillStats] speechcraft\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- Hand To Hand (returns @{#SkillStat})\n-- @function [parent=#SkillStats] handtohand\n-- @param openmw.core#GameObject actor\n-- @return #SkillStat\n\n---\n-- @type ActorStats\n-- @field #DynamicStats dynamic\n-- @field #AttributeStats attributes\n\n---\n-- Level (returns @{#LevelStat})\n-- @function [parent=#ActorStats] level\n-- @param openmw.core#GameObject actor\n-- @return #LevelStat\n\n--- The actor's stats.\n-- @field [parent=#Actor] #ActorStats stats\n\n---\n-- @type NpcStats\n-- @extends ActorStats\n-- @field #SkillStats skills\n\n\n--------------------------------------------------------------------------------\n-- @{#Item} functions (all items that can be placed to an inventory or container)\n-- @field [parent=#types] #Item Item\n\n--- Functions for items that can be placed to an inventory or container\n-- @type Item\n\n---\n-- Whether the object is an item.\n-- @function [parent=#Item] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Get this item's current enchantment charge.\n-- @function [parent=#Item] getEnchantmentCharge\n-- @param openmw.core#GameObject item\n-- @return #number The charge remaining. -1 if the enchantment has never been used, implying the charge is full. Unenchanted items will always return a value of -1.\n\n---\n-- Checks if the item restocks.\n-- Returns true if the object restocks, and false otherwise.\n-- @function [parent=#Item] isRestocking\n-- @param openmw.core#GameObject item\n-- @return #boolean\n\n---\n-- Set this item's enchantment charge.\n-- @function [parent=#Item] setEnchantmentCharge\n-- @param openmw.core#GameObject item\n-- @param #number charge\n\n---\n-- Whether the object is supposed to be carriable. It is true for all items except\n-- lights without the Carry flag. Non-carriable lights can still be put into\n-- an inventory with an explicit `object:moveInto` call.\n-- @function [parent=#Item] isCarriable\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Set of properties that differentiates one item from another of the same record type.\n-- @function [parent=#Item] itemData\n-- @param openmw.core#GameObject item\n-- @return #ItemData\n\n---\n-- @type ItemData\n-- @field #number condition The item's current condition. Time remaining for lights. Uses left for lockpicks and probes. Current health for weapons and armor.\n\n--------------------------------------------------------------------------------\n-- @{#Creature} functions\n-- @field [parent=#types] #Creature Creature\n\n---\n-- @type Creature\n-- @extends #Actor\n-- @field #Actor baseType @{#Actor}\n-- @field #list<#CreatureRecord> records A read-only list of all @{#CreatureRecord}s in the world database.\n\n---\n-- Whether the object is a creature.\n-- @function [parent=#Creature] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n--- Creature.TYPE\n-- @type CreatureTYPE\n-- @field #number Creatures\n-- @field #number Daedra\n-- @field #number Undead\n-- @field #number Humanoid\n\n--- @{#CreatureTYPE}\n-- @field [parent=#Creature] #CreatureTYPE TYPE\n\n---\n-- Returns the read-only @{#CreatureRecord} of a creature\n-- @function [parent=#Creature] record\n-- @param #any objectOrRecordId\n-- @return #CreatureRecord\n\n---\n-- @type CreatureRecord\n-- @field #string id The record ID of the creature\n-- @field #string name\n-- @field #string baseCreature Record id of a base creature, which was modified to create this one\n-- @field #string model VFS path to the creature's model\n-- @field #string mwscript\n-- @field #number soulValue The soul value of the creature record\n-- @field #number type The @{#Creature.TYPE} of the creature\n-- @field #number baseGold The base barter gold of the creature\n-- @field #map<#string, #boolean> servicesOffered The services of the creature, in a table. Value is if the service is provided or not, and they are indexed by: Spells, Spellmaking, Enchanting, Training, Repair, Barter, Weapon, Armor, Clothing, Books, Ingredients, Picks, Probes, Lights, Apparatus, RepairItems, Misc, Potions, MagicItems, Travel.\n\n\n--- @{#NPC} functions\n-- @field [parent=#types] #NPC NPC\n\n---\n-- @type NPC\n-- @extends #Actor\n-- @field #Actor baseType @{#Actor}\n-- @field [parent=#NPC] #NpcStats stats\n-- @field #list<#NpcRecord> records A read-only list of all @{#NpcRecord}s in the world database.\n\n---\n-- Whether the object is an NPC or a Player.\n-- @function [parent=#NPC] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Get all factions in which NPC has a membership.\n-- Note: this function does not take in account an expelling state.\n-- @function [parent=#NPC] getFactions\n-- @param openmw.core#GameObject actor NPC object\n-- @return #list<#string> factionIds List of faction IDs.\n-- @usage local NPC = require('openmw.types').NPC;\n-- for _, factionId in pairs(types.NPC.getFactions(actor)) do\n--     print(factionId);\n-- end\n\n---\n-- Get rank of given NPC in given faction.\n-- Throws an exception if there is no such faction.\n-- Note: this function does not take in account an expelling state.\n-- @function [parent=#NPC] getFactionRank\n-- @param openmw.core#GameObject actor NPC object\n-- @param #string faction Faction ID\n-- @return #number rank Rank index (from 1), 0 if NPC is not in faction.\n-- @usage local NPC = require('openmw.types').NPC;\n-- print(NPC.getFactionRank(player, \"mages guild\");\n\n---\n-- Set rank of given NPC in given faction.\n-- Throws an exception if there is no such faction, target rank does not exist or actor is not a member of given faction.\n-- For NPCs faction also should be an NPC's primary faction.\n-- @function [parent=#NPC] setFactionRank\n-- @param openmw.core#GameObject actor NPC object\n-- @param #string faction Faction ID\n-- @param #number value Rank index (from 1).\n-- @usage local NPC = require('openmw.types').NPC;\n-- NPC.setFactionRank(player, \"mages guild\", 6);\n\n---\n-- Adjust rank of given NPC in given faction.\n-- Throws an exception if there is no such faction or actor is not a member of given faction.\n-- For NPCs faction also should be an NPC's primary faction.\n-- Notes:\n--\n--   * If rank should become <= 0 after modification, function set rank to lowest available rank.\n--   * If rank should become > 0 after modification, but target rank does not exist, function set rank to the highest valid rank.\n-- @function [parent=#NPC] modifyFactionRank\n-- @param openmw.core#GameObject actor NPC object\n-- @param #string faction Faction ID\n-- @param #number value Rank index (from 1) modifier. If rank reaches 0 for player character, he leaves the faction.\n-- @usage local NPC = require('openmw.types').NPC;\n-- NPC.modifyFactionRank(player, \"mages guild\", 1);\n\n---\n-- Add given actor to given faction.\n-- Throws an exception if there is no such faction or target actor is not player.\n-- Function does nothing if valid target actor is already a member of target faction.\n-- @function [parent=#NPC] joinFaction\n-- @param openmw.core#GameObject actor NPC object\n-- @param #string faction Faction ID\n-- @usage local NPC = require('openmw.types').NPC;\n-- NPC.joinFaction(player, \"mages guild\");\n\n---\n-- Remove given actor from given faction.\n-- Function removes rank data and expelling state, but keeps a reputation in target faction.\n-- Throws an exception if there is no such faction or target actor is not player.\n-- Function does nothing if valid target actor is already not member of target faction.\n-- @function [parent=#NPC] leaveFaction\n-- @param openmw.core#GameObject actor NPC object\n-- @param #string faction Faction ID\n-- @usage local NPC = require('openmw.types').NPC;\n-- NPC.leaveFaction(player, \"mages guild\");\n\n---\n-- Get reputation of given actor in given faction.\n-- Throws an exception if there is no such faction.\n-- @function [parent=#NPC] getFactionReputation\n-- @param openmw.core#GameObject actor NPC object\n-- @param #string faction Faction ID\n-- @return #number reputation Reputation level, 0 if NPC is not in faction.\n-- @usage local NPC = require('openmw.types').NPC;\n-- print(NPC.getFactionReputation(player, \"mages guild\"));\n\n---\n-- Set reputation of given actor in given faction.\n-- Throws an exception if there is no such faction.\n-- @function [parent=#NPC] setFactionReputation\n-- @param openmw.core#GameObject actor NPC object\n-- @param #string faction Faction ID\n-- @param #number value Reputation value\n-- @usage local NPC = require('openmw.types').NPC;\n-- NPC.setFactionReputation(player, \"mages guild\", 100);\n\n---\n-- Adjust reputation of given actor in given faction.\n-- Throws an exception if there is no such faction.\n-- @function [parent=#NPC] modifyFactionReputation\n-- @param openmw.core#GameObject actor NPC object\n-- @param #string faction Faction ID\n-- @param #number value Reputation modifier value\n-- @usage local NPC = require('openmw.types').NPC;\n-- NPC.modifyFactionReputation(player, \"mages guild\", 5);\n\n---\n-- Expel NPC from given faction.\n-- Throws an exception if there is no such faction.\n-- Note: expelled NPC still keeps his rank and reputation in faction, he just get an additonal flag for given faction.\n-- @function [parent=#NPC] expel\n-- @param openmw.core#GameObject actor NPC object\n-- @param #string faction Faction ID\n-- @usage local NPC = require('openmw.types').NPC;\n-- NPC.expel(player, \"mages guild\");\n\n---\n-- Clear expelling of NPC from given faction.\n-- Throws an exception if there is no such faction.\n-- @function [parent=#NPC] clearExpelled\n-- @param openmw.core#GameObject actor NPC object\n-- @param #string faction Faction ID\n-- @usage local NPC = require('openmw.types').NPC;\n-- NPC.clearExpell(player, \"mages guild\");\n\n---\n-- Check if NPC is expelled from given faction.\n-- Throws an exception if there is no such faction.\n-- @function [parent=#NPC] isExpelled\n-- @param openmw.core#GameObject actor NPC object\n-- @param #string faction Faction ID\n-- @return #bool isExpelled True if NPC is expelled from the faction.\n-- @usage local NPC = require('openmw.types').NPC;\n-- local result = NPC.isExpelled(player, \"mages guild\");\n\n---\n-- Returns the current disposition of the provided NPC. This is their derived disposition, after modifiers such as personality and faction relations are taken into account.\n-- @function [parent=#NPC] getDisposition\n-- @param openmw.core#GameObject object\n-- @param openmw.core#GameObject player The player that you want to check the disposition for.\n-- @return #number\n\n---\n-- Get the total weight that the actor can carry.\n-- @function [parent=#NPC] getCapacity\n-- @param openmw.core#GameObject actor\n-- @return #number\n\n--- @{#Classes}: Class Data\n-- @field [parent=#NPC] #Classes classes\n\n---\n-- A read-only list of all @{#ClassRecord}s in the world database.\n-- @field [parent=#Classes] #list<#ClassRecord> records\n\n---\n-- Returns a read-only @{#ClassRecord}\n-- @function [parent=#Classes] record\n-- @param #string recordId\n-- @return #ClassRecord\n\n---\n-- Class data record\n-- @type ClassRecord\n-- @field #string id Class id\n-- @field #string name Class name\n-- @field #list<#string> attributes A read-only list containing the specialized attributes of the class.\n-- @field #list<#string> majorSkills A read-only list containing the major skills of the class.\n-- @field #list<#string> minorSkills A read-only list containing the minor skills of the class.\n-- @field #string description Class description\n-- @field #boolean isPlayable True if the player can play as this class\n-- @field #string specialization Class specialization. Either combat, magic, or stealth.\n\n---\n-- Whether the NPC or player is in the werewolf form at the moment.\n-- @function [parent=#NPC] isWerewolf\n-- @param openmw.core#GameObject actor\n-- @return #boolean\n\n---\n-- Returns the read-only @{#NpcRecord} of an NPC\n-- @function [parent=#NPC] record\n-- @param #any objectOrRecordId\n-- @return #NpcRecord\n\n---\n-- @type NpcRecord\n-- @field #string id The record ID of the NPC\n-- @field #string name\n-- @field #string race\n-- @field #string class Name of the NPC's class (e. g. Acrobat)\n-- @field #string mwscript MWScript that is attached to this NPC\n-- @field #string hair Path to the hair body part model\n-- @field #string head Path to the head body part model\n-- @field #number baseGold The base barter gold of the NPC\n-- @field #number baseDisposition NPC's starting disposition\n-- @field #bool isMale The gender setting of the NPC\n-- @field #map<#string, #boolean> servicesOffered The services of the NPC, in a table. Value is if the service is provided or not, and they are indexed by: Spells, Spellmaking, Enchanting, Training, Repair, Barter, Weapon, Armor, Clothing, Books, Ingredients, Picks, Probes, Lights, Apparatus, RepairItems, Misc, Potions, MagicItems, Travel.\n\n\n--------------------------------------------------------------------------------\n-- @{#Player} functions\n-- @field [parent=#types] #Player Player\n\n---\n-- @type Player\n-- @extends #NPC\n-- @field #NPC baseType @{#NPC}\n\n---\n-- Whether the object is a player.\n-- @function [parent=#Player] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Returns the bounty or crime level of the player\n-- @function [parent=#Player] getCrimeLevel\n-- @param openmw.core#GameObject player\n-- @return #number\n\n---\n-- Whether the character generation for this player is finished.\n-- @function [parent=#Player] isCharGenFinished\n-- @param openmw.core#GameObject player\n-- @return #boolean\n\n---\n-- Whether teleportation for this player is enabled.\n-- @function [parent=#Player] isTeleportingEnabled\n-- @param openmw.core#GameObject player\n-- @return #boolean\n\n---\n-- Enables or disables teleportation for this player.\n-- @function [parent=#Player] setTeleportingEnabled\n-- @param openmw.core#GameObject player\n-- @param #boolean state True to enable teleporting, false to disable.\n\n---\n-- Returns a list containing quests @{#PlayerQuest} for the specified player, indexed by quest ID.\n-- @function [parent=#Player] quests\n-- @param openmw.core#GameObject player\n-- @return #list<#PlayerQuest>\n-- @usage -- Get stage of a specific quest\n-- stage = types.Player.quests(player)[\"ms_fargothring\"].stage\n-- @usage -- Start a new quest, add it to the player's quest list but don't add any journal entries\n-- types.Player.quests(player)[\"ms_fargothring\"].stage = 0\n\n---\n-- @type PlayerQuest\n-- @field #string id The quest id.\n-- @field #number stage The quest stage (global and player scripts can change it). Changing the stage starts the quest if it wasn't started.\n-- @field #bool started Whether the quest is started.\n-- @field #bool finished Whether the quest is finished (global and player scripts can change it).\n\n---\n-- Sets the quest stage for the given quest, on the given player, and adds the entry to the journal, if there is an entry at the specified stage. Can only be used in global or player scripts.\n-- @function [parent=#PlayerQuest] addJournalEntry\n-- @param self\n-- @param #number stage Quest stage\n-- @param openmw.core#GameObject actor (optional) The actor who is the source of the journal entry, it may be used in journal entries with variables such as `%name(The speaker's name)` or `%race(The speaker's race)`.\n\n---\n-- Get state of a control switch. I.e. is the player able to move/fight/jump/etc.\n-- @function [parent=#Player] getControlSwitch\n-- @param openmw.core#GameObject player\n-- @param #ControlSwitch key Control type (see @{openmw.types#CONTROL_SWITCH})\n-- @return #boolean\n\n---\n-- Set state of a control switch. I.e. forbid or allow the player to move/fight/jump/etc.\n-- Can be used only in global or player scripts.\n-- @function [parent=#Player] setControlSwitch\n-- @param openmw.core#GameObject player\n-- @param #ControlSwitch key Control type (see @{openmw.types#CONTROL_SWITCH})\n-- @param #boolean value\n\n---\n-- String id of a @{#CONTROL_SWITCH}\n-- @type ControlSwitch\n\n---\n-- @type CONTROL_SWITCH\n-- @field [parent=#CONTROL_SWITCH] #ControlSwitch Controls Ability to move\n-- @field [parent=#CONTROL_SWITCH] #ControlSwitch Fighting Ability to attack\n-- @field [parent=#CONTROL_SWITCH] #ControlSwitch Jumping Ability to jump\n-- @field [parent=#CONTROL_SWITCH] #ControlSwitch Looking Ability to change view direction\n-- @field [parent=#CONTROL_SWITCH] #ControlSwitch Magic Ability to use magic\n-- @field [parent=#CONTROL_SWITCH] #ControlSwitch ViewMode Ability to toggle 1st/3rd person view\n-- @field [parent=#CONTROL_SWITCH] #ControlSwitch VanityMode Vanity view if player doesn't touch controls for a long time\n\n---\n-- Values that can be used with getControlSwitch/setControlSwitch.\n-- @field [parent=#Player] #CONTROL_SWITCH CONTROL_SWITCH\n\n\n--------------------------------------------------------------------------------\n-- @{#Armor} functions\n-- @field [parent=#types] #Armor Armor\n\n---\n-- @type Armor\n-- @extends #Item\n-- @field #Item baseType @{#Item}\n-- @field #list<#ArmorRecord> records A read-only list of all @{#ArmorRecord}s in the world database.\n\n---\n-- Whether the object is an Armor.\n-- @function [parent=#Armor] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n--- Armor.TYPE\n-- @type ArmorTYPE\n-- @field #number Helmet\n-- @field #number Cuirass\n-- @field #number LPauldron\n-- @field #number RPauldron\n-- @field #number Greaves\n-- @field #number Boots\n-- @field #number LGauntlet\n-- @field #number RGauntlet\n-- @field #number Shield\n-- @field #number LBracer\n-- @field #number RBracer\n\n--- @{#ArmorTYPE}\n-- @field [parent=#Armor] #ArmorTYPE TYPE\n\n---\n-- Returns the read-only @{#ArmorRecord} of an Armor\n-- @function [parent=#Armor] record\n-- @param #any objectOrRecordId\n-- @return #ArmorRecord\n\n---\n-- @type ArmorRecord\n-- @field #string id Record id\n-- @field #string name Human-readable name\n-- @field #string model VFS path to the model\n-- @field #string mwscript MWScript on this armor (can be empty)\n-- @field #string icon VFS path to the icon\n-- @field #string enchant The enchantment ID of this armor (can be empty)\n-- @field #number weight\n-- @field #number value\n-- @field #number type See @{#Armor.TYPE}\n-- @field #number health\n-- @field #number baseArmor The base armor rating of this armor\n-- @field #number enchantCapacity\n\n---\n-- Creates a @{#ArmorRecord} without adding it to the world database, for the armor to appear correctly on the body, make sure to use a template as described below.\n-- Use @{openmw_world#(world).createRecord} to add the record to the world.\n-- @function [parent=#Armor] createRecordDraft\n-- @param #ArmorRecord armor A Lua table with the fields of a ArmorRecord, with an additional field `template` that accepts a @{#ArmorRecord} as a base.\n-- @return #ArmorRecord A strongly typed Armor record.\n-- @usage local armorTemplate = types.Armor.record('orcish_cuirass')\n-- local armorTable = {name = \"Better Orcish Cuirass\",template = armorTemplate,baseArmor = armorTemplate.baseArmor + 10}\n--  --This is the new record we want to create, with a record provided as a template.\n-- local recordDraft = types.Armor.createRecordDraft(armorTable)--Need to convert the table into the record draft\n-- local newRecord = world.createRecord(recordDraft)--This creates the actual record\n-- world.createObject(newRecord):moveInto(playerActor)--Create an instance of this object, and move it into the player's inventory\n\n\n--- @{#Book} functions\n-- @field [parent=#types] #Book Book\n\n---\n-- @type Book\n-- @extends #Item\n-- @field #Item baseType @{#Item}\n-- @field #list<#BookRecord> records A read-only list of all @{#BookRecord}s in the world database.\n\n---\n-- Whether the object is a Book.\n-- @function [parent=#Book] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n--- Book.SKILL\n-- @type BookSKILL\n-- @field #string acrobatics \"acrobatics\"\n-- @field #string alchemy \"alchemy\"\n-- @field #string alteration \"alteration\"\n-- @field #string armorer \"armorer\"\n-- @field #string athletics \"athletics\"\n-- @field #string axe \"axe\"\n-- @field #string block \"block\"\n-- @field #string bluntWeapon \"bluntweapon\"\n-- @field #string conjuration \"conjuration\"\n-- @field #string destruction \"destruction\"\n-- @field #string enchant \"enchant\"\n-- @field #string handToHand \"handtohand\"\n-- @field #string heavyArmor \"heavyarmor\"\n-- @field #string illusion \"illusion\"\n-- @field #string lightArmor \"lightarmor\"\n-- @field #string longBlade \"longblade\"\n-- @field #string marksman \"marksman\"\n-- @field #string mediumArmor \"mediumarmor\"\n-- @field #string mercantile \"mercantile\"\n-- @field #string mysticism \"mysticism\"\n-- @field #string restoration \"restoration\"\n-- @field #string security \"security\"\n-- @field #string shortBlade \"shortblade\"\n-- @field #string sneak \"sneak\"\n-- @field #string spear \"spear\"\n-- @field #string speechcraft \"speechcraft\"\n-- @field #string unarmored \"unarmored\"\n\n--- DEPRECATED, use @{openmw.core#Skill}\n-- @field [parent=#Book] #BookSKILL SKILL\n\n---\n-- Returns the read-only @{#BookRecord} of a book\n-- @function [parent=#Book] record\n-- @param #any objectOrRecordId\n-- @return #BookRecord\n\n---\n-- @type BookRecord\n-- @field #string id The record ID of the book\n-- @field #string name Name of the book\n-- @field #string model VFS path to the model\n-- @field #string mwscript MWScript on this book (can be empty)\n-- @field #string icon VFS path to the icon\n-- @field #string enchant The enchantment ID of this book (can be empty)\n-- @field #string text The text content of the book\n-- @field #number weight\n-- @field #number value\n-- @field #string skill The skill that this book teaches. See @{openmw.core#SKILL}\n-- @field #boolean isScroll\n-- @field #number enchantCapacity\n\n---\n-- Creates a @{#BookRecord} without adding it to the world database.\n-- Use @{openmw_world#(world).createRecord} to add the record to the world.\n-- @function [parent=#Book] createRecordDraft\n-- @param #BookRecord book A Lua table with the fields of a BookRecord, with an optional field `template` that accepts a @{#BookRecord} as a base.\n-- @return #BookRecord A strongly typed Book record.\n\n--- @{#Clothing} functions\n-- @field [parent=#types] #Clothing Clothing\n\n---\n-- @type Clothing\n-- @extends #Item\n-- @field #Item baseType @{#Item}\n-- @field #list<#ClothingRecord> records A read-only list of all @{#ClothingRecord}s in the world database.\n\n---\n-- Whether the object is a Clothing.\n-- @function [parent=#Clothing] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n--- Clothing.TYPE\n-- @type ClothingTYPE\n-- @field #number Amulet\n-- @field #number Belt\n-- @field #number LGlove\n-- @field #number Pants\n-- @field #number RGlove\n-- @field #number Ring\n-- @field #number Robe\n-- @field #number Shirt\n-- @field #number Shoes\n-- @field #number Skirt\n\n--- @{#ClothingTYPE}\n-- @field [parent=#Clothing] #ClothingTYPE TYPE\n\n---\n-- Returns the read-only @{#ClothingRecord} of a Clothing\n-- @function [parent=#Clothing] record\n-- @param #any objectOrRecordId\n-- @return #ClothingRecord\n\n---\n-- Creates a @{#ClothingRecord} without adding it to the world database, for the clothing to appear correctly on the body, make sure to use a template as described below.\n-- Use @{openmw_world#(world).createRecord} to add the record to the world.\n-- @function [parent=#Clothing] createRecordDraft\n-- @param #ClothingRecord clothing A Lua table with the fields of a ClothingRecord, with an additional field `template` that accepts a @{#ClothingRecord} as a base.\n-- @return #ClothingRecord A strongly typed clothing record.\n-- @usage local clothingTemplate = types.Clothing.record('exquisite_robe_01')\n-- local clothingTable = {name = \"Better Exquisite Robe\",template = clothingTemplate,enchantCapacity = clothingTemplate.enchantCapacity + 10}\n--  --This is the new record we want to create, with a record provided as a template.\n-- local recordDraft = types.Clothing.createRecordDraft(clothingTable)--Need to convert the table into the record draft\n-- local newRecord = world.createRecord(recordDraft)--This creates the actual record\n-- world.createObject(newRecord):moveInto(playerActor)--Create an instance of this object, and move it into the player's inventory\n\n---\n-- @type ClothingRecord\n-- @field #string id Record id\n-- @field #string name Name of the clothing\n-- @field #string model VFS path to the model\n-- @field #string mwscript MWScript on this clothing (can be empty)\n-- @field #string icon VFS path to the icon\n-- @field #string enchant The enchantment ID of this clothing (can be empty)\n-- @field #number weight\n-- @field #number value\n-- @field #number type See @{#Clothing.TYPE}\n-- @field #number enchantCapacity\n\n\n\n\n--- @{#Ingredient} functions\n-- @field [parent=#types] #Ingredient Ingredient\n\n---\n-- @type Ingredient\n-- @extends #Item\n-- @field #Item baseType @{#Item}\n-- @field #list<#IngredientRecord> records A read-only list of all @{#IngredientRecord}s in the world database.\n\n---\n-- Whether the object is an Ingredient.\n-- @function [parent=#Ingredient] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Returns the read-only @{#IngredientRecord} of a Ingredient\n-- @function [parent=#Ingredient] record\n-- @param #any objectOrRecordId\n-- @return #IngredientRecord\n\n---\n-- @type IngredientRecord\n-- @field #string id Record id\n-- @field #string name Human-readable name\n-- @field #string model VFS path to the model\n-- @field #string mwscript MWScript on this potion (can be empty)\n-- @field #string icon VFS path to the icon\n-- @field #number weight\n-- @field #number value\n-- @field #list<openmw.core#MagicEffectWithParams> effects The effects (@{#list<openmw.core#MagicEffectWithParams>}) of the ingredient\n\n\n--- @{#Lockable} functions\n-- @field [parent=#types] #Lockable Lockable\n\n---\n-- Returns the key record of a lockable object(door, container)\n-- @function [parent=#Lockable] getKeyRecord\n-- @param openmw.core#GameObject object\n-- @return #MiscellaneousRecord\n\n---\n-- Sets the key of a lockable object(door, container); removes it if empty string is provided. Must be used in a global script.\n-- @function [parent=#Lockable] setKeyRecord\n-- @param openmw.core#GameObject object\n-- @param #any miscOrId @{#MiscellaneousRecord} or string misc item id Record ID of the key to use.\n\n---\n-- Returns the trap spell of a lockable object(door, container)\n-- @function [parent=#Lockable] getTrapSpell\n-- @param openmw.core#GameObject object\n-- @return openmw.core#Spell\n\n---\n-- Sets the trap spell of a lockable object(door, container); removes it if empty string is provided. Must be used in a global script.\n-- @function [parent=#Lockable] setTrapSpell\n-- @param openmw.core#GameObject object\n-- @param #any spellOrId @{openmw.core#Spell} or string spell id Record ID for the trap to use\n\n---\n-- Returns the lock level of a lockable object(door, container). Does not determine if an object is locked or not, if an object is locked while this is set above 0, this value will be used if no other value is specified.\n-- @function [parent=#Lockable] getLockLevel\n-- @param openmw.core#GameObject object\n-- @return #number\n\n\n---\n-- Returns true if the lockable object is locked, and false if it is not.\n-- @function [parent=#Lockable] isLocked\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n\n---\n-- Sets the lock level level of a lockable object(door, container);Locks if not already locked; Must be used in a global script.\n-- @function [parent=#Lockable] lock\n-- @param openmw.core#GameObject object\n-- @param #number lockLevel Level to lock the object at. Optional, if not specified, then 1 will be used, or the previous level if it was locked before.\n\n---\n-- Unlocks the lockable object. Does not change the lock level, it can be kept for future use.\n-- @function [parent=#Lockable] unlock\n-- @param openmw.core#GameObject object\n\n\n\n--- @{#Light} functions\n-- @field [parent=#types] #Light Light\n\n---\n-- @type Light\n-- @extends #Item\n-- @field #Item baseType @{#Item}\n-- @field #list<#LightRecord> records A read-only list of all @{#LightRecord}s in the world database.\n\n---\n-- Whether the object is a Light.\n-- @function [parent=#Light] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Returns the read-only @{#LightRecord} of a Light\n-- @function [parent=#Light] record\n-- @param #any objectOrRecordId\n-- @return #LightRecord\n\n---\n-- @type LightRecord\n-- @field #string id Record id\n-- @field #string name Human-readable name\n-- @field #string model VFS path to the model\n-- @field #string mwscript MWScript on this light (can be empty)\n-- @field #string icon VFS path to the icon\n-- @field #string sound VFS path to the sound\n-- @field #number weight\n-- @field #number value\n-- @field #number duration\n-- @field #number radius\n-- @field #number color\n-- @field #boolean isCarriable\n\n\n\n--- Functions for @{#Miscellaneous} objects\n-- @field [parent=#types] #Miscellaneous Miscellaneous\n\n---\n-- @type Miscellaneous\n-- @extends #Item\n-- @field #Item baseType @{#Item}\n-- @field #list<#MiscellaneousRecord> records A read-only list of all @{#MiscellaneousRecord}s in the world database.\n\n---\n-- Whether the object is a Miscellaneous.\n-- @function [parent=#Miscellaneous] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Returns the read-only @{#MiscellaneousRecord} of a miscellaneous item\n-- @function [parent=#Miscellaneous] record\n-- @param #any objectOrRecordId\n-- @return #MiscellaneousRecord\n\n---\n-- Returns the read-only soul of a miscellaneous item\n-- @function [parent=#Miscellaneous] getSoul\n-- @param openmw.core#GameObject object\n-- @return #string\n\n---\n-- Creates a @{#MiscellaneousRecord} without adding it to the world database.\n-- Use @{openmw_world#(world).createRecord} to add the record to the world.\n-- @function [parent=#Miscellaneous] createRecordDraft\n-- @param #MiscellaneousRecord miscellaneous A Lua table with the fields of a MiscellaneousRecord, with an optional field `template` that accepts a @{#MiscellaneousRecord} as a base.\n-- @return #MiscellaneousRecord A strongly typed Miscellaneous record.\n\n---\n-- Sets the soul of a miscellaneous item, intended for soul gem objects; Must be used in a global script.\n-- @function [parent=#Miscellaneous] setSoul\n-- @param openmw.core#GameObject object\n-- @param #string soulId Record ID for the soul of the creature to use\n\n---\n-- @type MiscellaneousRecord\n-- @field #string id The record ID of the miscellaneous item\n-- @field #string name The name of the miscellaneous item\n-- @field #string model VFS path to the model\n-- @field #string mwscript MWScript on this miscellaneous item (can be empty)\n-- @field #string icon VFS path to the icon\n-- @field #number weight\n-- @field #number value\n-- @field #boolean isKey\n\n--- @{#Potion} functions\n-- @field [parent=#types] #Potion Potion\n\n---\n-- @type Potion\n-- @extends #Item\n-- @field #Item baseType @{#Item}\n-- @field #list<#PotionRecord> records A read-only list of all @{#PotionRecord}s in the world database.\n\n---\n-- Whether the object is a Potion.\n-- @function [parent=#Potion] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Returns the read-only @{#PotionRecord} of a potion\n-- @function [parent=#Potion] record\n-- @param #any objectOrRecordId\n-- @return #PotionRecord\n\n---\n-- Creates a @{#PotionRecord} without adding it to the world database.\n-- Use @{openmw_world#(world).createRecord} to add the record to the world.\n-- @function [parent=#Potion] createRecordDraft\n-- @param #PotionRecord potion A Lua table with the fields of a PotionRecord, with an optional field `template` that accepts a @{#PotionRecord} as a base.\n-- @return #PotionRecord A strongly typed Potion record.\n\n---\n-- @type PotionRecord\n-- @field #string id Record id\n-- @field #string name Human-readable name\n-- @field #string model VFS path to the model\n-- @field #string mwscript MWScript on this potion (can be empty)\n-- @field #string icon VFS path to the icon\n-- @field #number weight\n-- @field #number value\n-- @field #list<openmw.core#MagicEffectWithParams> effects The effects (@{#list<openmw.core#MagicEffectWithParams>}) of the potion\n\n\n\n--- @{#Weapon} functions\n-- @field [parent=#types] #Weapon Weapon\n\n---\n-- @type Weapon\n-- @extends #Item\n-- @field #Item baseType @{#Item}\n-- @field #list<#WeaponRecord> records A read-only list of all @{#WeaponRecord}s in the world database.\n\n---\n-- Whether the object is a Weapon.\n-- @function [parent=#Weapon] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n--- Weapon.TYPE\n-- @type WeaponTYPE\n-- @field #number ShortBladeOneHand\n-- @field #number LongBladeOneHand\n-- @field #number LongBladeTwoHand\n-- @field #number BluntOneHand\n-- @field #number BluntTwoClose\n-- @field #number BluntTwoWide\n-- @field #number SpearTwoWide\n-- @field #number AxeOneHand\n-- @field #number AxeTwoHand\n-- @field #number MarksmanBow\n-- @field #number MarksmanCrossbow\n-- @field #number MarksmanThrown\n-- @field #number Arrow\n-- @field #number Bolt\n\n--- @{#WeaponTYPE}\n-- @field [parent=#Weapon] #WeaponTYPE TYPE\n\n---\n-- Returns the read-only @{#WeaponRecord} of a weapon\n-- @function [parent=#Weapon] record\n-- @param #any objectOrRecordId\n-- @return #WeaponRecord\n\n---\n-- @type WeaponRecord\n-- @field #string id Record id\n-- @field #string name Human-readable name\n-- @field #string model VFS path to the model\n-- @field #string mwscript MWScript on this weapon (can be empty)\n-- @field #string icon VFS path to the icon\n-- @field #string enchant\n-- @field #boolean isMagical\n-- @field #boolean isSilver\n-- @field #number weight\n-- @field #number value\n-- @field #number type See @{#Weapon.TYPE}\n-- @field #number health\n-- @field #number speed\n-- @field #number reach\n-- @field #number enchantCapacity\n-- @field #number chopMinDamage\n-- @field #number chopMaxDamage\n-- @field #number slashMinDamage\n-- @field #number slashMaxDamage\n-- @field #number thrustMinDamage\n-- @field #number thrustMaxDamage\n\n---\n-- Creates a @{#WeaponRecord} without adding it to the world database.\n-- Use @{openmw_world#(world).createRecord} to add the record to the world.\n-- @function [parent=#Weapon] createRecordDraft\n-- @param #WeaponRecord weapon A Lua table with the fields of a WeaponRecord, with an optional field `template` that accepts a @{#WeaponRecord} as a base.\n-- @return #WeaponRecord A strongly typed Weapon record.\n\n--- @{#Apparatus} functions\n-- @field [parent=#types] #Apparatus Apparatus\n\n---\n-- @type Apparatus\n-- @extends #Item\n-- @field #Item baseType @{#Item}\n-- @field #list<#ApparatusRecord> records A read-only list of all @{#ApparatusRecord}s in the world database.\n\n---\n-- Whether the object is an Apparatus.\n-- @function [parent=#Apparatus] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n--- Apparatus.TYPE\n-- @type ApparatusTYPE\n-- @field #number MortarPestle\n-- @field #number Alembic\n-- @field #number Calcinator\n-- @field #number Retort\n\n--- @{#ApparatusTYPE}\n-- @field [parent=#Apparatus] #ApparatusTYPE TYPE\n\n---\n-- Returns the read-only @{#ApparatusRecord} of an apparatus\n-- @function [parent=#Apparatus] record\n-- @param #any objectOrRecordId\n-- @return #ApparatusRecord\n\n---\n-- @type ApparatusRecord\n-- @field #string id The record ID of the apparatus\n-- @field #string name The name of the apparatus\n-- @field #string model VFS path to the model\n-- @field #string mwscript MWScript on this apparatus (can be empty)\n-- @field #string icon VFS path to the icon\n-- @field #number type The type of apparatus. See @{#Apparatus.TYPE}\n-- @field #number weight\n-- @field #number value\n-- @field #number quality The quality of the apparatus\n\n--- @{#Lockpick} functions\n-- @field [parent=#types] #Lockpick Lockpick\n\n---\n-- @type Lockpick\n-- @extends #Item\n-- @field #Item baseType @{#Item}\n-- @field #list<#LockpickRecord> records A read-only list of all @{#LockpickRecord}s in the world database.\n\n---\n-- Whether the object is a Lockpick.\n-- @function [parent=#Lockpick] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Returns the read-only @{#LockpickRecord} of a lockpick\n-- @function [parent=#Lockpick] record\n-- @param #any objectOrRecordId\n-- @return #LockpickRecord\n\n---\n-- @type LockpickRecord\n-- @field #string id The record ID of the lockpick\n-- @field #string name The name of the lockpick\n-- @field #string model VFS path to the model\n-- @field #string mwscript MWScript on this lockpick (can be empty)\n-- @field #string icon VFS path to the icon\n-- @field #number maxCondition The maximum number of uses of this lockpick\n-- @field #number weight\n-- @field #number value\n-- @field #number quality The quality of the lockpick\n\n--- @{#Probe} functions\n-- @field [parent=#types] #Probe Probe\n\n---\n-- @type Probe\n-- @extends #Item\n-- @field #Item baseType @{#Item}\n-- @field #list<#ProbeRecord> records A read-only list of all @{#ProbeRecord}s in the world database.\n\n---\n-- Whether the object is a Probe.\n-- @function [parent=#Probe] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Returns the read-only @{#ProbeRecord} of a probe\n-- @function [parent=#Probe] record\n-- @param #any objectOrRecordId\n-- @return #ProbeRecord\n\n---\n-- @type ProbeRecord\n-- @field #string id The record ID of the probe\n-- @field #string name The name of the probe\n-- @field #string model VFS path to the model\n-- @field #string mwscript MWScript on this probe (can be empty)\n-- @field #string icon VFS path to the icon\n-- @field #number maxCondition The maximum number of uses of this probe\n-- @field #number weight\n-- @field #number value\n-- @field #number quality The quality of the probe\n\n--- @{#Repair} functions\n-- @field [parent=#types] #Repair Repair\n\n---\n-- @type Repair\n-- @extends #Item\n-- @field #Item baseType @{#Item}\n-- @field #list<#RepairRecord> records A read-only list of all @{#RepairRecord}s in the world database.\n\n---\n-- Whether the object is a Repair.\n-- @function [parent=#Repair] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Returns the read-only @{#RepairRecord} of a repair tool\n-- @function [parent=#Repair] record\n-- @param #any objectOrRecordId\n-- @return #RepairRecord\n\n---\n-- @type RepairRecord\n-- @field #string id The record ID of the repair tool\n-- @field #string name The name of the repair tool\n-- @field #string model VFS path to the model\n-- @field #string mwscript MWScript on this repair tool (can be empty)\n-- @field #string icon VFS path to the icon\n-- @field #number maxCondition The maximum number of uses of this repair tool\n-- @field #number weight\n-- @field #number value\n-- @field #number quality The quality of the repair tool\n\n--- @{#Activator} functions\n-- @field [parent=#types] #Activator Activator\n\n---\n-- @type Activator\n-- @field #list<#ActivatorRecord> records A read-only list of all @{#ActivatorRecord}s in the world database.\n\n---\n-- Whether the object is an Activator.\n-- @function [parent=#Activator] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Returns the read-only @{#ActivatorRecord} of an activator\n-- @function [parent=#Activator] record\n-- @param #any objectOrRecordId\n-- @return #ActivatorRecord\n\n---\n-- @type ActivatorRecord\n-- @field #string id Record id\n-- @field #string name Human-readable name\n-- @field #string model VFS path to the model\n-- @field #string mwscript MWScript on this activator (can be empty)\n\n---\n-- Creates a @{#ActivatorRecord} without adding it to the world database.\n-- Use @{openmw_world#(world).createRecord} to add the record to the world.\n-- @function [parent=#Activator] createRecordDraft\n-- @param #ActivatorRecord activator A Lua table with the fields of a ActivatorRecord, with an optional field `template` that accepts a @{#ActivatorRecord} as a base.\n-- @return #ActivatorRecord A strongly typed Activator record.\n\n\n--------------------------------------------------------------------------------\n-- @{#Container} functions\n-- @field [parent=#types] #Container Container\n\n---\n-- @type Container\n-- @extends #Lockable\n-- @field #Lockable baseType @{#Lockable}\n-- @field #list<#ContainerRecord> records A read-only list of all @{#ContainerRecord}s in the world database.\n\n---\n-- Container content.\n-- @function [parent=#Container] content\n-- @param openmw.core#GameObject object\n-- @return openmw.core#Inventory\n\n---\n-- Container content (same as `Container.content`, added for consistency with `Actor.inventory`).\n-- @function [parent=#Container] inventory\n-- @param openmw.core#GameObject object\n-- @return openmw.core#Inventory\n\n---\n-- Whether the object is a Container.\n-- @function [parent=#Container] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Returns the total weight of everything in a container\n-- @function [parent=#Container] getEncumbrance\n-- @param openmw.core#GameObject object\n-- @return #number\n\n---\n-- Returns the capacity of a container\n-- @function [parent=#Container] getCapacity\n-- @param openmw.core#GameObject object\n-- @return #number\n\n---\n-- Returns the read-only @{#ContainerRecord} of a container\n-- @function [parent=#Container] record\n-- @param #any objectOrRecordId\n-- @return #ContainerRecord\n\n---\n-- @type ContainerRecord\n-- @field #string id Record id\n-- @field #string name Human-readable name\n-- @field #string model VFS path to the model\n-- @field #string mwscript MWScript on this container (can be empty)\n-- @field #number weight capacity of this container\n\n\n--------------------------------------------------------------------------------\n-- @{#Door} functions\n-- @field [parent=#types] #Door Door\n\n---\n-- @type Door\n-- @extends #Lockable\n-- @field #Lockable baseType @{#Lockable}\n-- @field #list<#DoorRecord> records A read-only list of all @{#DoorRecord}s in the world database.\n\n---\n-- Whether the object is a Door.\n-- @function [parent=#Door] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Whether the door is a teleport.\n-- @function [parent=#Door] isTeleport\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Destination (only if a teleport door).\n-- @function [parent=#Door] destPosition\n-- @param openmw.core#GameObject object\n-- @return openmw.util#Vector3\n\n---\n-- Destination rotation (only if a teleport door).\n-- @function [parent=#Door] destRotation\n-- @param openmw.core#GameObject object\n-- @return openmw.util#Transform\n\n---\n-- Destination cell (only if a teleport door).\n-- @function [parent=#Door] destCell\n-- @param openmw.core#GameObject object\n-- @return openmw.core#Cell\n\n---\n-- Returns the read-only @{#DoorRecord} of a door\n-- @function [parent=#Door] record\n-- @param #any objectOrRecordId\n-- @return #DoorRecord\n\n---\n-- @type DoorRecord\n-- @field #string id Record id\n-- @field #string name Human-readable name\n-- @field #string model VFS path to the model\n-- @field #string mwscript MWScript on this door (can be empty)\n-- @field #string openSound VFS path to the sound of opening\n-- @field #string closeSound VFS path to the sound of closing\n\n\n\n--- Functions for @{#Static} objects\n-- @field [parent=#types] #Static Static\n\n---\n-- @type Static\n-- @field #list<#StaticRecord> records A read-only list of all @{#StaticRecord}s in the world database.\n\n---\n-- Whether the object is a Static.\n-- @function [parent=#Static] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Returns the read-only @{#StaticRecord} of a Static\n-- @function [parent=#Static] record\n-- @param #any objectOrRecordId\n-- @return #StaticRecord\n\n---\n-- @type StaticRecord\n-- @field #string id Record id\n-- @field #string model VFS path to the model\n\n\n--- @{#CreatureLevelledList} functions\n-- @field [parent=#types] #CreatureLevelledList LevelledCreature\n\n---\n-- @type CreatureLevelledList\n-- @field #list<#CreatureLevelledListRecord> records A read-only list of all @{#CreatureLevelledListRecord}s in the world database.\n\n---\n-- Whether the object is a CreatureLevelledList.\n-- @function [parent=#CreatureLevelledList] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Returns the read-only @{#CreatureLevelledListRecord} of a levelled creature\n-- @function [parent=#CreatureLevelledList] record\n-- @param #any objectOrRecordId\n-- @return #CreatureLevelledListRecord\n\n---\n-- @type CreatureLevelledListRecord\n-- @field #string id Record id\n-- @field #number chanceNone Chance this list won't spawn anything [0-1]\n-- @field #boolean calculateFromAllLevels Calculate from all levels <= player level, not just the closest below player\n-- @field #list<#LevelledListItem> creatures\n\n---\n-- Picks a random id from the levelled list.\n-- @function [parent=#CreatureLevelledListRecord] getRandomId\n-- @param openmw.core#CreatureLevelledListRecord listRecord The list\n-- @param #number MaxLvl The maximum level to select entries for\n-- @return #string An id\n\n---\n-- @type LevelledListItem\n-- @field #string id Item id\n-- @field #number level The minimum player level at which this item can occur\n\n\n--- Functions for @{#ESM4Activator} objects\n-- @field [parent=#types] #ESM4Activator ESM4Activator\n\n--- Functions for @{#ESM4Ammunition} objects\n-- @field [parent=#types] #ESM4Ammunition ESM4Ammunition\n\n--- Functions for @{#ESM4Armor} objects\n-- @field [parent=#types] #ESM4Armor ESM4Armor\n\n--- Functions for @{#ESM4Book} objects\n-- @field [parent=#types] #ESM4Book ESM4Book\n\n--- Functions for @{#ESM4Clothing} objects\n-- @field [parent=#types] #ESM4Clothing ESM4Clothing\n\n--- Functions for @{#ESM4Door} objects\n-- @field [parent=#types] #ESM4Door ESM4Door\n\n--- Functions for @{#ESM4Flora} objects\n-- @field [parent=#types] #ESM4Flora ESM4Flora\n\n--- Functions for @{#ESM4Terminal} objects\n-- @field [parent=#types] #ESM4Terminal ESM4Terminal\n\n--- Functions for @{#ESM4Ingredient} objects\n-- @field [parent=#types] #ESM4Ingredient ESM4Ingredient\n\n--- Functions for @{#ESM4ItemMod} objects\n-- @field [parent=#types] #ESM4ItemMod ESM4ItemMod\n\n--- Functions for @{#ESM4Light} objects\n-- @field [parent=#types] #ESM4Light ESM4Light\n\n--- Functions for @{#ESM4Miscellaneous} objects\n-- @field [parent=#types] #ESM4Miscellaneous ESM4Miscellaneous\n\n--- Functions for @{#ESM4MovableStatic} objects\n-- @field [parent=#types] #ESM4MovableStatic ESM4MovableStatic\n\n--- Functions for @{#ESM4Potion} objects\n-- @field [parent=#types] #ESM4Potion ESM4Potion\n\n--- Functions for @{#ESM4Static} objects\n-- @field [parent=#types] #ESM4Static ESM4Static\n\n--- Functions for @{#ESM4Weapon} objects\n-- @field [parent=#types] #ESM4Weapon ESM4Weapon\n\n---\n-- @type ESM4Terminal\n-- @field #list<#ESM4TerminalRecord> records A read-only list of all @{#ESM4TerminalRecord}s in the world database.\n\n---\n-- Whether the object is a ESM4Terminal.\n-- @function [parent=#ESM4Terminal] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Returns the read-only @{#ESM4TerminalRecord} of a terminal\n-- @function [parent=#ESM4Terminal] record\n-- @param #any objectOrRecordId\n-- @return #ESM4TerminalRecord\n\n---\n-- @type ESM4TerminalRecord\n-- @field #string id Record id (Form ID)\n-- @field #string editorId Human-readable ID\n-- @field #string name Human-readable name\n-- @field #string model VFS path to the model\n-- @field #string text Text body of the terminal record\n-- @field #string resultText Result text of the terminal record\n\n---\n-- @type ESM4Door\n-- @extends #Lockable\n-- @field #Lockable baseType @{#Lockable}\n\n---\n-- Whether the object is a ESM4Door.\n-- @function [parent=#ESM4Door] objectIsInstance\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Whether the door is a teleport.\n-- @function [parent=#ESM4Door] isTeleport\n-- @param openmw.core#GameObject object\n-- @return #boolean\n\n---\n-- Destination (only if a teleport door).\n-- @function [parent=#ESM4Door] destPosition\n-- @param openmw.core#GameObject object\n-- @return openmw.util#Vector3\n\n---\n-- Destination rotation (only if a teleport door).\n-- @function [parent=#ESM4Door] destRotation\n-- @param openmw.core#GameObject object\n-- @return openmw.util#Transform\n\n---\n-- Destination cell (only if a teleport door).\n-- @function [parent=#ESM4Door] destCell\n-- @param openmw.core#GameObject object\n-- @return openmw.core#Cell\n\n---\n-- Returns the read-only @{#ESM4DoorRecord} of a door\n-- @function [parent=#ESM4Door] record\n-- @param #any objectOrRecordId\n-- @return #ESM4DoorRecord\n\n---\n-- Returns a read-only list of all @{#ESM4DoorRecord}s in the world database.\n-- @function [parent=#ESM4Door] records\n-- @return #list<#ESM4DoorRecord>\n\n---\n-- @type ESM4DoorRecord\n-- @field #string id Record id\n-- @field #string name Human-readable name\n-- @field #string model VFS path to the model\n\nreturn nil\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\lua_api\\openmw\\ui.lua": "---\n-- `openmw.ui` controls user interface.\n-- Can be used only by local scripts, that are attached to a player.\n-- @module ui\n-- @usage\n-- local ui = require('openmw.ui')\n\n---\n-- Widget types\n-- @field [parent=#ui] #TYPE TYPE\n\n---\n-- Alignment values (details depend on the specific property). For horizontal alignment the order is left to right, for vertical alignment the order is top to bottom.\n-- @type ALIGNMENT\n-- @field Start\n-- @field Center\n-- @field End\n\n---\n-- Alignment values (left to right, top to bottom)\n-- @field [parent=#ui] #ALIGNMENT ALIGNMENT\n\n---\n-- Tools for working with layers\n-- @field [parent=#ui] #Layers layers\n\n---\n-- All available widget types\n-- @type TYPE\n-- @field Widget Base widget type\n-- @field Text Display text\n-- @field TextEdit Accepts user text input\n-- @field Window Can be moved and resized by the user\n-- @field Image Displays an image\n-- @field Flex Aligns widgets in a row or column\n-- @field Container Automatically wraps around its contents\n\n---\n-- Shows given message at the bottom of the screen.\n-- @function [parent=#ui] showMessage\n-- @param #string msg\n\n---\n-- Predefined colors for console output\n-- @field [parent=#ui] #CONSOLE_COLOR CONSOLE_COLOR\n\n---\n-- Predefined colors for console output\n-- @type CONSOLE_COLOR\n-- @field openmw.util#Color Default\n-- @field openmw.util#Color Error\n-- @field openmw.util#Color Success\n-- @field openmw.util#Color Info\n\n---\n-- Print to the in-game console.\n-- @function [parent=#ui] printToConsole\n-- @param #string msg\n-- @param openmw.util#Color color\n\n---\n-- Set mode of the in-game console.\n-- The mode can be any string, by default is empty.\n-- If not empty, then the console doesn't handle mwscript commands and\n-- instead passes user input to Lua scripts via `onConsoleCommand` engine handler.\n-- @function [parent=#ui] setConsoleMode\n-- @param #string mode\n\n---\n-- Set selected object for console.\n-- @function [parent=#ui] setConsoleSelectedObject\n-- @param openmw.core#GameObject obj\n\n---\n-- Returns the size of the OpenMW window in pixels as a 2D vector.\n-- @function [parent=#ui] screenSize\n-- @return openmw.util#Vector2\n\n---\n-- Converts a given table of tables into an @{openmw.ui#Content}\n-- @function [parent=#ui] content\n-- @param #table table\n-- @return #Content\n\n---\n-- Creates a UI element from the given layout table\n-- @function [parent=#ui] create\n-- @param #Layout layout\n-- @return #Element\n\n---\n-- Adds a settings page to main menu setting's Scripts tab.\n-- @function [parent=#ui] registerSettingsPage\n-- @param #SettingsPageOptions page\n\n---\n-- Table with settings page options, passed as an argument to ui.registerSettingsPage\n-- @type SettingsPageOptions\n-- @field #string name Name of the page, displayed in the list, used for search\n-- @field #string searchHints Additional keywords used in search, not displayed anywhere\n-- @field #Element element The page's UI, which will be attached to the settings tab. The root widget has to have a fixed size. Set the `size` field in `props`, `relativeSize` is ignored.\n\n---\n-- Update all existing UI elements. Potentially extremely slow, so only call this when necessary, e. g. after overriding a template.\n-- @function [parent=#ui] updateAll\n\n---\n-- Layout\n-- @type Layout\n-- @field type Type of the widget, one of the values in #TYPE. Must match the type in #Template if both are present\n-- @field #string layer Optional layout to display in. Only applies for the root widget.\n--   Note: if the #Element isn't attached to anything, it won't be visible!\n-- @field #string name Optional name of the layout. Allows access by name from Content\n-- @field #table props Optional table of widget properties\n-- @field #table events Optional table of event callbacks\n-- @field #Content content Optional @{openmw.ui#Content} of children layouts\n-- @field #Template template Optional #Template\n-- @field #table external Optional table of external properties\n-- @field userData Arbitrary data for you to use, e. g. when receiving the layout in an event callback\n\n---\n-- Template\n-- @type Template\n-- @field #table props\n-- @field #Content content\n-- @field type One of the values in #TYPE, serves as the default value for the #Layout\n\n---\n-- @type Layer\n-- @field #string name Name of the layer\n-- @field openmw.util#Vector2 size Size of the layer in pixels\n\n---\n-- Layers. Implements [iterables#List](iterables.html#List) of #Layer.\n-- @type Layers\n-- @list <#Layer>\n-- @usage\n-- ui.layers.insertAfter('HUD', 'NewLayer', { interactive = true })\n-- local fourthLayer = ui.layers[4]\n-- local windowsIndex = ui.layers.indexOf('Windows')\n-- for i, layer in ipairs(ui.layers) do\n--   print('layer', i, layer.name, layer.size)\n-- end\n\n---\n-- Index of the layer with the given name. Returns nil if the layer doesn't exist\n-- @function [parent=#Layers] indexOf\n-- @param #string name Name of the layer\n-- @return #number, #nil index\n\n---\n-- Creates a layer and inserts it after another layer (shifts indexes of some other layers).\n-- @function [parent=#Layers] insertAfter\n-- @param #string afterName Name of the layer after which the new layer will be inserted\n-- @param #string name Name of the new layer\n-- @param #table options Table with a boolean `interactive` field (default is true). Layers with interactive = false will ignore all mouse interactions.\n\n---\n-- Creates a layer and inserts it before another layer (shifts indexes of some other layers).\n-- @function [parent=#Layers] insertBefore\n-- @param #string beforeName Name of the layer before which the new layer will be inserted\n-- @param #string name Name of the new layer\n-- @param #table options Table with a boolean `interactive` field (default is true). Layers with interactive = false will ignore all mouse interactions.\n\n---\n-- Content. An array-like container, which allows to reference elements by their name.\n-- Implements [iterables#List](iterables.html#List) of #Layout or #Element and [iterables#Map](iterables.html#Map) of #string to #Layout or #Element.\n-- @type Content\n-- @list <#any>\n-- @usage\n-- local content = ui.content {\n--    { name = 'input' },\n-- }\n-- -- bad idea!\n-- -- content[1].name = 'otherInput'\n-- -- do this instead:\n-- content.input = { name = 'otherInput' }\n-- @usage\n-- local content = ui.content {\n--    { name = 'display' },\n--    { name = 'submit' },\n-- }\n-- -- allowed, but shifts all the items after it \"up\" the array\n-- content.display = nil\n-- -- still no holes after this!\n-- @usage\n-- -- iterate over a Content\n-- for i = 1, #content do\n--    print('widget',content[i].name,'at',i)\n-- end\n-- @usage\n-- -- Note: layout names can collide with method names. Because of that you can't use a layout name such as \"insert\":\n-- local content = ui.content {\n--     { name = 'insert '}\n-- }\n-- content.insert.content = ui.content {} -- fails here, content.insert is a function!\n\n---\n-- Content also acts as a map of names to Layouts\n-- @function [parent=#Content] __index\n-- @param self\n-- @param #string name\n-- @return #any\n\n---\n-- Puts the layout at given index by shifting all the elements after it\n-- @function [parent=#Content] insert\n-- @param self\n-- @param #number index\n-- @param #any layoutOrElement\n\n---\n-- Adds the layout at the end of the Content\n-- (same as calling insert with `last index + 1`)\n-- @function [parent=#Content] add\n-- @param self\n-- @param #any layoutOrElement\n\n---\n-- Finds the index of the given layout. If it is not in the container, returns nil\n-- @function [parent=#Content] indexOf\n-- @param self\n-- @param #any layoutOrElement\n-- @return #number, #nil index\n\n---\n-- Element. An element of the user interface\n-- @type Element\n\n---\n-- Refreshes the rendered element to match the current layout state.\n-- Refreshes positions and sizes, but not the layout of the child Elements.\n-- @function [parent=#Element] update\n-- @param self\n\n-- @usage\n-- local child = ui.create {\n--     type = ui.TYPE.Text,\n--     props = {\n--         text = 'child 1',\n--     },\n-- }\n-- local parent = ui.create {\n--     content = ui.content {\n--         child,\n--         {\n--             type = ui.TYPE.Text,\n--             props = {\n--                 text = 'parent 1',\n--             },\n--         }\n--     }\n-- }\n-- -- ...\n-- child.layout.props.text = 'child 2'\n-- parent.layout.content[2].props.text = 'parent 2'\n-- parent:update() -- will show 'parent 2', but 'child 1'\n\n\n---\n-- Destroys the element\n-- @function [parent=#Element] destroy\n-- @param self\n\n---\n-- Access or replace the element's layout\n--   Note: Is reset to `nil` on `destroy`\n-- @field [parent=#Element] #Layout layout\n\n---\n-- Mouse event, passed as an argument to relevant UI events\n-- @type MouseEvent\n-- @field openmw.util#Vector2 position Absolute position of the mouse cursor\n-- @field openmw.util#Vector2 offset Position of the mouse cursor relative to the widget\n-- @field #number button Mouse button which triggered the event.\n--   Matches the arguments of @{openmw_input#input.isMouseButtonPressed} (`nil` for none, 1 for left, 3 for right).\n\n---\n-- Register a new texture resource. Can be used to manually atlas UI textures.\n-- @function [parent=#ui] texture\n-- @param #TextureResourceOptions options\n-- @return #TextureResource\n-- @usage\n-- local ui = require('openmw.ui')\n-- local vector2 = require('openmw.util').vector2\n-- local myAtlas = 'textures/my_atlas.dds' -- a 128x128 atlas\n-- local texture1 = ui.texture { -- texture in the top left corner of the atlas\n--     path = myAtlas,\n--     offset = vector2(0, 0),\n--     size = vector2(64, 64),\n-- }\n-- local texture2 = ui.texture { -- texture in the top right corner of the atlas\n--     path = myAtlas,\n--     offset = vector2(64, 0),\n--     size = vector2(64, 64),\n-- }\n\n---\n-- A texture ready to be used by UI widgets\n-- @type TextureResource\n\n---\n-- Table with arguments passed to ui.texture.\n-- @type TextureResourceOptions\n-- @field #string path Path to the texture file. Required\n-- @field openmw.util#Vector2 offset Offset of this resource in the texture. (0, 0) by default\n-- @field openmw.util#Vector2 size Size of the resource in the texture. (0, 0) by default. 0 means the whole texture size is used.\n\nreturn nil\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\lua_api\\openmw\\util.lua": "---\n-- `openmw.util` defines utility functions and classes like 3D vectors, that don't depend on the game world.\n-- @module util\n-- @usage local util = require('openmw.util')\n\n\n---\n-- Rounds the given value to the nearest whole number.\n-- @function [parent=#util] round\n-- @param #number value\n-- @return #number The rounded value.\n-- @usage\n-- local util = require('openmw.util')\n-- local roundedValue = util.round(3.141592)\n-- print(roundedValue) -- prints 3\n\n---\n-- Remaps the value from one range to another.\n-- @function [parent=#util] remap\n-- @param #number value\n-- @param #number min\n-- @param #number max\n-- @param #number newMin\n-- @param #number newMax\n-- @return #number The remapped value.\n-- @usage\n-- local util = require('openmw.util')\n-- local newValue = util.remap(3, 0, 10, 0, 100)\n-- print(newValue) -- prints 30\n\n---\n-- Limits given value to the interval [`from`, `to`].\n-- @function [parent=#util] clamp\n-- @param #number value\n-- @param #number from\n-- @param #number to\n-- @return #number min(max(value, from), to)\n\n---\n-- Adds `2pi*k` and puts the angle in range `[-pi, pi]`.\n-- @function [parent=#util] normalizeAngle\n-- @param #number angle Angle in radians\n-- @return #number Angle in range `[-pi, pi]`\n\n---\n-- Makes a table read only.\n-- @function [parent=#util] makeReadOnly\n-- @param #table table Any table.\n-- @return #table The same table wrapped with read only userdata.\n\n---\n-- Makes a table read only and overrides `__index` with the strict version that throws an error if the key is not found.\n-- @function [parent=#util] makeStrictReadOnly\n-- @param #table table Any table.\n-- @return #table The same table wrapped with read only userdata.\n\n---\n-- Parses Lua code from string and returns as a function.\n-- @function [parent=#util] loadCode\n-- @param #string code Lua code.\n-- @param #table table Environment to run the code in.\n-- @return #function The loaded code.\n\n---\n-- Bitwise And (supports any number of arguments).\n-- @function [parent=#util] bitAnd\n-- @param #number A First argument (integer).\n-- @param #number B Second argument (integer).\n-- @return #number Bitwise And of A and B.\n\n---\n-- Bitwise Or (supports any number of arguments).\n-- @function [parent=#util] bitOr\n-- @param #number A First argument (integer).\n-- @param #number B Second argument (integer).\n-- @return #number Bitwise Or of A and B.\n\n---\n-- Bitwise Xor (supports any number of arguments).\n-- @function [parent=#util] bitXor\n-- @param #number A First argument (integer).\n-- @param #number B Second argument (integer).\n-- @return #number Bitwise Xor of A and B.\n\n---\n-- Bitwise inversion.\n-- @function [parent=#util] bitNot\n-- @param #number A Argument (integer).\n-- @return #number Bitwise Not of A.\n\n\n---\n-- Immutable 2D vector\n-- @type Vector2\n-- @field #number x\n-- @field #number y\n-- @usage\n-- v = util.vector2(3, 4)\n-- v.x, v.y       -- 3.0, 4.0\n-- str(v)         -- \"(3.0, 4.0)\"\n-- v:length()     -- 5.0    length\n-- v:length2()    -- 25.0   square of the length\n-- v:normalize()  -- vector2(3/5, 4/5)\n-- v:rotate(radians)    -- rotate counterclockwise (returns rotated vector)\n-- v1:dot(v2)     -- dot product (returns a number)\n-- v1 * v2        -- dot product\n-- v1 + v2        -- vector addition\n-- v1 - v2        -- vector subtraction\n-- v1 * x         -- multiplication by a number\n-- v1 / x         -- division by a number\n\n---\n-- Creates a new 2D vector. Vectors are immutable and can not be changed after creation.\n-- @function [parent=#util] vector2\n-- @param #number x.\n-- @param #number y.\n-- @return #Vector2.\n\n---\n-- @function [parent=#Vector2] __add\n-- @param self\n-- @param #Vector2 v\n-- @return #Vector2 sum of the vectors\n\n---\n-- @function [parent=#Vector2] __sub\n-- @param self\n-- @param #Vector2 v\n-- @return #Vector2 difference of the vectors\n\n---\n-- @function [parent=#Vector2] __mul\n-- @param self\n-- @param #number k\n-- @return #Vector2 vector multiplied by a number\n\n---\n-- @function [parent=#Vector2] __div\n-- @param self\n-- @param #number k\n-- @return #Vector2 vector divided by a number\n\n---\n-- Length of the vector.\n-- @function [parent=#Vector2] length\n-- @param self\n-- @return #number\n\n---\n-- Square of the length of the vector.\n-- @function [parent=#Vector2] length2\n-- @param self\n-- @return #number\n\n---\n-- Normalizes vector.\n-- It doesn't change the original vector.\n-- @function [parent=#Vector2] normalize\n-- @param self\n-- @return #Vector2 normalized vector\n-- @return #number the length of the original vector\n\n---\n-- Rotates 2D vector clockwise.\n-- @function [parent=#Vector2] rotate\n-- @param self\n-- @param #number angle Angle in radians\n-- @return #Vector2 Rotated vector.\n\n---\n-- Dot product.\n-- @function [parent=#Vector2] dot\n-- @param self\n-- @param #Vector2 v\n-- @return #number\n\n---\n-- Element-wise multiplication\n-- @function [parent=#Vector2] emul\n-- @param self\n-- @param #Vector2 v\n-- @return #Vector2\n\n---\n-- Element-wise division\n-- @function [parent=#Vector2] ediv\n-- @param self\n-- @param #Vector2 v\n-- @return #Vector2\n\n\n---\n-- Immutable 3D vector\n-- @type Vector3\n-- @field #number x\n-- @field #number y\n-- @field #number z\n-- @usage\n-- v = util.vector3(3, 4, 5)\n-- v.x, v.y, v.z  -- 3.0, 4.0, 5.0\n-- str(v)         -- \"(3.0, 4.0, 4.5)\"\n-- v:length()     -- length\n-- v:length2()    -- square of the length\n-- v:normalize()  -- normalized vector\n-- v1:dot(v2)     -- dot product (returns a number)\n-- v1 * v2        -- dot product (returns a number)\n-- v1:cross(v2)   -- cross product (returns a vector)\n-- v1 ^ v2        -- cross product (returns a vector)\n-- v1 + v2        -- vector addition\n-- v1 - v2        -- vector subtraction\n-- v1 * x         -- multiplication by a number\n-- v1 / x         -- division by a number\n\n---\n-- Creates a new 3D vector. Vectors are immutable and can not be changed after creation.\n-- @function [parent=#util] vector3\n-- @param #number x.\n-- @param #number y.\n-- @param #number z.\n-- @return #Vector3.\n\n---\n-- @function [parent=#Vector3] __add\n-- @param self\n-- @param #Vector3 v\n-- @return #Vector3 sum of the vectors\n\n---\n-- @function [parent=#Vector3] __sub\n-- @param self\n-- @param #Vector3 v\n-- @return #Vector3 difference of the vectors\n\n---\n-- @function [parent=#Vector3] __mul\n-- @param self\n-- @param #number k\n-- @return #Vector3 vector multiplied by a number\n\n---\n-- @function [parent=#Vector3] __div\n-- @param self\n-- @param #number k\n-- @return #Vector3 vector divided by a number\n\n---\n-- @function [parent=#Vector3] __tostring\n-- @param self\n-- @return #string\n\n---\n-- Length of the vector\n-- @function [parent=#Vector3] length\n-- @param self\n-- @return #number\n\n---\n-- Square of the length of the vector\n-- @function [parent=#Vector3] length2\n-- @param self\n-- @return #number\n\n---\n-- Normalizes vector.\n-- It doesn't change the original vector.\n-- @function [parent=#Vector3] normalize\n-- @param self\n-- @return #Vector3 normalized vector\n-- @return #number the length of the original vector\n\n---\n-- Dot product.\n-- @function [parent=#Vector3] dot\n-- @param self\n-- @param #Vector3 v\n-- @return #number\n\n---\n-- Cross product.\n-- @function [parent=#Vector3] cross\n-- @param self\n-- @param #Vector3 v\n-- @return #Vector3\n\n---\n-- Element-wise multiplication\n-- @function [parent=#Vector3] emul\n-- @param self\n-- @param #Vector3 v\n-- @return #Vector3\n\n---\n-- Element-wise division\n-- @function [parent=#Vector3] ediv\n-- @param self\n-- @param #Vector3 v\n-- @return #Vector3\n\n\n---\n-- Immutable 4D vector.\n-- @type Vector4\n-- @field #number x\n-- @field #number y\n-- @field #number z\n-- @field #number w\n-- @usage\n-- v = util.vector4(3, 4, 5, 6)\n-- v.x, v.y, v.z, v.w  -- 3.0, 4.0, 5.0, 6.0\n-- str(v)         -- \"(3.0, 4.0, 5.0, 6.0)\"\n-- v:length()     -- length\n-- v:length2()    -- square of the length\n-- v:normalize()  -- normalized vector\n-- v1:dot(v2)     -- dot product (returns a number)\n-- v1 * v2        -- dot product (returns a number)\n-- v1 + v2        -- vector addition\n-- v1 - v2        -- vector subtraction\n-- v1 * x         -- multiplication by a number\n-- v1 / x         -- division by a number\n\n---\n-- Creates a new 4D vector. Vectors are immutable and can not be changed after creation.\n-- @function [parent=#util] vector4\n-- @param #number x.\n-- @param #number y.\n-- @param #number z.\n-- @param #number w.\n-- @return #Vector4.\n\n---\n-- @function [parent=#Vector4] __add\n-- @param self\n-- @param #Vector4 v\n-- @return #Vector4 sum of the vectors\n\n---\n-- @function [parent=#Vector4] __sub\n-- @param self\n-- @param #Vector4 v\n-- @return #Vector4 difference of the vectors\n\n---\n-- @function [parent=#Vector4] __mul\n-- @param self\n-- @param #number k\n-- @return #Vector4 vector multiplied by a number\n\n---\n-- @function [parent=#Vector4] __div\n-- @param self\n-- @param #number k\n-- @return #Vector4 vector divided by a number\n\n---\n-- @function [parent=#Vector4] __tostring\n-- @param self\n-- @return #string\n\n---\n-- Length of the vector\n-- @function [parent=#Vector4] length\n-- @param self\n-- @return #number\n\n---\n-- Square of the length of the vector\n-- @function [parent=#Vector4] length2\n-- @param self\n-- @return #number\n\n---\n-- Normalizes vector.\n-- It doesn't change the original vector.\n-- @function [parent=#Vector4] normalize\n-- @param self\n-- @return #Vector4 normalized vector\n-- @return #number the length of the original vector\n\n---\n-- Dot product.\n-- @function [parent=#Vector4] dot\n-- @param self\n-- @param #Vector4 v\n-- @return #number\n\n---\n-- Element-wise multiplication\n-- @function [parent=#Vector4] emul\n-- @param self\n-- @param #Vector4 v\n-- @return #Vector4\n\n---\n-- Element-wise division\n-- @function [parent=#Vector4] ediv\n-- @param self\n-- @param #Vector4 v\n-- @return #Vector4\n\n---\n-- Immutable box.\n-- @type Box\n-- @field #Vector3 center The center of the box\n-- @field #Vector3 halfSize The half sizes of the box along each axis\n-- @field #Transform transform A transformation which encapsulates the boxes center pointer (translation), half sizes (scale), and rotation.\n-- @field #table vertices Table of the 8 vertices which comprise the box, taking rotation into account\n\n---\n-- Creates a new Box with a given center and half sizes. Boxes are immutable and can not be changed after creation.\n-- @function [parent=#util] box\n-- @param #Vector3 center\n-- @param #Vector3 halfSize in each dimension (x, y, z)\n-- @return #Box\n\n---\n-- Creates a new Box from a given transformation. Boxes are immutable and can not be changed after creation.\n-- @function [parent=#util] box\n-- @param #Transform transform A transformation which encapsulates the boxes center pointer (translation), half sizes (scale), and rotation.\n-- @return #Box\n-- @usage\n-- -- Creates a 1x1x1 length box centered at the origin\n-- util.box(util.transform.scale(util.vector3(0.5, 0.5, 0.5)))\n\n---\n-- Color in RGBA format. All of the component values are in the range [0, 1].\n-- @type Color\n-- @field #number r Red component\n-- @field #number g Green component\n-- @field #number b Blue component\n-- @field #number a Alpha (transparency) component\n\n---\n-- Returns a Vector4 with RGBA components of the Color.\n-- @function [parent=#Color] asRgba\n-- @param self\n-- @return #Vector4\n\n---\n-- Returns a Vector3 with RGB components of the Color.\n-- @function [parent=#Color] asRgb\n-- @param self\n-- @return #Vector3\n\n---\n-- Converts the color into a HEX string.\n-- @function [parent=#Color] asHex\n-- @param self\n-- @return #string\n\n---\n-- Methods for creating #Color values from different formats.\n-- @type COLOR\n\n---\n-- Methods for creating #Color values from different formats.\n-- @field [parent=#util] #COLOR color\n\n---\n-- Creates a Color from RGBA format\n-- @function [parent=#COLOR] rgba\n-- @param #number r\n-- @param #number g\n-- @param #number b\n-- @param #number a\n-- @return #Color\n\n---\n-- Creates a Color from RGB format. Equivalent to calling util.rgba with a = 1.\n-- @function [parent=#COLOR] rgb\n-- @param #number r\n-- @param #number g\n-- @param #number b\n-- @return #Color\n\n---\n-- Parses a hex color string into a Color.\n-- @function [parent=#COLOR] hex\n-- @param #string hex A hex color string in RRGGBB format (e. g. \"ff0000\").\n-- @return #Color\n\n---\n-- @type Transform\n\n---\n-- Combine transforms (will apply in reverse order)\n-- @function [parent=#Transform] __mul\n-- @param self\n-- @param #Transform t\n-- @return #Transform\n\n---\n-- Returns the inverse transform.\n-- @function [parent=#Transform] inverse\n-- @param self\n-- @return #Transform\n\n---\n-- Apply transform to a vector\n-- @function [parent=#Transform] apply\n-- @param self\n-- @param #Vector3 v\n-- @return #Vector3\n\n---\n-- Get yaw angle (radians)\n-- @function [parent=#Transform] getYaw\n-- @param self\n-- @return #number\n\n---\n-- Get pitch angle (radians)\n-- @function [parent=#Transform] getPitch\n-- @param self\n-- @return #number\n\n---\n-- Get Euler angles for XZ rotation order (pitch and yaw; radians)\n-- @function [parent=#Transform] getAnglesXZ\n-- @param self\n-- @return #number pitch (rotation around X axis)\n-- @return #number yaw (rotation around Z axis)\n\n---\n-- Get Euler angles for ZYX rotation order (radians)\n-- @function [parent=#Transform] getAnglesZYX\n-- @param self\n-- @return #number rotation around Z axis (first rotation)\n-- @return #number rotation around Y axis (second rotation)\n-- @return #number rotation around X axis (third rotation)\n\n---\n-- @type TRANSFORM\n-- @field [parent=#TRANSFORM] #Transform identity Empty transform.\n\n---\n-- Movement by given vector.\n-- @function [parent=#TRANSFORM] move\n-- @param #Vector3 offset\n-- @return #Transform\n-- @usage\n-- -- Accepts either 3 numbers or a 3D vector\n-- util.transform.move(x, y, z)\n-- util.transform.move(util.vector3(x, y, z))\n\n---\n-- Scale transform.\n-- @function [parent=#TRANSFORM] scale\n-- @param #number scaleX.\n-- @param #number scaleY.\n-- @param #number scaleZ.\n-- @return #Transform.\n-- @usage\n-- -- Accepts either 3 numbers or a 3D vector\n-- util.transform.scale(x, y, z)\n-- util.transform.scale(util.vector3(x, y, z))\n\n\n---\n-- Rotation around a vector (counterclockwise if the vector points to us).\n-- @function [parent=#TRANSFORM] rotate\n-- @param #number angle\n-- @param #Vector3 axis.\n-- @return #Transform.\n\n---\n-- X-axis rotation (equivalent to `rotate(angle, vector3(-1, 0, 0))`).\n-- @function [parent=#TRANSFORM] rotateX\n-- @param #number angle\n-- @return #Transform.\n\n---\n-- Y-axis rotation (equivalent to `rotate(angle, vector3(0, -1, 0))`).\n-- @function [parent=#TRANSFORM] rotateY\n-- @param #number angle\n-- @return #Transform.\n\n---\n-- Z-axis rotation (equivalent to `rotate(angle, vector3(0, 0, -1))`).\n-- @function [parent=#TRANSFORM] rotateZ\n-- @param #number angle\n-- @return #Transform.\n\n---\n-- 3D transforms (scale/move/rotate) that can be applied to 3D vectors.\n-- Several transforms can be combined and applied to a vector using multiplication.\n-- Combined transforms apply in reverse order (from right to left).\n-- @field [parent=#util] #TRANSFORM transform\n-- @usage\n-- local util = require('openmw.util')\n-- local trans = util.transform\n-- local fromActorSpace = trans.move(actor.position) * trans.rotateZ(actor.rotation:getYaw())\n--\n-- -- rotation is applied first, movement is second\n-- local posBehindActor = fromActorSpace * util.vector3(0, -100, 0)\n--\n-- -- equivalent to trans.rotateZ(-actor.rotation:getYaw()) * trans.move(-actor.position)\n-- local toActorSpace = fromActorSpace:inverse()\n-- local relativeTargetPos = toActorSpace * target.position\n-- local deltaAngle = math.atan2(relativeTargetPos.y, relativeTargetPos.x)\n\nreturn nil\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\lua_api\\openmw\\vfs.lua": "---\n-- `openmw.vfs` provides read-only access to data directories via VFS.\n-- Interface is very similar to \"io\" library.\n-- @module vfs\n-- @usage local vfs = require('openmw.vfs')\n\n\n\n---\n-- @type FileHandle\n-- @field #string fileName VFS path to related file\n\n---\n-- Close a file handle\n-- @function [parent=#FileHandle] close\n-- @param self\n-- @return #boolean true if a call succeeds without errors.\n-- @return #nil, #string nil plus the error message in case of any error.\n\n---\n-- Get an iterator function to fetch the next line from given file.\n-- Throws an exception if file is closed.\n--\n-- Hint: since garbage collection works once per frame,\n-- you will get the whole file in RAM if you read it in one frame.\n-- So if you need to read a really large file, it is better to split reading\n-- between different frames (e.g. by keeping a current position in file\n-- and using a \"seek\" to read from saved position).\n-- @function [parent=#FileHandle] lines\n-- @param self\n-- @return #function Iterator function to get next line\n-- @usage f = vfs.open(\"Test\\\\test.txt\");\n-- for line in f:lines() do\n--     print(line);\n-- end\n\n---\n-- Set new position in file.\n-- Throws an exception if file is closed or seek base is incorrect.\n-- @function [parent=#FileHandle] seek\n-- @param self\n-- @param #string whence Seek base (optional, \"cur\" by default). Can be:\n--\n--   * \"set\" - seek from beginning of file;\n--   * \"cur\" - seek from current position;\n--   * \"end\" - seek from end of file (offset needs to be <= 0);\n-- @param #number offset Offset from given base (optional, 0 by default)\n-- @return #number new position in file if a call succeeds without errors.\n-- @return #nil, #string nil plus the error message in case of any error.\n-- @usage -- set pointer to beginning of file\n-- f = vfs.open(\"Test\\\\test.txt\");\n-- f:seek(\"set\");\n-- @usage -- print current position in file\n-- f = vfs.open(\"Test\\\\test.txt\");\n-- print(f:seek());\n-- @usage -- print file size\n-- f = vfs.open(\"Test\\\\test.txt\");\n-- print(f:seek(\"end\"));\n\n---\n-- Read data from file to strings.\n-- Throws an exception if file is closed, if there is too many arguments or if an invalid format encountered.\n--\n-- Hint: since garbage collection works once per frame,\n-- you will get the whole file in RAM if you read it in one frame.\n-- So if you need to read a really large file, it is better to split reading\n-- between different frames (e.g. by keeping a current position in file\n-- and using a \"seek\" to read from saved position).\n-- @function [parent=#FileHandle] read\n-- @param self\n-- @param ... Read formats (up to 20 arguments, default value is one \"*l\"). Can be:\n--\n--   * \"\\*a\" (or \"*all\") - reads the whole file, starting at the current position as #string. On end of file, it returns the empty string.\n--   * \"\\*l\" (or \"*line\") - reads the next line (skipping the end of line), returning nil on end of file (nil and error message if error occured);\n--   * \"\\*n\" (or \"*number\") - read a floating point value as #number (nil and error message if error occured);\n--   * number - reads a #string with up to this number of characters, returning nil on end of file (nil and error message if error occured). If number is 0 and end of file is not reached, it reads nothing and returns an empty string;\n-- @return #string One #string for every format if a call succeeds without errors. One #string for every successfully handled format, nil for first failed format.\n-- @usage -- read three numbers from file\n-- f = vfs.open(\"Test\\\\test.txt\");\n-- local n1, n2, n3 = f:read(\"*number\", \"*number\", \"*number\");\n-- @usage -- read 10 bytes from file\n-- f = vfs.open(\"Test\\\\test.txt\");\n-- local n4 = f:read(10);\n-- @usage -- read until end of file\n-- f = vfs.open(\"Test\\\\test.txt\");\n-- local n5 = f:read(\"*all\");\n-- @usage -- read a line from file\n-- f = vfs.open(\"Test\\\\test.txt\");\n-- local n6 = f:read();\n-- @usage -- try to read three numbers from file with \"1\" content\n-- f = vfs.open(\"one.txt\");\n-- print(f:read(\"*number\", \"*number\", \"*number\"));\n-- -- prints(1, nil)\n\n---\n-- Check if file exists in VFS\n-- @function [parent=#vfs] fileExists\n-- @param #string fileName Path to file in VFS\n-- @return #boolean (true - exists, false - does not exist)\n-- @usage local exists = vfs.fileExists(\"Test\\\\test.txt\");\n\n---\n-- Open a file\n-- @function [parent=#vfs] open\n-- @param #string fileName Path to file in VFS\n-- @return #FileHandle Opened file handle if a call succeeds without errors.\n-- @return #nil, #string nil plus the error message in case of any error.\n-- @usage f, msg = vfs.open(\"Test\\\\test.txt\");\n-- -- print file name or error message\n-- if (f == nil)\n--     print(msg);\n-- else\n--     print(f.fileName);\n-- end\n\n---\n-- Get an iterator function to fetch the next line from file with given path.\n-- Throws an exception if file is closed or file with given path does not exist.\n-- Closes file automatically when it fails to read any more bytes.\n--\n-- Hint: since garbage collection works once per frame,\n-- you will get the whole file in RAM if you read it in one frame.\n-- So if you need to read a really large file, it is better to split reading\n-- between different frames (e.g. by keeping a current position in file\n-- and using a \"seek\" to read from saved position).\n-- @function [parent=#vfs] lines\n-- @param #string fileName Path to file in VFS\n-- @return #function Iterator function to get next line\n-- @usage for line in vfs.lines(\"Test\\\\test.txt\") do\n--     print(line);\n-- end\n\n---\n-- Get iterator function to fetch file names with given path prefix from VFS\n-- @function [parent=#vfs] pathsWithPrefix\n-- @param #string path Path prefix\n-- @return #function Function to get next file name\n-- @usage -- get all files with given prefix from VFS index\n-- for fileName in vfs.pathsWithPrefix(\"Music\\\\Explore\") do\n--     print(fileName);\n-- end\n-- @usage -- get some first files\n-- local getNextFile = vfs.pathsWithPrefix(\"Music\\\\Explore\");\n-- local firstFile = getNextFile();\n-- local secondFile = getNextFile();\n\n---\n-- Detect a file handle type\n-- @function [parent=#vfs] type\n-- @param #any handle Object to check\n-- @return #string File handle type. Can be:\n--\n--   * \"file\" - an argument is a valid opened @{openmw.vfs#FileHandle};\n--   * \"closed file\" - an argument is a valid closed @{openmw.vfs#FileHandle};\n--   * nil - an argument is not a @{openmw.vfs#FileHandle};\n-- @usage f = vfs.open(\"Test\\\\test.txt\");\n-- print(vfs.type(f));\n\nreturn nil\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\lua_api\\openmw\\world.lua": "---\n-- `openmw.world` is an interface to the game world for global scripts.\n-- Can not be used from local scripts.\n-- @module world\n-- @usage local world = require('openmw.world')\n\n\n\n---\n-- List of currently active actors.\n-- @field [parent=#world] openmw.core#ObjectList activeActors\n\n---\n-- List of players. Currently (since multiplayer is not yet implemented) always has one element.\n-- @field [parent=#world] openmw.core#ObjectList players\n\n---\n-- Functions related to MWScript (see @{#MWScriptFunctions}).\n-- @field [parent=#world] #MWScriptFunctions mwscript\n\n---\n-- Functions related to MWScript.\n-- @type MWScriptFunctions\n\n---\n-- @type MWScriptVariables\n-- @map <#string, #number>\n\n---\n-- Returns local mwscript on ``object``. Returns `nil` if the script doesn't exist or is not started.\n-- @function [parent=#MWScriptFunctions] getLocalScript\n-- @param openmw.core#GameObject object\n-- @param openmw.core#GameObject player (optional) Will be used in multiplayer mode to get the script if there is a separate instance for each player. Currently has no effect.\n-- @return #MWScript, #nil\n\n---\n-- Returns mutable global variables. In multiplayer, these may be specific to the provided player.\n-- @function [parent=#MWScriptFunctions] getGlobalVariables\n-- @param openmw.core#GameObject player (optional) Will be used in multiplayer mode to get the globals if there is a separate instance for each player. Currently has no effect.\n-- @return #MWScriptVariables\n\n---\n-- Returns global mwscript with given recordId. Returns `nil` if the script doesn't exist or is not started.\n-- Currently there can be only one instance of each mwscript, but in multiplayer it will be possible to have a separate instance per player.\n-- @function [parent=#MWScriptFunctions] getGlobalScript\n-- @param #string recordId\n-- @param openmw.core#GameObject player (optional) Will be used in multiplayer mode to get the script if there is a separate instance for each player. Currently has no effect.\n-- @return #MWScript, #nil\n\n---\n-- @type MWScript\n-- @field #string recordId Id of the script\n-- @field openmw.core#GameObject object The object the script is attached to.\n-- @field openmw.core#GameObject player The player the script refers to.\n-- @field #MWScriptVariables variables Local variables of the script (mutable)\n-- @usage\n-- for _, script in ipairs(world.mwscript.getLocalScripts(object)) do\n--   -- print the value of local variable 'something' (0 if there is no such variable)\n--   print(script.variables.something)\n--   -- set the variable 'something' (raises an error if there is no such variable)\n--   script.variables.something = 5\n-- end\n\n---\n-- Loads a named cell\n-- @function [parent=#world] getCellByName\n-- @param #string cellName\n-- @return openmw.core#Cell\n\n---\n-- Loads an exterior cell by grid indices\n-- @function [parent=#world] getExteriorCell\n-- @param #number gridX\n-- @param #number gridY\n-- @param #any cellOrName (optional) other cell or cell name in the same exterior world space\n-- @return openmw.core#Cell\n\n---\n-- List of all cells\n-- @field [parent=#world] #list<openmw.core#Cell> cells\n-- @usage for i, cell in ipairs(world.cells) do print(cell) end\n\n---\n-- Simulation time in seconds.\n-- The number of simulation seconds passed in the game world since starting a new game.\n-- @function [parent=#world] getSimulationTime\n-- @return #number\n\n---\n-- The scale of simulation time relative to real time.\n-- @function [parent=#world] getSimulationTimeScale\n-- @return #number\n\n---\n-- Set the simulation time scale.\n-- @function [parent=#world] setSimulationTimeScale\n-- @param #number scale\n\n---\n-- Game time in seconds.\n-- @function [parent=#world] getGameTime\n-- @return #number\n\n---\n-- The scale of game time relative to simulation time.\n-- @function [parent=#world] getGameTimeScale\n-- @return #number\n\n---\n-- Set the ratio of game time speed to simulation time speed.\n-- @function [parent=#world] setGameTimeScale\n-- @param #number ratio\n\n---\n-- Whether the world is paused (onUpdate doesn't work when the world is paused).\n-- @function [parent=#world] isWorldPaused\n-- @return #boolean\n\n---\n-- Pause the game starting from the next frame.\n-- @function [parent=#world] pause\n-- @param #string tag (optional, empty string by default) The game will be paused until `unpause` is called with the same tag.\n\n---\n-- Remove given tag from the list of pause tags. Resume the game starting from the next frame if the list became empty.\n-- @function [parent=#world] unpause\n-- @param #string tag (optional, empty string by default) Needed to undo `pause` called with this tag.\n\n---\n-- The tags that are currently pausing the game.\n-- @function [parent=#world] getPausedTags\n-- @return #table\n\n---\n-- Return an object by RefNum/FormId.\n-- Note: the function always returns @{openmw.core#GameObject} and doesn't validate that\n-- the object exists in the game world. If it doesn't exist or not yet loaded to memory),\n-- then `obj:isValid()` will be `false`.\n-- @function [parent=#world] getObjectByFormId\n-- @param #string formId String returned by `core.getFormId`\n-- @return openmw.core#GameObject\n-- @usage local obj = world.getObjectByFormId(core.getFormId('Morrowind.esm', 128964))\n\n---\n-- Create a new instance of the given record.\n-- After creation the object is in the disabled state. Use :teleport to place to the world or :moveInto to put it into a container or an inventory.\n-- Note that dynamically created creatures, NPCs, and container inventories will not respawn.\n-- @function [parent=#world] createObject\n-- @param #string recordId Record ID in lowercase\n-- @param #number count (optional, 1 by default) The number of objects in stack\n-- @return openmw.core#GameObject\n-- @usage  -- put 100 gold on the ground at the position of `actor`\n-- money = world.createObject('gold_001', 100)\n-- money:teleport(actor.cell.name, actor.position)\n-- @usage -- put 50 gold into the actor's inventory\n-- money = world.createObject('gold_001', 50)\n-- money:moveInto(types.Actor.inventory(actor))\n\n---\n-- Creates a custom record in the world database.\n-- Eventually meant to support all records, but the current\n-- set of supported types is limited to:\n--\n-- * @{openmw.types#PotionRecord},\n-- * @{openmw.types#ArmorRecord},\n-- * @{openmw.types#BookRecord},\n-- * @{openmw.types#MiscellaneousRecord},\n-- * @{openmw.types#ClothingRecord},\n-- * @{openmw.types#WeaponRecord},\n-- * @{openmw.types#ActivatorRecord}\n-- @function [parent=#world] createRecord\n-- @param #any record A record to be registered in the database. Must be one of the supported types.\n-- @return #any A new record added to the database. The type is the same as the input's.\n\nreturn nil\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\lua_libs\\content.lua": "local M = {}\nM.__Content = true\n\nfunction validateContentChild(v)\n    if not (type(v) == 'table' or v.__type and v.__type.name == 'LuaUi::Element') then\n        error('Content can only contain tables and Elements')\n    end\nend\n\nM.new = function(source)\n    local result = {}\n    result.__nameIndex = {}\n    for i, v in ipairs(source) do\n        validateContentChild(v)\n        result[i] = v\n        if type(v.name) == 'string' then\n            result.__nameIndex[v.name] = i\n        end\n    end\n    return setmetatable(result, M)\nend\nlocal function validateIndex(self, index)\n    if type(index) ~= 'number' then\n        error('Unexpected Content key: ' .. tostring(index))\n    end\n    if index < 1 or (#self + 1) < index then\n        error('Invalid Content index: ' .. tostring(index))\n    end\nend\n\nlocal function getIndexFromKey(self, key)\n    local index = key\n    if type(key) == 'string' then\n        index = self.__nameIndex[key]\n        if not index then\n            error('Unexpected content key:' .. key)\n        end\n    end\n    validateIndex(self, index)\n    return index\nend\n\nlocal methods = {\n    insert = function(self, index, value)\n        validateIndex(self, index)\n        validateContentChild(value)\n        for i = #self, index, -1 do\n            rawset(self, i + 1, rawget(self, i))\n            local name = rawget(self, i + 1)\n            if name then\n                self.__nameIndex[name] = i + 1\n            end\n        end\n        rawset(self, index, value)\n        if value.name then\n            self.__nameIndex[value.name] = index\n        end\n    end,\n    indexOf = function(self, value)\n        if type(value) == 'string' then\n            return self.__nameIndex[value]\n        else\n            for i = 1, #self do\n                if rawget(self, i) == value then\n                    return i\n                end\n            end\n        end\n        return nil\n    end,\n    add = function(self, value)\n        self:insert(#self + 1, value)\n        return #self\n    end,\n}\nM.__index = function(self, key)\n    if methods[key] then return methods[key] end\n    local index = getIndexFromKey(self, key)\n    return rawget(self, index)\nend\nlocal function nameAt(self, index)\n    local v = rawget(self, index)\n    return v and type(v.name) == 'string' and v.name\nend\n\nlocal function remove(self, index)\n    local oldName = nameAt(self, index)\n    if oldName then\n        self.__nameIndex[oldName] = nil\n    end\n    if index > #self then\n        error('Invalid Content index:' .. tostring(index))\n    end\n    for i = index, #self - 1 do\n        local v = rawget(self, i + 1)\n        rawset(self, i, v)\n        if type(v.name) == 'string' then\n            self.__nameIndex[v.name] = i\n        end\n    end\n    rawset(self, #self, nil)\nend\n\nlocal function assign(self, index, value)\n    local oldName = nameAt(self, index)\n    if oldName then\n        self.__nameIndex[oldName] = nil\n    end\n    rawset(self, index, value)\n    if value.name then\n        self.__nameIndex[value.name] = index\n    end\nend\n\nM.__newindex = function(self, key, value)\n    local index = getIndexFromKey(self, key)\n    if value == nil then\n        remove(self, index)\n    else\n        validateContentChild(value)\n        assign(self, index, value)\n    end\nend\nM.__tostring = function(self)\n    return ('UiContent{%d layouts}'):format(#self)\nend\nlocal function next(self, index)\n    local v = rawget(self, index)\n    if v then\n        return index + 1, v\n    else\n        return nil, nil\n    end\nend\n\nM.__pairs = function(self)\n    return next, self, 1\nend\nM.__ipairs = M.__pairs\nM.__metatable = false\n\nreturn M\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\openmw_aux\\calendar.lua": "---\n-- `openmw_aux.calendar` defines utility functions for formatting game time.\n-- Implementation can be found in `resources/vfs/openmw_aux/calendar.lua`.\n-- @module calendar\n-- @usage local calendar = require('openmw_aux.calendar')\n\nlocal core = require('openmw.core')\nlocal time = require('openmw_aux.time')\nlocal conf = require('openmw_aux.calendarconfig')\nlocal l10n = core.l10n('Calendar')\n\nlocal monthsDuration = conf.monthsDuration\nlocal daysInYear = 0\nfor _, d in ipairs(monthsDuration) do daysInYear = daysInYear + d end\n\nlocal function gameTime(t)\n    if not t then\n        return core.getGameTime()\n    else\n        local days = (t.year or 0) * daysInYear + (t.day or 0)\n        for i = 1, (t.month or 1)-1 do\n            days = days + monthsDuration[i]\n        end\n        return days * time.day + (t.hour or 0) * time.hour +\n               (t.min or 0) * time.minute + (t.sec or 0) * time.second\n    end\nend\n\nlocal function defaultDateFormat(t)\n    return l10n('dateFormat', {\n        day = t.day,\n        month = l10n('month' .. t.month),\n        monthInGenitive = l10n('monthInGenitive' .. t.month),\n        year = t.year,\n    })\nend\n\nlocal function formatGameTime(formatStr, timestamp)\n    timestamp = timestamp or core.getGameTime()\n\n    local t = {}\n    local day = math.floor(timestamp / time.day) + conf.startingYearDay - 1\n    t.year = math.floor(day / daysInYear) + conf.startingYear\n    t.yday = day % daysInYear + 1\n    t.wday = (day + conf.startingWeekDay - conf.startingYearDay) % conf.daysInWeek + 1\n    timestamp = timestamp % time.day\n    t.hour = math.floor(timestamp / time.hour)\n    timestamp = timestamp % time.hour\n    t.min = math.floor(timestamp / time.minute)\n    t.sec = math.floor(timestamp) % time.minute\n\n    t.day = t.yday\n    t.month = 1\n    while t.day > monthsDuration[t.month] do\n        t.day = t.day - monthsDuration[t.month]\n        t.month = t.month + 1\n    end\n\n    if formatStr == '*t' then return t end\n\n    local replFn = function(tag)\n        if tag == '%a' or tag == '%A' then return l10n('weekday' .. t.wday) end\n        if tag == '%b' or tag == '%B' then return l10n('monthInGenitive' .. t.month) end\n        if tag == '%c' then\n            return string.format('%02d:%02d %s', t.hour, t.min, defaultDateFormat(t))\n        end\n        if tag == '%d' then return string.format('%02d', t.day) end\n        if tag == '%e' then return string.format('%2d', t.day) end\n        if tag == '%H' then return string.format('%02d', t.hour) end\n        if tag == '%I' then return string.format('%02d', (t.hour - 1) % 12 + 1) end\n        if tag == '%M' then return string.format('%02d', t.min) end\n        if tag == '%m' then return string.format('%02d', t.month) end\n        if tag == '%p' then\n            if t.hour >= 0 and t.hour < 12 then\n                return l10n('am')\n            else\n                return l10n('pm')\n            end\n        end\n        if tag == '%S' then return string.format('%02d', t.sec) end\n        if tag == '%w' then return t.wday - 1 end\n        if tag == '%x' then return defaultDateFormat(t) end\n        if tag == '%X' then return string.format('%02d:%02d', t.hour, t.min) end\n        if tag == '%Y' then return t.year end\n        if tag == '%y' then return string.format('%02d', t.year % 100) end\n        if tag == '%%' then return '%' end\n        error('Unknown tag \"'..tag..'\"')\n    end\n\n    local res, _ = string.gsub(formatStr or '%c', '%%.', replFn)\n    return res\nend\n\nreturn {\n    --- An equivalent of `os.time` for game time.\n    -- See [https://www.lua.org/pil/22.1.html](https://www.lua.org/pil/22.1.html)\n    -- @function [parent=#calendar] gameTime\n    -- @param #table table a table which describes a date (optional).\n    -- @return #number a timestamp.\n    gameTime = gameTime,\n\n    --- An equivalent of `os.date` for game time.\n    -- See [https://www.lua.org/pil/22.1.html](https://www.lua.org/pil/22.1.html).\n    -- It is a slow function. Please try not to use it in every frame.\n    -- @function [parent=#calendar] formatGameTime\n    -- @param #string format format of date (optional)\n    -- @param #number time time to format (default value is current time)\n    -- @return #string a formatted string representation of `time`.\n    formatGameTime = formatGameTime,\n\n    --- The number of months in a year\n    -- @field [parent=#calendar] #number monthCount\n    monthCount = #monthsDuration,\n\n    --- The number of days in a year\n    -- @field [parent=#calendar] #number daysInYear\n    daysInYear = daysInYear,\n\n    --- The number of days in a week\n    -- @field [parent=#calendar] #number daysInWeek\n    daysInWeek = conf.daysInWeek,\n\n    --- The number of days in a month\n    -- @function [parent=#calendar] daysInMonth\n    -- @param monthIndex\n    -- @return #number\n    daysInMonth = function(m)\n        return monthsDuration[(m-1) % #monthsDuration + 1]\n    end,\n\n    --- The name of a month\n    -- @function [parent=#calendar] monthName\n    -- @param monthIndex\n    -- @return #string\n    monthName = function(m)\n        return l10n('month' .. ((m-1) % #monthsDuration + 1))\n    end,\n\n    --- The name of a month in genitive (for English is the same as `monthName`, but in some languages the form can differ).\n    -- @function [parent=#calendar] monthNameInGenitive\n    -- @param monthIndex\n    -- @return #string\n    monthNameInGenitive = function(m)\n        return l10n('monthInGenitive' .. ((m-1) % #monthsDuration + 1))\n    end,\n\n    --- The name of a weekday\n    -- @function [parent=#calendar] weekdayName\n    -- @param dayIndex\n    -- @return #string\n    weekdayName = function(d)\n        return l10n('weekday' .. ((d-1) % conf.daysInWeek + 1))\n    end,\n}\n\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\openmw_aux\\calendarconfig.lua": "return {\n    monthsDuration = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},\n    daysInWeek = 7,\n\n    -- It is the day of OpenMW 0.1.0 release, we use it as default starting date\n    startingYear = 2008,\n    startingYearDay = 151,\n    startingWeekDay = 0,\n}\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\openmw_aux\\time.lua": "---\n-- `openmw_aux.time` defines utility functions for timers.\n-- Implementation can be found in `resources/vfs/openmw_aux/time.lua`.\n-- @module time\n-- @usage local time = require('openmw_aux.time')\n\nlocal time = {\n    second = 1,\n    minute = 60,\n    hour = 3600,\n    day = 3600 * 24,\n    GameTime = 'GameTime',\n    SimulationTime = 'SimulationTime',\n}\n\n---\n-- Alias of async:registerTimerCallback ; register a function as a timer callback.\n-- @function [parent=#time] registerTimerCallback\n-- @param #string name\n-- @param #function func\n-- @return openmw.async#TimerCallback\nfunction time.registerTimerCallback(name, fn)\n    local async = require('openmw.async')\n    return async:registerTimerCallback(name, fn)\nend\n\n---\n-- Alias of async:newSimulationTimer ; call callback(arg) in `delay` game seconds.\n-- Callback must be registered in advance.\n-- @function [parent=#time] newGameTimer\n-- @param #number delay\n-- @param openmw.async#TimerCallback callback A callback returned by `registerTimerCallback`\n-- @param arg An argument for `callback`; can be `nil`.\nfunction time.newGameTimer(delay, callback, callbackArg)\n    local async = require('openmw.async')\n    return async:newGameTimer(delay, callback, callbackArg)\nend\n\n---\n-- Alias of async:newSimulationTimer ; call callback(arg) in `delay` simulation seconds.\n-- Callback must be registered in advance.\n-- @function [parent=#time] newSimulationTimer\n-- @param #number delay\n-- @param openmw.async#TimerCallback callback A callback returned by `registerTimerCallback`\n-- @param arg An argument for `callback`; can be `nil`.\nfunction time.newSimulationTimer(delay, callback, callbackArg)\n    local async = require('openmw.async')\n    return async:newSimulationTimer(delay, callback, callbackArg)\nend\n\n---\n-- Run given function repeatedly.\n-- Note that loading a save stops the evaluation. If it should work always, call it during initialization of the script (i.e. not in a handler)\n-- @function [parent=#time] runRepeatedly\n-- @param #function fn the function that should be called\n-- @param #number period interval\n-- @param #table options additional options `initialDelay` and `type`.\n-- `initialDelay` - delay before the first call. If missed then the delay is a random number in range [0, N]. Randomization is used for performance reasons -- to prevent all scripts from doing time consuming operations at the same time.\n-- `type` - either `time.SimulationTime` (by default, timer uses simulation time) or `time.GameTime` (timer uses game time).\n-- @return #function a function without arguments that can be used to stop the periodical evaluation.\n-- @usage\n-- local stopFn = time.runRepeatedly(function() print('Test') end,\n--                                   5 * time.second)  -- print 'Test' every 5 seconds\n-- stopFn()  -- stop printing 'Test'\n-- time.runRepeatedly(  -- print 'Test' every 5 minutes with initial 30 second delay\n--     function() print('Test2') end, 5 * time.minute,\n--     { initialDelay = 30 * time.second })\n-- @usage\n-- local timeBeforeMidnight = time.day - core.getGameTime() % time.day\n-- time.runRepeatedly(doSomething, time.day, {\n--     initialDelay = timeBeforeMidnight,\n--     type = time.GameTime,\n-- })  -- call `doSomething` at the end of every game day.\nfunction time.runRepeatedly(fn, period, options)\n    if period <= 0 then\n        error('Period must be positive. If you want it to be as small '..\n              'as possible, use the engine handler `onUpdate` instead', 2)\n    end\n    local async = require('openmw.async')\n    local core = require('openmw.core')\n    local initialDelay = (options and options.initialDelay) or math.random() * period\n    local getTimeFn, newTimerFn\n    if (options and options.type) == time.GameTime then\n        getTimeFn = core.getGameTime\n        newTimerFn = async.newUnsavableGameTimer\n    else\n        getTimeFn = core.getSimulationTime\n        newTimerFn = async.newUnsavableSimulationTimer\n    end\n    local baseTime = getTimeFn() + initialDelay\n    local breakFlag = false\n    local wrappedFn\n    wrappedFn = function()\n        if breakFlag then return end\n        fn()\n        local nextDelay = 1.5 * period - math.fmod(getTimeFn() - baseTime + period / 2, period)\n        newTimerFn(async, nextDelay, wrappedFn)\n    end\n    newTimerFn(async, initialDelay, wrappedFn)\n    return function() breakFlag = true end\nend\n\nreturn time\n\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\openmw_aux\\ui.lua": "local ui = require('openmw.ui')\n\n---\n-- `openmw_aux.ui` defines utility functions for UI.\n-- Implementation can be found in `resources/vfs/openmw_aux/ui.lua`.\n-- @module ui\n-- @usage local auxUi = require('openmw_aux.ui')\nlocal aux_ui = {}\n\nlocal function deepContentCopy(content)\n    local result = ui.content{}\n    for _, v in ipairs(content) do\n        result:add(aux_ui.deepLayoutCopy(v))\n    end\n    return result\nend\n\n---\n-- @function [parent=#ui] deepLayoutCopy\n-- @param #table layout\n-- @return #table copied layout\nfunction aux_ui.deepLayoutCopy(layout)\n    local result = {}\n    for k, v in pairs(layout) do\n        if k == 'content' then\n            result[k] = deepContentCopy(v)\n        elseif type(v) == 'table' then\n            result[k] = aux_ui.deepLayoutCopy(v)\n        else\n            result[k] = v\n        end\n    end\n    return result\nend\n\nreturn aux_ui\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\openmw_aux\\util.lua": "---\n-- `openmw_aux.util` defines utility functions that are implemented in Lua rather than in C++.\n-- Implementation can be found in `resources/vfs/openmw_aux/util.lua`.\n-- @module util\n-- @usage local aux_util = require('openmw_aux.util')\n\nlocal aux_util = {}\n\nlocal function deepToString(val, level, prefix)\n    local level = (level or 1) - 1\n    local ok, iter, t = pcall(function() return pairs(val) end)\n    if level < 0 or not ok then\n        return tostring(val)\n    end\n    local newPrefix = prefix .. '  '\n    local strs = {tostring(val) .. ' {\\n'}\n    for k, v in iter, t do\n        strs[#strs + 1] = newPrefix .. tostring(k) .. ' = ' .. deepToString(v, level, newPrefix) .. ',\\n'\n    end\n    strs[#strs + 1] = prefix .. '}'\n    return table.concat(strs)\nend\n\n---\n-- Works like `tostring` but shows also content of tables.\n-- @function [parent=#util] deepToString\n-- @param #any value The value to convert to string\n-- @param #number maxDepth Max depth of tables unpacking (optional, 1 by default)\nfunction aux_util.deepToString(value, maxDepth)\n    return deepToString(value, maxDepth, '')\nend\n\n---\n-- Finds the element the minimizes `scoreFn`.\n-- @function [parent=#util] findMinScore\n-- @param #table array Any array\n-- @param #function scoreFn Function that returns either nil/false or a number for each element of the array\n-- @return element The element the minimizes `scoreFn`\n-- @return #number score The output of `scoreFn(element)`\n-- @return #number index The index of the chosen element in the array\n-- @usage -- Find the nearest NPC\n-- local nearestNPC, distToNPC = aux_util.findMinScore(\n--     nearby.actors,\n--     function(actor)\n--         return actor.type == types.NPC and (self.position - actor.position):length()\n--     end)\nfunction aux_util.findMinScore(array, scoreFn)\n    local bestValue, bestScore, bestIndex\n    for i = 1, #array do\n        local v = array[i]\n        local score = scoreFn(v)\n        if score and (not bestScore or bestScore > score) then\n            bestValue, bestScore, bestIndex = v, score, i\n        end\n    end\n    return bestValue, bestScore, bestIndex\nend\n\n---\n-- Computes `scoreFn` for each element of `array` and filters out elements with false and nil results.\n-- @function [parent=#util] mapFilter\n-- @param #table array Any array\n-- @param #function scoreFn Filter function\n-- @return #table Output array\n-- @return #table Array of the same size with corresponding scores\n-- @usage -- Find all NPCs in `nearby.actors`\n-- local NPCs = aux_util.mapFilter(\n--     nearby.actors,\n--     function(actor) return actor.type == types.NPC end)\nfunction aux_util.mapFilter(array, scoreFn)\n    local res = {}\n    local scores = {}\n    for i = 1, #array do\n        local v = array[i]\n        local f = scoreFn(v)\n        if f then\n            scores[#res + 1] = f\n            res[#res + 1] = v\n        end\n    end\n    return res, scores\nend\n\n---\n-- Filters and sorts `array` by the scores calculated by `scoreFn`. The same as `aux_util.mapFilter`, but the result is sorted.\n-- @function [parent=#util] mapFilterSort\n-- @param #table array Any array\n-- @param #function scoreFn Filter function\n-- @return #table Output array\n-- @return #table Array of the same size with corresponding scores\n-- @usage -- Find all NPCs in `nearby.actors` and sort them by distances\n-- local NPCs, distances = aux_util.mapFilterSort(\n--     nearby.actors,\n--     function(actor)\n--         return actor.type == types.NPC and (self.position - actor.position):length()\n--     end)\nfunction aux_util.mapFilterSort(array, scoreFn)\n    local values, scores = aux_util.mapFilter(array, scoreFn)\n    local size = #values\n    local ids = {}\n    for i = 1, size do ids[i] = i end\n    table.sort(ids, function(i, j) return scores[i] < scores[j] end)\n    local sortedValues = {}\n    local sortedScores = {}\n    for i = 1, size do\n        sortedValues[i] = values[ids[i]]\n        sortedScores[i] = scores[ids[i]]\n    end\n    return sortedValues, sortedScores\nend\n\nreturn aux_util\n\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\activationhandlers.lua": "local async = require('openmw.async')\nlocal types = require('openmw.types')\nlocal world = require('openmw.world')\n\nlocal EnableObject = async:registerTimerCallback('EnableObject', function(obj) obj.enabled = true end)\n\nlocal function ESM4DoorActivation(door, actor)\n    -- TODO: Implement lockpicking minigame\n    -- TODO: Play door opening animation and sound\n    local Door4 = types.ESM4Door\n    if Door4.isTeleport(door) then\n        actor:teleport(Door4.destCell(door), Door4.destPosition(door), Door4.destRotation(door))\n    else\n        door.enabled = false\n        async:newSimulationTimer(5, EnableObject, door)\n    end\n    return false -- disable activation handling in C++ mwmechanics code\nend\n\nlocal function ESM4BookActivation(book, actor)\n    if actor.type == types.Player then\n        actor:sendEvent('AddUiMode', { mode = 'Book', target = book })\n    end\nend\n\nlocal handlersPerObject = {}\nlocal handlersPerType = {}\n\nhandlersPerType[types.ESM4Book] = { ESM4BookActivation }\nhandlersPerType[types.ESM4Door] = { ESM4DoorActivation }\n\nlocal function onActivate(obj, actor)\n    if world.isWorldPaused() then\n        return\n    end\n    local handlers = handlersPerObject[obj.id]\n    if handlers then\n        for i = #handlers, 1, -1 do\n            if handlers[i](obj, actor) == false then\n                return -- skip other handlers\n            end\n        end\n    end\n    handlers = handlersPerType[obj.type]\n    if handlers then\n        for i = #handlers, 1, -1 do\n            if handlers[i](obj, actor) == false then\n                return -- skip other handlers\n            end\n        end\n    end\n    types.Actor.activeEffects(actor):remove('invisibility')\n    world._runStandardActivationAction(obj, actor)\nend\n\nreturn {\n    interfaceName = 'Activation',\n    ---\n    -- @module Activation\n    -- @usage require('openmw.interfaces').Activation\n    interface = {\n        --- Interface version\n        -- @field [parent=#Activation] #number version\n        version = 0,\n\n        --- Add new activation handler for a specific object.\n        -- If `handler(object, actor)` returns false, other handlers for\n        -- the same object (including type handlers) will be skipped.\n        -- @function [parent=#Activation] addHandlerForObject\n        -- @param openmw.core#GameObject obj The object.\n        -- @param #function handler The handler.\n        addHandlerForObject = function(obj, handler)\n            local handlers = handlersPerObject[obj.id]\n            if handlers == nil then\n                handlers = {}\n                handlersPerObject[obj.id] = handlers\n            end\n            handlers[#handlers + 1] = handler\n        end,\n\n        --- Add new activation handler for a type of objects.\n        -- If `handler(object, actor)` returns false, other handlers for\n        -- the same object (including type handlers) will be skipped.\n        -- @function [parent=#Activation] addHandlerForType\n        -- @param #any type A type from the `openmw.types` package.\n        -- @param #function handler The handler.\n        addHandlerForType = function(type, handler)\n            local handlers = handlersPerType[type]\n            if handlers == nil then\n                handlers = {}\n                handlersPerType[type] = handlers\n            end\n            handlers[#handlers + 1] = handler\n        end,\n    },\n    engineHandlers = { onActivate = onActivate },\n}\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\ai.lua": "local self = require('openmw.self')\nlocal interfaces = require('openmw.interfaces')\n\nlocal function startPackage(args)\n    local cancelOther = args.cancelOther\n    if cancelOther == nil then cancelOther = true end\n    if args.type == 'Combat' then\n        if not args.target then error(\"target required\") end\n        self:_startAiCombat(args.target, cancelOther)\n    elseif args.type == 'Pursue' then\n        if not args.target then error(\"target required\") end\n        self:_startAiPursue(args.target, cancelOther)\n    elseif args.type == 'Follow' then\n        if not args.target then error(\"target required\") end\n        self:_startAiFollow(args.target, cancelOther)\n    elseif args.type == 'Escort' then\n        if not args.target then error(\"target required\") end\n        if not args.destPosition then error(\"destPosition required\") end\n        self:_startAiEscort(args.target, args.destCell or self.cell, args.duration or 0, args.destPosition, cancelOther)\n    elseif args.type == 'Wander' then\n        self:_startAiWander(args.distance or 0, args.duration or 0, cancelOther)\n    elseif args.type == 'Travel' then\n        if not args.destPosition then error(\"destPosition required\") end\n        self:_startAiTravel(args.destPosition, cancelOther)\n    else\n        error('Unsupported AI Package: ' .. args.type)\n    end\nend\n\nlocal function filterPackages(filter)\n    self:_iterateAndFilterAiSequence(filter)\nend\n\nreturn {\n    interfaceName = 'AI',\n    --- Basic AI interface\n    -- @module AI\n    -- @usage require('openmw.interfaces').AI\n    interface = {\n        --- Interface version\n        -- @field [parent=#AI] #number version\n        version = 0,\n\n        --- AI Package\n        -- @type Package\n        -- @field #string type Type of the AI package.\n        -- @field openmw.core#GameObject target Target (usually an actor) of the AI package (can be nil).\n        -- @field #boolean sideWithTarget Whether to help the target in combat (true or false).\n        -- @field openmw.util#Vector3 destPosition Destination point of the AI package.\n\n        --- Return the currently active AI package (or `nil` if there are no AI packages).\n        -- @function [parent=#AI] getActivePackage\n        -- @return #Package\n        getActivePackage = function() return self:_getActiveAiPackage() end,\n\n        --- Start new AI package.\n        -- @function [parent=#AI] startPackage\n        -- @param #table options See the \"Built-in AI packages\" page.\n        startPackage = startPackage,\n\n        --- Iterate over all packages starting from the active one and remove those where `filterCallback` returns false.\n        -- @function [parent=#AI] filterPackages\n        -- @param #function filterCallback\n        filterPackages = filterPackages,\n\n        --- Iterate over all packages and run `callback` for each starting from the active one.\n        -- The same as `filterPackage`, but without removal.\n        -- @function [parent=#AI] forEachPackage\n        -- @param #function callback\n        forEachPackage = function(callback)\n            local filter = function(p)\n                callback(p)\n                return true\n            end\n            filterPackages(filter)\n        end,\n\n        --- Remove packages of given type (remove all packages if the type is not specified).\n        -- @function [parent=#AI] removePackages\n        -- @param #string packageType (optional) The type of packages to remove.\n        removePackages = function(packageType)\n            filterPackages(function(p) return packageType and p.type ~= packageType end)\n        end,\n\n        --- Return the target of the active package if the package has given type\n        -- @function [parent=#AI] getActiveTarget\n        -- @param #string packageType The expected type of the active package\n        -- @return openmw.core#GameObject The target (can be nil if the package has no target or has another type)\n        getActiveTarget = function(packageType)\n            local p = self:_getActiveAiPackage()\n            if p and p.type == packageType then\n                return p.target\n            else\n                return nil\n            end\n        end,\n\n        --- Get list of targets of all packages of the given type.\n        -- @function [parent=#AI] getTargets\n        -- @param #string packageType\n        -- @return #list<openmw.core#GameObject>\n        getTargets = function(packageType)\n            local res = {}\n            filterPackages(function(p)\n                if p.type == packageType and p.target then\n                    res[#res + 1] = p.target\n                end\n                return true\n            end)\n            return res\n        end,\n    },\n    eventHandlers = {\n        StartAIPackage = function(options) interfaces.AI.startPackage(options) end,\n        RemoveAIPackages = function(packageType) interfaces.AI.removePackages(packageType) end,\n    },\n}\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\cellhandlers.lua": "local types = require('openmw.types')\nlocal util = require('openmw.util')\nlocal world = require('openmw.world')\n\nlocal CELL_SIZE = 8192\n\nlocal function getRandomPosition(cellX, cellY)\n    local x = math.random(7892)\n    local y = math.random(7892)\n    local z = -math.random(1748)\n    return util.vector3(cellX + x, cellY + y, z)\nend\n\nlocal function getRandomOffset()\n    local x = math.random(1000)\n    local y = math.random(1000)\n    local z = math.random(1000)\n    local v = util.vector3(x, y, z)\n    return v:normalize() * 100\nend\n\nlocal function getPlayerLevel()\n    return types.Player.stats.level(world.players[1]).current\nend\n\nlocal function spawnFish(cell)\n    if (cell.worldSpaceId ~= 'sys::default') then\n        return\n    end\n    local spawnCount = math.random(0, 10)\n    if (spawnCount < 1) then\n        return\n    end\n    local list = types.LevelledCreature.record('h2o_all_lev-2')\n    if (list == nil) then\n        return\n    end\n    local cellX = cell.gridX * CELL_SIZE\n    local cellY = cell.gridY * CELL_SIZE\n    local level = getPlayerLevel()\n    if (spawnCount <= 5) then -- spawn a number of random creatures selected from the list\n        while(spawnCount > 0) do\n            local id = list:getRandomId(level)\n            if (id ~= '') then\n                local ref = world.createObject(id)\n                ref:teleport(cell, getRandomPosition(cellX, cellY))\n            end\n            spawnCount = spawnCount - 1\n        end\n    else -- spawn a horde of a single creature selected from the list\n        local id = list:getRandomId(level)\n        if (id ~= '') then\n            local basePos = getRandomPosition(cellX, cellY)\n            while(spawnCount > 0) do\n                local ref = world.createObject(id)\n                ref:teleport(cell, basePos + getRandomOffset())\n                spawnCount = spawnCount - 1\n            end\n        end\n    end\nend\n\nreturn {\n    engineHandlers = { onNewExterior = spawnFish }\n}\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\playercontrols.lua": "local core = require('openmw.core')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal util = require('openmw.util')\nlocal ui = require('openmw.ui')\nlocal Actor = require('openmw.types').Actor\nlocal Player = require('openmw.types').Player\n\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\n\nlocal settingsGroup = 'SettingsOMWControls'\n\nlocal function boolSetting(key, default)\n    return {\n        key = key,\n        renderer = 'checkbox',\n        name = key,\n        description = key..'Description',\n        default = default,\n    }\nend\n\nI.Settings.registerPage({\n  key = 'OMWControls',\n  l10n = 'OMWControls',\n  name = 'ControlsPage',\n  description = 'ControlsPageDescription',\n})\n\nI.Settings.registerGroup({\n    key = settingsGroup,\n    page = 'OMWControls',\n    l10n = 'OMWControls',\n    name = 'MovementSettings',\n    permanentStorage = true,\n    settings = {\n        boolSetting('alwaysRun', false),\n        boolSetting('toggleSneak', false),\n    },\n})\n\nlocal settings = storage.playerSection(settingsGroup)\n\nlocal attemptJump = false\nlocal startAttack = false\nlocal autoMove = false\nlocal movementControlsOverridden = false\nlocal combatControlsOverridden = false\nlocal uiControlsOverridden = false\n\nlocal function processMovement()\n    local controllerMovement = -input.getAxisValue(input.CONTROLLER_AXIS.MoveForwardBackward)\n    local controllerSideMovement = input.getAxisValue(input.CONTROLLER_AXIS.MoveLeftRight)\n    if controllerMovement ~= 0 or controllerSideMovement ~= 0 then\n        -- controller movement\n        if util.vector2(controllerMovement, controllerSideMovement):length2() < 0.25\n           and not self.controls.sneak and Actor.isOnGround(self) and not Actor.isSwimming(self) then\n            self.controls.run = false\n            self.controls.movement = controllerMovement * 2\n            self.controls.sideMovement = controllerSideMovement * 2\n        else\n            self.controls.run = true\n            self.controls.movement = controllerMovement\n            self.controls.sideMovement = controllerSideMovement\n        end\n    else\n        -- keyboard movement\n        self.controls.movement = 0\n        self.controls.sideMovement = 0\n        if input.isActionPressed(input.ACTION.MoveLeft) then\n            self.controls.sideMovement = self.controls.sideMovement - 1\n        end\n        if input.isActionPressed(input.ACTION.MoveRight) then\n            self.controls.sideMovement = self.controls.sideMovement + 1\n        end\n        if input.isActionPressed(input.ACTION.MoveBackward) then\n            self.controls.movement = self.controls.movement - 1\n        end\n        if input.isActionPressed(input.ACTION.MoveForward) then\n            self.controls.movement = self.controls.movement + 1\n        end\n        self.controls.run = input.isActionPressed(input.ACTION.Run) ~= settings:get('alwaysRun')\n    end\n    if self.controls.movement ~= 0 or not Actor.canMove(self) then\n        autoMove = false\n    elseif autoMove then\n        self.controls.movement = 1\n    end\n    self.controls.jump = attemptJump and Player.getControlSwitch(self, Player.CONTROL_SWITCH.Jumping)\n    if not settings:get('toggleSneak') then\n        self.controls.sneak = input.isActionPressed(input.ACTION.Sneak)\n    end\nend\n\nlocal function processAttacking()\n    if startAttack then\n        self.controls.use = 1\n    elseif Actor.stance(self) == Actor.STANCE.Spell then\n        self.controls.use = 0\n    elseif input.getAxisValue(input.CONTROLLER_AXIS.TriggerRight) < 0.6\n           and not input.isActionPressed(input.ACTION.Use) then\n        -- The value \"0.6\" shouldn't exceed the triggering threshold in BindingsManager::actionValueChanged.\n        -- TODO: Move more logic from BindingsManager to Lua and consider to make this threshold configurable.\n        self.controls.use = 0\n    end\nend\n\nlocal function onFrame(dt)\n    local controlsAllowed = Player.getControlSwitch(self, Player.CONTROL_SWITCH.Controls)\n                            and not core.isWorldPaused() and not I.UI.getMode()\n    if not movementControlsOverridden then\n        if controlsAllowed then\n            processMovement()\n        else\n            self.controls.movement = 0\n            self.controls.sideMovement = 0\n            self.controls.jump = false\n        end\n    end\n    if controlsAllowed and not combatControlsOverridden then\n        processAttacking()\n    end\n    attemptJump = false\n    startAttack = false\nend\n\nlocal function checkNotWerewolf()\n    if Player.isWerewolf(self) then\n        ui.showMessage(core.getGMST('sWerewolfRefusal'))\n        return false\n    else\n        return true\n    end\nend\n\nlocal function isJournalAllowed()\n    -- During chargen journal is not allowed until magic window is allowed\n    return I.UI.getWindowsForMode(I.UI.MODE.Interface)[I.UI.WINDOW.Magic]\nend\n\nlocal function onInputAction(action)\n    if not Player.getControlSwitch(self, Player.CONTROL_SWITCH.Controls) then\n        return\n    end\n\n    if not uiControlsOverridden then\n        if action == input.ACTION.Inventory then\n            if I.UI.getMode() == nil then\n                I.UI.setMode(I.UI.MODE.Interface)\n            elseif I.UI.getMode() == I.UI.MODE.Interface or I.UI.getMode() == I.UI.MODE.Container then\n                I.UI.removeMode(I.UI.getMode())\n            end\n        elseif action == input.ACTION.Journal then\n            if I.UI.getMode() == I.UI.MODE.Journal then\n                I.UI.removeMode(I.UI.MODE.Journal)\n            elseif isJournalAllowed() then\n                I.UI.addMode(I.UI.MODE.Journal)\n            end\n        elseif action == input.ACTION.QuickKeysMenu then\n            if I.UI.getMode() == I.UI.MODE.QuickKeysMenu then\n                I.UI.removeMode(I.UI.MODE.QuickKeysMenu)\n            elseif checkNotWerewolf() and Player.isCharGenFinished(self) then\n                I.UI.addMode(I.UI.MODE.QuickKeysMenu)\n            end\n        end\n    end\n\n    if core.isWorldPaused() or I.UI.getMode() then\n        return\n    end\n\n    if action == input.ACTION.Jump then\n        attemptJump = true\n    elseif action == input.ACTION.Use then\n        startAttack = Actor.stance(self) ~= Actor.STANCE.Nothing\n    elseif action == input.ACTION.AutoMove and not movementControlsOverridden then\n        autoMove = not autoMove\n    elseif action == input.ACTION.AlwaysRun and not movementControlsOverridden then\n        settings:set('alwaysRun', not settings:get('alwaysRun'))\n    elseif action == input.ACTION.Sneak and not movementControlsOverridden then\n        if settings:get('toggleSneak') then\n            self.controls.sneak = not self.controls.sneak\n        end\n    elseif action == input.ACTION.ToggleSpell and not combatControlsOverridden then\n        if Actor.stance(self) == Actor.STANCE.Spell then\n            Actor.setStance(self, Actor.STANCE.Nothing)\n        elseif Player.getControlSwitch(self, Player.CONTROL_SWITCH.Magic) then\n            if checkNotWerewolf() then\n                Actor.setStance(self, Actor.STANCE.Spell)\n            end\n        end\n    elseif action == input.ACTION.ToggleWeapon and not combatControlsOverridden then\n        if Actor.stance(self) == Actor.STANCE.Weapon then\n            Actor.setStance(self, Actor.STANCE.Nothing)\n        elseif Player.getControlSwitch(self, Player.CONTROL_SWITCH.Fighting) then\n            Actor.setStance(self, Actor.STANCE.Weapon)\n        end\n    end\nend\n\nlocal function onSave()\n    return {sneaking = self.controls.sneak}\nend\n\nlocal function onLoad(data)\n    if not data then return end\n    self.controls.sneak = data.sneaking or false\nend\n\nreturn {\n    engineHandlers = {\n        onFrame = onFrame,\n        onInputAction = onInputAction,\n        onSave = onSave,\n        onLoad = onLoad,\n    },\n    interfaceName = 'Controls',\n    ---\n    -- @module Controls\n    -- @usage require('openmw.interfaces').Controls\n    interface = {\n        --- Interface version\n        -- @field [parent=#Controls] #number version\n        version = 1,\n\n        --- When set to true then the movement controls including jump and sneak are not processed and can be handled by another script.\n        -- If movement should be disallowed completely, consider to use `types.Player.setControlSwitch` instead.\n        -- @function [parent=#Controls] overrideMovementControls\n        -- @param #boolean value\n        overrideMovementControls = function(v) movementControlsOverridden = v end,\n\n        --- When set to true then the controls \"attack\", \"toggle spell\", \"toggle weapon\" are not processed and can be handled by another script.\n        -- If combat should be disallowed completely, consider to use `types.Player.setControlSwitch` instead.\n        -- @function [parent=#Controls] overrideCombatControls\n        -- @param #boolean value\n        overrideCombatControls = function(v) combatControlsOverridden = v end,\n\n        --- When set to true then the controls \"open inventory\", \"open journal\" and so on are not processed and can be handled by another script.\n        -- @function [parent=#Controls] overrideUiControls\n        -- @param #boolean value\n        overrideUiControls = function(v) uiControlsOverridden = v end,\n    }\n}\n\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\ui.lua": "local ui = require('openmw.ui')\nlocal util = require('openmw.util')\nlocal self = require('openmw.self')\nlocal core = require('openmw.core')\nlocal ambient = require('openmw.ambient')\n\nlocal MODE = ui._getAllUiModes()\nlocal WINDOW = ui._getAllWindowIds()\n\nlocal replacedWindows = {}\nlocal hiddenWindows = {}\nlocal modeStack = {}\n\nlocal modePause = {}\nfor _, mode in pairs(MODE) do\n    modePause[mode] = true\nend\n\nlocal function registerWindow(window, showFn, hideFn)\n    if not WINDOW[window] then\n        error('At the moment it is only possible to override existing windows. Window \"'..\n              tostring(window)..'\" not found.')\n    end\n    ui._setWindowDisabled(window, true)\n    if replacedWindows[window] then\n        replacedWindows[window].hideFn()\n    end\n    replacedWindows[window] = {showFn = showFn, hideFn = hideFn, visible = false}\n    hiddenWindows[window] = nil\nend\n\nlocal function updateHidden(mode, options)\n    local toHide = {}\n    if options and options.windows then\n        for _, w in pairs(ui._getAllowedWindows(mode)) do\n            toHide[w] = true\n        end\n        for _, w in pairs(options.windows) do\n            toHide[w] = nil\n        end\n    end\n    for w, _ in pairs(hiddenWindows) do\n        if toHide[w] then\n            toHide[w] = nil\n        else\n            hiddenWindows[w] = nil\n            if not replacedWindows[w] then\n                ui._setWindowDisabled(w, false)\n            end\n        end\n    end\n    for w, _ in pairs(toHide) do\n        hiddenWindows[w] = true\n        if not replacedWindows[w] then\n            ui._setWindowDisabled(w, true)\n        end\n    end\nend\n\nlocal function setMode(mode, options)\n    local function impl()\n        updateHidden(mode, options)\n        ui._setUiModeStack({mode}, options and options.target)\n    end\n    if mode then\n        if not pcall(impl) then\n            error('Invalid mode: ' .. tostring(mode))\n        end\n    else\n        ui._setUiModeStack({})\n    end\nend\n\nlocal function addMode(mode, options)\n    local function impl()\n        updateHidden(mode, options)\n        ui._setUiModeStack(modeStack, options and options.target)\n    end\n    modeStack[#modeStack + 1] = mode\n    if not pcall(impl) then\n        modeStack[#modeStack] = nil\n        error('Invalid mode: ' .. tostring(mode))\n    end\nend\n\nlocal function removeMode(mode)\n    local sizeBefore = #modeStack\n    local j = 1\n    for i = 1, sizeBefore do\n        if modeStack[i] ~= mode then\n            modeStack[j] = modeStack[i]\n            j = j + 1\n        end\n    end\n    for i = j, sizeBefore do modeStack[i] = nil end\n    if sizeBefore > #modeStack then\n        ui._setUiModeStack(modeStack)\n    end\nend\n\nlocal oldMode = nil\nlocal function onUiModeChanged(changedByLua, arg)\n    local newStack = ui._getUiModeStack()\n    for i = 1, math.max(#modeStack, #newStack) do\n        modeStack[i] = newStack[i]\n    end\n    for w, state in pairs(replacedWindows) do\n        if state.visible then\n            state.hideFn()\n            state.visible = false\n        end\n    end\n    local mode = newStack[#newStack]\n    if mode then\n        if not changedByLua then\n            updateHidden(mode)\n        end\n        for _, w in pairs(ui._getAllowedWindows(mode)) do\n            local state = replacedWindows[w]\n            if state and not hiddenWindows[w] then\n                state.showFn(arg)\n                state.visible = true\n            end\n        end\n    end\n    local shouldPause = false\n    for _, m in pairs(modeStack) do\n        shouldPause = shouldPause or modePause[m]\n    end\n    if shouldPause then\n        core.sendGlobalEvent('Pause', 'ui')\n    else\n        core.sendGlobalEvent('Unpause', 'ui')\n    end\n    self:sendEvent('UiModeChanged', {oldMode = oldMode, newMode = mode, arg = arg})\n    oldMode = mode\nend\n\nlocal function onUiModeChangedEvent(data)\n    if data.oldMode == data.newMode then\n        return\n    end\n    -- Sounds are processed in the event handler rather than in engine handler\n    -- in order to allow them to be overridden in mods.\n    if data.newMode == MODE.Journal or data.newMode == MODE.Book then\n        ambient.playSound('book open', {scale = false})\n    elseif data.oldMode == MODE.Journal or data.oldMode == MODE.Book then\n        if not ambient.isSoundPlaying('item book up') then\n            ambient.playSound('book close', {scale = false})\n        end\n    elseif data.newMode == MODE.Scroll or data.oldMode == MODE.Scroll then\n        if not ambient.isSoundPlaying('item book up') then\n            ambient.playSound('scroll', {scale = false})\n        end\n    end\nend\n\nreturn {\n    interfaceName = 'UI',\n    ---\n    -- @module UI\n    -- @usage require('openmw.interfaces').UI\n    interface = {\n        --- Interface version\n        -- @field [parent=#UI] #number version\n        version = 1,\n\n        --- All available UI modes.\n        -- Use `view(I.UI.MODE)` in `luap` console mode to see the list.\n        -- @field [parent=#UI] #table MODE\n        MODE = util.makeStrictReadOnly(MODE),\n\n        --- All windows.\n        -- Use `view(I.UI.WINDOW)` in `luap` console mode to see the list.\n        -- @field [parent=#UI] #table WINDOW\n        WINDOW = util.makeStrictReadOnly(WINDOW),\n\n        --- Register new implementation for the window with given name; overrides previous implementation.\n        -- Adding new windows is not supported yet. At the moment it is only possible to override built-in windows.\n        -- @function [parent=#UI] registerWindow\n        -- @param #string windowName\n        -- @param #function showFn Callback that will be called when the window should become visible\n        -- @param #function hideFn Callback that will be called when the window should be hidden\n        registerWindow = registerWindow,\n\n        --- Returns windows that can be shown in given mode.\n        -- @function [parent=#UI] getWindowsForMode\n        -- @param #string mode\n        -- @return #table\n        getWindowsForMode = ui._getAllowedWindows,\n\n        --- Stack of currently active modes\n        -- @field [parent=#UI] modes\n        modes = util.makeReadOnly(modeStack),\n\n        --- Get current mode (nil if all windows are closed), equivalent to `I.UI.modes[#I.UI.modes]`\n        -- @function [parent=#UI] getMode\n        -- @return #string\n        getMode = function() return modeStack[#modeStack] end,\n\n        --- Drop all active modes and set mode.\n        -- @function [parent=#UI] setMode\n        -- @param #string mode (optional) New mode\n        -- @param #table options (optional) Table with keys 'windows' and/or 'target' (see example).\n        -- @usage I.UI.setMode() -- drop all modes\n        -- @usage I.UI.setMode('Interface') -- drop all modes and open interface\n        -- @usage -- Drop all modes, open interface, but show only the map window.\n        -- I.UI.setMode('Interface', {windows = {'Map'}})\n        setMode = setMode,\n\n        --- Add mode to stack without dropping other active modes.\n        -- @function [parent=#UI] addMode\n        -- @param #string mode New mode\n        -- @param #table options (optional) Table with keys 'windows' and/or 'target' (see example).\n        -- @usage I.UI.addMode('Journal') -- open journal without dropping active modes.\n        -- @usage -- Open barter with an NPC\n        -- I.UI.addMode('Barter', {target = actor})\n        addMode = addMode,\n\n        --- Remove the specified mode from active modes.\n        -- @function [parent=#UI] removeMode\n        -- @param #string mode Mode to drop\n        removeMode = removeMode,\n\n        --- Set whether the mode should pause the game.\n        -- @function [parent=#UI] setPauseOnMode\n        -- @param #string mode Mode to configure\n        -- @param #boolean shouldPause\n        setPauseOnMode = function(mode, shouldPause) modePause[mode] = shouldPause end,\n\n        --- Set whether the UI should be visible.\n        -- @function [parent=#UI] setHudVisibility\n        -- @param #boolean showHud\n        setHudVisibility = function(showHud) ui._setHudVisibility(showHud) end,\n\n        ---\n        -- Returns if the player HUD is visible or not\n        -- @function [parent=#UI] isHudVisible\n        -- @return #boolean\n        isHudVisible = function() return ui._isHudVisible() end,\n\n        -- TODO\n        -- registerHudElement = function(name, showFn, hideFn) end,\n        -- showHudElement = function(name, bool) end,\n        -- hudElements,  -- map from element name to its visibility\n    },\n    engineHandlers = {\n        _onUiModeChanged = onUiModeChanged,\n    },\n    eventHandlers = {\n        UiModeChanged = onUiModeChangedEvent,\n        AddUiMode = function(options) addMode(options.mode, options) end,\n        SetUiMode = function(options) setMode(options.mode, options) end,\n    },\n}\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\usehandlers.lua": "local types = require('openmw.types')\nlocal world = require('openmw.world')\n\nlocal handlersPerObject = {}\nlocal handlersPerType = {}\n\nlocal function useItem(obj, actor, force)\n    local options = { force = force or false }\n    local handlers = handlersPerObject[obj.id]\n    if handlers then\n        for i = #handlers, 1, -1 do\n            if handlers[i](obj, actor, options) == false then\n                return -- skip other handlers\n            end\n        end\n    end\n    handlers = handlersPerType[obj.type]\n    if handlers then\n        for i = #handlers, 1, -1 do\n            if handlers[i](obj, actor, options) == false then\n                return -- skip other handlers\n            end\n        end\n    end\n    world._runStandardUseAction(obj, actor, options.force)\nend\n\nreturn {\n    interfaceName = 'ItemUsage',\n    ---\n    -- Allows to extend or override built-in item usage mechanics.\n    -- Note: at the moment it can override item usage in inventory\n    -- (dragging an item on the character's model), but\n    --\n    -- * can't intercept actions performed by mwscripts;\n    -- * can't intercept actions performed by the AI (i.e. drinking a potion in combat);\n    -- * can't intercept actions performed via quick keys menu.\n    -- @module ItemUsage\n    -- @usage local I = require('openmw.interfaces')\n    --\n    -- -- Override Use action (global script).\n    -- -- Forbid equipping armor with weight > 5\n    -- I.ItemUsage.addHandlerForType(types.Armor, function(armor, actor)\n    --     if types.Armor.record(armor).weight > 5 then\n    --         return false -- disable other handlers\n    --     end\n    -- end)\n    --\n    -- -- Call Use action (any script).\n    -- core.sendGlobalEvent('UseItem', {object = armor, actor = player})\n    interface = {\n        --- Interface version\n        -- @field [parent=#ItemUsage] #number version\n        version = 0,\n\n        --- Add new use action handler for a specific object.\n        -- If `handler(object, actor, options)` returns false, other handlers for\n        -- the same object (including type handlers) will be skipped.\n        -- @function [parent=#ItemUsage] addHandlerForObject\n        -- @param openmw.core#GameObject obj The object.\n        -- @param #function handler The handler.\n        addHandlerForObject = function(obj, handler)\n            local handlers = handlersPerObject[obj.id]\n            if handlers == nil then\n                handlers = {}\n                handlersPerObject[obj.id] = handlers\n            end\n            handlers[#handlers + 1] = handler\n        end,\n\n        --- Add new use action handler for a type of objects.\n        -- If `handler(object, actor, options)` returns false, other handlers for\n        -- the same object (including type handlers) will be skipped.\n        -- @function [parent=#ItemUsage] addHandlerForType\n        -- @param #any type A type from the `openmw.types` package.\n        -- @param #function handler The handler.\n        addHandlerForType = function(type, handler)\n            local handlers = handlersPerType[type]\n            if handlers == nil then\n                handlers = {}\n                handlersPerType[type] = handlers\n            end\n            handlers[#handlers + 1] = handler\n        end,\n    },\n    engineHandlers = { _onUseItem = useItem },\n    eventHandlers = {\n        UseItem = function(data)\n            if not data.object then\n                error('UseItem: missing argument \"object\"')\n            end\n            if not data.actor or not types.Actor.objectIsInstance(data.actor) then\n                error('UseItem: invalid argument \"actor\"')\n            end\n            useItem(data.object, data.actor, data.force)\n        end\n    }\n}\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\worldeventhandlers.lua": "local world = require('openmw.world')\n\nreturn {\n    eventHandlers = {\n        Pause = function(tag) world.pause(tag) end,\n        Unpause = function(tag) world.unpause(tag) end,\n        SetGameTimeScale = function(scale) world.setGameTimeScale(scale) end,\n        SetSimulationTimeScale = function(scale) world.setSimulationTimeScale(scale) end,\n    },\n}\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\camera\\camera.lua": "local camera = require('openmw.camera')\nlocal core = require('openmw.core')\nlocal input = require('openmw.input')\nlocal util = require('openmw.util')\nlocal self = require('openmw.self')\nlocal nearby = require('openmw.nearby')\nlocal async = require('openmw.async')\nlocal I = require('openmw.interfaces')\n\nlocal Actor = require('openmw.types').Actor\nlocal Player = require('openmw.types').Player\n\nlocal settings = require('scripts.omw.camera.settings').thirdPerson\nlocal head_bobbing = require('scripts.omw.camera.head_bobbing')\nlocal third_person = require('scripts.omw.camera.third_person')\nlocal pov_auto_switch = require('scripts.omw.camera.first_person_auto_switch')\nlocal move360 = require('scripts.omw.camera.move360')\n\nlocal MODE = camera.MODE\n\nlocal previewIfStandStill = false\nlocal showCrosshairInThirdPerson = false\nlocal slowViewChange = false\n\nlocal function updateSettings()\n    previewIfStandStill = settings:get('previewIfStandStill')\n    showCrosshairInThirdPerson = settings:get('viewOverShoulder')\n    camera.allowCharacterDeferredRotation(settings:get('deferredPreviewRotation'))\n    local collisionType = util.bitAnd(nearby.COLLISION_TYPE.Default, util.bitNot(nearby.COLLISION_TYPE.Actor))\n    collisionType = util.bitOr(collisionType, nearby.COLLISION_TYPE.Camera)\n    if settings:get('ignoreNC') then\n        collisionType = util.bitOr(collisionType, nearby.COLLISION_TYPE.VisualOnly)\n    end\n    camera.setCollisionType(collisionType)\n    move360.enabled = settings:get('move360')\n    move360.turnSpeed = settings:get('move360TurnSpeed')\n    pov_auto_switch.enabled = settings:get('povAutoSwitch')\n    slowViewChange = settings:get('slowViewChange')\nend\n\nlocal primaryMode\n\nlocal noModeControl = {}\nlocal noStandingPreview = {}\nlocal noHeadBobbing = {}\nlocal noZoom = {}\n\nlocal function init()\n    camera.setFieldOfView(camera.getBaseFieldOfView())\n    if camera.getMode() == MODE.FirstPerson then\n        primaryMode = MODE.FirstPerson\n    else\n        primaryMode = MODE.ThirdPerson\n        camera.setMode(MODE.ThirdPerson)\n    end\n    updateSettings()\nend\n\nsettings:subscribe(async:callback(updateSettings))\n\nlocal smoothedSpeed = 0\nlocal previewTimer = 0\n\nlocal function updatePOV(dt)\n    local switchLimit = 0.25\n    if input.isActionPressed(input.ACTION.TogglePOV) and Player.getControlSwitch(self, Player.CONTROL_SWITCH.ViewMode) then\n        previewTimer = previewTimer + dt\n        if primaryMode == MODE.ThirdPerson or previewTimer >= switchLimit then\n            third_person.standingPreview = false\n            camera.setMode(MODE.Preview)\n        end\n    elseif previewTimer > 0 then\n        if previewTimer <= switchLimit then\n            if primaryMode == MODE.FirstPerson then\n                primaryMode = MODE.ThirdPerson\n            else\n                primaryMode = MODE.FirstPerson\n            end\n        end\n        camera.setMode(primaryMode)\n        if camera.getMode() == MODE.Preview then\n            -- If Preview -> FirstPerson change is queued (because of 3rd person animation),\n            -- then first exit Preview by switching to ThirdPerson, and then queue the switch to FirstPerson.\n            camera.setMode(MODE.ThirdPerson)\n            camera.setMode(MODE.FirstPerson)\n        end\n        previewTimer = 0\n    end\nend\n\nlocal idleTimer = 0\nlocal vanityDelay = core.getGMST('fVanityDelay')\n\nlocal function updateVanity(dt)\n    local vanityAllowed = Player.getControlSwitch(self, Player.CONTROL_SWITCH.VanityMode)\n    if vanityAllowed and idleTimer > vanityDelay and camera.getMode() ~= MODE.Vanity then\n        camera.setMode(MODE.Vanity)\n    end\n    if camera.getMode() == MODE.Vanity then\n        if not vanityAllowed or idleTimer == 0 then\n            camera.setMode(primaryMode)\n        else\n            camera.setYaw(camera.getYaw() + math.rad(3) * dt)\n        end\n    end\nend\n\nlocal function updateSmoothedSpeed(dt)\n    local speed = Actor.getCurrentSpeed(self)\n    speed = speed / (1 + speed / 500)\n    local maxDelta = 300 * dt\n    smoothedSpeed = smoothedSpeed + util.clamp(speed - smoothedSpeed, -maxDelta, maxDelta)\nend\n\nlocal minDistance = 30\nlocal maxDistance = 800\n\nlocal function zoom(delta)\n    if not Player.getControlSwitch(self, Player.CONTROL_SWITCH.ViewMode) or\n       not Player.getControlSwitch(self, Player.CONTROL_SWITCH.Controls) or\n       camera.getMode() == MODE.Static or next(noZoom) then\n        return\n    end\n    if camera.getMode() ~= MODE.FirstPerson then\n        local obstacleDelta = third_person.preferredDistance - camera.getThirdPersonDistance()\n        if delta > 0 and third_person.baseDistance == minDistance and\n           (camera.getMode() ~= MODE.Preview or third_person.standingPreview) and not next(noModeControl) then\n            primaryMode = MODE.FirstPerson\n            camera.setMode(primaryMode)\n        elseif delta > 0 or obstacleDelta < -delta then\n            third_person.baseDistance = util.clamp(third_person.baseDistance - delta - obstacleDelta, minDistance, maxDistance)\n        end\n    elseif delta < 0 and not next(noModeControl) then\n        primaryMode = MODE.ThirdPerson\n        camera.setMode(primaryMode)\n        third_person.baseDistance = minDistance\n    end\nend\n\nlocal function applyControllerZoom(dt)\n    if input.isActionPressed(input.ACTION.TogglePOV) then\n        local triggerLeft = input.getAxisValue(input.CONTROLLER_AXIS.TriggerLeft)\n        local triggerRight = input.getAxisValue(input.CONTROLLER_AXIS.TriggerRight)\n        local controllerZoom = (triggerRight - triggerLeft) * 100 * dt\n        if controllerZoom ~= 0 then\n            zoom(controllerZoom)\n        end\n    end\nend\n\nlocal function updateStandingPreview()\n    local mode = camera.getMode()\n    if not previewIfStandStill or next(noStandingPreview)\n       or mode == MODE.FirstPerson or mode == MODE.Static or mode == MODE.Vanity then\n        third_person.standingPreview = false\n        return\n    end\n    local standingStill = Actor.getCurrentSpeed(self) == 0 and Actor.getStance(self) == Actor.STANCE.Nothing\n    if standingStill and mode == MODE.ThirdPerson then\n        third_person.standingPreview = true\n        camera.setMode(MODE.Preview)\n    elseif not standingStill and third_person.standingPreview then\n        third_person.standingPreview = false\n        camera.setMode(primaryMode)\n    end\nend\n\nlocal function updateCrosshair()\n    camera.showCrosshair(\n        camera.getMode() == MODE.FirstPerson or\n        (showCrosshairInThirdPerson and (camera.getMode() == MODE.ThirdPerson or third_person.standingPreview)))\nend\n\nlocal function onUpdate(dt)\n    camera.setExtraPitch(0)\n    camera.setExtraYaw(0)\n    camera.setExtraRoll(0)\n    camera.setFirstPersonOffset(util.vector3(0, 0, 0))\n    updateSmoothedSpeed(dt)\n    pov_auto_switch.onUpdate(dt)\nend\n\nlocal function updateIdleTimer(dt)\n    if not input.isIdle() then\n        idleTimer = 0\n    elseif self.controls.movement ~= 0 or self.controls.sideMovement ~= 0 or self.controls.jump or self.controls.use ~= 0 then\n        idleTimer = 0  -- also reset the timer in case of a scripted movement\n    else\n        idleTimer = idleTimer + dt\n    end\nend\n\nlocal function onFrame(dt)\n    if core.isWorldPaused() or I.UI.getMode() then return end\n    updateIdleTimer(dt)\n    local mode = camera.getMode()\n    if (mode == MODE.FirstPerson or mode == MODE.ThirdPerson) and not camera.getQueuedMode() then\n        primaryMode = mode\n    end\n    if mode ~= MODE.Static then\n        if not next(noModeControl) then\n            updatePOV(dt)\n            updateVanity(dt)\n        end\n        updateStandingPreview()\n        updateCrosshair()\n    end\n    applyControllerZoom(dt)\n    third_person.update(dt, smoothedSpeed)\n    if not next(noHeadBobbing) then head_bobbing.update(dt, smoothedSpeed) end\n    if slowViewChange then\n        local maxIncrease = dt * (100 + third_person.baseDistance)\n        camera.setPreferredThirdPersonDistance(\n            math.min(camera.getThirdPersonDistance() + maxIncrease, third_person.preferredDistance))\n    end\n    move360.onFrame(dt)\nend\n\nreturn {\n    interfaceName = 'Camera',\n    ---\n    -- @module Camera\n    -- @usage require('openmw.interfaces').Camera\n    interface = {\n        --- Interface version is 1\n        -- @field [parent=#Camera] #number version\n        version = 1,\n\n        --- Return primary mode (MODE.FirstPerson or MODE.ThirdPerson).\n        -- @function [parent=#Camera] getPrimaryMode\n        -- @return #number @{openmw.camera#MODE}\n        getPrimaryMode = function() return primaryMode end,\n\n        --- Get base third person distance (without applying angle and speed modifiers).\n        -- @function [parent=#Camera] getBaseThirdPersonDistance\n        -- @return #number\n        getBaseThirdPersonDistance = function() return third_person.baseDistance end,\n        --- Set base third person distance\n        -- @function [parent=#Camera] setBaseThirdPersonDistance\n        -- @param #number value\n        setBaseThirdPersonDistance = function(v) third_person.baseDistance = v end,\n        --- Get the desired third person distance if there would be no obstacles (with angle and speed modifiers)\n        -- @function [parent=#Camera] getTargetThirdPersonDistance\n        -- @return #number\n        getTargetThirdPersonDistance = function() return third_person.preferredDistance end,\n\n        --- Whether the built-in mode control logic is enabled.\n        -- @function [parent=#Camera] isModeControlEnabled\n        -- @return #boolean\n        isModeControlEnabled = function() return not next(noModeControl) end,\n        --- Disable with (optional) tag until the corresponding enable function is called with the same tag.\n        -- @function [parent=#Camera] disableModeControl\n        -- @param #string tag (optional, empty string by default) Will be disabled until the enabling function is called with the same tag\n        disableModeControl = function(tag) noModeControl[tag or ''] = true end,\n        --- Undo disableModeControl\n        -- @function [parent=#Camera] enableModeControl\n        -- @param #string tag (optional, empty string by default)\n        enableModeControl = function(tag) noModeControl[tag or ''] = nil end,\n\n        --- Whether the built-in standing preview logic is enabled.\n        -- @function [parent=#Camera] isStandingPreviewEnabled\n        -- @return #boolean\n        isStandingPreviewEnabled = function() return previewIfStandStill and not next(noStandingPreview) end,\n        --- Disable with (optional) tag until the corresponding enable function is called with the same tag.\n        -- @function [parent=#Camera] disableStandingPreview\n        -- @param #string tag (optional, empty string by default) Will be disabled until the enabling function is called with the same tag\n        disableStandingPreview = function(tag) noStandingPreview[tag or ''] = true end,\n        --- Undo disableStandingPreview\n        -- @function [parent=#Camera] enableStandingPreview\n        -- @param #string tag (optional, empty string by default)\n        enableStandingPreview = function(tag) noStandingPreview[tag or ''] = nil end,\n\n        --- Whether head bobbing is enabled.\n        -- @function [parent=#Camera] isHeadBobbingEnabled\n        -- @return #boolean\n        isHeadBobbingEnabled = function() return head_bobbing.enabled and not next(noHeadBobbing) end,\n        --- Disable with (optional) tag until the corresponding enable function is called with the same tag.\n        -- @function [parent=#Camera] disableHeadBobbing\n        -- @param #string tag (optional, empty string by default) Will be disabled until the enabling function is called with the same tag\n        disableHeadBobbing = function(tag) noHeadBobbing[tag or ''] = true end,\n        --- Undo disableHeadBobbing\n        -- @function [parent=#Camera] enableHeadBobbing\n        -- @param #string tag (optional, empty string by default)\n        enableHeadBobbing = function(tag) noHeadBobbing[tag or ''] = nil end,\n\n        --- Whether the built-in zooming is enabled.\n        -- @function [parent=#Camera] isZoomEnabled\n        -- @return #boolean\n        isZoomEnabled = function() return not next(noZoom) end,\n        --- Disable with (optional) tag until the corresponding enable function is called with the same tag.\n        -- @function [parent=#Camera] disableZoom\n        -- @param #string tag (optional, empty string by default) Will be disabled until the enabling function is called with the same tag\n        disableZoom = function(tag) noZoom[tag or ''] = true end,\n        --- Undo disableZoom\n        -- @function [parent=#Camera] enableZoom\n        -- @param #string tag (optional, empty string by default)\n        enableZoom = function(tag) noZoom[tag or ''] = nil end,\n\n        --- Whether the the third person offset can be changed by the built-in camera script.\n        -- @function [parent=#Camera] isThirdPersonOffsetControlEnabled\n        -- @return #boolean\n        isThirdPersonOffsetControlEnabled = function() return not next(third_person.noOffsetControl) end,\n        --- Disable with (optional) tag until the corresponding enable function is called with the same tag.\n        -- @function [parent=#Camera] disableThirdPersonOffsetControl\n        -- @param #string tag (optional, empty string by default) Will be disabled until the enabling function is called with the same tag\n        disableThirdPersonOffsetControl = function(tag) third_person.noOffsetControl[tag or ''] = true end,\n        --- Undo disableThirdPersonOffsetControl\n        -- @function [parent=#Camera] enableThirdPersonOffsetControl\n        -- @param #string tag (optional, empty string by default)\n        enableThirdPersonOffsetControl = function(tag) third_person.noOffsetControl[tag or ''] = nil end,\n    },\n    engineHandlers = {\n        onUpdate = onUpdate,\n        onFrame = onFrame,\n        onInputAction = function(action)\n            if core.isWorldPaused() or I.UI.getMode() then return end\n            if action == input.ACTION.ZoomIn then\n                zoom(10)\n            elseif action == input.ACTION.ZoomOut then\n                zoom(-10)\n            end\n            move360.onInputAction(action)\n        end,\n        onTeleported = function()\n            camera.instantTransition()\n        end,\n        onActive = init,\n        onLoad = function(data)\n            if data and data.distance then third_person.baseDistance = data.distance end\n        end,\n        onSave = function()\n            return {version = 0, distance = third_person.baseDistance}\n        end,\n    },\n}\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\camera\\first_person_auto_switch.lua": "local camera = require('openmw.camera')\nlocal util = require('openmw.util')\nlocal nearby = require('openmw.nearby')\nlocal self = require('openmw.self')\n\nlocal forcedFirstPerson = false\nlocal limitSwitch = 40\nlocal limitReturn = 65\n\nlocal rayOptions = {collisionType = nearby.COLLISION_TYPE.Default - nearby.COLLISION_TYPE.Actor}\nlocal function castRayBackward()\n    local from = camera.getTrackedPosition()\n    local orient = util.transform.rotateZ(camera.getYaw()) * util.transform.rotateX(camera.getPitch())\n    local resLeft = nearby.castRay(from, from + orient * util.vector3(-30, -limitReturn, 0), rayOptions)\n    local resRight = nearby.castRay(from, from + orient * util.vector3(30, -limitReturn, 0), rayOptions)\n    local distLeft = limitReturn + 1\n    local distRight = limitReturn + 1\n    if resLeft.hit then distLeft = (resLeft.hitPos - from):length() end\n    if resRight.hit then distRight = (resRight.hitPos - from):length() end\n    return math.min(distLeft, distRight)\nend\n\nlocal M = {\n    enabled = false,\n}\n\nfunction M.onUpdate(dt)\n    if camera.getMode() ~= camera.MODE.FirstPerson then forcedFirstPerson = false end\n    if not M.enabled then\n        if forcedFirstPerson then\n            camera.setMode(camera.MODE.ThirdPerson, false)\n            forcedFirstPerson = false\n        end\n        return\n    end\n    if camera.getMode() == camera.MODE.ThirdPerson and camera.getThirdPersonDistance() < limitSwitch\n            and math.abs(util.normalizeAngle(camera.getYaw() - self.rotation:getYaw())) < math.rad(10) then\n        if castRayBackward() <= limitSwitch then\n            camera.setMode(camera.MODE.FirstPerson, true)\n            forcedFirstPerson = true\n        end\n        return\n    end\n    if forcedFirstPerson then\n        if castRayBackward() > limitReturn then\n            camera.setMode(camera.MODE.ThirdPerson, false)\n            forcedFirstPerson = false\n        end\n    end\nend\n\nreturn M\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\camera\\head_bobbing.lua": "local camera = require('openmw.camera')\nlocal self = require('openmw.self')\nlocal util = require('openmw.util')\nlocal async = require('openmw.async')\n\nlocal Actor = require('openmw.types').Actor\n\nlocal M = {}\n\nlocal settings = require('scripts.omw.camera.settings').headBobbing\n\nlocal doubleStepLength, stepHeight, maxRoll\n\nlocal function updateSettings()\n    M.enabled = settings:get('enabled')\n    doubleStepLength = settings:get('step') * 2\n    stepHeight = settings:get('height')\n    maxRoll = math.rad(settings:get('roll'))\nend\n\nupdateSettings()\nsettings:subscribe(async:callback(updateSettings))\n\nlocal effectWeight = 0\nlocal totalMovement = 0\n\n-- Trajectory of each step is a scaled arc of 60 degrees.\nlocal halfArc = math.rad(30)\nlocal sampleArc = function(x) return 1 - math.cos(x * halfArc) end\nlocal arcHeight = sampleArc(1)\n\nfunction M.update(dt, smoothedSpeed)\n    local speed = Actor.getCurrentSpeed(self)\n    speed = speed / (1 + speed / 500)  -- limit bobbing frequency if the speed is very high\n    totalMovement = totalMovement + speed * dt\n    if not M.enabled or camera.getMode() ~= camera.MODE.FirstPerson then\n        effectWeight = 0\n        return\n    end\n    if Actor.isOnGround(self) then\n        effectWeight = math.min(1, effectWeight + dt * 5)\n    else\n        effectWeight = math.max(0, effectWeight - dt * 5)\n    end\n\n    local doubleStepState = totalMovement / doubleStepLength\n    doubleStepState = doubleStepState - math.floor(doubleStepState)  -- from 0 to 1 during 2 steps\n    local stepState = math.abs(doubleStepState * 4 - 2) - 1  -- from -1 to 1 on even steps and from 1 to -1 on odd steps\n    local effect = sampleArc(stepState) / arcHeight  -- range from 0 to 1\n\n    -- Smoothly reduce the effect to zero when the player stops\n    local coef = math.min(smoothedSpeed / 300, 1) * effectWeight\n\n    local zOffset = (0.5 - effect) * coef * stepHeight  -- range from -stepHeight/2 to stepHeight/2\n    local roll = ((stepState > 0 and 1) or -1) * effect * coef * maxRoll  -- range from -maxRoll to maxRoll\n    camera.setFirstPersonOffset(camera.getFirstPersonOffset() + util.vector3(0, 0, zOffset))\n    camera.setExtraRoll(camera.getExtraRoll() + roll)\nend\n\nreturn M\n\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\camera\\move360.lua": "local core = require('openmw.core')\nlocal camera = require('openmw.camera')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal util = require('openmw.util')\nlocal I = require('openmw.interfaces')\n\nlocal Actor = require('openmw.types').Actor\nlocal Player = require('openmw.types').Player\n\nlocal MODE = camera.MODE\n\nlocal active = false\n\nlocal M = {\n    enabled = false,\n    turnSpeed = 5,\n}\n\nlocal function turnOn()\n    I.Camera.disableStandingPreview()\n    active = true\nend\n\nlocal function turnOff()\n    I.Camera.enableStandingPreview()\n    active = false\n    if camera.getMode() == MODE.Preview then\n        camera.setMode(MODE.ThirdPerson)\n    end\nend\n\nfunction M.onFrame(dt)\n    if core.isWorldPaused() then return end\n    local newActive = M.enabled and Actor.getStance(self) == Actor.STANCE.Nothing\n    if newActive and not active then\n        turnOn()\n    elseif not newActive and active then\n        turnOff()\n    end\n    if not active then return end\n    if camera.getMode() == MODE.Static then return end\n    if camera.getMode() == MODE.ThirdPerson then camera.setMode(MODE.Preview) end\n    if camera.getMode() == MODE.Preview and not input.isActionPressed(input.ACTION.TogglePOV) then\n        camera.showCrosshair(camera.getFocalPreferredOffset():length() > 5)\n        local move = util.vector2(self.controls.sideMovement, self.controls.movement)\n        local yawDelta = camera.getYaw() - self.rotation:getYaw()\n        move = move:rotate(-yawDelta)\n        self.controls.sideMovement = move.x\n        self.controls.movement = move.y\n        self.controls.pitchChange = camera.getPitch() * math.cos(yawDelta) - self.rotation:getPitch()\n        if move:length() > 0.05 then\n            local delta = math.atan2(move.x, move.y)\n            local maxDelta = math.max(delta, 1) * M.turnSpeed * dt\n            self.controls.yawChange = util.clamp(delta, -maxDelta, maxDelta)\n        else\n            self.controls.yawChange = 0\n        end\n    end\nend\n\nfunction M.onInputAction(action)\n    if not active or core.isWorldPaused() or\n       not Player.getControlSwitch(self, Player.CONTROL_SWITCH.ViewMode) or\n       not Player.getControlSwitch(self, Player.CONTROL_SWITCH.Controls) or\n       input.isActionPressed(input.ACTION.TogglePOV) or\n       not I.Camera.isModeControlEnabled() then\n        return\n    end\n    if action == input.ACTION.ZoomIn and camera.getMode() == MODE.Preview\n       and I.Camera.getBaseThirdPersonDistance() == 30 then\n        self.controls.yawChange = camera.getYaw() - self.rotation:getYaw()\n        camera.setMode(MODE.FirstPerson)\n    elseif action == input.ACTION.ZoomOut and camera.getMode() == MODE.FirstPerson then\n        camera.setMode(MODE.Preview)\n        I.Camera.setBaseThirdPersonDistance(30)\n    end\nend\n\nreturn M\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\camera\\settings.lua": "local storage = require('openmw.storage')\nlocal async = require('openmw.async')\nlocal I = require('openmw.interfaces')\n\nI.Settings.registerPage({\n  key = 'OMWCamera',\n  l10n = 'OMWCamera',\n  name = 'Camera',\n  description = 'settingsPageDescription',\n})\n\nlocal thirdPersonGroup = 'SettingsOMWCameraThirdPerson'\nlocal headBobbingGroup = 'SettingsOMWCameraHeadBobbing'\n\nlocal function boolSetting(prefix, key, default)\n    return {\n        key = key,\n        renderer = 'checkbox',\n        name = prefix..key,\n        description = prefix..key..'Description',\n        default = default,\n    }\nend\n\nlocal function floatSetting(prefix, key, default)\n    return {\n        key = key,\n        renderer = 'number',\n        name = prefix..key,\n        description = prefix..key..'Description',\n        default = default,\n    }\nend\n\nI.Settings.registerGroup({\n    key = thirdPersonGroup,\n    page = 'OMWCamera',\n    l10n = 'OMWCamera',\n    name = 'thirdPersonSettings',\n    permanentStorage = true,\n    order = 0,\n    settings = {\n        boolSetting('', 'viewOverShoulder', false),\n        floatSetting('', 'shoulderOffsetX', 30),\n        floatSetting('', 'shoulderOffsetY', -10),\n        boolSetting('', 'autoSwitchShoulder', false),\n        floatSetting('', 'zoomOutWhenMoveCoef', 20),\n        boolSetting('', 'previewIfStandStill', false),\n        boolSetting('', 'deferredPreviewRotation', false),\n        boolSetting('', 'ignoreNC', false),\n        boolSetting('', 'move360', false),\n        floatSetting('', 'move360TurnSpeed', 5),\n        boolSetting('', 'slowViewChange', false),\n        boolSetting('', 'povAutoSwitch', false),\n    },\n})\n\nI.Settings.registerGroup({\n    key = headBobbingGroup,\n    page = 'OMWCamera',\n    l10n = 'OMWCamera',\n    name = 'headBobbingSettings',\n    permanentStorage = true,\n    order = 1,\n    settings = {\n        boolSetting('headBobbing_', 'enabled', false),\n        floatSetting('headBobbing_', 'step', 90),\n        floatSetting('headBobbing_', 'height', 3),\n        floatSetting('headBobbing_', 'roll', 0.2),\n    },\n})\n\nlocal settings = {\n    thirdPerson = storage.playerSection(thirdPersonGroup),\n    headBobbing = storage.playerSection(headBobbingGroup),\n}\n\nlocal function updateViewOverShoulderDisabled()\n    local shoulderDisabled = not settings.thirdPerson:get('viewOverShoulder')\n    I.Settings.updateRendererArgument(thirdPersonGroup, 'shoulderOffsetX', {disabled = shoulderDisabled})\n    I.Settings.updateRendererArgument(thirdPersonGroup, 'shoulderOffsetY', {disabled = shoulderDisabled})\n    I.Settings.updateRendererArgument(thirdPersonGroup, 'autoSwitchShoulder', {disabled = shoulderDisabled})\n    I.Settings.updateRendererArgument(thirdPersonGroup, 'zoomOutWhenMoveCoef', {disabled = shoulderDisabled})\n\n    local move360Disabled = not settings.thirdPerson:get('move360')\n    I.Settings.updateRendererArgument(thirdPersonGroup, 'move360TurnSpeed', {disabled = move360Disabled})\nend\n\nlocal function updateHeadBobbingDisabled()\n    local disabled = not settings.headBobbing:get('enabled')\n    I.Settings.updateRendererArgument(headBobbingGroup, 'step', {disabled = disabled, min = 1})\n    I.Settings.updateRendererArgument(headBobbingGroup, 'height', {disabled = disabled})\n    I.Settings.updateRendererArgument(headBobbingGroup, 'roll', {disabled = disabled, min = 0, max = 90})\nend\n\nupdateViewOverShoulderDisabled()\nupdateHeadBobbingDisabled()\n\nsettings.thirdPerson:subscribe(async:callback(updateViewOverShoulderDisabled))\nsettings.headBobbing:subscribe(async:callback(updateHeadBobbingDisabled))\n\nreturn settings\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\camera\\third_person.lua": "local camera = require('openmw.camera')\nlocal util = require('openmw.util')\nlocal self = require('openmw.self')\nlocal nearby = require('openmw.nearby')\nlocal async = require('openmw.async')\n\nlocal Actor = require('openmw.types').Actor\n\nlocal settings = require('scripts.omw.camera.settings').thirdPerson\n\nlocal MODE = camera.MODE\nlocal STATE = { RightShoulder = 0, LeftShoulder = 1, Combat = 2, Swimming = 3 }\n\nlocal M = {\n    baseDistance = 192,\n    preferredDistance = 0,\n    standingPreview = false,\n    noOffsetControl = {},\n}\n\nlocal viewOverShoulder, autoSwitchShoulder\nlocal shoulderOffset\nlocal zoomOutWhenMoveCoef\n\nlocal defaultShoulder, rightShoulderOffset, leftShoulderOffset\nlocal combatOffset = util.vector2(0, 15)\n\nlocal noThirdPersonLastFrame = true\n\nlocal function updateSettings()\n    viewOverShoulder = settings:get('viewOverShoulder')\n    autoSwitchShoulder = settings:get('autoSwitchShoulder')\n    shoulderOffset = util.vector2(settings:get('shoulderOffsetX'),\n                                  settings:get('shoulderOffsetY'))\n    zoomOutWhenMoveCoef = settings:get('zoomOutWhenMoveCoef')\n\n    defaultShoulder = (shoulderOffset.x > 0 and STATE.RightShoulder) or STATE.LeftShoulder\n    rightShoulderOffset = util.vector2(math.abs(shoulderOffset.x), shoulderOffset.y)\n    leftShoulderOffset = util.vector2(-math.abs(shoulderOffset.x), shoulderOffset.y)\n    noThirdPersonLastFrame = true\nend\nupdateSettings()\nsettings:subscribe(async:callback(updateSettings))\n\nlocal state = defaultShoulder\n\nlocal function ray(from, angle, limit)\n    local to = from + util.transform.rotateZ(angle) * util.vector3(0, limit, 0)\n    local res = nearby.castRay(from, to, {collisionType = camera.getCollisionType()})\n    if res.hit then\n        return (res.hitPos - from):length()\n    else\n        return limit\n    end\nend\n\nlocal function trySwitchShoulder()\n    local limitToSwitch = 120  -- switch to other shoulder if wall is closer than this limit\n    local limitToSwitchBack = 300  -- switch back to default shoulder if there is no walls at this distance\n\n    local pos = camera.getTrackedPosition()\n    local rayRight = ray(pos, camera.getYaw() + math.rad(90), limitToSwitchBack + 1)\n    local rayLeft = ray(pos, camera.getYaw() - math.rad(90), limitToSwitchBack + 1)\n    local rayRightForward = ray(pos, camera.getYaw() + math.rad(30), limitToSwitchBack + 1)\n    local rayLeftForward = ray(pos, camera.getYaw() - math.rad(30), limitToSwitchBack + 1)\n\n    local distRight = math.min(rayRight, rayRightForward)\n    local distLeft = math.min(rayLeft, rayLeftForward)\n\n    if distLeft < limitToSwitch and distRight > limitToSwitchBack then\n        state = STATE.RightShoulder\n    elseif distRight < limitToSwitch and distLeft > limitToSwitchBack then\n        state = STATE.LeftShoulder\n    elseif distRight > limitToSwitchBack and distLeft > limitToSwitchBack then\n        state = defaultShoulder\n    end\nend\n\nlocal function calculateDistance(smoothedSpeed)\n    local smoothedSpeedSqr = smoothedSpeed * smoothedSpeed\n    return (M.baseDistance + math.max(camera.getPitch(), 0) * 50\n            + smoothedSpeedSqr / (smoothedSpeedSqr + 300*300) * zoomOutWhenMoveCoef)\nend\n\nlocal function updateState()\n    local mode = camera.getMode()\n    local oldState = state\n    if Actor.getStance(self) ~= Actor.STANCE.Nothing and mode == MODE.ThirdPerson then\n        state = STATE.Combat\n    elseif Actor.isSwimming(self) then\n        state = STATE.Swimming\n    elseif oldState == STATE.Combat or oldState == STATE.Swimming then\n        state = defaultShoulder\n    elseif not state then\n        state = defaultShoulder\n    end\n    if (mode == MODE.ThirdPerson or Actor.getCurrentSpeed(self) > 0 or state ~= oldState or noThirdPersonLastFrame)\n       and (state == STATE.LeftShoulder or state == STATE.RightShoulder) then\n        if autoSwitchShoulder then\n            trySwitchShoulder()\n        else\n            state = defaultShoulder\n        end\n    end\n    if oldState ~= state or noThirdPersonLastFrame then\n        -- State was changed, start focal point transition.\n        if mode == MODE.Vanity then\n            -- Player doesn't touch controls for a long time. Transition should be very slow.\n            camera.setFocalTransitionSpeed(0.2)\n        elseif (oldState == STATE.Combat or state == STATE.Combat) and\n               (mode ~= MODE.Preview or M.standingPreview) then\n            -- Transition to/from combat mode and we are not in preview mode. Should be fast.\n            camera.setFocalTransitionSpeed(5.0)\n        else\n            camera.setFocalTransitionSpeed(1.0)  -- Default transition speed.\n        end\n\n        if state == STATE.RightShoulder then\n            camera.setFocalPreferredOffset(rightShoulderOffset)\n        elseif state == STATE.LeftShoulder then\n            camera.setFocalPreferredOffset(leftShoulderOffset)\n        else\n            camera.setFocalPreferredOffset(combatOffset)\n        end\n    end\nend\n\nfunction M.update(dt, smoothedSpeed)\n    local mode = camera.getMode()\n    if mode == MODE.FirstPerson or mode == MODE.Static then\n        noThirdPersonLastFrame = true\n        return\n    end\n    if not viewOverShoulder then\n        M.preferredDistance = M.baseDistance\n        camera.setPreferredThirdPersonDistance(M.baseDistance)\n        if noThirdPersonLastFrame then\n            camera.setFocalPreferredOffset(util.vector2(0, 0))\n            camera.instantTransition()\n            noThirdPersonLastFrame = false\n        end\n        return\n    end\n\n    if not next(M.noOffsetControl) then\n        updateState()\n    else\n        state = nil\n    end\n\n    M.preferredDistance = calculateDistance(smoothedSpeed)\n    if noThirdPersonLastFrame then  -- just switched to third person view\n        camera.setPreferredThirdPersonDistance(M.preferredDistance)\n        camera.instantTransition()\n        noThirdPersonLastFrame = false\n    else\n        local maxIncrease = dt * (100 + M.baseDistance)\n        camera.setPreferredThirdPersonDistance(math.min(\n            M.preferredDistance, camera.getThirdPersonDistance() + maxIncrease))\n    end\nend\n\nreturn M\n\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\console\\global.lua": "local util = require('openmw.util')\n\nlocal player = nil\n\nlocal function printToConsole(...)\n    local strs = {}\n    for i = 1, select('#', ...) do\n        strs[i] = tostring(select(i, ...))\n    end\n    player:sendEvent('OMWConsolePrint', table.concat(strs, '\\t'))\nend\n\nlocal function printRes(...)\n    if select('#', ...) >= 0 then\n        printToConsole(...)\n    end\nend\n\nlocal env = {\n    I = require('openmw.interfaces'),\n    util = require('openmw.util'),\n    storage = require('openmw.storage'),\n    core = require('openmw.core'),\n    types = require('openmw.types'),\n    vfs = require('openmw.vfs'),\n    async = require('openmw.async'),\n    world = require('openmw.world'),\n    aux_util = require('openmw_aux.util'),\n    view = require('openmw_aux.util').deepToString,\n    print = printToConsole,\n    exit = function() player:sendEvent('OMWConsoleExit') end,\n    help = function() player:sendEvent('OMWConsoleHelp') end,\n}\nenv._G = env\nsetmetatable(env, {__index = _G, __metatable = false})\n_G = nil\n\nlocal function executeLuaCode(code)\n    local fn\n    local ok, err = pcall(function() fn = util.loadCode('return ' .. code, env) end)\n    if ok then\n        ok, err = pcall(function() printRes(fn()) end)\n    else\n        ok, err = pcall(function() util.loadCode(code, env)() end)\n    end\n    if not ok then\n        player:sendEvent('OMWConsoleError', err)\n    end\nend\n\nreturn {\n    eventHandlers = {\n        OMWConsoleEval = function(data)\n            player = data.player\n            env.selected = data.selected\n            executeLuaCode(data.code)\n            if env.selected ~= data.selected then\n                local ok, err = pcall(function() player:sendEvent('OMWConsoleSetSelected', env.selected) end)\n                if not ok then player:sendEvent('OMWConsoleError', err) end\n            end\n        end,\n        OMWConsoleStartLocal = function(data)\n            player = data.player\n            ok, err = pcall(function()\n                if not data.selected:hasScript('scripts/omw/console/local.lua') then\n                    data.selected:addScript('scripts/omw/console/local.lua')\n                end\n            end)\n            if ok then\n                player:sendEvent('OMWConsoleSetContext', data.selected)\n            else\n                player:sendEvent('OMWConsoleError', err)\n            end\n        end,\n        OMWConsoleStopLocal = function(obj)\n            if obj:hasScript('scripts/omw/console/local.lua') then\n                obj:removeScript('scripts/omw/console/local.lua')\n            end\n        end,\n    },\n}\n\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\console\\local.lua": "local util = require('openmw.util')\nlocal core = require('openmw.core')\nlocal self = require('openmw.self')\n\nlocal player = nil\n\nlocal function printToConsole(...)\n    local strs = {}\n    for i = 1, select('#', ...) do\n        strs[i] = tostring(select(i, ...))\n    end\n    player:sendEvent('OMWConsolePrint', table.concat(strs, '\\t'))\nend\n\nlocal function printRes(...)\n    if select('#', ...) >= 0 then\n        printToConsole(...)\n    end\nend\n\nlocal env = {\n    I = require('openmw.interfaces'),\n    util = require('openmw.util'),\n    storage = require('openmw.storage'),\n    core = require('openmw.core'),\n    types = require('openmw.types'),\n    vfs = require('openmw.vfs'),\n    async = require('openmw.async'),\n    nearby = require('openmw.nearby'),\n    self = require('openmw.self'),\n    aux_util = require('openmw_aux.util'),\n    view = require('openmw_aux.util').deepToString,\n    print = printToConsole,\n    exit = function() player:sendEvent('OMWConsoleExit') end,\n    help = function() player:sendEvent('OMWConsoleHelp') end,\n}\nenv._G = env\nsetmetatable(env, {__index = _G, __metatable = false})\n_G = nil\n\nlocal function executeLuaCode(code)\n    local fn\n    local ok, err = pcall(function() fn = util.loadCode('return ' .. code, env) end)\n    if ok then\n        ok, err = pcall(function() printRes(fn()) end)\n    else\n        ok, err = pcall(function() util.loadCode(code, env)() end)\n    end\n    if not ok then\n        player:sendEvent('OMWConsoleError', err)\n    end\nend\n\nreturn {\n    eventHandlers = {\n        OMWConsoleEval = function(data)\n            player = data.player\n            env.selected = data.selected\n            executeLuaCode(data.code)\n            if env.selected ~= data.selected then\n                local ok, err = pcall(function() player:sendEvent('OMWConsoleSetSelected', env.selected) end)\n                if not ok then player:sendEvent('OMWConsoleError', err) end\n            end\n        end,\n    },\n    engineHandlers = {\n        onLoad = function()\n            core.sendGlobalEvent('OMWConsoleStopLocal', self.object)\n        end,\n    }\n}\n\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\console\\player.lua": "local ui = require('openmw.ui')\nlocal util = require('openmw.util')\nlocal self = require('openmw.self')\nlocal core = require('openmw.core')\n\nlocal function printHelp()\n    local msg = [[\nThis is the built-in Lua interpreter.\nhelp() - print this message\nexit() - exit Lua mode\nselected - currently selected object (click on any object to change)\nview(_G) - print content of the table `_G` (current environment)\n    standard libraries (math, string, etc.) are loaded by default but not visible in `_G`\nview(types, 2) - print table `types` (i.e. `openmw.types`) and its subtables (2 - traversal depth)]]\n    ui.printToConsole(msg, ui.CONSOLE_COLOR.Info)\nend\n\nlocal function printToConsole(...)\n    local strs = {}\n    for i = 1, select('#', ...) do\n        strs[i] = tostring(select(i, ...))\n    end\n    return ui.printToConsole(table.concat(strs, '\\t'), ui.CONSOLE_COLOR.Info)\nend\n\nlocal function printRes(...)\n    if select('#', ...) >= 0 then\n        printToConsole(...)\n    end\nend\n\nlocal currentSelf = nil\nlocal currentMode = ''\n\nlocal function exitLuaMode()\n    currentSelf = nil\n    currentMode = ''\n    ui.setConsoleMode('')\n    ui.printToConsole('Lua mode OFF', ui.CONSOLE_COLOR.Success)\nend\n\nlocal function setContext(obj)\n    ui.printToConsole('Lua mode ON, use exit() to return, help() for more info', ui.CONSOLE_COLOR.Success)\n    if obj == self then\n        currentMode = 'Lua[Player]'\n        ui.printToConsole('Context: Player', ui.CONSOLE_COLOR.Success)\n    elseif obj then\n        if not obj:isValid() then error('Object not available') end\n        currentMode = 'Lua['..obj.recordId..']'\n        ui.printToConsole('Context: Local['..tostring(obj)..']', ui.CONSOLE_COLOR.Success)\n    else\n        currentMode = 'Lua[Global]'\n        ui.printToConsole('Context: Global', ui.CONSOLE_COLOR.Success)\n    end\n    currentSelf = obj\n    ui.setConsoleMode(currentMode)\nend\n\nlocal function setSelected(obj)\n    local ok, err = pcall(function() ui.setConsoleSelectedObject(obj) end)\n    if ok then\n        ui.printToConsole('Selected object changed', ui.CONSOLE_COLOR.Success)\n    else\n        ui.printToConsole(err, ui.CONSOLE_COLOR.Error)\n    end\nend\n\nlocal env = {\n    I = require('openmw.interfaces'),\n    util = require('openmw.util'),\n    storage = require('openmw.storage'),\n    core = require('openmw.core'),\n    types = require('openmw.types'),\n    vfs = require('openmw.vfs'),\n    ambient = require('openmw.ambient'),\n    async = require('openmw.async'),\n    nearby = require('openmw.nearby'),\n    self = require('openmw.self'),\n    input = require('openmw.input'),\n    ui = require('openmw.ui'),\n    camera = require('openmw.camera'),\n    aux_util = require('openmw_aux.util'),\n    debug = require('openmw.debug'),\n    view = require('openmw_aux.util').deepToString,\n    print = printToConsole,\n    exit = exitLuaMode,\n    help = printHelp,\n}\nenv._G = env\nsetmetatable(env, {__index = _G, __metatable = false})\n_G = nil\n\nlocal function executeLuaCode(code)\n    local fn\n    local ok, err = pcall(function() fn = util.loadCode('return ' .. code, env) end)\n    if ok then\n        ok, err = pcall(function() printRes(fn()) end)\n    else\n        ok, err = pcall(function() util.loadCode(code, env)() end)\n    end\n    if not ok then\n        ui.printToConsole(err, ui.CONSOLE_COLOR.Error)\n    end\nend\n\nlocal function onConsoleCommand(mode, cmd, selectedObject)\n    env.selected = selectedObject\n    if mode == '' then\n        cmd, arg = cmd:lower():match('(%w+) *(%w*)')\n        if cmd == 'lua' then\n            if arg == 'player' then\n                cmd = 'luap'\n            elseif arg == 'global' then\n                cmd = 'luag'\n            elseif arg == 'selected' then\n                cmd = 'luas'\n            else\n                local msg = [[\nUsage: 'lua player' or 'luap' - enter player context\n       'lua global' or 'luag' - enter global context\n       'lua selected' or 'luas' - enter local context on the selected object]]\n                ui.printToConsole(msg, ui.CONSOLE_COLOR.Info)\n            end\n        end\n        if cmd == 'luap' or (cmd == 'luas' and selectedObject == self.object) then\n            setContext(self)\n        elseif cmd == 'luag' then\n            setContext()\n        elseif cmd == 'luas' then\n            if selectedObject then\n                core.sendGlobalEvent('OMWConsoleStartLocal', {player=self.object, selected=selectedObject})\n            else\n                ui.printToConsole('No selected object', ui.CONSOLE_COLOR.Error)\n            end\n        end\n    elseif mode == currentMode then\n        if cmd == 'exit()' then\n            exitLuaMode()\n        elseif currentSelf == self then\n            executeLuaCode(cmd)\n            if env.selected ~= selectedObject then setSelected(env.selected) end\n        elseif currentSelf then\n            currentSelf:sendEvent('OMWConsoleEval', {player=self.object, code=cmd, selected=selectedObject})\n        else\n            core.sendGlobalEvent('OMWConsoleEval', {player=self.object, code=cmd, selected=selectedObject})\n        end\n    end\nend\n\nreturn {\n    engineHandlers = {onConsoleCommand = onConsoleCommand},\n    eventHandlers = {\n        OMWConsolePrint = function(msg) ui.printToConsole(tostring(msg), ui.CONSOLE_COLOR.Info) end,\n        OMWConsoleError = function(msg) ui.printToConsole(tostring(msg), ui.CONSOLE_COLOR.Error) end,\n        OMWConsoleSetContext = setContext,\n        OMWConsoleSetSelected = setSelected,\n        OMWConsoleExit = exitLuaMode,\n        OMWConsoleHelp = printHelp,\n    }\n}\n\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\mechanics\\playercontroller.lua": "local core = require('openmw.core')\nlocal nearby = require('openmw.nearby')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\n\nlocal cell = nil\nlocal autodoors = {}\n\nlocal function onCellChange()\n    autodoors = {}\n    for _, door in ipairs(nearby.doors) do\n        if door.type == types.ESM4Door and types.ESM4Door.record(door).isAutomatic then\n            autodoors[#autodoors + 1] = door\n        end\n    end\nend\n\nlocal autodoorActivationDist = 300\n\nlocal lastAutoActivation = 0\nlocal function processAutomaticDoors()\n    if core.getRealTime() - lastAutoActivation < 2 then\n        return\n    end\n    for _, door in ipairs(autodoors) do\n        if door.enabled and (door.position - self.position):length() < autodoorActivationDist then\n            print('Automatic activation of', door)\n            door:activateBy(self)\n            lastAutoActivation = core.getRealTime()\n        end\n    end\nend\n\nlocal function onUpdate()\n    if self.cell ~= cell then\n        cell = self.cell\n        onCellChange()\n    end\n    processAutomaticDoors()\nend\n\nreturn {\n    engineHandlers = {\n        onUpdate = onUpdate,\n    },\n}\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\mwui\\borders.lua": "local ui = require('openmw.ui')\nlocal util = require('openmw.util')\n\nlocal auxUi = require('openmw_aux.ui')\n\nlocal constants = require('scripts.omw.mwui.constants')\n\nlocal v2 = util.vector2\nlocal whiteTexture = constants.whiteTexture\nlocal menuTransparency = ui._getMenuTransparency()\n\nlocal sideParts = {\n    left = v2(0, 0),\n    right = v2(1, 0),\n    top = v2(0, 0),\n    bottom = v2(0, 1),\n}\nlocal cornerParts = {\n    top_left = v2(0, 0),\n    top_right = v2(1, 0),\n    bottom_left = v2(0, 1),\n    bottom_right = v2(1, 1),\n}\n\nlocal borderSidePattern = 'textures/menu_%s_border_%s.dds'\nlocal borderCornerPattern = 'textures/menu_%s_border_%s_corner.dds'\n\nlocal borderResources = {}\nlocal borderPieces = {}\nfor _, thickness in ipairs{'thin', 'thick'} do\n    borderResources[thickness] = {}\n    for k in pairs(sideParts) do\n        borderResources[thickness][k] = ui.texture{ path = borderSidePattern:format(thickness, k) }\n    end\n    for k in pairs(cornerParts) do\n        borderResources[thickness][k] = ui.texture{ path = borderCornerPattern:format(thickness, k) }\n    end\n\n    borderPieces[thickness] = {}\n    for k in pairs(sideParts) do\n        local horizontal = k == 'top' or k == 'bottom'\n        borderPieces[thickness][k] = {\n            type = ui.TYPE.Image,\n            props = {\n                resource = borderResources[thickness][k],\n                tileH = horizontal,\n                tileV = not horizontal,\n            },\n        }\n    end\n    for k in pairs(cornerParts) do\n        borderPieces[thickness][k] = {\n            type = ui.TYPE.Image,\n            props = {\n                resource = borderResources[thickness][k],\n            },\n        }\n    end\nend\n\n\n\nlocal function borderTemplates(thickness)\n    local borderSize = (thickness == 'thin') and constants.border or constants.thickBorder\n    local borderV = v2(1, 1) * borderSize\n    local result = {}\n    result.horizontalLine = {\n        type = ui.TYPE.Image,\n        props = {\n            resource = borderResources[thickness].top,\n            tileH = true,\n            tileV = false,\n            size = v2(0, borderSize),\n            relativeSize = v2(1, 0),\n        },\n    }\n\n    result.verticalLine = {\n        type = ui.TYPE.Image,\n        props = {\n            resource = borderResources[thickness].left,\n            tileH = false,\n            tileV = true,\n            size = v2(borderSize, 0),\n            relativeSize = v2(0, 1),\n        },\n    }\n\n    result.borders = {\n        content = ui.content {},\n    }\n    for k, v in pairs(sideParts) do\n        local horizontal = k == 'top' or k == 'bottom'\n        local direction = horizontal and v2(1, 0) or v2(0, 1)\n        result.borders.content:add {\n            template = borderPieces[thickness][k],\n            props = {\n                position = (direction - v) * borderSize,\n                relativePosition = v,\n                size = (v2(1, 1) - direction * 3) * borderSize,\n                relativeSize = direction,\n            }\n        }\n    end\n    for k, v in pairs(cornerParts) do\n        result.borders.content:add {\n            template = borderPieces[thickness][k],\n            props = {\n                position = -v * borderSize,\n                relativePosition = v,\n                size = borderV,\n            },\n        }\n    end\n    result.borders.content:add {\n        external = { slot = true },\n        props = {\n            position = borderV,\n            size = borderV * -2,\n            relativeSize = v2(1, 1),\n        }\n    }\n\n    result.box = {\n        type = ui.TYPE.Container,\n        content = ui.content{},\n    }\n    for k, v in pairs(sideParts) do\n        local horizontal = k == 'top' or k == 'bottom'\n        local direction = horizontal and v2(1, 0) or v2(0, 1)\n        result.box.content:add {\n            template = borderPieces[thickness][k],\n            props = {\n                position = (direction + v) * borderSize,\n                relativePosition = v,\n                size = (v2(1, 1) - direction) * borderSize,\n                relativeSize = direction,\n            }\n        }\n    end\n    for k, v in pairs(cornerParts) do\n        result.box.content:add {\n            template = borderPieces[thickness][k],\n            props = {\n                position = v * borderSize,\n                relativePosition = v,\n                size = borderV,\n            },\n        }\n    end\n    result.box.content:add {\n        external = { slot = true },\n        props = {\n            position = borderV,\n            relativeSize = v2(1, 1),\n        }\n    }\n\n    local backgroundTransparent = {\n        type = ui.TYPE.Image,\n        props = {\n            resource = whiteTexture,\n            color = util.color.rgb(0, 0, 0),\n            alpha = menuTransparency,\n        },\n    }\n    local backgroundSolid = {\n        type = ui.TYPE.Image,\n        props = {\n            resource = whiteTexture,\n            color = util.color.rgb(0, 0, 0),\n        },\n    }\n\n    result.boxTransparent = auxUi.deepLayoutCopy(result.box)\n    result.boxTransparent.content:insert(1, {\n        template = backgroundTransparent,\n        props = {\n            relativeSize = v2(1, 1),\n            size = borderV * 2,\n        },\n    })\n\n    result.boxSolid = auxUi.deepLayoutCopy(result.box)\n    result.boxSolid.content:insert(1, {\n        template = backgroundSolid,\n        props = {\n            relativeSize = v2(1, 1),\n            size = borderV * 2,\n        },\n    })\n\n    return result\nend\n\nlocal thinBorders = borderTemplates('thin')\nlocal thickBorders = borderTemplates('thick')\n\nreturn function(templates)\n    for k, t in pairs(thinBorders) do\n        templates[k] = t\n    end\n    for k, t in pairs(thickBorders) do\n        templates[k .. 'Thick'] = t\n    end\nend\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\mwui\\constants.lua": "local ui = require('openmw.ui')\nlocal util = require('openmw.util')\n\nreturn {\n    textNormalSize = 16,\n    textHeaderSize = 16,\n    headerColor = util.color.rgb(223 / 255, 201 / 255, 159 / 255),\n    normalColor = util.color.rgb(202 / 255, 165 / 255, 96 / 255),\n    border = 2,\n    thickBorder = 4,\n    padding = 2,\n    whiteTexture = ui.texture { path = 'white' },\n}",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\mwui\\filters.lua": "local ui = require('openmw.ui')\nlocal util = require('openmw.util')\n\nlocal constants = require('scripts.omw.mwui.constants')\n\nreturn function(templates)\n    templates.disabled = {\n        type = ui.TYPE.Container,\n        props = {\n            alpha = 0.6,\n        },\n        content = ui.content {\n            {\n                props = {\n                    relativeSize = util.vector2(1, 1),\n                },\n                external = {\n                    slot = true,\n                },\n            },\n            {\n                type = ui.TYPE.Image,\n                props = {\n                    resource = constants.whiteTexture,\n                    color = util.color.rgb(0, 0, 0),\n                    relativeSize = util.vector2(1, 1),\n                },\n            },\n        },\n    }\nend",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\mwui\\init.lua": "local util = require('openmw.util')\n\nlocal function shallowLayoutCopy(source, target)\n    for k in pairs(target) do\n        target[k] = nil\n    end\n    for k, v in pairs(source) do\n        target[k] = v\n    end\n    return target\nend\n\n---\n-- @type Templates\n-- @usage\n-- local I = require('openmw.interfaces')\n-- local ui = require('openmw.ui')\n-- local auxUi = require('openmw_aux.ui')\n-- ui.create {\n--     template = I.MWUI.templates.textNormal,\n--     layer = 'Windows',\n--     type = ui.TYPE.Text,\n--     props = {\n--         text = 'Hello, world!',\n--     },\n-- }\n-- -- important to copy here\n-- local myText = auxUi.deepLayoutCopy(I.MWUI.templates.textNormal)\n-- myText.props.textSize = 20\n-- I.MWUI.templates.textNormal = myText\n-- ui.updateAll()\n\nlocal templatesMeta = {\n    __index = function(self, key)\n        return self.__templates[key]\n    end,\n    __newindex = function(self, key, template)\n        local target = self.__templates[key]\n        if target == template then\n            error(\"Overriding a template with itself\")\n        else\n            shallowLayoutCopy(template, target)\n        end\n    end,\n}\n\n---\n-- @module MWUI\n-- @usage require('openmw.interfaces').MWUI\nlocal function TemplateOverrides(templates)\n    return setmetatable({\n        __templates = util.makeReadOnly(templates),\n    }, templatesMeta)\nend\n\n---\n-- @field [parent=#MWUI] #Templates templates\nlocal templates = {}\n\n---\n-- Container that adds padding around its content.\n-- @field [parent=#Templates] openmw.ui#Template padding\n\n---\n-- Standard spacing interval\n-- @field [parent=#Templates] openmw.ui#Template interval\nrequire('scripts.omw.mwui.space')(templates)\n\n---\n-- Standard rectangular borders\n-- @field [parent=#Templates] openmw.ui#Template borders\n\n---\n-- Container wrapping the content with borders\n-- @field [parent=#Templates] openmw.ui#Template box\n\n---\n-- Same as box, but with a semi-transparent background\n-- @field [parent=#Templates] openmw.ui#Template boxTransparent\n---\n-- Same as box, but with a solid background\n-- @field [parent=#Templates] openmw.ui#Template boxSolid\n\n---\n-- Expanding vertical line\n-- @field [parent=#Templates] openmw.ui#Template verticalLine\n\n---\n-- Expanding horizontal line\n-- @field [parent=#Templates] openmw.ui#Template horizontalLine\n\n---\n-- Standard rectangular borders\n-- @field [parent=#Templates] openmw.ui#Template bordersThick\n\n---\n-- Container wrapping the content with borders\n-- @field [parent=#Templates] openmw.ui#Template boxThick\n\n---\n-- Same as box, but with a semi-transparent background\n-- @field [parent=#Templates] openmw.ui#Template boxTransparentThick\n---\n-- Same as box, but with a solid background\n-- @field [parent=#Templates] openmw.ui#Template boxSolidThick\n\n---\n-- Expanding vertical line\n-- @field [parent=#Templates] openmw.ui#Template verticalLineThick\n\n---\n-- Expanding horizontal line\n-- @field [parent=#Templates] openmw.ui#Template horizontalLineThick\nrequire('scripts.omw.mwui.borders')(templates)\n\n---\n-- Standard \"sand\" colored text\n-- @field [parent=#Templates] openmw.ui#Template textNormal\n\n---\n-- Header white colored text\n-- @field [parent=#Templates] openmw.ui#Template textHeader\n\n---\n-- Standard \"sand\" colored multiline text\n-- @field [parent=#Templates] openmw.ui#Template textParagraph\nrequire('scripts.omw.mwui.text')(templates)\n\n---\n-- Single line text input\n-- @field [parent=#Templates] openmw.ui#Template textEditLine\n\n---\n-- Multiline text input\n-- @field [parent=#Templates] openmw.ui#Template textEditBox\nrequire('scripts.omw.mwui.textEdit')(templates)\n\n---\n-- Shades its children and makes them uninteractible\n-- @field [parent=#Templates] openmw.ui#Template disabled\nrequire('scripts.omw.mwui.filters')(templates)\n\n---\n-- Interface version\n-- @field [parent=#MWUI] #number version\nlocal interface = {\n    version = 0,\n    templates = TemplateOverrides(templates),\n}\n\nreturn {\n    interfaceName = \"MWUI\",\n    interface = interface,\n}\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\mwui\\space.lua": "local ui = require('openmw.ui')\nlocal util = require('openmw.util')\n\nlocal constants = require('scripts.omw.mwui.constants')\n\nlocal borderV = util.vector2(1, 1) * constants.border\n\nreturn function(templates)\n    templates.padding = {\n        type = ui.TYPE.Container,\n        content = ui.content {\n            {\n                props = {\n                    size = borderV,\n                },\n            },\n            {\n                external = { slot = true },\n                props = {\n                    position = borderV,\n                    relativeSize = util.vector2(1, 1),\n                },\n            },\n            {\n                props = {\n                    position = borderV,\n                    relativePosition = util.vector2(1, 1),\n                    size = borderV,\n                },\n            },\n        }\n    }\n    templates.interval = {\n        type = ui.TYPE.Widget,\n        props = {\n            size = borderV,\n        },\n    }\nend",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\mwui\\text.lua": "local ui = require('openmw.ui')\nlocal util = require('openmw.util')\n\nlocal constants = require('scripts.omw.mwui.constants')\n\nlocal textNormal = {\n    type = ui.TYPE.Text,\n    props = {\n        textSize = constants.textNormalSize,\n        textColor = constants.normalColor,\n    },\n}\n\nlocal textHeader = {\n    type = ui.TYPE.Text,\n    props = {\n        textSize = constants.textHeaderSize,\n        textColor = constants.headerColor,\n    },\n}\n\nlocal textParagraph = {\n    type = ui.TYPE.TextEdit,\n    props = {\n        textSize = constants.textNormalSize,\n        textColor = constants.normalColor,\n        autoSize = true,\n        readOnly = true,\n        multiline = true,\n        wordWrap = true,\n        size = util.vector2(100, 0),\n    },\n}\n\nreturn function(templates)\n    templates.textNormal = textNormal\n    templates.textHeader = textHeader\n    templates.textParagraph = textParagraph\nend",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\mwui\\textEdit.lua": "local util = require('openmw.util')\nlocal ui = require('openmw.ui')\n\nlocal constants = require('scripts.omw.mwui.constants')\n\nreturn function(templates)\n    templates.textEditLine = {\n        type = ui.TYPE.TextEdit,\n        props = {\n            size = util.vector2(150, 0),\n            autoSize = true,\n            textSize = constants.textNormalSize,\n            textColor = constants.normalColor,\n            multiline = false,\n        },\n    }\n\n    templates.textEditBox = {\n        type = ui.TYPE.TextEdit,\n        props = {\n            size = util.vector2(150, 5 * constants.textNormalSize),\n            textSize = constants.textNormalSize,\n            textColor = constants.normalColor,\n            multiline = true,\n            wordWrap = true,\n        },\n    }\nend",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\settings\\common.lua": "local storage = require('openmw.storage')\n\nlocal groupSectionKey = 'OmwSettingGroups'\nlocal conventionPrefix = 'Settings'\nlocal argumentSectionPostfix = 'Arguments'\n\nlocal contextSection = storage.playerSection or storage.globalSection\nlocal groupSection = contextSection(groupSectionKey)\ngroupSection:reset()\ngroupSection:removeOnExit()\n\nlocal function validateSettingOptions(options)\n    if type(options) ~= 'table' then\n        error('Setting options must be a table')\n    end\n    if type(options.key) ~= 'string' then\n        error('Setting must have a key')\n    end\n    if type(options.renderer) ~= 'string' then\n        error('Setting must have a renderer')\n    end\n    if type(options.name) ~= 'string' then\n        error('Setting must have a name localization key')\n    end\n    if options.description ~= nil and type(options.description) ~= 'string' then\n        error('Setting description key must be a string')\n    end\nend\n\nlocal function validateGroupOptions(options)\n    if type(options) ~= 'table' then\n        error('Group options must be a table')\n    end\n    if type(options.key) ~= 'string' then\n        error('Group must have a key')\n    end\n    if options.key:sub(1, conventionPrefix:len()) ~= conventionPrefix then\n        print((\"Group key %s doesn't start with %s\"):format(options.key, conventionPrefix))\n    end\n    if type(options.page) ~= 'string' then\n        error('Group must belong to a page')\n    end\n    if type(options.order) ~= 'number' and type(options.order) ~= 'nil' then\n        error('Group order must be a number')\n    end\n    if type(options.l10n) ~= 'string' then\n        error('Group must have a localization context')\n    end\n    if type(options.name) ~= 'string' then\n        error('Group must have a name localization key')\n    end\n    if options.description ~= nil and type(options.description) ~= 'string' then\n        error('Group description key must be a string')\n    end\n    if type(options.permanentStorage) ~= 'boolean' then\n        error('Group must have a permanentStorage flag')\n    end\n    if type(options.settings) ~= 'table' then\n        error('Group must have a table of settings')\n    end\n    for _, opt in ipairs(options.settings) do\n        validateSettingOptions(opt)\n    end\nend\n\nlocal function registerSetting(options)\n    return {\n        key = options.key,\n        default = options.default,\n        renderer = options.renderer,\n        argument = options.argument,\n\n        name = options.name,\n        description = options.description,\n    }\nend\n\nlocal function registerGroup(options)\n    validateGroupOptions(options)\n    if groupSection:get(options.key) then\n        error(('Group with key %s was already registered'):format(options.key))\n    end\n    local group = {\n        key = options.key,\n        page = options.page,\n        order = options.order or 0,\n        l10n = options.l10n,\n        name = options.name,\n        description = options.description,\n        permanentStorage = options.permanentStorage,\n        settings = {},\n    }\n    local valueSection = contextSection(options.key)\n    local argumentSection = contextSection(options.key .. argumentSectionPostfix)\n    argumentSection:removeOnExit()\n    for i, opt in ipairs(options.settings) do\n        local setting = registerSetting(opt)\n        setting.order = i\n        if group.settings[setting.key] then\n            error(('Duplicate setting key %s'):format(options.key))\n        end\n        group.settings[setting.key] = setting\n        if valueSection:get(setting.key) == nil then\n            valueSection:set(setting.key, setting.default)\n        end\n        argumentSection:set(setting.key, setting.argument)\n    end\n    groupSection:set(group.key, group)\nend\n\nreturn {\n    getSection = function(global, key)\n        return (global and storage.globalSection or storage.playerSection)(key)\n    end,\n    getArgumentSection = function(global, key)\n        return (global and storage.globalSection or storage.playerSection)(key .. argumentSectionPostfix)\n    end,\n    updateRendererArgument = function(groupKey, settingKey, argument)\n        local argumentSection = contextSection(groupKey .. argumentSectionPostfix)\n        argumentSection:set(settingKey, argument)\n    end,\n    setGlobalEvent = 'OMWSettingsGlobalSet',\n    groupSectionKey = groupSectionKey,\n    onLoad = function(saved)\n        if not saved then return end\n        for groupKey, settings in pairs(saved) do\n            local section = contextSection(groupKey)\n            for key, value in pairs(settings) do\n                section:set(key, value)\n            end\n        end\n    end,\n    onSave = function()\n        local saved = {}\n        for groupKey, group in pairs(groupSection:asTable()) do\n            if not group.permanentStorage then\n                saved[groupKey] = contextSection(groupKey):asTable()\n            end\n        end\n        return saved\n    end,\n    registerGroup = registerGroup,\n}\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\settings\\global.lua": "local storage = require('openmw.storage')\n\nlocal common = require('scripts.omw.settings.common')\n\nreturn {\n    interfaceName = 'Settings',\n    interface = {\n        registerGroup = common.registerGroup,\n        updateRendererArgument = common.updateRendererArgument,\n    },\n    engineHandlers = {\n        onLoad = common.onLoad,\n        onSave = common.onSave,\n    },\n    eventHandlers = {\n        [common.setGlobalEvent] = function(e)\n            storage.globalSection(e.groupKey):set(e.settingKey, e.value)\n        end,\n    },\n}",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\settings\\player.lua": "local common = require('scripts.omw.settings.common')\nlocal render = require('scripts.omw.settings.render')\n\nrequire('scripts.omw.settings.renderers')(render.registerRenderer)\n\n---\n-- @type PageOptions\n-- @field #string key A unique key\n-- @field #string l10n A localization context (an argument of core.l10n)\n-- @field #string name A key from the localization context\n-- @field #string description A key from the localization context (optional, can be `nil`)\n\n---\n-- @type GroupOptions\n-- @field #string key A unique key, starts with \"Settings\" by convention\n-- @field #string l10n A localization context (an argument of core.l10n)\n-- @field #string name A key from the localization context\n-- @field #string description A key from the localization context (optional, can be `nil`)\n-- @field #string page Key of a page which will contain this group\n-- @field #number order Groups within the same page are sorted by this number, or their key for equal values.\n--   Defaults to 0.\n-- @field #boolean permanentStorage Whether the group should be stored in permanent storage, or in the save file\n-- @field #list<#SettingOptions> settings A [iterables#List](iterables.html#List) table of #SettingOptions\n\n---\n-- Table of setting options\n-- @type SettingOptions\n-- @field #string key A unique key\n-- @field #string name A key from the localization context\n-- @field #string description A key from the localization context (optional, can be `nil`)\n-- @field default A default value\n-- @field #string renderer A renderer key (see the \"Built-in Setting Renderers\" page)\n-- @field argument An argument for the renderer\n\nreturn {\n    interfaceName = 'Settings',\n    ---\n    -- @module Settings\n    -- @usage\n    -- -- In a player script\n    -- local storage = require('openmw.storage')\n    -- local I = require('openmw.interfaces')\n    -- I.Settings.registerPage {\n    --     key = 'MyModPage',\n    --     l10n = 'MyMod',\n    --     name = 'My Mod Name',\n    --     description = 'My Mod Description',\n    -- }\n    -- I.Settings.registerGroup {\n    --     key = 'SettingsPlayerMyMod',\n    --     page = 'MyModPage',\n    --     l10n = 'MyMod',\n    --     name = 'My Group Name',\n    --     description = 'My Group Description',\n    --     permanentStorage = false,\n    --     settings = {\n    --         {\n    --             key = 'Greeting',\n    --             renderer = 'textLine',\n    --             name = 'Greeting',\n    --             description = 'Text to display when the game starts',\n    --             default = 'Hello, world!',\n    --         },\n    --     },\n    -- }\n    -- local playerSettings = storage.playerSection('SettingsPlayerMyMod')\n    -- ...\n    -- ui.showMessage(playerSettings:get('Greeting'))\n    -- -- ...\n    -- -- access a setting page registered by a global script\n    -- local globalSettings = storage.globalSection('SettingsGlobalMyMod')\n    interface = {\n        ---\n        -- @field [parent=#Settings] #string version\n        version = 0,\n        ---\n        -- @function [parent=#Settings] registerPage Register a page to be displayed in the settings menu,\n        --   only available in player scripts\n        -- @param #PageOptions options\n        -- @usage\n        -- I.Settings.registerPage({\n        --   key = 'MyModName',\n        --   l10n = 'MyModName',\n        --   name = 'MyModName',\n        --   description = 'MyModDescription',\n        -- })---\n        registerPage = render.registerPage,\n        ---\n        -- @function [parent=#Settings] registerRenderer Register a renderer,\n        --   only avaialable in player scripts\n        -- @param #string key\n        -- @param #function renderer A renderer function, receives setting's value,\n        --   a function to change it and an argument from the setting options\n        -- @usage\n        -- I.Settings.registerRenderer('text', function(value, set, arg)\n        --   return {\n        --     type = ui.TYPE.TextEdit,\n        --     props = {\n        --       size = util.vector2(arg and arg.size or 150, 30),\n        --       text = value,\n        --       textColor = util.color.rgb(1, 1, 1),\n        --       textSize = 15,\n        --       textAlignV = ui.ALIGNMENT.End,\n        --     },\n        --     events = {\n        --       textChanged = async:callback(function(s) set(s) end),\n        --     },\n        --   }\n        -- end)\n        registerRenderer = render.registerRenderer,\n        ---\n        -- @function [parent=#Settings] registerGroup Register a group to be attached to a page,\n        --   available both in player and global scripts\n        -- @param #GroupOptions options\n        -- @usage\n        -- I.Settings.registerGroup {\n        --     key = 'SettingsTest',\n        --     page = 'test',\n        --     l10n = 'test',\n        --     name = 'Player',\n        --     description = 'Player settings group',\n        --     permanentStorage = false,\n        --     settings = {\n        --         {\n        --             key = 'Greeting',\n        --             default = 'Hi',\n        --             renderer = 'textLine',\n        --             name = 'Text Input',\n        --             description = 'Short text input',\n        --         },\n        --         {\n        --             key = 'Flag',\n        --             default = false,\n        --             renderer = 'checkbox',\n        --             name = 'Flag',\n        --             description = 'Flag toggle',\n        --         },\n        --     }\n        -- }\n        registerGroup = common.registerGroup,\n        ---\n        -- @function [parent=#Settings] updateRendererArgument Change the renderer argument of a setting\n        --   available both in player and global scripts\n        -- @param #string groupKey A settings group key\n        -- @param #string settingKey A setting key\n        -- @param argument A renderer argument\n        updateRendererArgument = common.updateRendererArgument,\n    },\n    engineHandlers = {\n        onLoad = common.onLoad,\n        onSave = common.onSave,\n    },\n}\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\settings\\render.lua": "local ui = require('openmw.ui')\nlocal util = require('openmw.util')\nlocal async = require('openmw.async')\nlocal core = require('openmw.core')\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\n\nlocal common = require('scripts.omw.settings.common')\n\nlocal renderers = {}\nlocal function registerRenderer(name, renderFunction)\n    renderers[name] = renderFunction\nend\n\nlocal interfaceL10n = core.l10n('Interface')\n\nlocal pages = {}\nlocal groups = {}\nlocal pageOptions = {}\n\nlocal interval = { template = I.MWUI.templates.interval }\nlocal growingIntreval = {\n    template = I.MWUI.templates.interval,\n    external = {\n        grow = 1,\n    },\n}\nlocal spacer =  {\n    props = {\n        size = util.vector2(0, 10),\n    },\n}\nlocal bigSpacer =  {\n    props = {\n        size = util.vector2(0, 50),\n    },\n}\nlocal stretchingLine = {\n    template = I.MWUI.templates.horizontalLine,\n    external = {\n        stretch = 1,\n    },\n}\nlocal spacedLines = function(count)\n    local content = {}\n    table.insert(content, spacer)\n    table.insert(content, stretchingLine)\n    for i = 2, count do\n        table.insert(content, interval)\n        table.insert(content, stretchingLine)\n    end\n    table.insert(content, spacer)\n    return {\n        type = ui.TYPE.Flex,\n        external = {\n            stretch = 1,\n        },\n        content = ui.content(content),\n    }\nend\n\nlocal function interlaceSeparator(layouts, separator)\n    local result = {}\n    result[1] = layouts[1]\n    for i = 2, #layouts do\n        table.insert(result, separator)\n        table.insert(result, layouts[i])\n    end\n    return result\nend\n\nlocal function setSettingValue(global, groupKey, settingKey, value)\n    if global then\n        core.sendGlobalEvent(common.setGlobalEvent, {\n            groupKey = groupKey,\n            settingKey = settingKey,\n            value = value,\n        })\n    else\n        storage.playerSection(groupKey):set(settingKey, value)\n    end\nend\n\nlocal function renderSetting(group, setting, value, global)\n    local renderFunction = renderers[setting.renderer]\n    if not renderFunction then\n        error(('Setting %s of %s has unknown renderer %s'):format(setting.key, group.key, setting.renderer))\n    end\n    local set = function(value)\n        setSettingValue(global, group.key, setting.key, value)\n    end\n    local l10n = core.l10n(group.l10n)\n    local titleLayout = {\n        type = ui.TYPE.Flex,\n        content = ui.content {\n            {\n                template = I.MWUI.templates.textHeader,\n                props = {\n                    text = l10n(setting.name),\n                },\n            },\n        },\n    }\n    if setting.description then\n        titleLayout.content:add(interval)\n        titleLayout.content:add {\n            template = I.MWUI.templates.textParagraph,\n            props = {\n                text = l10n(setting.description),\n                size = util.vector2(300, 0),\n            },\n        }\n    end\n    local argument = common.getArgumentSection(global, group.key):get(setting.key)\n    return {\n        name = setting.key,\n        type = ui.TYPE.Flex,\n        props = {\n            horizontal = true,\n            arrange = ui.ALIGNMENT.Center,\n        },\n        external = {\n            stretch = 1,\n        },\n        content = ui.content {\n            titleLayout,\n            growingIntreval,\n            renderFunction(value, set, argument),\n        },\n    }\nend\n\nlocal groupLayoutName = function(key, global)\n    return ('%s%s'):format(global and 'global_' or 'player_', key)\nend\n\nlocal function renderGroup(group, global)\n    local l10n = core.l10n(group.l10n)\n\n    local valueSection = common.getSection(global, group.key)\n    local settingLayouts = {}\n    local sortedSettings = {}\n    for _, setting in pairs(group.settings) do\n        sortedSettings[setting.order] = setting\n    end\n    for _, setting in ipairs(sortedSettings) do\n        table.insert(settingLayouts, renderSetting(group, setting, valueSection:get(setting.key), global))\n    end\n    local settingsContent = ui.content(interlaceSeparator(settingLayouts, spacedLines(1)))\n\n    local resetButtonLayout = {\n        template = I.MWUI.templates.box,\n        events = {\n            mouseClick = async:callback(function()\n                for _, setting in pairs(group.settings) do\n                    setSettingValue(global, group.key, setting.key, setting.default)\n                end\n            end),\n        },\n        content = ui.content {\n            {\n                template = I.MWUI.templates.padding,\n                content = ui.content {\n                    {\n                        template = I.MWUI.templates.textNormal,\n                        props = {\n                            text = interfaceL10n('Reset')\n                        },\n                    },\n                },\n            },\n        },\n    }\n\n    local titleLayout = {\n        type = ui.TYPE.Flex,\n        external = {\n            stretch = 1,\n        },\n        content = ui.content {\n            {\n                template = I.MWUI.templates.textHeader,\n                props = {\n                    text = l10n(group.name),\n                    textSize = 20,\n                },\n            }\n        },\n    }\n    if group.description then\n        titleLayout.content:add(interval)\n        titleLayout.content:add {\n            template = I.MWUI.templates.textParagraph,\n            props = {\n                text = l10n(group.description),\n                size = util.vector2(300, 0),\n            },\n        }\n    end\n\n    return {\n        name = groupLayoutName(group.key, global),\n        type = ui.TYPE.Flex,\n        external = {\n            stretch = 1,\n        },\n        content = ui.content {\n            {\n                type = ui.TYPE.Flex,\n                props = {\n                    horizontal = true,\n                    arrange = ui.ALIGNMENT.Center,\n                },\n                external = {\n                    stretch = 1,\n                },\n                content = ui.content {\n                    titleLayout,\n                    growingIntreval,\n                    resetButtonLayout,\n                },\n            },\n            spacedLines(2),\n            {\n                name = 'settings',\n                type = ui.TYPE.Flex,\n                content = settingsContent,\n                external = {\n                    stretch = 1,\n                },\n            },\n        },\n    }\nend\n\nlocal function pageGroupComparator(a, b)\n    return a.order < b.order or (\n        a.order == b.order and a.key < b.key\n    )\nend\n\nlocal function generateSearchHints(page)\n    local hints = {}\n    local l10n = core.l10n(page.l10n)\n    table.insert(hints, l10n(page.name))\n    if page.description then\n        table.insert(hints, l10n(page.description))\n    end\n    local pageGroups = groups[page.key]\n    for _, pageGroup in pairs(pageGroups) do\n        local group = common.getSection(pageGroup.global, common.groupSectionKey):get(pageGroup.key)\n        local l10n = core.l10n(group.l10n)\n        table.insert(hints, l10n(group.name))\n        if group.description then\n            table.insert(hints, l10n(group.description))\n        end\n        for _, setting in pairs(group.settings) do\n            table.insert(hints, l10n(setting.name))\n            if setting.description then\n                table.insert(hints, l10n(setting.description))\n            end\n        end\n    end\n    return table.concat(hints, ' ')\nend\n\nlocal function renderPage(page)\n    local l10n = core.l10n(page.l10n)\n    local sortedGroups = {}\n    for i, v in ipairs(groups[page.key]) do sortedGroups[i] = v end\n    table.sort(sortedGroups, pageGroupComparator)\n    local groupLayouts = {}\n    for _, pageGroup in ipairs(sortedGroups) do\n        local group = common.getSection(pageGroup.global, common.groupSectionKey):get(pageGroup.key)\n        table.insert(groupLayouts, renderGroup(group, pageGroup.global))\n    end\n    local groupsLayout = {\n        name = 'groups',\n        type = ui.TYPE.Flex,\n        external = {\n            stretch = 1,\n        },\n        content = ui.content(interlaceSeparator(groupLayouts, bigSpacer)),\n    }\n    local titleLayout = {\n        type = ui.TYPE.Flex,\n        external = {\n            stretch = 1,\n        },\n        content = ui.content {\n            {\n                template = I.MWUI.templates.textHeader,\n                props = {\n                    text = l10n(page.name),\n                    textSize = 22,\n                },\n            },\n            spacedLines(3),\n        },\n    }\n    if page.description then\n        titleLayout.content:add {\n            template = I.MWUI.templates.textParagraph,\n            props = {\n                text = l10n(page.description),\n                size = util.vector2(300, 0),\n            },\n        }\n    end\n    local layout = {\n        name = page.key,\n        type = ui.TYPE.Flex,\n        props = {\n            position = util.vector2(10, 10),\n        },\n        content = ui.content {\n            titleLayout,\n            bigSpacer,\n            groupsLayout,\n            bigSpacer,\n        },\n    }\n    return {\n        name = l10n(page.name),\n        element = ui.create(layout),\n        searchHints = generateSearchHints(page),\n    }\nend\n\nlocal function onSettingChanged(global)\n    return async:callback(function(groupKey, settingKey)\n        local group = common.getSection(global, common.groupSectionKey):get(groupKey)\n        if not group or not pageOptions[group.page] then return end\n\n        local value = common.getSection(global, group.key):get(settingKey)\n\n        local element = pageOptions[group.page].element\n        local groupsLayout = element.layout.content.groups\n        local groupLayout = groupsLayout.content[groupLayoutName(group.key, global)]\n        local settingsContent = groupLayout.content.settings.content\n        settingsContent[settingKey] = renderSetting(group, group.settings[settingKey], value, global)\n        element:update()\n    end)\nend\nlocal function onGroupRegistered(global, key)\n    local group = common.getSection(global, common.groupSectionKey):get(key)\n    groups[group.page] = groups[group.page] or {}\n    local pageGroup =  {\n        key = group.key,\n        global = global,\n        order = group.order,\n    }\n    table.insert(groups[group.page], pageGroup)\n    common.getSection(global, group.key):subscribe(onSettingChanged(global))\n    common.getArgumentSection(global, group.key):subscribe(async:callback(function(_, settingKey)\n        local groupKey = group.key\n        local group = common.getSection(global, common.groupSectionKey):get(groupKey)\n        if not group or not pageOptions[group.page] then return end\n\n        local value = common.getSection(global, group.key):get(settingKey)\n\n        local element = pageOptions[group.page].element\n        local groupsLayout = element.layout.content.groups\n        local groupLayout = groupsLayout.content[groupLayoutName(group.key, global)]\n        local settingsContent = groupLayout.content.settings.content\n        settingsContent[settingKey] = renderSetting(group, group.settings[settingKey], value, global)\n        element:update()\n    end))\n\n    if not pages[group.page] then return end\n    local options = renderPage(pages[group.page])\n    if pageOptions[group.page] then\n        pageOptions[group.page].element:destroy()\n    else\n        pageOptions[group.page] = {}\n    end\n    for k, v in pairs(options) do\n        pageOptions[group.page][k] = v\n    end\nend\nlocal globalGroups = storage.globalSection(common.groupSectionKey)\nfor groupKey in pairs(globalGroups:asTable()) do\n    onGroupRegistered(true, groupKey)\nend\nglobalGroups:subscribe(async:callback(function(_, key)\n    if key then onGroupRegistered(true, key) end\nend))\nstorage.playerSection(common.groupSectionKey):subscribe(async:callback(function(_, key)\n    if key then onGroupRegistered(false, key) end\nend))\n\nlocal function registerPage(options)\n    if type(options) ~= 'table' then\n        error('Page options must be a table')\n    end\n    if type(options.key) ~= 'string' then\n        error('Page must have a key')\n    end\n    if type(options.l10n) ~= 'string' then\n        error('Page must have a localization context')\n    end\n    if type(options.name) ~= 'string' then\n        error('Page must have a name')\n    end\n    if options.description ~= nil and type(options.description) ~= 'string' then\n        error('Page description key must be a string')\n    end\n    local page = {\n        key = options.key,\n        l10n = options.l10n,\n        name = options.name,\n        description = options.description,\n    }\n    pages[page.key] = page\n    groups[page.key] = groups[page.key] or {}\n    pageOptions[page.key] = renderPage(page)\n    ui.registerSettingsPage(pageOptions[page.key])\nend\n\nreturn {\n    registerPage = registerPage,\n    registerRenderer = registerRenderer,\n}",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs\\scripts\\omw\\settings\\renderers.lua": "local core = require('openmw.core')\nlocal ui = require('openmw.ui')\nlocal async = require('openmw.async')\nlocal util = require('openmw.util')\nlocal I = require('openmw.interfaces')\n\nlocal function applyDefaults(argument, defaults)\n    if not argument then return defaults end\n    if pairs(defaults) and pairs(argument) then\n        local result = {}\n        for k, v in pairs(defaults) do\n            result[k] = v\n        end\n        for k, v in pairs(argument) do\n            result[k] = v\n        end\n        return result\n    end\n    return argument\nend\n\nlocal function paddedBox(layout)\n    return {\n        template = I.MWUI.templates.box,\n        content = ui.content {\n            {\n                template = I.MWUI.templates.padding,\n                content = ui.content { layout },\n            },\n        }\n    }\nend\n\nlocal function disable(disabled, layout)\n    if disabled then\n        return {\n            template = I.MWUI.templates.disabled,\n            content = ui.content {\n                layout,\n            },\n        }\n    else\n        return layout\n    end\nend\n\nreturn function(registerRenderer)\n    do\n        local defaultArgument = {\n            disabled = false,\n        }\n        registerRenderer('textLine', function(value, set, argument)\n            argument = applyDefaults(argument, defaultArgument)\n            return disable(argument.disabled, paddedBox {\n                template = I.MWUI.templates.textEditLine,\n                props = {\n                    text = tostring(value),\n                },\n                events = {\n                    textChanged = async:callback(function(s) set(s) end),\n                },\n            })\n        end)\n    end\n\n    do\n        local defaultArgument = {\n            disabled = false,\n            l10n = 'Interface',\n            trueLabel = 'Yes',\n            falseLabel = 'No',\n        }\n        registerRenderer('checkbox', function(value, set, argument)\n            argument = applyDefaults(argument, defaultArgument)\n            local l10n = core.l10n(argument.l10n)\n            local box = paddedBox {\n                template = I.MWUI.templates.padding,\n                content = ui.content {\n                    {\n                        template = I.MWUI.templates.textNormal,\n                        props = {\n                            text = l10n(value and argument.trueLabel or argument.falseLabel)\n                        },\n                    },\n                },\n            }\n            box.events = {\n                mouseClick = async:callback(function() set(not value) end)\n            }\n            return disable(argument.disabled, box)\n        end)\n    end\n\n    do\n        local function validateNumber(text, argument)\n            local number = tonumber(text)\n            if not number then return end\n            if argument.min and number < argument.min then return end\n            if argument.max and number > argument.max then return end\n            if argument.integer and math.floor(number) ~= number then return end\n            return number\n        end\n        local defaultArgument = {\n            disabled = false,\n            integer = false,\n            min = nil,\n            max = nil,\n        }\n        registerRenderer('number', function(value, set, argument)\n            argument = applyDefaults(argument, defaultArgument)\n            local lastInput = nil\n            return disable(argument.disabled, paddedBox {\n                template = I.MWUI.templates.textEditLine,\n                props = {\n                    text = tostring(value),\n                    size = util.vector2(80, 0),\n                },\n                events = {\n                    textChanged = async:callback(function(text)\n                        lastInput = text\n                    end),\n                    focusLoss = async:callback(function()\n                        if not lastInput then return end\n                        local number = validateNumber(lastInput, argument)\n                        if not number then\n                            set(value)\n                        end\n                        if number and number ~= value then\n                            set(number)\n                        end\n                    end),\n                },\n            })\n        end)\n    end\n\n    do\n        local defaultArgument = {\n            disabled = false,\n            l10n = nil,\n            items = {},\n        }\n        local leftArrow = ui.texture {\n            path = 'textures/omw_menu_scroll_left.dds',\n        }\n        local rightArrow = ui.texture {\n            path = 'textures/omw_menu_scroll_right.dds',\n        }\n        registerRenderer('select', function(value, set, argument)\n            argument = applyDefaults(argument, defaultArgument)\n            if not argument.l10n then\n                error('\"select\" renderer requires a \"l10n\" argument')\n            end\n            if not pcall(function()\n                    local _ = ipairs(argument.items)\n                    assert(#argument.items > 0)\n                end)\n            then\n                error('\"select\" renderer requires an \"items\" array as an argument')\n            end\n            local l10n = core.l10n(argument.l10n)\n            local index = nil\n            local itemCount = #argument.items\n            for i, item in ipairs(argument.items) do\n                if item == value then\n                    index = i\n                end\n            end\n            local label = l10n(tostring(value))\n            local labelColor = nil\n            if index == nil then\n                labelColor = util.color.rgb(1, 0, 0)\n            end\n            local body = {\n                type = ui.TYPE.Flex,\n                props = {\n                    horizontal = true,\n                    arrange = ui.ALIGNMENT.Center,\n                },\n                content = ui.content {\n                    {\n                        type = ui.TYPE.Image,\n                        props = {\n                            resource = leftArrow,\n                            size = util.vector2(1, 1) * 12,\n                        },\n                        events = {\n                            mouseClick = async:callback(function()\n                                if not index then\n                                    set(argument.items[#argument.items])\n                                    return\n                                end\n                                index = (index - 2) % itemCount + 1\n                                set(argument.items[index])\n                            end),\n                        },\n                    },\n                    { template = I.MWUI.templates.interval },\n                    {\n                        template = I.MWUI.templates.textNormal,\n                        props = {\n                            text = label,\n                            textColor = labelColor,\n                        },\n                        external = {\n                            grow = 1,\n                        },\n                    },\n                    { template = I.MWUI.templates.interval },\n                    {\n                        type = ui.TYPE.Image,\n                        props = {\n                            resource = rightArrow,\n                            size = util.vector2(1, 1) * 12,\n                        },\n                        events = {\n                            mouseClick = async:callback(function()\n                                if not index then\n                                    set(argument.items[1])\n                                    return\n                                end\n                                index = (index) % itemCount + 1\n                                set(argument.items[index])\n                            end),\n                        },\n                    },\n                },\n            }\n            return disable(argument.disabled, paddedBox(body))\n        end)\n    end\n\n    do\n        local whiteTexture = ui.texture { path = 'white' }\n        local defaultArgument = {\n            disabled = false,\n        }\n        registerRenderer('color', function(value, set, argument)\n            argument = applyDefaults(argument, defaultArgument)\n            local colorDisplay = {\n                template = I.MWUI.templates.box,\n                content = ui.content {\n                    {\n                        type = ui.TYPE.Image,\n                        props = {\n                            resource = whiteTexture,\n                            color = value,\n                            -- TODO: remove hardcoded size when possible\n                            size = util.vector2(1, 1) * 20,\n                        },\n                    }\n                },\n            }\n            local lastInput = nil\n            local hexInput = paddedBox {\n                template = I.MWUI.templates.textEditLine,\n                props = {\n                    text = value:asHex(),\n                },\n                events = {\n                    textChanged = async:callback(function(text)\n                        lastInput = text\n                    end),\n                    focusLoss = async:callback(function()\n                        if not lastInput then return end\n                        if not pcall(function() set(util.color.hex(lastInput)) end)\n                        then\n                            set(value)\n                        end\n                    end),\n                },\n            }\n            return disable(argument.disabled, {\n                type = ui.TYPE.Flex,\n                props = {\n                    horizontal = true,\n                    arrange = ui.ALIGNMENT.Center,\n                },\n                content = ui.content {\n                    colorDisplay,\n                    { template = I.MWUI.templates.interval },\n                    hexInput,\n                }\n            })\n        end)\n    end\nend\n",
    "OpenMW windows build release-53842-0-49-2-1703368090\\Release\\resources\\vfs-mw\\openmw_aux\\calendarconfig.lua": "return {\n    monthsDuration = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},\n    daysInWeek = 7,\n    startingYear = 427,\n    startingYearDay = 227,\n    -- Friday, calculated from TES2 and TES4's starting week days (see #7546)\n    startingWeekDay = 5,\n}\n"
  }
}