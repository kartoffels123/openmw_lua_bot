{
  "folder_name": "Skill Uses Scaled",
  "lua_files": {
    "Skill_Uses_Scaled-54267-1-03-1719308736\\scripts\\Skill_Uses_Scaled\\core.lua": "local types         = require('openmw.types')\nlocal self          = require('openmw.self')\nlocal skp           = require('openmw.interfaces').SkillProgression\nlocal anim          = require('openmw.animation')\nlocal i_AnimControl = require('openmw.interfaces').AnimationController\n\nlocal Dt            = require('scripts.Skill_Uses_Scaled.data')\nlocal Fn            = require('scripts.Skill_Uses_Scaled.func')\nlocal Mui           = require('scripts.Skill_Uses_Scaled.modui')\n\nfor _, _groupname in ipairs(Dt.ATTACK_ANIMATION_GROUPS) do\n\t--i_AnimControl.addTextKeyHandler(_groupname, function(groupname, key) print('Completion: '..string.format('%.2f', anim.getTextKeyTime(self, 'hit'))..' | Key: '..key) end)\n\ti_AnimControl.addTextKeyHandler(_groupname, function(groupname, key) Fn.get_attack(groupname, key) end)\nend\ni_AnimControl.addTextKeyHandler('spellcast', function(groupname, key) Fn.get_spell(groupname, key) end)\n\nFn.make_scalers()\nskp.addSkillUsedHandler(function(skillid, options)\n\tif Dt.scalers[skillid] then\n\t\toptions.skillGain = Dt.scalers[skillid].func(options.useType, options.skillGain)\n\tend\nend)\n\nFn.register_Use_Action_Handler()\n\nlocal armor = nil          -- create here instead of every frame\nlocal armor_thisframe = {} -- create here instead of every frame\nlocal onUpdate = function(dt)\n\tarmor_thisframe = {}\n\tarmor = Fn.get_equipped_armor()\n\tfor _, _obj in ipairs(armor) do\n\t\tarmor_thisframe[types.Armor.record(_obj).type] = types.Item.itemData(_obj).condition\n\tend\n\tDt.pc.armor_condition:set_prevframe(armor_thisframe)\nend\nlocal onFrame = function(dt)\n\tif Dt.securiting then\n\t\tlocal target = Fn.get_security_target()\n\t\tif target then Dt.pc.security_target = target end\n\t\tif Mui.getSetting(\"SUS_DEBUG\") then -- I'd love to not have this here, but it's better to have it.\n\t\t\tlocal printcounter = Dt.counters.security(1)\n\t\t\tif printcounter > 150.01 then\n\t\t\t\tprint('Scanning lockables...')\n\t\t\t\tDt.counters.security(-printcounter)\n\t\t\tend\n\t\tend\n\tend\nend\n\nlocal onInit = function()\n\tMui.loadPreset('current')\nend\nlocal onSave = function()\n\tMui.savePreset('current')\n\treturn { marathon_counter = Dt.counters.athletics(0) }\nend\nlocal onLoad = function(data)\n\tMui.loadPreset('current')\n\tif data then if data.marathon_counter then Dt.counters.athletics(data.marathon_counter) end end\nend\n\nreturn {\n\tengineHandlers = {\n\t\tonUpdate = onUpdate,\n\t\tonFrame  = onFrame,\n\t\tonInit   = onInit,\n\t\tonSave   = onSave,\n\t\tonLoad   = onLoad,\n\t},\n\teventHandlers = {\n\t\tSUS_updateGLOBvar = function(t) Dt.GLOB[t.id] = t.val end,\n\t\tUiModeChanged = function(data)\n\t\t\tif not data.newMode then return end\n\t\t\tif data.oldMode then return end\n\t\t\tif not Dt.STANCE.WEAPON[types.Actor.getStance(self)] then return end\n\t\t\tlocal weapon = types.Actor.getEquipment(self, Dt.SLOTS.WEAPON)\n\t\t\tif not weapon or (weapon.type == types.Weapon) then\n\t\t\t\tFn.set_hit_release()\n\t\t\tend\n\t\tend,\n\t}\n}\n",
    "Skill_Uses_Scaled-54267-1-03-1719308736\\scripts\\Skill_Uses_Scaled\\data.lua": "local types = require('openmw.types')\nlocal time  = require('openmw_aux.time')\nlocal core  = require('openmw.core')\nlocal util  = require('openmw.util')\n\n\n-- TOOLS\nlocal function makecounter(val)\n\tlocal count = val\n\treturn function(mod)\n\t\tcount = count + mod\n\t\treturn count\n\tend\nend\n\nlocal function setpreviousval(key, val)\n\tlocal oldval = val\n\treturn function(self, newval)\n\t\tself[key] = oldval\n\t\toldval = newval\n\tend\nend\n\nlocal function get(var) -- var must be serializable, recursions WILL stack overflow :D\n\tif type(var) ~= 'table' then\n\t\treturn var\n\telse\n\t\tlocal deepcopy = {}\n\t\tfor _key, _value in pairs(var) do deepcopy[_key] = get(_value) end\n\t\treturn deepcopy\n\tend\nend\n\nlocal Dt = {}\n-- Player Data\nDt.pc = {\n\tspell           = nil,                                                                   --_obj,\n\tarmor_condition = { set_prevframe = setpreviousval('prevframe', {}) },\n\tattack          = { speed = 0, damage = 0, step = 0, minkey = '', group = '', draw = 0 }, -- weapon = _obj\n\tprobepick       = nil,                                                                   -- _obj\n\tsecurity_target = nil,                                                                   -- _obj\n\tgrounded        = nil,\n\tposition        = util.vector3(0, 0, 0),\n}\n-- Engine Data\nDt.ATTACK_ANIMATION_GROUPS = {\n\t'handtohand',\n\t'crossbow',\n\t'weapononehand',\n\t'weapontwohand',\n\t'weapontwowide',\n\t'bowandarrow',\n\t'throwweapon',\n\t'weapontwoclose',\n\t'blunttwohand',\n\t'bluntonehand',\n\t'shortbladeonehand'\n}\nDt.ATTACK_ANIMATION_KEYS = {\n\tMIN = {\n\t\t['chop min attack'] = 'chop',\n\t\t['slash min attack'] = 'slash',\n\t\t['thrust min attack'] = 'thrust',\n\t\t['shoot min attack'] = 'shoot',\n\t},\n\tMAX = {\n\t\t['chop max attack'] = true,\n\t\t['slash max attack'] = true,\n\t\t['thrust max attack'] = true,\n\t\t['shoot max attack'] = true,\n\t},\n\tHIT_RELEASE = {\n\t\t['chop hit'] = 'chop',\n\t\t['slash hit'] = 'slash',\n\t\t['thrust hit'] = 'thrust',\n\t\t['shoot release'] = 'chop',\n\t},\n}\nDt.SPELL_ANIMATION_KEYS = {\n\t['target start'] = true,\n\t['touch start'] = true,\n\t['self start'] = true,\n}\nDt.WEAPON_TYPES = {\n\tMELEE = {\n\t\t[types.Weapon.TYPE.AxeOneHand] = 'axe',\n\t\t[types.Weapon.TYPE.AxeTwoHand] = 'axe',\n\t\t[types.Weapon.TYPE.BluntOneHand] = 'bluntweapon',\n\t\t[types.Weapon.TYPE.BluntTwoClose] = 'bluntweapon',\n\t\t[types.Weapon.TYPE.BluntTwoWide] = 'bluntweapon',\n\t\t[types.Weapon.TYPE.LongBladeOneHand] = 'longblade',\n\t\t[types.Weapon.TYPE.LongBladeTwoHand] = 'longblade',\n\t\t[types.Weapon.TYPE.ShortBladeOneHand] = 'shortblade',\n\t\t[types.Weapon.TYPE.SpearTwoWide] = 'spear',\n\t},\n\tBOW = {\n\t\t[types.Weapon.TYPE.MarksmanBow] = 'marksman',\n\t\t[types.Weapon.TYPE.MarksmanCrossbow] = 'marksman',\n\t},\n\tAMMO = {\n\t\t[types.Weapon.TYPE.Bolt] = 'marksman',\n\t\t[types.Weapon.TYPE.Arrow] = 'marksman',\n\t},\n\tTHROWN = {\n\t\t[types.Weapon.TYPE.MarksmanThrown] = 'marksman',\n\t},\n}\n-- CHECK TYPE WHEN USING THESE, THEY CAN HAVE THINGS OF OTHER TYPES\nDt.SLOTS = {\n\tWEAPON = get(types.Actor.EQUIPMENT_SLOT.CarriedRight),\n\tMELEE  = get(types.Actor.EQUIPMENT_SLOT.CarriedRight),\n\tBOW    = get(types.Actor.EQUIPMENT_SLOT.CarriedRight),\n\tTHROWN = get(types.Actor.EQUIPMENT_SLOT.CarriedRight),\n\tAMMO   = get(types.Actor.EQUIPMENT_SLOT.Ammunition),\n\tSHIELD = get(types.Actor.EQUIPMENT_SLOT.CarriedLeft),\n\tARMOR  = {\n\t\tget(types.Actor.EQUIPMENT_SLOT.Boots),\n\t\tget(types.Actor.EQUIPMENT_SLOT.CarriedLeft),\n\t\tget(types.Actor.EQUIPMENT_SLOT.Cuirass),\n\t\tget(types.Actor.EQUIPMENT_SLOT.Greaves),\n\t\tget(types.Actor.EQUIPMENT_SLOT.Helmet),\n\t\tget(types.Actor.EQUIPMENT_SLOT.LeftGauntlet),\n\t\tget(types.Actor.EQUIPMENT_SLOT.LeftPauldron),\n\t\tget(types.Actor.EQUIPMENT_SLOT.RightGauntlet),\n\t\tget(types.Actor.EQUIPMENT_SLOT.RightPauldron),\n\t},\n}\nDt.ARMOR_TYPES = {\n\t[types.Armor.TYPE.Boots] = core.getGMST('iBootsWeight'),\n\t[types.Armor.TYPE.Cuirass] = core.getGMST('iCuirassWeight'),\n\t[types.Armor.TYPE.Greaves] = core.getGMST('iGreavesWeight'),\n\t[types.Armor.TYPE.Helmet] = core.getGMST('iHelmWeight'),\n\t[types.Armor.TYPE.LGauntlet] = core.getGMST('iGauntletWeight'),\n\t[types.Armor.TYPE.LPauldron] = core.getGMST('iPauldronWeight'),\n\t[types.Armor.TYPE.LBracer] = core.getGMST('iGauntletWeight'),\n\t[types.Armor.TYPE.RBracer] = core.getGMST('iGauntletWeight'),\n\t[types.Armor.TYPE.RGauntlet] = core.getGMST('iGauntletWeight'),\n\t[types.Armor.TYPE.RPauldron] = core.getGMST('iPauldronWeight'),\n\t[types.Armor.TYPE.Shield] = core.getGMST('iShieldWeight'),\n}\nDt.ARMOR_RATING_WEIGHTS = {\n\t[types.Armor.TYPE.Cuirass] = 0.3,\n\t[types.Armor.TYPE.Shield] = 0.1,\n\t[types.Armor.TYPE.Helmet] = 0.1,\n\t[types.Armor.TYPE.Greaves] = 0.1,\n\t[types.Armor.TYPE.Boots] = 0.1,\n\t[types.Armor.TYPE.LPauldron] = 0.1,\n\t[types.Armor.TYPE.RPauldron] = 0.1,\n\t[types.Armor.TYPE.LGauntlet] = 0.05,\n\t[types.Armor.TYPE.RGauntlet] = 0.05,\n\t[types.Armor.TYPE.LBracer] = 0.05,\n\t[types.Armor.TYPE.RBracer] = 0.05,\n}\nDt.GMST = {\n\tiBaseArmorSkill      = core.getGMST('iBaseArmorSkill'),\n\tfWeaponDamageMult    = core.getGMST('fWeaponDamageMult'),\n\tfDamageStrengthMult  = core.getGMST('fDamageStrengthMult'),\n\tfDamageStrengthBase  = core.getGMST('fDamageStrengthBase'),\n\tfLightMaxMod         = core.getGMST('fLightMaxMod'),\n\tfMedMaxMod           = core.getGMST('fMedMaxMod'),\n\tfUnarmoredBase1      = core.getGMST('fUnarmoredBase1'),\n\tfUnarmoredBase2      = core.getGMST('fUnarmoredBase2'),\n\tiBlockMaxChance      = core.getGMST('iBlockMaxChance'),\n\tiBlockMinChance      = core.getGMST('iBlockMinChance'),\n\tfMaxHandToHandMult   = core.getGMST('fMaxHandToHandMult'),\n\tfMinHandToHandMult   = core.getGMST('fMinHandToHandMult'),\n\tfHandtoHandHealthPer = core.getGMST('fHandtoHandHealthPer'),\n\tfMinWalkSpeed        = core.getGMST('fMinWalkSpeed'), -- Currently unused, could be made to affect athletics formula but it seemed too convoluted.\n\tfMaxWalkSpeed        = core.getGMST('fMaxWalkSpeed'), -- Same as previous, I aired on using a flat speed multiplier instead.\n\tfEncumbranceStrMult  = core.getGMST('fEncumbranceStrMult'),\n\tiMaxActivateDist     = core.getGMST('iMaxActivateDist'),\n}\nDt.GLOB = {} -- Global variables go here. Unused at the moment.\nDt.ATTRIBUTES = { 'strength', 'intelligence', 'willpower', 'agility', 'speed', 'endurance', 'personality', 'luck' }\nDt.SKILLS = {\n\t'acrobatics', 'alchemy', 'alteration', 'armorer', 'athletics', 'axe', 'block', 'bluntweapon', 'conjuration',\n\t'destruction', 'enchant', 'handtohand', 'heavyarmor', 'illusion', 'lightarmor', 'longblade', 'marksman', 'mediumarmor',\n\t'mercantile', 'mysticism', 'restoration', 'security', 'shortblade', 'sneak', 'spear', 'speechcraft', 'unarmored'\n}\nDt.scaler_groups = {\n\tSPELL  = { 'alteration', 'conjuration', 'destruction', 'illusion', 'mysticism', 'restoration' },\n\tWEAPON = { 'axe', 'bluntweapon', 'longblade', 'shortblade', 'spear', 'marksman' },\n\tARMOR  = { 'heavyarmor', 'lightarmor', 'mediumarmor' }, -- !! Armor health gets reduced by the amount of incoming damage it *blocked*.\n}\nDt.STANCE = {\n\tWEAPON  = { [types.Actor.STANCE.Weapon] = true },\n\tSPELL   = { [types.Actor.STANCE.Spell] = true },\n\tNOTHING = { [types.Actor.STANCE.Nothing] = true },\n}\nDt.scalers = {\n\tdefault = { func = function(useType, xp) return xp end },\n\tnew     = function(self, t) end\n}\n-- SCRIPT LOGIC VARIABLES\nDt.counters = {\n\tframe           = makecounter(0),\n\tweapon          = makecounter(0),\n\tunarmored       = makecounter(0),\n\tacrobatics      = makecounter(0),\n\tathletics       = makecounter(0),\n\tathletics_debug = makecounter(0),\n\tsecurity        = makecounter(0),\n}\nDt.securiting = false\n\n--[] Scaler creator: Scalers are simple functions that become the body of skp.addSkillUsedHandler(func) through a Dt.scalers[skillid]() call.\n\nfunction Dt.scalers:new(t)\n\tif (t.name) then self[t.name] = {} else error('You can\\'t create a nameless scaler!') end\n\tself[t.name].func = t.func\nend\n\n-- RETURN || NEED THIS SO FILE DO THING\nreturn Dt\n",
    "Skill_Uses_Scaled-54267-1-03-1719308736\\scripts\\Skill_Uses_Scaled\\func.lua": "local core   = require('openmw.core')\nlocal self   = require('openmw.self')\nlocal types  = require('openmw.types')\nlocal async  = require('openmw.async')\nlocal time   = require('openmw_aux.time')\nlocal ui     = require('openmw.ui')\nlocal i_UI   = require('openmw.interfaces').UI\nlocal input  = require('openmw.input')\nlocal camera = require('openmw.camera')\nlocal util   = require('openmw.util')\nlocal nearby = require('openmw.nearby')\nlocal skp    = require('openmw.interfaces').SkillProgression\nlocal anim   = require('openmw.animation')\n\nlocal Dt     = require('scripts.Skill_Uses_Scaled.data')\nlocal Mui    = require('scripts.Skill_Uses_Scaled.modui')\n-- TOOLS\nlocal eps    = 0.001\nlocal function equal(a, b) return (math.abs(b - a) < eps) end\n\nlocal function percentify(num) return string.format('%.1f', num * 100) .. '%' end\n\nlocal function get(var) -- var must be serializable, recursions WILL stack overflow :D\n\tif type(var) ~= 'table' then\n\t\treturn var\n\telse\n\t\tlocal deepcopy = {}\n\t\tfor _key, _value in pairs(var) do deepcopy[_key] = get(_value) end\n\t\treturn deepcopy\n\tend\nend\n\n-- local function makecounter(val)\n-- \tlocal count = val\n-- \tlocal simseconds = function() return core.getSimulationTime() - (core.getSimulationTime() % 0.01 * time.second) end\n-- \tlocal start = simseconds() -- for debugging\n-- \treturn function(mod)\n-- \t\tcount = count + mod\n-- \t\treturn count\n-- \tend\n-- end\n\nlocal function DEBUG(string)\n\tif Mui.getSetting(\"SUS_DEBUG\") then\n\t\tif Mui.getSetting(\"SUS_VERBOSE\") then\n\t\t\tui.showMessage(string)\n\t\telse\n\t\t\tprint(string)\n\t\tend\n\tend\nend\n\n-- Credit to zackhasacat for this one\n-- I shortened it by removing checks I don't need (due to where it's used)\n-- Also made it use and return SUS Dt values\nlocal function getArmorType(armor_obj)\n\tlocal lightMultiplier = Dt.GMST.fLightMaxMod + 0.0005\n\tlocal medMultiplier   = Dt.GMST.fMedMaxMod + 0.0005\n\tlocal armorType       = types.Armor.record(armor_obj).type\n\tlocal weight          = types.Armor.record(armor_obj).weight\n\tlocal armorTypeWeight = math.floor(Dt.ARMOR_TYPES[armorType])\n\tif weight <= armorTypeWeight * lightMultiplier then  -- print('SKILL: lightarmor')\n\t\treturn 'lightarmor'\n\telseif weight <= armorTypeWeight * medMultiplier then -- print('SKILL: mediumarmor')\n\t\treturn 'mediumarmor'\n\telse                                                 -- print('SKILL: heavyarmor')\n\t\treturn 'heavyarmor'\n\tend\nend\n\n-- Credit to Pharis for this one. I couldn't have made it, no chance in hell.\nlocal function getFacedObject()\n\tlocal origin = camera.getPosition();\n\tlocal direction = camera.viewportToWorldVector(util.vector2(0.5, 0.5));\n\n\tlocal activationDistance = Dt.GMST.iMaxActivateDist + camera.getThirdPersonDistance();\n\tlocal telekinesis = types.Actor.activeEffects(self):getEffect(core.magic.EFFECT_TYPE.Telekinesis);\n\tif (telekinesis) then\n\t\tactivationDistance = activationDistance + (telekinesis.magnitude * 22);\n\tend;\n\n\tlocal result = nearby.castRenderingRay(\n\t\torigin,\n\t\torigin + direction * activationDistance,\n\t\t{ ignore = self }\n\t);\n\n\tif (result ~= nil and result.hit) then return result.hitObject; end;\nend;\n\n-- DEFINITIONS --\n-----------------------------------------------------------------------------------------------------------\n\nlocal Fn = {}\n\n-----------------------------------------------------------------------------------------------------------\n\nFn.get_attack_damage = function(min, max, str_mod, health_mod, draw)\n\tlocal base = min + (max - min) * draw\n\tlocal damage = base * str_mod * health_mod\n\treturn damage\nend\nFn.get_H2H_damage = function(draw)\n\tlocal str_mod = types.Player.stats.attributes.strength(self).base / Mui.getSetting('HandToHand_Strength')\n\tlocal damage_per_skillpoint = Fn.get_attack_damage(Dt.GMST.fMinHandToHandMult, Dt.GMST.fMaxHandToHandMult, str_mod, 1,\n\t\tdraw)\n\tlocal skill = types.Player.stats.skills.handtohand(self)\n\t\t\t.base -- Note we don't count fortifies. This prevents sujama from murdering your XP rates.\n\tlocal damage = (damage_per_skillpoint * skill)\n\treturn damage\nend\nFn.get_weapon_damage = function(weapon, draw, atktype)\n\tlocal wp_record = types.Weapon.record(weapon)\n\tlocal min = wp_record[atktype .. 'MinDamage']\n\tlocal max = wp_record[atktype .. 'MaxDamage']\n\tlocal str_mod = types.Player.stats.attributes.strength(self).base * Dt.GMST.fDamageStrengthMult / 10 +\n\t\t\tDt.GMST.fDamageStrengthBase\n\tlocal dur_current = weapon.condition\n\tlocal health_mod = 1\n\tif dur_current then\n\t\thealth_mod = weapon.condition / types.Weapon.record(weapon).health\n\telseif Dt.WEAPON_TYPES.BOW[wp_record.type] then\n\t\tlocal ammo = types.Actor.getEquipment(self, Dt.SLOTS.AMMO)\n\t\tlocal ammo_record = types.Weapon.record(ammo)\n\t\tmin = min + ammo_record[atktype .. 'MinDamage']\n\t\tmax = max + ammo_record[atktype .. 'MaxDamage']\n\telseif Dt.WEAPON_TYPES.THROWN[wp_record.type] then\n\t\thealth_mod = 2 --Thrown weapons count twice as they are both weapon and projectile.\n\tend\n\tlocal damage = Fn.get_attack_damage(min, max, str_mod, health_mod, draw)\n\treturn damage\nend\n\nlocal function get_attack_draw()\n\tif not (Dt.pc.attack.step == 1) then return Dt.pc.attack.draw end\n\tlocal atktype = Dt.ATTACK_ANIMATION_KEYS.MIN[Dt.pc.attack.minkey]\n\tlocal group   = Dt.pc.attack.group\n\tlocal min     = anim.getTextKeyTime(self, group .. ': ' .. atktype .. ' min attack')\n\tlocal current = anim.getCurrentTime(self, group)\n\tlocal max     = anim.getTextKeyTime(self, group .. ': ' .. atktype .. ' max attack')\n\tif current < min then\n\t\tprint('SUS: Can\\'t get weapon draw if current < min')\n\t\treturn\n\tend\n\tDt.pc.attack.step = 2 -- Make sure we don't check again till the next hit is reached.\n\tlocal draw = 0\n\tif current < max then -- Getting draw mid-windup. Calculate how far we've gotten.\n\t\tmax = math.max(0, max - min)\n\t\tcurrent = math.max(0, current - min)\n\t\tdraw = math.min(current / max, 1)\n\tend -- If we skipped this block, then we've not drawn our weapon at all, and draw = 0\n\treturn draw\nend\nfunction Fn.get_attack(groupname, key)\n\tif Dt.pc.attack.step == 0 then\n\t\tif Dt.ATTACK_ANIMATION_KEYS.MIN[key] then\n\t\t\tDt.pc.attack.step   = 1\n\t\t\tDt.pc.attack.minkey = key\n\t\t\tDt.pc.attack.group  = groupname\n\t\tend\n\telseif Dt.pc.attack.step == 1 or Dt.pc.attack.step == 2 then\n\t\tif Dt.pc.attack.step == 1 and Dt.ATTACK_ANIMATION_KEYS.MAX[key] then\n\t\t\tDt.pc.attack.draw = 1 -- No need to calculate. We reached max. It's a full draw.\n\t\t\tDt.pc.attack.step = 2\n\t\telseif Dt.ATTACK_ANIMATION_KEYS.HIT_RELEASE[key] then\n\t\t\tDt.pc.attack.draw = get_attack_draw()\n\t\t\tDt.pc.attack.step = 0\n\t\t\t-- Get attack min and max damages\n\t\t\tlocal weapon = types.Actor.getEquipment(self, Dt.SLOTS.WEAPON)\n\t\t\tif weapon then\n\t\t\t\tDt.pc.attack.damage = math.max(1,\n\t\t\t\t\tFn.get_weapon_damage(weapon, Dt.pc.attack.draw, Dt.ATTACK_ANIMATION_KEYS.HIT_RELEASE[key]))\n\t\t\telse\n\t\t\t\tDt.pc.attack.damage = math.max(1, Fn.get_H2H_damage(Dt.pc.attack.draw))\n\t\t\tend\n\t\tend\n\tend\nend\n\nlocal draw\nFn.set_hit_release = function()\n\tif Dt.pc.attack.step == 1 then\n\t\tdraw = get_attack_draw()\n\t\tif draw then\n\t\t\tDt.pc.attack.draw = draw\n\t\t\tDt.pc.attack.step = 2\n\t\tend\n\tend\nend\nFn.set_hit_release_callback = async:registerTimerCallback('set_hit_release_callback',\n\tfunction() if not input.getBooleanActionValue(\"Use\") then Fn.set_hit_release() end end)\n\nfunction Fn.get_spell(groupname, key)\n\tif Dt.SPELL_ANIMATION_KEYS[key] then\n\t\tlocal spell = types.Actor.getSelectedSpell(self)\n\t\tif spell then Dt.pc.spell = types.Actor.getSelectedSpell(self) end\n\tend\nend\n\nFn.register_Use_Action_Handler = function()\n\tlocal useCallback = async:callback(\n\t\tfunction()\n\t\t\tif input.getBooleanActionValue(\"Use\") then\n\t\t\t\tif i_UI.getMode() then\n\t\t\t\t\treturn -- We're in a menu\n\t\t\t\telseif Dt.STANCE.WEAPON[types.Actor.getStance(self)] then\n\t\t\t\t\tlocal weapon = types.Actor.getEquipment(self, Dt.SLOTS.WEAPON)\n\t\t\t\t\tif not weapon then\n\t\t\t\t\t\treturn -- H2H\n\t\t\t\t\telseif (weapon.type == types.Lockpick) or (weapon.type == types.Probe) then\n\t\t\t\t\t\tDt.pc.security_target = Fn.get_security_target()\n\t\t\t\t\t\tDt.securiting = true -- We make onFrame scan continuously in case the player starts without a valid target and moves their cursor to one while holding click down.\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tif not Dt.STANCE.WEAPON[types.Actor.getStance(self)] then return end\n\t\t\t\tlocal weapon = types.Actor.getEquipment(self, Dt.SLOTS.WEAPON)\n\t\t\t\tif not weapon or (weapon.type == types.Weapon) then                     -- H2H\n\t\t\t\t\tif not i_UI.getMode() then Fn.set_hit_release() end\n\t\t\t\telseif (weapon.type == types.Lockpick) or (weapon.type == types.Probe) then -- Security\n\t\t\t\t\tDt.securiting = false\n\t\t\t\t\tDt.pc.security_target = nil                                           -- This will turn the scaler off in case another mod triggers security uses outside of this loop.\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t)\n\tinput.registerActionHandler(\"Use\", useCallback)\nend\n\nFn.get_active_effect_mag       = function(effectid) return types.Actor.activeEffects(self):getEffect(effectid).magnitude end\n\nFn.has_effect                  = function(effectid) return not (types.Actor.activeEffects(self):getEffect(effectid).magnitude == 0) end\n\nFn.get_security_target         = function()\n\tlocal target = getFacedObject()\n\tlocal lockable = nil -- scopeset\n\tif target and (target.type == types.Door or target.type == types.Container) then\n\t\tlockable          = {}\n\t\tlockable.islocked = types.Lockable.isLocked(target)\n\t\tlockable.level    = types.Lockable.getLockLevel(target)\n\t\tlockable.trap     = types.Lockable.getTrapSpell(target)\n\tend\n\treturn lockable\nend\n\nFn.get_equipped_armor          = function()\n\tlocal armor_list = {}\n\tfor _, _object in pairs(types.Actor.getEquipment(self)) do\n\t\tif _object.type == types.Armor then table.insert(armor_list, _object) end\n\tend\n\treturn armor_list\nend\n\nFn.get_hit_armorpiece          = function()\n\tfor _, _obj in ipairs(Fn.get_equipped_armor()) do\n\t\tlocal slot = types.Armor.record(_obj).type\n\t\tif not equal(Dt.pc.armor_condition.prevframe[slot], types.Item.itemData(_obj).condition) then return _obj end\n\tend\nend\n\nFn.clean_slots                 = function(_slot, _armor_types) -- This is to guarantee we don't get ghost unarmored slots for gauntlets and bracers\n\tif _slot == types.Armor.TYPE.LBracer or _slot == types.Armor.TYPE.LGauntlet then\n\t\t_armor_types[types.Armor.TYPE.LBracer] = nil\n\t\t_armor_types[types.Armor.TYPE.LGauntlet] = nil\n\telseif _slot == types.Armor.TYPE.RBracer or _slot == types.Armor.TYPE.RGauntlet then\n\t\t_armor_types[types.Armor.TYPE.RBracer] = nil\n\t\t_armor_types[types.Armor.TYPE.RGauntlet] = nil\n\telse\n\t\t_armor_types[_slot] = nil\n\tend\n\treturn _armor_types\nend\n\nFn.get_unarmored_slots         = function()\n\tlocal armor_types = get(Dt.ARMOR_TYPES)\n\tlocal armor = Fn.get_equipped_armor()\n\tfor _, _obj in ipairs(armor) do Fn.clean_slots(types.Armor.record(_obj).type, armor_types) end\n\tlocal unarmored_slots = {}\n\tfor _slot, _ in pairs(armor_types) do table.insert(unarmored_slots, _slot) end\n\treturn unarmored_slots --Note this is iterable and #ble. That's important.\nend\n\nFn.get_AR                      = function()\n\tlocal skill  = 0\n\tlocal rating = 0\n\tlocal armor  = Fn.get_equipped_armor()\n\tfor _, _obj in ipairs(armor) do\n\t\tskill        = types.Player.stats.skills[getArmorType(_obj)](self).modified\n\t\tlocal slot   = types.Armor.record(_obj).type\n\t\tlocal hp_mod = types.Item.itemData(_obj).condition / types.Armor.record(_obj).health\n\t\trating       = rating +\n\t\t\t\ttypes.Armor.record(_obj).baseArmor * hp_mod * Dt.ARMOR_RATING_WEIGHTS[slot] * skill / Dt.GMST.iBaseArmorSkill\n\tend\n\tlocal unarmored_slots = Fn.get_unarmored_slots()\n\tfor _, _slot in ipairs(unarmored_slots) do\n\t\tskill = types.Player.stats.skills.unarmored(self).modified\n\t\trating = rating +\n\t\t\t\tskill * Dt.GMST.fUnarmoredBase1 * skill * Dt.GMST.fUnarmoredBase2 *\n\t\t\t\tDt.ARMOR_RATING_WEIGHTS\n\t\t\t\t[_slot] -- Why have 2 GMSTs for 1 number? Precision? Yeah precision I guess.\n\tend\n\trating = rating + Fn.get_active_effect_mag('shield')\n\treturn rating\nend\n\nlocal unarmored_hit_decay      = time.runRepeatedly(function()\n\tif Dt.counters.unarmored(0) > 0.01 then\n\t\tDt.counters.unarmored(-math.max(Dt.counters.unarmored(0) / Mui.getSetting('Unarmored_Decay_Time'),\n\t\t\t2 / (Mui.getSetting('Unarmored_Decay_Time'))))\n\telse\n\t\tDt.counters.unarmored(-Dt.counters.unarmored(0))\n\tend\nend, time.second)\nlocal acrobatics_jump_decay    = time.runRepeatedly(function()\n\tif Dt.counters.acrobatics(0) > 0.01 then\n\t\tDt.counters.acrobatics(-math.max(Dt.counters.acrobatics(0) / Mui.getSetting('Acrobatics_Decay_Time'),\n\t\t\t2 / (Mui.getSetting('Acrobatics_Decay_Time'))))\n\telse\n\t\tDt.counters.acrobatics(-Dt.counters.acrobatics(0))\n\tend\nend, time.second)\nlocal athletics_run_decay      = time.runRepeatedly(function()\n\tif Dt.counters.athletics(0) > 0.01 then\n\t\tDt.counters.athletics(-math.max(Dt.counters.athletics(0) - Mui.getSetting('Athletics_Decay_Time'), 1))\n\telse\n\t\tDt.counters.athletics(-Dt.counters.athletics(0))\n\tend\n\tif Dt.counters.athletics_debug(0) > 9.01 then\n\t\tDEBUG('SUS [Athletics] Decay Timer: ' .. string.format('%.0f', Dt.counters.athletics(0)))\n\tend\nend, time.second)\n\n--  =============\n--  || SCALERS ||\n--  =============\n\nFn.make_scalers                = function()\n\t-- ARMOR\n\t-----------------------------------------------------------------------------------------------------------\n\tfor _, _skillid in ipairs(Dt.scaler_groups.ARMOR) do\n\t\tDt.scalers:new {\n\t\t\tname = _skillid,\n\t\t\tfunc = function(_, xp)\n\t\t\t\tif not Mui.getSetting('toggle_armor') then return xp end\n\t\t\t\tif not Mui.getSetting(_skillid) then return xp end\n\n\t\t\t\t-- Disable scaling while under the effect of Disintegrate Armor, for you may get ridiculous amounts of XP if the stars line up wrong.\n\t\t\t\t-- For the sake of robustness and simplicity, it's a tradeoff I'm willing to accept. I will NOT attempt to fix it.\n\t\t\t\tif Fn.has_effect('disintegratearmor') then\n\t\t\t\t\tDEBUG('SUS - Disintegrate Armor in effect, returning vanilla XP')\n\t\t\t\t\treturn xp\n\t\t\t\tend\n\t\t\t\tlocal armor_obj = Fn.get_hit_armorpiece()\n\t\t\t\tif not armor_obj then return xp end -- If we didn't find a hit piece, we skip scaling and leave XP vanilla. It's an edge case not worth pursuing.\n\n\t\t\t\t-- Estimate incoming damage from AR and condition lost instead of directly using condition lost.\n\t\t\t\t-- This helps avoid low ARs becoming a pit of neverleveling.\n\t\t\t\tlocal condition_lost = Dt.pc.armor_condition.prevframe[types.Armor.record(armor_obj).type] -\n\t\t\t\t\t\ttypes.Item.itemData(armor_obj).condition\n\t\t\t\tlocal rating = Fn.get_AR()\n\t\t\t\tlocal damage = (condition_lost * rating) / (rating - condition_lost)\n\t\t\t\t-- Armor skill and AR GMSTs are combined to make leveling below base AR faster, and above slower.\n\t\t\t\tlocal skill = types.Player.stats.skills[_skillid](self).base\n\t\t\t\tlocal multiplier = damage / Mui.getSetting('Armor_Damage_To_XP') * 60 / (30 + skill)\n\t\t\t\txp = xp * (multiplier * Mui.getSetting('Scaling_Multiplier') + Mui.getSetting('Base_Action_Value')) *\n\t\t\t\t\t\tMui.getSetting('Global_Multiplier')\n\n\t\t\t\t-- Add a hit for Unarmored's timer, so that having a couple empty pieces doesn't result in massive unarmored bonuses.\n\t\t\t\tDt.counters.unarmored(1)\n\t\t\t\tDEBUG('SUS [Armor] Skill Uses: ' ..\n\t\t\t\t\tstring.format('%.2f', multiplier * Mui.getSetting('Scaling_Multiplier') + Mui.getSetting('Base_Action_Value')) *\n\t\t\t\t\tMui.getSetting('Global_Multiplier') ..\n\t\t\t\t\t' | XP ' .. string.format('%.2f', xp) .. ' | Damage Received: ' .. string.format('%.2f', damage))\n\n\t\t\t\treturn xp\n\t\t\tend\n\t\t}\n\tend\n\n\t-- BLOCK\n\t-----------------------------------------------------------------------------------------------------------\n\tDt.scalers:new { name = 'block',\n\t\tfunc = function(_, xp)\n\t\t\tif not Mui.getSetting('toggle_armor') then return xp end\n\t\t\tif not Mui.getSetting('block') then return xp end\n\n\t\t\t-- Disable scaling while under the effect of Disintegrate Armor, for you may get ridiculous amounts of XP if the stars line up wrong.\n\t\t\t-- For the sake of robustness and simplicity, it's a tradeoff I'm willing to accept. I will NOT attempt to fix it.\n\t\t\tif Fn.has_effect('disintegratearmor') then\n\t\t\t\tDEBUG('SUS - Disintegrate Armor in effect, returning vanilla XP')\n\t\t\t\treturn xp\n\t\t\tend\n\t\t\tlocal armor_obj = types.Actor.getEquipment(self, Dt.SLOTS.SHIELD)\n\t\t\tlocal current_shield_condition = 0 -- if armor_obj is nill, because the shield was broken and unequipped, then we count condition as 0.\n\t\t\tlocal condition_lost = 0\n\t\t\t-- With armor the likelyhood of breaking is low, so we're better off just returning xp, but here we should air on the side of scaling the edge case rather than ignoring it.\n\t\t\tif armor_obj then\n\t\t\t\tcurrent_shield_condition = types.Item.itemData(armor_obj).condition\n\t\t\t\tcondition_lost = Dt.pc.armor_condition.prevframe[types.Armor.record(armor_obj).type] - current_shield_condition\n\t\t\telse\n\t\t\t\tDEBUG('Armor pice broken! Returning vanilla XP')\n\t\t\t\treturn xp\n\t\t\tend\n\t\t\tlocal damage = condition_lost\n\t\t\t-- Armor skill and AR GMSTs are combined to make leveling below base AR faster, and above slower.\n\t\t\tlocal skill = types.Player.stats.skills.block(self).base\n\n\t\t\tlocal multiplier = damage / Mui.getSetting('Block_Damage_To_XP') * 60 / (30 + skill)\n\t\t\txp = xp * (multiplier * Mui.getSetting('Scaling_Multiplier') + Mui.getSetting('Base_Action_Value')) *\n\t\t\t\t\tMui.getSetting('Global_Multiplier')\n\n\t\t\tDEBUG('SUS [Block] Skill Uses: ' ..\n\t\t\t\tstring.format('%.2f', multiplier * Mui.getSetting('Scaling_Multiplier') + Mui.getSetting('Base_Action_Value')) *\n\t\t\t\tMui.getSetting('Global_Multiplier') ..\n\t\t\t\t' | XP ' .. string.format('%.2f', xp) .. ' | Damage Received: ' .. string.format('%.2f', damage))\n\n\t\t\t-- Note we DON'T add an unarmored hit down here. You fully blocked, took no damage and gained no armor skill xp, so it doesn't count as a hit in my books.\n\n\t\t\treturn xp\n\t\tend\n\t}\n\n\t-- UNARMORED\n\t-----------------------------------------------------------------------------------------------------------\n\tDt.scalers:new { name = 'unarmored',\n\t\tfunc = function(_, xp)\n\t\t\tif not Mui.getSetting('unarmored') then return xp end\n\n\t\t\tlocal armor_weight = 0\n\t\t\tlocal armor = Fn.get_equipped_armor()\n\t\t\tfor _, _obj in ipairs(armor) do armor_weight = armor_weight + types.Armor.record(_obj).weight end\n\t\t\t--       local race     = get_val(types.Player.record(self).race)\n\t\t\tlocal beast_factor = 1 -- If you have more than 3 empty slots, this will stay a 1 and not affect your XP rates, even if you are Argonian/Khajiit\n\t\t\t--       if #Fn.get_unarmored_slots() <= 3 and (race == 'argonian' or race == 'khajiit') then beast_factor = Mui.getSetting('Unarmored_Beast_Races')/ #Fn.get_unarmored_slots() end\n\t\t\tlocal gank_factor  = (Mui.getSetting('Unarmored_Start') - Mui.getSetting('Unarmored_Min')) /\n\t\t\t\t\t(2 * Dt.counters.unarmored(1) - 1) + Mui.getSetting('Unarmored_Min')\n\t\t\tlocal skill        = types.Player.stats.skills['unarmored'](self).base\n\t\t\tlocal rating       = skill * Dt.GMST.fUnarmoredBase1 * skill * Dt.GMST.fUnarmoredBase2\n\t\t\tlocal skill_factor = 100 /\n\t\t\t\t\t(35 + rating + skill + armor_weight * Mui.getSetting('Unarmored_Armor_Mult')) -- Rating is added here alongside skill, because unarmored has exponential scaling baked in.\n\n\t\t\tlocal multiplier   = skill_factor * beast_factor * gank_factor\n\t\t\txp                 = xp * (multiplier * Mui.getSetting('Scaling_Multiplier') + Mui.getSetting('Base_Action_Value')) *\n\t\t\t\t\tMui.getSetting('Global_Multiplier')\n\n\t\t\tDEBUG('SUS [Unarmored] Skill Uses: ' ..\n\t\t\t\tstring.format('%.2f', multiplier * Mui.getSetting('Scaling_Multiplier') + Mui.getSetting('Base_Action_Value')) *\n\t\t\t\tMui.getSetting('Global_Multiplier') ..\n\t\t\t\t' | XP ' .. string.format('%.2f', xp) .. ' | Hit Counter: ' .. string.format('%.2f', Dt.counters.unarmored(0)))\n\n\t\t\treturn xp\n\t\tend\n\t}\n\n\t-- SPELL\n\t-----------------------------------------------------------------------------------------------------------\n\tfor _, _skillid in ipairs(Dt.scaler_groups.SPELL) do\n\t\tDt.scalers:new { name = _skillid,\n\t\t\tfunc = function(_, xp)\n\t\t\t\tif not Mui.getSetting('toggle_magic') then return xp end\n\t\t\t\tif not Mui.getSetting(_skillid) then return xp end\n\n\t\t\t\tlocal spell = Dt.pc.spell\n\t\t\t\tif not spell then\n\t\t\t\t\tDEBUG('SUS - Held Spell not found, returning vanilla XP')\n\t\t\t\t\treturn xp\n\t\t\t\telseif (not spell.cost) or (spell.cost == 0) then\n\t\t\t\t\tDEBUG('SUS - Held Spell\\'s cost (' .. tostring(spell.cost) .. ') is not valid, returning vanilla XP')\n\t\t\t\t\treturn xp\n\t\t\t\tend\n\t\t\t\tlocal max_mp = types.Player.stats.dynamic.magicka(self).base\n\t\t\t\tlocal mp_factor = 0.01 * max_mp\n\t\t\t\tlocal multiplier = spell.cost / Mui.getSetting('Magicka_to_XP') * 4.8 / (4 + math.max(0, mp_factor - 1))\n\t\t\t\txp = xp * (multiplier * Mui.getSetting('Scaling_Multiplier') + Mui.getSetting('Base_Action_Value')) *\n\t\t\t\t\t\tMui.getSetting('Global_Multiplier')\n\n\t\t\t\tDEBUG('SUS [Magic] Skill Uses: ' ..\n\t\t\t\t\tstring.format('%.2f', multiplier * Mui.getSetting('Scaling_Multiplier') + Mui.getSetting('Base_Action_Value')) *\n\t\t\t\t\tMui.getSetting('Global_Multiplier') ..\n\t\t\t\t\t' | XP ' .. string.format('%.2f', xp) .. ' | Spell Cost: ' .. string.format('%.2f', spell.cost))\n\n\t\t\t\tif not Mui.getSetting('toggle_refund') then return xp end\n\n\t\t\t\tlocal armor_weight = 0\n\t\t\t\tlocal armor = Fn.get_equipped_armor()\n\t\t\t\tfor _, _obj in ipairs(armor) do armor_weight = armor_weight + types.Armor.record(_obj).weight end\n\t\t\t\tlocal armor_offset                               = armor_weight * Mui.getSetting('MP_Refund_Armor_mult')\n\t\t\t\tlocal cost_factor                                = max_mp / (max_mp + spell.cost)\n\t\t\t\tlocal skill                                      = types.Player.stats.skills[_skillid](self).base\n\t\t\t\tlocal skill_factor                               = (skill - Mui.getSetting('MP_Refund_Skill_Offset') - armor_offset) /\n\t\t\t\t\t\t(40 + skill)\n\n\t\t\t\tlocal refund                                     = spell.cost * cost_factor * skill_factor * 0.01 *\n\t\t\t\t\t\tMui.getSetting('MP_Refund_Max_Percent')\n\n\t\t\t\t--Yes, this will apply even if current > max.\n\t\t\t\t--To keep vanilla compatibility, we have to consider current>max as a valid gameplay state, since Fortify Magicka doesn't increase Max MP.\n\t\t\t\ttypes.Player.stats.dynamic.magicka(self).current = types.Player.stats.dynamic.magicka(self).current + refund\n\t\t\t\tif refund > 0 then\n\t\t\t\t\tDEBUG('SUS [Dynamic Spell Cost] Refund: ' ..\n\t\t\t\t\t\tstring.format('%.2f', refund / spell.cost * 100) .. '% | ' .. string.format('%.2f', refund) .. ' MP')\n\t\t\t\telse\n\t\t\t\t\tDEBUG('SUS [Dynamic Spell Cost] Penalty: ' ..\n\t\t\t\t\t\tstring.format('%.2f', refund / spell.cost * 100) .. '% | ' .. string.format('%.2f', refund) .. ' MP')\n\t\t\t\tend\n\n\t\t\t\treturn xp\n\t\t\tend\n\t\t}\n\tend\n\n\t-- MELEE\n\t-----------------------------------------------------------------------------------------------------------\n\tfor _, _skillid in ipairs(Dt.scaler_groups.WEAPON) do\n\t\tDt.scalers:new { name = _skillid,\n\t\t\tfunc = function(_, xp)\n\t\t\t\tif not Mui.getSetting('toggle_physical') then return xp end\n\t\t\t\tif not Mui.getSetting(_skillid) then return xp end\n\n\t\t\t\tlocal skill = types.Player.stats.skills[_skillid](self).base\n\t\t\t\tlocal multiplier = Dt.pc.attack.damage / Mui.getSetting('Physical_Damage_to_XP') * 80 / (40 + skill)\n\t\t\t\txp = xp * (multiplier * Mui.getSetting('Scaling_Multiplier') + Mui.getSetting('Base_Action_Value')) *\n\t\t\t\t\t\tMui.getSetting('Global_Multiplier')\n\t\t\t\tDEBUG('SUS [Weapon] Skill Uses: ' ..\n\t\t\t\t\tstring.format('%.2f', multiplier * Mui.getSetting('Scaling_Multiplier') + Mui.getSetting('Base_Action_Value')) *\n\t\t\t\t\tMui.getSetting('Global_Multiplier') ..\n\t\t\t\t\t' | XP ' ..\n\t\t\t\t\tstring.format('%.2f', xp) ..\n\t\t\t\t\t' | Damage Dealt: ' ..\n\t\t\t\t\tstring.format('%.2f', Dt.pc.attack.damage) .. ' | Weapon Draw // Attack Charge: ' ..\n\t\t\t\t\tpercentify(Dt.pc.attack.draw))\n\t\t\t\treturn xp\n\t\t\tend\n\t\t}\n\tend\n\n\t-- HAND TO HAND\n\t-----------------------------------------------------------------------------------------------------------\n\tDt.scalers:new { name = 'handtohand',\n\t\tfunc = function(_, xp)\n\t\t\tif not Mui.getSetting('toggle_physical') then return xp end\n\t\t\tif not Mui.getSetting('handtohand') then return xp end\n\n\t\t\t-- Now we average your fatigue damage and your health damage.\n\t\t\t-- It's the best method I could think of to balance the fact that H2H goes through 2 different healthbars at 2 different rates\n\t\t\t-- ..while also keeping compatibility with mods that change H2H GMSTs.\n\t\t\tlocal skill = types.Player.stats.skills.handtohand(self).base\n\t\t\tlocal damage = Dt.pc.attack.damage\n\t\t\tlocal damage = (damage + damage * Dt.GMST.fHandtoHandHealthPer) / 2\n\t\t\tlocal multiplier = damage / Mui.getSetting('Physical_Damage_to_XP') * 80 / (40 + skill)\n\t\t\txp = xp * (multiplier * Mui.getSetting('Scaling_Multiplier') + Mui.getSetting('Base_Action_Value')) *\n\t\t\t\t\tMui.getSetting('Global_Multiplier')\n\t\t\tDEBUG('SUS [Hand-To-Hand] Skill Uses: ' ..\n\t\t\t\tstring.format('%.2f', multiplier * Mui.getSetting('Scaling_Multiplier') + Mui.getSetting('Base_Action_Value')) *\n\t\t\t\tMui.getSetting('Global_Multiplier') ..\n\t\t\t\t' | XP ' ..\n\t\t\t\tstring.format('%.2f', xp) ..\n\t\t\t\t' | Damage Dealt: ' ..\n\t\t\t\tstring.format('%.2f', damage) .. ' | Weapon Draw // Attack Charge: ' .. percentify(Dt.pc.attack.draw))\n\t\t\treturn xp\n\t\tend\n\t}\n\t-- ACROBATICS\n\t-----------------------------------------------------------------------------------------------------------\n\tDt.scalers:new { name = 'acrobatics',\n\t\tfunc = function(useType, xp)\n\t\t\tif not Mui.getSetting('acrobatics') then return xp end\n\n\t\t\tlocal encumbered_mult = Mui.getSetting('Acrobatics_Encumbrance_Min') +\n\t\t\t\t\t(Mui.getSetting('Acrobatics_Encumbrance_Max') - Mui.getSetting('Acrobatics_Encumbrance_Min'))\n\t\t\t\t\t* types.Actor.getEncumbrance(self) /\n\t\t\t\t\t(Dt.GMST.fEncumbranceStrMult * types.Player.stats.attributes.strength(self).base)\n\t\t\tlocal recursive_mult = 1\n\t\t\tif useType == skp.SKILL_USE_TYPES.Acrobatics_Jump then\n\t\t\t\trecursive_mult = (Mui.getSetting('Acrobatics_Start')) / (1 + (Dt.counters.acrobatics(1) - 1) / 2)\n\t\t\t\tDt.pc.grounded = false                         -- We skip the next athletics use, bunny hopping isn't running.\n\t\t\tend\n\t\t\tlocal multiplier = encumbered_mult * recursive_mult -- No fatigue% => no XP, and more weight% == less XP\n\t\t\txp = xp * (multiplier * Mui.getSetting('Scaling_Multiplier') + Mui.getSetting('Base_Action_Value')) *\n\t\t\t\t\tMui.getSetting('Global_Multiplier')\n\t\t\tDEBUG('SUS [Acrobatics] Skill Uses: ' ..\n\t\t\t\tstring.format('%.2f', multiplier * Mui.getSetting('Scaling_Multiplier') + Mui.getSetting('Base_Action_Value')) *\n\t\t\t\tMui.getSetting('Global_Multiplier') ..\n\t\t\t\t' | XP ' .. string.format('%.2f', xp) .. ' | Jump Mult: ' .. string.format('%.2f', recursive_mult))\n\t\t\treturn xp\n\t\tend\n\t}\n\t-- ATHLETICS\n\t-----------------------------------------------------------------------------------------------------------\n\tDt.scalers:new { name = 'athletics',\n\t\tfunc = function(_, xp)\n\t\t\tif not Mui.getSetting('athletics') then return xp end\n\t\t\tif not Dt.pc.grounded then\n\t\t\t\tDt.pc.grounded = true\n\t\t\t\treturn 0\n\t\t\tend -- We just jumped, setup for next cycle and give no xp.\n\t\t\tlocal position = self.object.position\n\t\t\tDt.pc.grounded = nearby.castRay(position, position - util.vector3(0, 0, 25),\n\t\t\t\t{ collisionType = nearby.COLLISION_TYPE.AnyPhysical }).hitPos\n\t\t\tlocal swimming = position.z < -100\n\t\t\tif not swimming and not Dt.pc.grounded and not Fn.has_effect('levitate') then\n\t\t\t\tDt.pc.grounded = true\n\t\t\t\treturn 0\n\t\t\tend -- We were in the air or in a particularly slopey slope, and we weren't levitating. Setup. Skip. | Fun fact: you DO run while levitating!\n\t\t\tlocal movement = Dt.pc.position - position\n\t\t\tmovement = math.abs(movement.x) + math.abs(movement.y)\n\t\t\tlocal move_factor = 1\n\t\t\tif movement < 150 then move_factor = Mui.getSetting('Athletics_No_Move_Penalty') end\n\t\t\tDt.pc.position        = position\n\t\t\tlocal encumbered_mult = Mui.getSetting('Athletics_Encumbrance_Min') +\n\t\t\t\t\t(Mui.getSetting('Athletics_Encumbrance_Max') - Mui.getSetting('Athletics_Encumbrance_Min'))\n\t\t\t\t\t* types.Actor.getEncumbrance(self) / (Dt.GMST.fEncumbranceStrMult\n\t\t\t\t\t\t* types.Player.stats.attributes.strength(self).base)\n\t\t\tlocal recursive_mult  = (Mui.getSetting('Athletics_Start')) +\n\t\t\t\t\t(Mui.getSetting('Athletics_Marathon') - (Mui.getSetting('Athletics_Start')))\n\t\t\t\t\t* (Dt.counters.athletics(2) - 2) / Mui.getSetting('Athletics_Decay_Time')\n\t\t\tif swimming then Dt.counters.athletics(2) end\n\t\t\tlocal multiplier = encumbered_mult * recursive_mult * move_factor\n\t\t\txp = xp * (multiplier * Mui.getSetting('Scaling_Multiplier') + Mui.getSetting('Base_Action_Value')) *\n\t\t\t\t\tMui.getSetting('Global_Multiplier')\n\t\t\tlocal printcounter = Dt.counters.athletics_debug(1)\n\t\t\tif printcounter > 5.01 then\n\t\t\t\tDEBUG('SUS [Athletics] Skill Uses: ' ..\n\t\t\t\t\tstring.format('%.2f', multiplier * Mui.getSetting('Scaling_Multiplier')\n\t\t\t\t\t\t+ Mui.getSetting('Base_Action_Value')) * Mui.getSetting('Global_Multiplier') .. ' | XP '\n\t\t\t\t\t.. string.format('%.2f', xp * printcounter) .. ' | Marathon Mult: ' .. string.format('%.2f', recursive_mult))\n\t\t\t\tDt.counters.athletics_debug(-printcounter)\n\t\t\tend\n\t\t\treturn xp\n\t\tend\n\t}\n\n\t-- SECURITy\n\t-----------------------------------------------------------------------------------------------------------\n\tDt.scalers:new { name = 'security',\n\t\tfunc = function(useType, xp)\n\t\t\tif not Mui.getSetting('security') then return xp end\n\n\t\t\tlocal target = Dt.pc.security_target\n\t\t\tif not target then\n\t\t\t\tprint('SUS - Targeted Door/Container not found, returning vanilla xp')\n\t\t\t\treturn xp\n\t\t\tend\n\t\t\tlocal security_print = ''\n\t\t\tlocal multiplier = 1\n\t\t\tif (useType == skp.SKILL_USE_TYPES.Security_PickLock) and Dt.pc.security_target.islocked then\n\t\t\t\tmultiplier = target.level / Mui.getSetting('Security_Lock_Points_To_XP')\n\t\t\t\tsecurity_print = 'Lock Level: ' .. target.level\n\t\t\telseif (useType == skp.SKILL_USE_TYPES.Security_DisarmTrap) and Dt.pc.security_target.trap then\n\t\t\t\tmultiplier = target.trap.cost / Mui.getSetting('Security_Trap_Points_To_XP')\n\t\t\t\tsecurity_print = 'Trap Level: ' .. target.trap.cost\n\t\t\tend\n\n\t\t\txp = xp * (multiplier * Mui.getSetting('Scaling_Multiplier') + Mui.getSetting('Base_Action_Value')) *\n\t\t\t\t\tMui.getSetting('Global_Multiplier')\n\t\t\tDEBUG('SUS [Security] Skill Uses: ' .. string.format('%.2f', multiplier * Mui.getSetting('Scaling_Multiplier')\n\t\t\t\t\t+ Mui.getSetting('Base_Action_Value')) * Mui.getSetting('Global_Multiplier')\n\t\t\t\t.. ' | XP ' .. string.format('%.2f', xp) .. ' | ' .. security_print)\n\t\t\treturn xp\n\t\tend\n\t}\n\n\tDEBUG('SUS: Scalering Commenced')\nend\n\n-----------------------------------------------------------------------------------------------------------\n\n-- RETURN || NEED THIS SO FILE DO THING\nreturn Fn\n",
    "Skill_Uses_Scaled-54267-1-03-1719308736\\scripts\\Skill_Uses_Scaled\\global.lua": "local world = require('openmw.world')\n\nreturn {\n\teventHandlers = {\n\t\tSUS_updateGLOBvar = function(t)\n\t\t\tt.source:sendEvent('SUS_updateGLOBvar',\n\t\t\t\t{ id = t.id, val = world.mwscript.getGlobalVariables(t.source)[t.id] }\n\t\t\t)\n\t\tend, -- t = {id = 'id', source = _obj}\n\t}\n}\n",
    "Skill_Uses_Scaled-54267-1-03-1719308736\\scripts\\Skill_Uses_Scaled\\modui.lua": "-- In a player script\nlocal storage  = require('openmw.storage')\nlocal settings = require('openmw.interfaces').Settings\nlocal async    = require('openmw.async')\nlocal ui       = require('openmw.ui')\nlocal Dt       = require('scripts.Skill_Uses_Scaled.data')\n\nlocal function num_range(min, max, step) -- \" Why have I done this \"\n\tif math.abs(step) < 0.0001 then\n\t\tprint('SUS: step must not be between -0.0001 and 0.0001')\n\t\treturn nil\n\tend\n\tlocal result = {}\n\tlocal digits = { tostring(step):find('%.(%d*)') }\n\tif not digits[3] then digits[3] = '' end\n\tlocal newdigits = '%.' .. #tostring(digits[3]) .. 'f'\n\tfor i = min, max, step do table.insert(result, 0 + string.format(newdigits, tostring(i))) end\n\treturn result\nend\n\nlocal function array_concat(array, ...)\n\tfor _, t in ipairs({ ... }) do\n\t\tfor _, v in ipairs(t) do table.insert(array, v) end\n\tend\n\treturn array\nend\n\nlocal function makeKeyEnum(keys)\n\tlocal result = {}\n\tfor _, key in ipairs(keys) do result[key] = true end\n\treturn result\nend\n\nlocal function edit_args(base, changes)\n\tfor k, v in pairs(changes) do base[k] = v end\n\treturn base\nend\n\nlocal function get(svar) -- s in svar means serializable | Recursions WILL stack overflow :D\n\tif type(svar) ~= 'table' then\n\t\treturn svar\n\telse\n\t\tlocal deepcopy = {}\n\t\tfor _key, _value in pairs(svar) do deepcopy[_key] = get(_value) end\n\t\treturn deepcopy\n\tend\nend\n\nlocal Mui = {}\n\nMui.presets = {\n\tcustom = {},\n\tdefault = {\n\t\tBase_Action_Value          = 0.3,\n\t\tGlobal_Multiplier          = 1,\n\t\tScaling_Multiplier         = 1,\n\t\tMagicka_to_XP              = 12,\n\t\tMP_Refund_Skill_Offset     = 15,\n\t\tMP_Refund_Armor_mult       = 0.5,\n\t\tMP_Refund_Max_Percent      = 50,\n\t\ttoggle_refund              = false,\n\t\ttoggle_magic               = true,\n\t\talteration                 = true,\n\t\tconjuration                = true,\n\t\tdestruction                = true,\n\t\tillusion                   = true,\n\t\tmysticism                  = true,\n\t\trestoration                = true,\n\t\tPhysical_Damage_to_XP      = 20,\n\t\ttoggle_h2h_str             = true,\n\t\tHandToHand_Strength        = 40,\n\t\ttoggle_physical            = true,\n\t\taxe                        = true,\n\t\tbluntweapon                = true,\n\t\tlongblade                  = true,\n\t\tshortblade                 = true,\n\t\tspear                      = true,\n\t\tmarksman                   = true,\n\t\thandtohand                 = true,\n\t\tArmor_Damage_To_XP         = 9,\n\t\tBlock_Damage_To_XP         = 9,\n\t\ttoggle_armor               = true,\n\t\theavyarmor                 = true,\n\t\tmediumarmor                = true,\n\t\tlightarmor                 = true,\n\t\tblock                      = true,\n\t\tUnarmored_Armor_Mult       = 0.5,\n\t\tUnarmored_Start            = 3,\n\t\tUnarmored_Min              = 0,\n\t\tUnarmored_Decay_Time       = 30,\n\t\t--Unarmored_Beast_Races      = 6     ,\n\t\tunarmored                  = true,\n\t\tAcrobatics_Start           = 1.75,\n\t\tAcrobatics_Decay_Time      = 6,\n\t\tAcrobatics_Encumbrance_Max = 0.5,\n\t\tAcrobatics_Encumbrance_Min = 1.5,\n\t\tacrobatics                 = true,\n\t\tAthletics_Start            = 0.5,\n\t\tAthletics_Marathon         = 2,\n\t\tAthletics_Decay_Time       = 180,\n\t\tAthletics_No_Move_Penalty  = 0.01,\n\t\tAthletics_Encumbrance_Max  = 1.5,\n\t\tAthletics_Encumbrance_Min  = 0.5,\n\t\tathletics                  = true,\n\t\tSecurity_Lock_Points_To_XP = 20,\n\t\tSecurity_Trap_Points_To_XP = 20,\n\t\tsecurity                   = true,\n\t\tSUS_DEBUG                  = false,\n\t\tSUS_VERBOSE                = true,\n\t}\n}\n\nMui.SKILLS_MAP = makeKeyEnum(Dt.SKILLS)\nMui.toggles = {\n\ttoggle_physical = { 'axe', 'bluntweapon', 'longblade', 'shortblade', 'spear', 'marksman', 'handtohand' }, --1~7\n\ttoggle_magic    = { 'alteration', 'conjuration', 'destruction', 'illusion', 'mysticism', 'restoration' }, --8~13\n\ttoggle_armor    = { 'heavyarmor', 'lightarmor', 'mediumarmor', 'block' },                                --14~17\n\t--toggle_refund     = {'MP_Refund_Skill_Offset', 'MP_Refund_Armor_mult', 'MP_Refund_Max_Percent'}\n}\n\nMui.settingsGroups = {}\nfunction addSettingsGroup(name)\n\tlocal groupid = \"Settings_SUS_\" .. name\n\tMui[groupid] = {}\n\tstorage.playerSection(groupid):reset()\n\ttable.insert(Mui.settingsGroups, groupid)\nend\n\nsettings.registerPage {\n\tkey         = 'susconfig',\n\tl10n        = 'Skill_Uses_Scaled',\n\tname        = 'Skill Uses Scaled',\n\tdescription = 'Configure and toggle XP scaling based on the gameplay value of each skill use.\\n' ..\n\t\t\t' All skills are configurable and can be toggled individually.\\n' ..\n\t\t\t' Skills with similar behaviour are grouped together, for clarity and convenience.',\n}\n\naddSettingsGroup('global')\nsettings.registerGroup {\n\tkey              = 'Settings_SUS_global',\n\tname             = 'Global Modifiers',\n\tdescription      = 'These settings change all SUS scalers by the same amount, use them to change how close to (or far from) vanilla your XP gains will be.',\n\tpage             = 'susconfig',\n\torder            = 1,\n\tl10n             = 'Skill_Uses_Scaled',\n\tpermanentStorage = false,\n\tsettings         = {\n\t\t{\n\t\t\tkey         = 'Global_Multiplier',\n\t\t\tname        = 'Global XP Rate',\n\t\t\tdescription = 'ALL XP gains are multiplied by this number. Use this to make leveling slower overall and stretch the early-game.. or do the opposite if you want to quickly level into late-game.',\n\t\t\trenderer    = 'select',\n\t\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(0, 1, .1), num_range(1.2, 3, .2)) },\n\t\t\tdefault     = Mui.presets.default.Global_Multiplier,\n\t\t}, {\n\t\tkey         = 'Base_Action_Value',\n\t\tname        = 'Base Action Value',\n\t\tdescription = 'How many flat skill uses worth of XP are added to the scaled values. 1 means one Vanilla skill use.\\n' ..\n\t\t\t\t' This lets you gain a baseline amount of XP regardless of how inneffective your action was, to represent the value of repetition alone.',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(0, 1, .1), num_range(1.2, 3, .2)) },\n\t\tdefault     = Mui.presets.default.Base_Action_Value,\n\t}, {\n\t\tkey         = 'Scaling_Multiplier',\n\t\tname        = 'Scaling Multiplier',\n\t\tdescription = 'Use this if you like how scaling works and would prefer to tone it down a little, but don\\'t want to change each scaler independently.\\n' ..\n\t\t\t\t' This does not affect the XP gained from the previous setting, use them together to determine how close your experience is to Vanilla.',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(0, 1, .1), num_range(1.2, 3, .2)) },\n\t\tdefault     = Mui.presets.default.Scaling_Multiplier,\n\t}\n\t}\n}\naddSettingsGroup('magic')\nMui.Settings_SUS_magic.args = {\n\tMP_Refund_Skill_Offset = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(1, 25, 1), num_range(30, 100, 5)), disabled = true },\n\tMP_Refund_Armor_mult   = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(.1, .9, .1), num_range(1, 3, 0.1)), disabled = true },\n\tMP_Refund_Max_Percent  = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(1, 25, 1), num_range(30, 100, 5)), disabled = true },\n}\nsettings.registerGroup {\n\tkey              = 'Settings_SUS_magic',\n\tname             = 'Magic Schools',\n\tdescription      = 'Successful spell casts will give XP proportional to the spell\\'s cost.\\n' ..\n\t\t\t' Optional, but recommended, are the provided refund/penalty mechanics.',\n\tpage             = 'susconfig',\n\torder            = 2,\n\tl10n             = 'Skill_Uses_Scaled',\n\tpermanentStorage = false,\n\tsettings         = {\n\t\t{\n\t\t\tkey         = 'Magicka_to_XP',\n\t\t\tname        = 'Magicka to XP',\n\t\t\tdescription = 'How much spell cost is equivalent to one vanilla skill use.',\n\t\t\trenderer    = 'select',\n\t\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(1, 25, 1), num_range(30, 100, 5)) },\n\t\t\tdefault     = Mui.presets.default.Magicka_to_XP,\n\t\t}, {\n\t\tkey         = 'toggle_refund',\n\t\tname        = 'Dynamic Spell Cost',\n\t\tdescription = 'Toggling this on will make your spell\\'s cost change depending on your gear and skill level, akin to spellcasting in Oblivion and Skyrim. High skill and no armor will result in a refund, while heavy armor and low skill will incur a penalty. Only applies on successful spellcasts.',\n\t\trenderer    = 'checkbox',\n\t\tdefault     = Mui.presets.default.toggle_refund,\n\t}, {\n\t\tkey         = 'MP_Refund_Skill_Offset',\n\t\tname        = 'Skill Offset',\n\t\tdescription = 'Magic skill is reduced by [This] for the calculation of Dynamic Spell Cost',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(1, 25, 1), num_range(30, 100, 5)), disabled = true },\n\t\tdefault     = Mui.presets.default.MP_Refund_Skill_Offset,\n\t}, {\n\t\tkey         = 'MP_Refund_Armor_mult',\n\t\tname        = 'Armor Penalty Offset',\n\t\tdescription = 'Magic skill is further reduced by [This]x[Equipped Armor Weight].\\n' ..\n\t\t\t\t' If after all offsets your skill is still positive, you\\'ll get a portion of the spell refunded, reducing spell cost. If the resulting number is negative, the \"refund\" will take extra magicka away instead, increasing spell cost.',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(.1, .9, .1), num_range(1, 3, 0.1)), disabled = true },\n\t\tdefault     = Mui.presets.default.MP_Refund_Armor_mult,\n\t}, {\n\t\tkey         = 'MP_Refund_Max_Percent',\n\t\tname        = 'Maximum Refund Percentage',\n\t\tdescription = 'Refund will never surpass [This]% of original spell cost. This also affects cost increases from skill offset and armor weight, when applicable.',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(1, 25, 1), num_range(30, 100, 5)), disabled = true },\n\t\tdefault     = Mui.presets.default.MP_Refund_Max_Percent,\n\t},\n\t\t{ key = 'toggle_magic', name = 'Enable XP Scaling for this Skill Group:', renderer = 'checkbox', default = Mui.presets.default.toggle_magic },\n\t\t{ key = 'alteration',   name = 'Alteration',                              renderer = 'checkbox', default = Mui.presets.default.alteration },\n\t\t{ key = 'conjuration',  name = 'Conjuration',                             renderer = 'checkbox', default = Mui.presets.default.conjuration },\n\t\t{ key = 'destruction',  name = 'Destruction',                             renderer = 'checkbox', default = Mui.presets.default.destruction },\n\t\t{ key = 'illusion',     name = 'Illusion',                                renderer = 'checkbox', default = Mui.presets.default.illusion },\n\t\t{ key = 'mysticism',    name = 'Mysticism',                               renderer = 'checkbox', default = Mui.presets.default.mysticism },\n\t\t{ key = 'restoration',  name = 'Restoration',                             renderer = 'checkbox', default = Mui.presets.default.restoration },\n\t},\n}\n\naddSettingsGroup('physical')\nMui.Settings_SUS_physical.args = {\n\tHandToHand_Strength = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(10, 100, 5)), disabled = false },\n}\nsettings.registerGroup {\n\tkey              = 'Settings_SUS_physical',\n\tname             = 'Weapons and Hand To Hand',\n\tdescription      = 'Successful attacks will give XP proportional to their damage.\\n' ..\n\t\t\t'Damaging enchantments on weapons are NOT counted, only the weapon\\'s own damage (modified by Strength and Condition).',\n\tpage             = 'susconfig',\n\torder            = 3,\n\tl10n             = 'Skill_Uses_Scaled',\n\tpermanentStorage = false,\n\tsettings         = {\n\t\t{\n\t\t\tkey         = 'Physical_Damage_to_XP',\n\t\t\tname        = 'Damage to XP',\n\t\t\tdescription = 'How much outgoing damage is equivalent to one vanilla skill use.\\n' ..\n\t\t\t\t\t' Not affected by enemy Armor Rating or by game difficulty.',\n\t\t\trenderer    = 'select',\n\t\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(1, 25, 1), num_range(30, 100, 5)) },\n\t\t\tdefault     = Mui.presets.default.Physical_Damage_to_XP,\n\t\t}, {\n\t\tkey      = 'toggle_h2h_str',\n\t\tname     = 'Factor Strength into Hand to Hand',\n\t\trenderer = 'checkbox',\n\t\tdefault  = Mui.presets.default.toggle_h2h_str,\n\t}, {\n\t\tkey         = 'HandToHand_Strength',\n\t\tname        = 'H2H Strength Ratio',\n\t\tdescription = 'H2H damage is multiplied by [STR]/[This] when calculating XP.\\n' ..\n\t\t\t\t' Default is same as OpenMW\\'s.\\n' ..\n\t\t\t\t' Does not affect Werewolves, since (due to how Vanilla Morrowind works) you don\\'t get XP from attacking while in Werewolf form.',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(10, 100, 5)) },\n\t\tdefault     = Mui.presets.default.HandToHand_Strength,\n\t},\n\t\t{ key = 'toggle_physical', name = 'Enable XP Scaling for this Skill Group:', renderer = 'checkbox', default = Mui.presets.default.toggle_physical },\n\t\t{ key = 'axe',             name = 'Axe',                                     renderer = 'checkbox', default = Mui.presets.default.axe },\n\t\t{ key = 'bluntweapon',     name = 'Blunt Weapon',                            renderer = 'checkbox', default = Mui.presets.default.bluntweapon },\n\t\t{ key = 'longblade',       name = 'Long Blade',                              renderer = 'checkbox', default = Mui.presets.default.longblade },\n\t\t{ key = 'shortblade',      name = 'Short Blade',                             renderer = 'checkbox', default = Mui.presets.default.shortblade },\n\t\t{ key = 'spear',           name = 'Spear',                                   renderer = 'checkbox', default = Mui.presets.default.spear },\n\t\t{ key = 'marksman',        name = 'Marksman',                                renderer = 'checkbox', default = Mui.presets.default.marksman },\n\t\t{ key = 'handtohand',      name = 'Hand To Hand',                            renderer = 'checkbox', default = Mui.presets.default.handtohand },\n\t},\n}\n\naddSettingsGroup('armor')\nsettings.registerGroup {\n\tkey              = 'Settings_SUS_armor',\n\tname             = 'Armor',\n\tdescription      = 'Hits taken will provide XP proportional to incoming damage.\\n' ..\n\t\t\t' Like vanilla, this is NOT triggered by spells or magic effects, nor is it affected by any magic-related damage.',\n\tpage             = 'susconfig',\n\torder            = 4,\n\tl10n             = 'Skill_Uses_Scaled',\n\tpermanentStorage = false,\n\tsettings         = {\n\t\t{\n\t\t\tkey         = 'Armor_Damage_To_XP',\n\t\t\tname        = 'Damage to XP',\n\t\t\tdescription = 'How much incoming damage is equivalent to one vanilla skill use.\\n' ..\n\t\t\t\t\t' Not affected by your Armor Rating or by game difficulty.',\n\t\t\trenderer    = 'select',\n\t\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(1, 25, 1), num_range(30, 100, 5)) },\n\t\t\tdefault     = Mui.presets.default.Armor_Damage_To_XP,\n\t\t}, {\n\t\tkey         = 'Block_Damage_To_XP',\n\t\tname        = 'Block - Damage to XP',\n\t\tdescription = 'How much blocked damage is equivalent to one vanilla skill use.\\n' ..\n\t\t\t\t' Remember that blocked hits are prevented completely.',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(1, 25, 1), num_range(30, 100, 5)) },\n\t\tdefault     = Mui.presets.default.Block_Damage_To_XP,\n\t},\n\t\t{ key = 'toggle_armor', name = 'Enable Scaling for this Skill Group:', renderer = 'checkbox', default = Mui.presets.default.toggle_armor },\n\t\t{ key = 'heavyarmor',   name = 'Heavy Armor',                          renderer = 'checkbox', default = Mui.presets.default.heavyarmor },\n\t\t{ key = 'mediumarmor',  name = 'Medium Armor',                         renderer = 'checkbox', default = Mui.presets.default.mediumarmor },\n\t\t{ key = 'lightarmor',   name = 'Light Armor',                          renderer = 'checkbox', default = Mui.presets.default.lightarmor },\n\t\t{ key = 'block',        name = 'Block',                                renderer = 'checkbox', default = Mui.presets.default.block },\n\t},\n}\n\naddSettingsGroup('unarmored')\nsettings.registerGroup {\n\tkey              = 'Settings_SUS_unarmored',\n\tname             = 'Unarmored',\n\tdescription      = 'Unarmored XP uses hit count instead of incoming damage, frontloading most of your progress into the first few hits of every encounter.\\n' ..\n\t\t\t' It was made this way for technical reasons, but the result is a good and viable defensive option for characters that can\\'t take enough hits to justify an Armor skill, but would still like to enjoy a modicum of protection from weaker enemies.',\n\tpage             = 'susconfig',\n\torder            = 5,\n\tl10n             = 'Skill_Uses_Scaled',\n\tpermanentStorage = false,\n\tsettings         = {\n\t\t{\n\t\t\tkey         = 'Unarmored_Start',\n\t\t\tname        = 'Starting Multiplier',\n\t\t\tdescription = 'The first hit you take is equivalent to [This] many vanilla skill uses.\\n' ..\n\t\t\t\t\t' This multiplier is drastically reduced on each consecutive hit.',\n\t\t\trenderer    = 'select',\n\t\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(.5, 5, .25), num_range(6, 15, 1)) },\n\t\t\tdefault     = Mui.presets.default.Unarmored_Start,\n\t\t}, {\n\t\tkey         = 'Unarmored_Decay_Time',\n\t\tname        = 'Penalty Timer',\n\t\tdescription = 'The Starting Multiplier is restored in [This] many seconds.\\n' ..\n\t\t\t\t' The higher this is, the harder it is to keep XP rates high in long battles',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(1, 25, 1), num_range(30, 100, 5), num_range(120, 600, 20)) },\n\t\tdefault     = Mui.presets.default.Unarmored_Decay_Time,\n\t}, {\n\t\tkey         = 'Unarmored_Min',\n\t\tname        = 'Minimum Multiplier',\n\t\tdescription = 'The more you get hit, the closer the XP multiplier gets to [This] many vanilla skill uses.',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(-1, 1, .1), num_range(1.25, 5, .25)) },\n\t\tdefault     = Mui.presets.default.Unarmored_Min,\n\t}, {\n\t\tkey         = 'Unarmored_Armor_Mult',\n\t\tname        = 'Armor Weight Penalty Multiplier',\n\t\tdescription = 'Weight of equipped armor will slow down unarmored XP gain. Weight is multiplied by [This] before being added to the XP formula.\\n' ..\n\t\t\t\t' This mechanic further encourages using Unarmored either by itself or along light armor.',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(-1, 1, .1), num_range(1.25, 5, .25)) },\n\t\tdefault     = Mui.presets.default.Unarmored_Armor_Mult,\n\t\t--  },{\n\t\t--    key         = 'Unarmored_Beast_Races',\n\t\t--    name        = 'Armored Beast Bonus',\n\t\t--    description = 'When playing an Argonian or Khajiit, XP from hits to Head and Feet (if they are unarmored) will be multiplied by [This].\\n'..\n\t\t--\t\t\t\t' This bonus is meant to mitigate the Armor Rating penalty for beast characters that run full armor sets, and has no effect on beast characters that don\\'t use armor.',\n\t\t--    renderer    = 'select',\n\t\t--    argument    = {l10n  = 'Skill_Uses_Scaled', items = array_concat(num_range(-1,1,.1), num_range(1.25,5,.25))},\n\t\t--    default     = 6,\n\t},\n\t\t{ key = 'unarmored', name = 'Enable scaling for Unarmored XP:', renderer = 'checkbox', default = Mui.presets.default.unarmored },\n\t},\n}\n\naddSettingsGroup('acrobatics')\nsettings.registerGroup {\n\tkey              = 'Settings_SUS_acrobatics',\n\tname             = 'Acrobatics',\n\tdescription      = 'Gain more XP for making larger, slower jumps, and progress faster while carrying little weight.\\n' ..\n\t\t\t' Jumping up slopes will still result in significant (albeit reduced) skill progress, while fall damage and calculated jumps will no longer lag massively behind.',\n\tpage             = 'susconfig',\n\torder            = 6,\n\tl10n             = 'Skill_Uses_Scaled',\n\tpermanentStorage = false,\n\tsettings         = {\n\t\t{\n\t\t\tkey         = 'Acrobatics_Start',\n\t\t\tname        = 'Starting Multiplier',\n\t\t\tdescription = 'The first jump you make is equivalent to [This] many vanilla skill uses.\\n' ..\n\t\t\t\t\t' This multiplier is reduced on each consecutive jump.',\n\t\t\trenderer    = 'select',\n\t\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(.25, 5, .25), num_range(6, 15, 1)) },\n\t\t\tdefault     = Mui.presets.default.Acrobatics_Start,\n\t\t}, {\n\t\tkey         = 'Acrobatics_Decay_Time',\n\t\tname        = 'Penalty Timer',\n\t\tdescription = 'The Starting Multiplier is restored in [This] many seconds. Increasing this number makes spam jumping even less valuable.',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(1, 25, 1), num_range(30, 100, 5), num_range(120, 600, 20)) },\n\t\tdefault     = Mui.presets.default.Acrobatics_Decay_Time,\n\t}, {\n\t\tkey         = 'Acrobatics_Encumbrance_Min',\n\t\tname        = 'Low Encumbrance Bonus',\n\t\tdescription = 'At 0% carry weight, your skill progress will be multiplied by [this].',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(.25, 5, .25), num_range(6, 15, 1)) },\n\t\tdefault     = Mui.presets.default.Acrobatics_Encumbrance_Min,\n\t}, {\n\t\tkey         = 'Acrobatics_Encumbrance_Max',\n\t\tname        = 'High Encumbrance Penalty',\n\t\tdescription = 'At 100% carry weight, your skill progress will be multiplied by [this].',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(.25, 5, .25), num_range(6, 15, 1)) },\n\t\tdefault     = Mui.presets.default.Acrobatics_Encumbrance_Max,\n\t},\n\t\t{ key = 'acrobatics', name = 'Enable scaling for Acrobatics XP:', renderer = 'checkbox', default = Mui.presets.default.acrobatics },\n\t},\n}\n\naddSettingsGroup('athletics')\nsettings.registerGroup {\n\tkey              = 'Settings_SUS_athletics',\n\tname             = 'Athletics',\n\tdescription      = 'Gain more XP for running long periods of time, and progress faster while carrying heavy weights.\\n' ..\n\t\t\t' Additionally, bad vanilla behaviour was fixed and you no longer gain athletics XP while jumping or falling (but you do gain XP while levitating).\\n' ..\n\t\t\t' Bunnyhopping long distances is still a good training method, just not for raising Athletics.\\n' ..\n\t\t\t' TLDR: If your legs are moving you\\'re training athletics, otherwise you aren\\'t.',\n\tpage             = 'susconfig',\n\torder            = 7,\n\tl10n             = 'Skill_Uses_Scaled',\n\tpermanentStorage = false,\n\tsettings         = {\n\t\t{\n\t\t\tkey         = 'Athletics_Start',\n\t\t\tname        = 'Starting Multiplier',\n\t\t\tdescription = 'Athletics XP is multiplied by a [Marathon Bonus]. This is the lowest it can get. \\n' ..\n\t\t\t\t\t' Note that by default this is 0.5, meaning it cuts your XP in half when moving short distances and making long stops.',\n\t\t\trenderer    = 'select',\n\t\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(.25, 5, .25), num_range(6, 15, 1)) },\n\t\t\tdefault     = Mui.presets.default.Athletics_Start,\n\t\t}, {\n\t\tkey         = 'Athletics_Decay_Time',\n\t\tname        = 'Marathon Timer',\n\t\tdescription = 'It takes [This] many seconds of continuous running or swimming to reach the Maximum Multiplier.\\n' ..\n\t\t\t\t' It\\'s increase and decrease are gradual, so you can stop for a few seconds and you won\\'t lose your entire progress.',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(30, 100, 5), num_range(120, 600, 20), num_range(660, 1200, 60)) },\n\t\tdefault     = Mui.presets.default.Athletics_Decay_Time,\n\t}, {\n\t\tkey         = 'Athletics_Marathon',\n\t\tname        = 'Maximum Multiplier',\n\t\tdescription = 'Athletics XP is multiplied by a [Marathon Bonus]. This is the highest it can get.',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(.25, 5, .25), num_range(6, 15, 1)) },\n\t\tdefault     = Mui.presets.default.Athletics_Marathon,\n\t}, {\n\t\tkey         = 'Athletics_No_Move_Penalty',\n\t\tname        = 'No Movement Penalty',\n\t\tdescription = 'While not significantly moving (i.e, running or swimming into a wall), XP will be multiplied by [This].\\n' ..\n\t\t\t\t' By default, it\\'s low enough to make maxing the skill this way take very long, but still allows \\'training\\' AFK.',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(-1, -0.1, 0.1), num_range(-0.09, 0.09, 0.01), num_range(0.1, 1, 0.1)) },\n\t\tdefault     = Mui.presets.default.Athletics_No_Move_Penalty,\n\t}, {\n\t\tkey         = 'Athletics_Encumbrance_Max',\n\t\tname        = 'High Encumbrance Bonus',\n\t\tdescription = 'At 100% carry weight, your skill progress will be multiplied by [this].',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(.25, 5, .25), num_range(6, 15, 1)) },\n\t\tdefault     = Mui.presets.default.Athletics_Encumbrance_Max,\n\t}, {\n\t\tkey         = 'Athletics_Encumbrance_Min',\n\t\tname        = 'Low Encumbrance Penalty',\n\t\tdescription = 'At 0% carry weight, your skill progress will be multiplied by [this].',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(.25, 5, .25), num_range(6, 15, 1)) },\n\t\tdefault     = Mui.presets.default.Athletics_Encumbrance_Min,\n\t},\n\t\t{ key = 'athletics', name = 'Enable scaling for Athletics XP:', renderer = 'checkbox', default = Mui.presets.default.athletics },\n\t},\n}\n\naddSettingsGroup('security')\nsettings.registerGroup {\n\tkey              = 'Settings_SUS_security',\n\tname             = 'Security',\n\tdescription      = 'Successful lockpicking will grant XP based on the difficulty of the lock opened.\\n' ..\n\t\t\t' Successful probing will grant XP based on the difficulty of the trap disarmed.',\n\tpage             = 'susconfig',\n\torder            = 8,\n\tl10n             = 'Skill_Uses_Scaled',\n\tpermanentStorage = false,\n\tsettings         = {\n\t\t{\n\t\t\tkey         = 'Security_Lock_Points_To_XP',\n\t\t\tname        = 'Lock Difficulty to XP',\n\t\t\tdescription = 'How many lock points are equivalent to one vanilla skill use.\\n' ..\n\t\t\t\t\t' Not affected by tool quality.',\n\t\t\trenderer    = 'select',\n\t\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(1, 25, 1), num_range(30, 100, 5)) },\n\t\t\tdefault     = Mui.presets.default.Security_Lock_Points_To_XP,\n\t\t}, {\n\t\tkey         = 'Security_Trap_Points_To_XP',\n\t\tname        = 'Trap Difficulty to XP',\n\t\tdescription = 'How many trap points are equivalent to one vanilla skill use.\\n' ..\n\t\t\t\t' Not affected by tool quality.\\n' ..\n\t\t\t\t' Note that trap difficulty is independent from lock difficulty, and directly based on the trap spell\\'s magic cost. Hard traps are generally dangerous, and easy ones mostly harmless.',\n\t\trenderer    = 'select',\n\t\targument    = { l10n = 'Skill_Uses_Scaled', items = array_concat(num_range(1, 25, 1), num_range(30, 100, 5)) },\n\t\tdefault     = Mui.presets.default.Security_Trap_Points_To_XP,\n\t},\n\t\t{ key = 'security', name = 'Enable scaling for Security XP:', renderer = 'checkbox', default = Mui.presets.default.security },\n\t},\n}\n\n--addSettingsGroup('presets')\n--settings.registerGroup {\n--  key              = 'Settings_SUS_presets',\n--  name             = 'Settings Presets',\n--  description      = 'Pick from available config presets, or save your current settings as a new preset for later use.',\n--  page             = 'susconfig',\n--  order            = 0,\n--  l10n             = 'Skill_Uses_Scaled',\n--  permanentStorage = true,\n--  settings         = {\n--\t--{\n--  --  key         = 'Security_Trap_Points_To_XP',\n--  --  name        = 'Trap Difficulty to XP',\n--  --  description = 'How many trap points are equivalent to one vanilla skill use.\\n'..\n--\t\t\t\t\t\t\t\t' Not affected by tool quality.\\n'..\n--\t\t\t\t\t\t\t\t' Note that trap difficulty is independent from lock difficulty, and directly based on the trap spell\\'s magic cost. Hard traps are generally dangerous, and easy ones mostly harmless.',\n--  --  renderer    = 'select',\n--  --  argument    = {l10n  = 'Skill_Uses_Scaled', items = array_concat(num_range(1,25,1), num_range(30, 100, 5))},\n--  --  default     = Mui.presets.default.Security_Trap_Points_To_XP,\n--  --},{\n--  --  key         = 'Security_Trap_Points_To_XP',\n--  --  name        = 'Trap Difficulty to XP',\n--  --  description = 'How many trap points are equivalent to one vanilla skill use.\\n'..\n--\t\t\t\t\t\t\t\t' Not affected by tool quality.\\n'..\n--\t\t\t\t\t\t\t\t' Note that trap difficulty is independent from lock difficulty, and directly based on the trap spell\\'s magic cost. Hard traps are generally dangerous, and easy ones mostly harmless.',\n--  --  renderer    = 'select',\n--  --  argument    = {l10n  = 'Skill_Uses_Scaled', items = array_concat(num_range(1,25,1), num_range(30, 100, 5))},\n--  --  default     = Mui.presets.default.Security_Trap_Points_To_XP,\n--  --},\n--  },\n--}\n\naddSettingsGroup('DEBUG')\nsettings.registerGroup {\n\tkey              = 'Settings_SUS_DEBUG',\n\tname             = 'Info & Debug',\n\tdescription      = '',\n\tpage             = 'susconfig',\n\torder            = 9,\n\tl10n             = 'Skill_Uses_Scaled',\n\tpermanentStorage = false,\n\tsettings         = {\n\t\t{\n\t\t\tkey         = 'SUS_DEBUG',\n\t\t\tname        = 'Enable Debug Messages',\n\t\t\tdescription = 'Print information on every skill use about XP gained (and about this mod\\'s multipliers) to the in-game F10 console.\\n' ..\n\t\t\t\t\t' Useful for anyone wishing to hone in their configuration, or to get a general idea of this mod\\'s (and vanilla morrowind\\'s) XP mechanics.',\n\t\t\trenderer    = 'checkbox',\n\t\t\tdefault     = Mui.presets.default.SUS_DEBUG,\n\t\t}, {\n\t\tkey         = 'SUS_VERBOSE',\n\t\tname        = 'Use Verbose Messaging',\n\t\tdescription = 'Show fancy messageboxes directly to your screen instead of to the F10 console.\\n' ..\n\t\t\t\t' Enabled by Default.\\n' ..\n\t\t\t\t' Whether this is more or less intrusive than the F10 window is a matter of opinion.. disable it if you prefer the console.',\n\t\trenderer    = 'checkbox',\n\t\tdefault     = Mui.presets.default.SUS_VERBOSE,\n\t},\n\t},\n}\n\nMui.custom_groups = {\n\ttoggle_refund  = true,\n\ttoggle_h2h_str = true,\n}\nMui.custom = function(group, key)\n\tif key == 'toggle_refund' then\n\t\tlocal args   = Mui.Settings_SUS_magic.args\n\t\tlocal offset = 'MP_Refund_Skill_Offset'\n\t\tlocal mult   = 'MP_Refund_Armor_mult'\n\t\tlocal max    = 'MP_Refund_Max_Percent'\n\t\tif Mui[group].section:get(key) then\n\t\t\tsettings.updateRendererArgument(group, offset, edit_args(args[offset], { disabled = false }))\n\t\t\tsettings.updateRendererArgument(group, mult, edit_args(args[mult], { disabled = false }))\n\t\t\tsettings.updateRendererArgument(group, max, edit_args(args[max], { disabled = false }))\n\t\telse\n\t\t\tsettings.updateRendererArgument(group, offset, edit_args(args[offset], { disabled = true }))\n\t\t\tsettings.updateRendererArgument(group, mult, edit_args(args[mult], { disabled = true }))\n\t\t\tsettings.updateRendererArgument(group, max, edit_args(args[max], { disabled = true }))\n\t\tend\n\telseif key == 'toggle_h2h_str' then\n\t\tlocal args  = Mui.Settings_SUS_physical.args\n\t\tlocal ratio = 'HandToHand_Strength'\n\t\tif Mui[group].section:get(key) then\n\t\t\tsettings.updateRendererArgument(group, ratio, edit_args(args[ratio], { disabled = false }))\n\t\telse\n\t\t\tsettings.updateRendererArgument(group, ratio, edit_args(args[ratio], { disabled = true }))\n\t\tend\n\tend\nend\n\nMui.update = async:callback(function(group, key)\n\tif key == nil then print(group .. ': nil key') end\n\tif (not group) or (not key) then\n\t\treturn\n\telseif Mui.toggles[key] then\n\t\tlocal toggled = Mui[group].section:get(key)\n\t\tfor _, setting in ipairs(Mui.toggles[key]) do\n\t\t\tsettings.updateRendererArgument(group, setting, { disabled = not toggled })\n\t\t\tif (not toggled) and Mui.getSetting(\"SUS_DEBUG\") then\n\t\t\t\tprint(setting ..\n\t\t\t\t\t': ' .. tostring(Mui[group].section:get(setting)))\n\t\t\tend\n\t\tend\n\t\tif Mui.getSetting(\"SUS_DEBUG\") then print(key .. ': ' .. tostring(Mui[group].section:get(key))) end\n\telseif Mui.custom_groups[key] then\n\t\tMui.custom(group, key)\n\telse\n\t\tif type(Mui[group].section:get(key)) == 'number' then\n\t\t\tif Mui.getSetting(\"SUS_DEBUG\") then print(key .. ': ' .. string.format('%.1f', Mui[group].section:get(key))) end\n\t\telse\n\t\t\tif Mui.getSetting(\"SUS_DEBUG\") then print(key .. ': ' .. tostring(Mui[group].section:get(key))) end\n\t\tend\n\tend\n\t--Mui.savePreset('current')\nend)\n\nMui.GROUPS_MAP = {}\nfor _, groupid in ipairs(Mui.settingsGroups) do\n\tMui[groupid].section = storage.playerSection(groupid)\n\tMui[groupid].section:subscribe(Mui.update)\n\tfor key in pairs(Mui[groupid].section:asTable()) do\n\t\tMui.GROUPS_MAP[key] = Mui[groupid].section\n\tend\nend\n\nMui.getSetting = function(settingid)\n\treturn Mui.GROUPS_MAP[settingid]:get(settingid)\nend\nMui.savePreset = function(name)\n\tlocal preset = {}\n\tfor _, groupid in ipairs(Mui.settingsGroups) do\n\t\tfor k, v in pairs(Mui[groupid].section:asTable()) do\n\t\t\tpreset[k] = v\n\t\t\tif Mui.getSetting(\"SUS_DEBUG\") then print('Saving... ' .. k .. ': ' .. tostring(v)) end\n\t\tend\n\tend\n\tstorage.playerSection(\"SUS_Presets\"):set(name, preset)\n\tstorage.playerSection(\"SUS_Presets\"):setLifeTime(storage.LIFE_TIME.Persistent)\nend\nMui.loadPreset = function(name)\n\tlocal target_as_table = storage.playerSection(\"SUS_Presets\"):asTable()[name]\n\tif target_as_table == nil then\n\t\tif Mui.getSetting(\"SUS_DEBUG\") then\n\t\t\tprint(\"[Loading defaults]\")\n\t\tend\n\t\ttarget_as_table = Mui.presets.default\n\tend\n\tfor _, groupid in ipairs(Mui.settingsGroups) do\n\t\tfor k, v in pairs(Mui[groupid].section:asTable()) do\n\t\t\tif target_as_table[k] ~= nil then\n\t\t\t\tMui[groupid].section:set(k, target_as_table[k])\n\t\t\t\tif Mui.getSetting(\"SUS_DEBUG\") then\n\t\t\t\t\tprint('SUS - Loading preset [' ..\n\t\t\t\t\t\tname .. '] | ' .. k .. ' -> ' .. tostring(target_as_table[k]))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\n--  Saving:\n--  Default \"standard\" preset = initCfg\n--  onLoad, Cfg = Mui.Storage[Settings_SUS_Current].section:getAll\n--  onLoad, loadMissingSettings(Cfg, initCfg)\n--  onSave, Settings_SUS_Current].section = Cfg\n-- Custom presets\n--  on preset save:\nreturn Mui\n"
  }
}