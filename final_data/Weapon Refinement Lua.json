{
  "folder_name": "Weapon Refinement Lua",
  "lua_files": {
    "main-54712-1-1-1716338399\\weapon-refinement-lua\\scripts\\weapon-refinement-lua\\weapon-refinement-lua-c.lua": "local self = require('openmw.self')\nlocal core = require(\"openmw.core\")\n\nlocal function EnableActivator(data)\n    core.sendGlobalEvent(\"GiveAnvilActivationInterface\",{\n        object = self.object\n    })\nend\n\n\nreturn {\n    engineHandlers = {\n        onActive = EnableActivator\n    }\n}",
    "main-54712-1-1-1716338399\\weapon-refinement-lua\\scripts\\weapon-refinement-lua\\weapon-refinement-lua-g.lua": "local core = require(\"openmw.core\")\nlocal types = require(\"openmw.types\")\nlocal world = require(\"openmw.world\")\nlocal acti = require(\"openmw.interfaces\").Activation\nlocal storage = require(\"openmw.storage\")\nlocal interface = require('openmw.interfaces')\nlocal util = require('openmw.util')\nlocal async = require('openmw.async')\nlocal vfs = require('openmw.vfs')\nlocal v3 = require('openmw.util').vector3\n\n--For some reason, weapon values are stored in unsigned chars internally in the engine. That means that the max damage a weapon can ever have for one of its ranges is 255.\n--We use a asymptotic increase here to allow you to gradually approach the cap, but never actually exceed it.\n--If OpenMW ever fully implements ESM4 weapons, there will be no need for the asymptotic increase - and you can just have weapon scaling scale effectively infinitely.\n--For now though, this is needed to prevent players weapon damage from rolling over into 0.\nfunction asymptoticIncrease(currentValue)\n    local maxLimit = 256\n    local growthRate = 0.1  -- Controls the approach speed to the limit\n    local maxPercentIncrease = 0.1  -- Maximum increase as a percentage of the current value. Keep this relatively low to discourage weapons from outpacing daedric too quickly. \n    local minIncrement = 1  -- Minimum increment value\n\n    if currentValue >= maxLimit then\n        return maxLimit - 1  -- Ensures it never reaches 255\n    else\n        local increment = growthRate * (maxLimit - currentValue)  -- Calculate potential increment using growth rate\n        local maxIncrement = currentValue * maxPercentIncrease  -- Calculate 10% of the current value as the cap\n        increment = math.min(increment, maxIncrement)  -- Use the smaller of the two increments\n        increment = math.max(increment, minIncrement)  -- Ensure the increment is at least the minimum increment\n        local newValue = currentValue + increment\n        if newValue >= maxLimit then\n            return maxLimit - 1\n        else\n            return newValue\n        end\n    end\nend\n\nlocal function round(num)\n    return num >= 0 and math.floor(num + 0.5) or math.ceil(num - 0.5)\nend\n\n--Some values are stored as a int32_t\n--Int32's have a maximum value that it can ever reach before rolling into the negatives.\n--We use this here to prevent it from ever rolling over into the negatives.\nfunction clampInt32(value)\n    local INT32_MAX = 2147483647\n    local INT32_MIN = -2147483648\n    return math.min(math.max(value, INT32_MIN), INT32_MAX)\nend\n\n--Disables all bound items. Lets not refine those\nlocal itemDenyListBound = {\n    [\"bound_battle_axe\"] = true,\n    [\"bound_dagger\"] = true,\n    [\"bound_longbow\"] = true,\n    [\"bound_longsword\"] = true,\n    [\"bound_mace\"] = true,\n    [\"bound_spear\"] = true\n}\n\n-- In Morrowind, there is a bug - that is preserved in OpenMW - where if you create a modified version of an item, that item won't work for quests anymore. This is because when you create a\n-- new record, such as by enchanting or refining here, that record won't be counted as the original item for the purposes of those quests.\n-- As such, a certain subset of items are warned against refining. Do note that this doesn't cover TR, or other modded content.\nlocal itemDenyListQuest = {\n    -- Every item on UESP flagged as 'quest item'\n    [\"lugrub's axe\"] = true,\n    [\"dwarven war axe_redas\"] = true,\n    [\"ebony staff caper\"] = true,\n    [\"ebony wizard's staff\"] = true,\n    [\"rusty_dagger_unique\"] = true,\n    [\"devil_tanto_tgamg\"] = true,\n    [\"daedric wakizashi_hhst\"] = true,\n    [\"glass_dagger_enamor\"] = true,\n    [\"dart_uniq_judgement\"] = true,\n    [\"dwemer_boots of flying\"] = true,\n    [\"bonemold_gah-julan_hhda\"] = true,\n    [\"bonemold_founders_helm\"] = true,\n    [\"bonemold_tshield_hrlb\"] = true,\n    [\"amulet of ashamanu (unique)\"] = true,\n    [\"amuletfleshmadewhole_uniq\"] = true,\n    [\"amulet_agustas_unique\"] = true,\n    [\"expensive_amulet_delyna\"] = true,\n    [\"expensive_amulet_aeta\"] = true,\n    [\"sarandas_amulet\"] = true,\n    [\"exquisite_amulet_hlervu1\"] = true,\n    [\"julielle_aumines_amulet\"] = true,\n    [\"linus_iulus_maran amulet\"] = true,\n    [\"amulet_skink_unique\"] = true,\n    [\"linus_iulus_stendarran_belt\"] = true,\n    [\"sarandas_belt\"] = true,\n    [\"common_glove_l/r_balmolagmer\"] = true,\n    [\"extravagant_rt_art_wild\"] = true,\n    [\"expensive_glove_left_ilmeni\"] = true,\n    [\"extravagant_glove_left/right_maur\"] = true,\n    [\"common_pants_02_hentus\"] = true,\n    [\"sarandas_pants_2\"] = true,\n    [\"adusamsi's_ring\"] = true,\n    [\"extravagant_ring_aund_uni\"] = true,\n    [\"ring_blackjinx_uniq\"] = true,\n    [\"exquisite_ring_brallion\"] = true,\n    [\"common_ring_danar\"] = true,\n    [\"sarandas_ring_2\"] = true,\n    [\"ring_keley\"] = true,\n    [\"expensive_ring_01_bill\"] = true,\n    [\"expensive_ring_aeta\"] = true,\n    [\"sarandas_ring_1\"] = true,\n    [\"expensive_ring_01_hrdt\"] = true,\n    [\"exquisite_ring_processus\"] = true,\n    [\"ring_dahrkmezalf_uniq\"] = true,\n    [\"extravagant_robe_01_red\"] = true,\n    [\"robe of st roris\"] = true,\n    [\"exquisite_robe_drake's pride\"] = true,\n    [\"sarandas_shirt_2\"] = true,\n    [\"exquisite_shirt_01_rasha\"] = true,\n    [\"sarandas_shoes_2\"] = true,\n    [\"therana's skirt\"] = true,\n    -- MQ Items. There is dialogue tied to if you have these in specific. Pretty sure the main quest scripts still work with this, but it's probably safer to just include it here.\n    [\"keening\"] = true,\n    [\"sunder\"] = true,\n    [\"wraithguard\"] = true\n}\n\n-- By manipulating these items, you don't break quests, instead you just prevent the item from being sold to the Museum in Mournhold for lots of gold.\nlocal itemDenyListMuseum = {\n    [\"ebony_bow_auriel\"] = true,\n    [\"ebony_shield_auriel\"] = true,\n    [\"bipolar blade\"] = true,\n    [\"bloodworm_helm_unique\"] = true,\n    [\"boots of blinding speed[unique]\"] = true,\n    [\"boots_apostle_unique\"] = true,\n    [\"longbow_shadows_unique\"] = true,\n    [\"claymore_chrysamere_unique\"] = true,\n    [\"cuirass_savior_unique\"] = true,\n    [\"glass dagger_symmachus_unique\"] = true,\n    [\"dragonbone_cuirass_unique\"] = true,\n    [\"ebon_plate_cuirass_unique\"] = true,\n    [\"towershield_eleidon_unique\"] = true,\n    [\"dagger_fang_unique\"] = true,\n    [\"katana_goldbrand_unique\"] = true,\n    [\"helm_bearclaw_unique\"] = true,\n    [\"claymore_iceblade_unique\"] = true,\n    [\"lords_cuirass_unique\"] = true,\n    [\"mace of molag bal_unique\"] = true,\n    [\"mace of slurring\"] = true,\n    [\"ring_phynaster_unique\"] = true,\n    [\"robe_lich_unique\"] = true,\n    [\"warhammer_crusher_unique\"] = true,\n    [\"spear_mercy_unique\"] = true,\n    [\"staff_hasedoki_unique\"] = true,\n    [\"staff_magnus_unique\"] = true,\n    [\"tenpaceboots\"] = true,\n    [\"longsword_umbra_unique\"] = true,\n    [\"ring_vampiric_unique\"] = true,\n    [\"daedric warhammer_ttgd\"] = true,\n    [\"ring_warlock_unique\"] = true\n}\n\n--Starwind is given special support!\n--If you have starwind in your load list, instead 'Anvils' are 'Modification bays', also disables world placement.\nlocal function isStarwind()\n    local contentFiles = core.contentFiles.list\n    for _, file in ipairs(contentFiles) do\n        if string.lower(file):find(\"starwind\") then\n            return true\n        end\n    end\n    return false\nend\n\n--Our main anvil record - we try to remember this with onsave, on load to avoid populating the save with tons of references to similar objects.\nlocal anvilRecordID = nil\n\n--Creates the item ref! The item ref is slightly different if we are playing in Starwind or not.\nlocal function initializeAnvilReference()\n    local anvilDraft = nil\n    if isStarwind() then\n        anvilDraft = types.Miscellaneous.createRecordDraft({\n            name = \"Modification Bay\",\n            weight = 40,\n            icon = \"icons/weapon-refinement-lua/modification_bay.tga\",\n            model = \"Meshes/Ig/Static/ContFootlocker.nif\",\n            value = 40\n        })\n    else\n        anvilDraft = types.Miscellaneous.createRecordDraft({\n            name = \"Anvil\",\n            weight = 40,\n            icon = \"icons/weapon-refinement-lua/anvil.tga\",\n            model = \"meshes/f/furn_anvil00.nif\",\n            value = 40\n        })\n    end\n    anvilRecordID = world.createRecord(anvilDraft).id\nend\n\n--This method spawns a few anvils in the world in places a player might find them early on.\n--They are pretty common on merchants, but figure its probably for the best to add a couple here as a safeguard.\nlocal function createWorldAnvils()\n    if not isStarwind() then\n        local a = anvilRecordID\n        local anv = world.createObject(a, 1)\n        anv:addScript(\"scripts/weapon-refinement-lua/weapon-refinement-lua-c.lua\")\n        anv:teleport(\"Balmora, Guild of Fighters\", util.vector3(-49.7944, 563.563, -347.03))\n\n        anv = world.createObject(a, 1)\n        anv:addScript(\"scripts/weapon-refinement-lua/weapon-refinement-lua-c.lua\")\n        anv:teleport(\"Seyda Neen, Arrille's Tradehouse\", util.vector3(-481.976, 84.7985, 415.97))\n    end\nend\n\nlocal function getGlobalAnvil()\n    local a = nil\n    if anvilRecordID == nil then\n        initializeAnvilReference()\n        createWorldAnvils()\n    end\n\n    a = anvilRecordID\n    return a\nend\n\n--Used the framework provided by \"HD Forge for OpenMW-Lua\" for this code section.\n--https://modding-openmw.gitlab.io/hd-forge-for-openmw-lua/\nlocal srcId = \"furn_anvil00\"\nlocal minAngle = 25\nlocal maxAngle = 360 - 25 -- 335\n\nlocal function replace(obj)\n    local angle = math.deg(math.abs(obj.position.y))\n\treturn obj.type == types.Static\n        and obj.recordId == srcId\n        and not ((angle > minAngle) and (angle < maxAngle))\nend\n\nlocal function onObjectActive(obj)\n    if replace(obj) then\n        local a = getGlobalAnvil()\n        local anv = world.createObject(a, 1)\n        anv.enabled = obj.enabled\n        anv:setScale(obj.scale)\n        anv:teleport(obj.cell, obj.position + obj.rotation * v3(0, 0, 0), obj.rotation)\n        anv:addScript(\"scripts/weapon-refinement-lua/weapon-refinement-lua-c.lua\")\n        obj:remove()\n    end\nend\n--\n\nlocal function OnSave()\n    local data = {}\n    if anvilRecordID ~= nil then\n        data.anvilID = anvilRecordID\n    end\n    return data\nend\n\nlocal function OnLoad(data)\n    if data ~= nill then\n        if data.anvilID ~= nil then\n            anvilRecordID = data.anvilID\n        end\n    else\n        local timer = async:newUnsavableSimulationTimer(\n            5,\n            function()\n                local a = getGlobalAnvil()\n            end\n        )\n    end\nend\n\nlocal function OnInitialize()\n    local timer = async:newUnsavableSimulationTimer(\n        5,\n        function()\n            local a = getGlobalAnvil()\n        end\n    )\nend\n\n-- This function calculates the chance to successfully refine a weapon, considering weapon stats and player skills.\nlocal function calculateRefinementSuccess(data, weapon)\n    -- Determine the maximum damage output of the weapon to establish a starting difficulty level.\n    local weaponMaxDamage = math.max(types.Weapon.record(weapon).chopMaxDamage, \n                                     types.Weapon.record(weapon).thrustMaxDamage, \n                                     types.Weapon.record(weapon).slashMaxDamage)\n\n    local weaponSpeed = types.Weapon.record(weapon).speed\n    local enchantCapacity = types.Weapon.record(weapon).enchantCapacity\n\n    -- Base difficulty challenge (DC) calculation, adjusting for weapon damage with logarithmic scaling.\n    local baseDC = (weaponMaxDamage / 1.5) + math.log(weaponMaxDamage)\n    local exponentialFactor = 0\n\n    -- Increase the difficulty challenge significantly if the weapon's max damage is above 240.\n    if weaponMaxDamage > 240 then\n        exponentialFactor = (weaponMaxDamage - 240)^2 * 3.42\n    end\n\n    -- Calculate the total difficulty challenge, ensuring a minimum DC of 10.\n    local totalDC = math.max(10, baseDC) + exponentialFactor\n\n    -- Modify the influence of weapon speed on the refinement process.\n    -- Slower speed on a weapon - aka a larger two handed weapon - improves our chances of success.\n    -- Without this, fast weapons would objectively be the best weapons to use.\n    local speedModifier = math.max(1, 3 - weaponSpeed)\n\n    -- Enchant capacity influence adjustment with diminishing returns beyond 22\n    -- Diminishing returns are used to prevent people from approaching the damage cap with just 100 armorer and something with a high enchantmentCapacity, like a Ebony Staff.\n    local enchantModifier\n    if enchantCapacity <= 22 then\n        enchantModifier = 0.5 + ((enchantCapacity - 1) / 21)  -- Scales from 0.5 to 1.5\n    else\n        -- Apply a logarithmic scale to reduce the rate of increase beyond 22. Most base MW weapons have around 1-22 capacity, while a few outliers have like 90 or so.\n        enchantModifier = 1.5 + math.log(enchantCapacity - 21) / math.log(30)\n    end\n\n    -- Compute the total skill modifier based on player's skills and attributes, modifying the chance of success.\n    local fatigueInfluence = data.fatigue / data.fatigueMax  -- Influence of player fatigue on success chance.\n    local skillModifier = (((0.25 * data.armorer) +          -- Armorer skill\n                           (0.02 * data.intelligence) +      -- Intelligence,\n                           (0.02 * data.agility) +           -- Agility,\n                           (0.01 * data.luck)) *             -- Luck,\n                           speedModifier) *                  -- Speed modifier,\n                           enchantModifier                   -- Enchant Modifier\n\n    -- Randomly determine the refinement roll, influenced by skill modifiers and fatigue.\n    local roll = (\n        math.random(\n            round(math.max(10, (totalDC * 0.10)))\n        ) + skillModifier\n    ) * fatigueInfluence\n\n    -- Determine if the refinement attempt is successful by comparing the roll to the total DC.\n    local isSuccess = roll >= totalDC\n\n    return isSuccess\nend\n\nlocal function incrementWeaponName(weaponName)\n    -- Check if the name ends with a space followed by a plus sign and a number\n    local baseName, upgradeLevel = string.match(weaponName, \"^(.+)%s+%+(%d+)$\")\n    \n    if upgradeLevel then\n        -- If it has an upgrade level, increment and clamp it\n        upgradeLevel = tonumber(upgradeLevel) + 1\n        upgradeLevel = clampInt32(upgradeLevel)\n        return baseName .. \" +\" .. upgradeLevel\n    else\n        -- If no upgrade level, append \"+1\" and ensure it stays within 32-bit int bounds\n        return weaponName .. \" +1\"\n    end\nend\n\n-- Function to replace the equipped weapon with an improved version\nlocal function MainWeaponRefinement(data)\n    local player = data.player\n    if not player then\n        return { success = false, message = 'Could not find player' }\n    end\n\n    -- Get the currently equipped weapon in the right hand\n    local weapon = types.Actor.getEquipment(player, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n    if not weapon then\n        return { success = false, message = 'No weapon equipped' }\n    end\n\n    local tempRecordId = weapon.recordId:lower()\n    if itemDenyListBound[tempRecordId] then\n        local thisIsBadResult = { success = false, message = \"The bound weapon lashes out as you attempt to manipulate it!\" }\n        player:sendEvent(\"boundWeaponHurtPlayer\", 10)\n        player:sendEvent(\"refinePlaySound\", {sound = \"Spell Failure Conjuration\" } )\n        player:sendEvent(\"displayResultMessage\", thisIsBadResult)\n        return\n    end\n\n    -- Check if the refinement process is successful\n    local success, _ = calculateRefinementSuccess(data, weapon)\n    if success then\n        -- Check if the weapon is on the quest deny list\n        if itemDenyListQuest[tempRecordId] then\n            local badSaveResult = { success = false, message = \"With this item's manipulation, the thread of prophecy is severed. Restore a saved game to restore the weave of fate, or persist in the doomed world you have created.\" }\n            player:sendEvent(\"displayResultMessage\", badSaveResult)\n        -- Check if the weapon is on the museum deny list\n        elseif itemDenyListMuseum[tempRecordId] then\n            local badSaveResult = { success = false, message = \"Tampering with this relic diminishes its ancient worth. To preserve its allure for collectors, restore a saved game or bear the diminished riches of your actions.\" }\n            player:sendEvent(\"displayResultMessage\", badSaveResult)\n        end\n\n        -- Calculate the value modifier for a weapon based on various skill attributes and a speed modifier.\n        local baseValue = types.Weapon.record(weapon).value\n        local armorerSkill = data.armorer\n        -- Determine the weapon's maximum damage across all attack types\n        local weaponMaxDamage = math.max(\n            types.Weapon.record(weapon).chopMaxDamage, \n            types.Weapon.record(weapon).thrustMaxDamage, \n            types.Weapon.record(weapon).slashMaxDamage\n        )\n\n        -- Cap the scaling factor to the lesser of the weapons max damage * 0.001, or 0.10.\n        -- This prevents you from being able to make Pickaxes thousands of gold in a single refine if your armorer skill is high enough.\n        local damageBasedScalingFactor = weaponMaxDamage * 0.001\n        local scalingFactor = math.min(damageBasedScalingFactor, 0.10)\n\n        -- Calculate diminishing impact of armorer skill as weapon value increases\n        -- This is mostly targeted at alchemy enjoyers with millions of armorer\n        local armorerImpact = math.max(armorerSkill / 100, 0) * math.log10(1000 / (baseValue / 1000 + 10))\n\n        -- Calculate the value modifier\n        local valueModifier = baseValue * scalingFactor * armorerImpact\n\n        -- Ensure the value modifier is at least 1 if the weapon's base value is under 1000\n        if baseValue < 1000 then\n            valueModifier = math.max(valueModifier, 1)\n        else\n            -- Ensure that the value modifier is not negative\n            valueModifier = math.max(valueModifier, 0)\n        end\n\n        -- Create a new weapon draft with improved stats\n        local newWeaponDraft = types.Weapon.createRecordDraft({\n            name = incrementWeaponName(types.Weapon.record(weapon).name),\n            chopMinDamage = asymptoticIncrease(types.Weapon.record(weapon).chopMinDamage),\n            chopMaxDamage = asymptoticIncrease(types.Weapon.record(weapon).chopMaxDamage),\n            thrustMinDamage = asymptoticIncrease(types.Weapon.record(weapon).thrustMinDamage),\n            thrustMaxDamage = asymptoticIncrease(types.Weapon.record(weapon).thrustMaxDamage),\n            slashMinDamage = asymptoticIncrease(types.Weapon.record(weapon).slashMinDamage),\n            slashMaxDamage = asymptoticIncrease(types.Weapon.record(weapon).slashMaxDamage),\n            value = clampInt32(types.Weapon.record(weapon).value + valueModifier),\n            template = types.Weapon.record(weapon)\n        })\n\n        -- Create the improved weapon record\n        local improvedWeaponRecord = world.createRecord(newWeaponDraft)\n        if not improvedWeaponRecord then\n            return { success = false, message = 'Error in the creation of the improved weapon record' }\n        end\n\n        -- Create the improved weapon object from the record\n        local improvedWeapon = world.createObject(improvedWeaponRecord.id, 1)\n        if not improvedWeapon then\n            return { success = false, message = 'Error in the creation of the improved weapon object' }\n        end\n\n        -- Move the improved weapon into the player's inventory and remove the old weapon\n        improvedWeapon:moveInto(types.Actor.inventory(player))\n        core.sendGlobalEvent('UseItem', {object = improvedWeapon, actor = player, force = true})\n        weapon:remove(1)\n\n        -- Play sound effect for successful refinement and display success message\n        player:sendEvent(\"refinePlaySound\", {sound = \"repair\" } )\n        local string = { success = true, message = \"You have received an improved version of your equipped weapon\" }\n        player:sendEvent(\"displayResultMessage\", string)\n        player:sendEvent(\"SkillUpFromRefine\", data)\n\n    else\n        -- Play sound effect for failed refinement and display failure message\n        player:sendEvent(\"refinePlaySound\", {sound = \"repair fail\"} )\n        local string = { success = true, message = \"You have failed to improve the item\" }\n        player:sendEvent(\"displayResultMessage\", string)\n    end\nend\n\n--This adds the activator interface for the anvils.\nlocal function giveAnvilActivationInterface(data)\n    interface.Activation.addHandlerForObject(\n        data.object,\n        function(object, actor)\n            local stance = types.Actor.getStance(actor)\n            if stance == 1 then\n                actor:sendEvent(\"attemptRefineWeapon\")\n                return false\n            else\n                return true\n            end\n        end\n    )\nend\n\nlocal function createAnvilForMerchant(data)\n    local a = getGlobalAnvil()\n\n    if types.Actor.inventory(data.arg):countOf(a) ~= 1 then\n        local anv = world.createObject(a, 1)\n        anv:addScript(\"scripts/weapon-refinement-lua/weapon-refinement-lua-c.lua\")\n        anv:moveInto(types.Actor.inventory(data.arg))\n    end\nend\n\nlocal function addItemToQuestDenyList(itemIds)\n    for _, id in pairs(itemIds) do\n        itemDenyListQuest[id:lower()] = true\n    end\nend\n\nlocal function removeItemFromQuestDenyList(itemIds)\n    for _, id in pairs(itemIds) do\n        itemDenyListQuest[id:lower()] = nil\n    end\nend\n\nlocal function addItemToMuseumDenyList(itemIds)\n    for _, id in pairs(itemIds) do\n        itemDenyListMuseum[id:lower()] = true\n    end\nend\n\nlocal function removeItemFromMuseumDenyList(itemIds)\n    for _, id in pairs(itemIds) do\n        itemDenyListMuseum[id:lower()] = nil\n    end\nend\n\nlocal function addItemToBoundDenyList(itemIds)\n    for _, id in pairs(itemIds) do\n        itemDenyListBound[id:lower()] = true\n    end\nend\n\nlocal function removeItemFromBoundDenyList(itemIds)\n    for _, id in pairs(itemIds) do\n        itemDenyListBound[id:lower()] = nil\n    end\nend\n\nreturn {\n    eventHandlers = {\n        GiveAnvilActivationInterface = giveAnvilActivationInterface,\n        mainWeaponRefinement = MainWeaponRefinement,\n        CreateAnvilForMerchant = createAnvilForMerchant\n    },\n    engineHandlers = {\n        onSave = OnSave,\n        onLoad = OnLoad,\n        onInit = OnInitialize,\n        onObjectActive = onObjectActive\n    },\n    interfaceName = \"WeaponRefinementLuaDenyLists\",\n    interface = {\n        AddItemToQuestDenyList = addItemToQuestDenyList,\n        RemoveItemFromQuestDenyList = removeItemFromQuestDenyList,\n        AddItemToMuseumDenyList = addItemToMuseumDenyList,\n        RemoveItemFromMuseumDenyList = removeItemFromMuseumDenyList,\n        AddItemToBoundDenyList = addItemToBoundDenyList,\n        RemoveItemFromBoundDenyList = removeItemFromBoundDenyList\n    }\n}\n",
    "main-54712-1-1-1716338399\\weapon-refinement-lua\\scripts\\weapon-refinement-lua\\weapon-refinement-lua-p.lua": "local ui = require('openmw.ui')\nlocal self = require('openmw.self')\nlocal core = require('openmw.core')\nlocal types = require(\"openmw.types\")\nlocal ambient = require(\"openmw.ambient\")\nlocal interface = require('openmw.interfaces')\nlocal skill = require('openmw.interfaces').SkillProgression\n\n--These classes for npcs automatically are given anvils when you try to barter with them\nlocal allowedClasses = {\n    [\"merchant\"] = true,\n    [\"pawnbroker\"] = true,\n    [\"smuggler\"] = true,\n    [\"trader\"] = true,\n    [\"trader service\"] = true,\n    [\"T_Glb_TraderService\"] = true,\n    [\"T_Glb_Trader\"] = true\n    --T_Glb entries are for TR\n    --originally, wanted to give more npc factions the ability to sell anvils. However, didnt work out due to how openmw's bartering system works. Leaving these commented until I find a workaround.\n    --[\"miner\"] = true,\n    --[\"smith\"] = true,\n    --[\"Master-at-Arms\"] = true,\n    --[\"Drillmaster\"] = true,\n    --[\"Warrior\"] = true,\n    --[\"Barbarian\"] = true\n}\n\nlocal function RefinePlaySound(data)\n    local params = {\n        timeOffset=0.1,\n        volume=0.3,\n        scale=false,\n        pitch=1.0,\n        loop=false\n     };\n     ambient.playSound(data.sound, params)\nend\n\n-- Function to request the record handler to give the player a fancy dagger\nlocal function BoundWeaponHurtPlayer(value)\n    local playerHealth = types.Actor.stats.dynamic.health(self).current\n    types.Actor.stats.dynamic.health(self).current = (playerHealth - value)\n    types.Actor.stats.dynamic.fatigue(self).current = -10\n    --ui.showMessage(\"Before resolution!\" .. tostring(refineAttempt))\nend\n\n-- Function to request the record handler to give the player a fancy dagger\nlocal function initiateRefineAttempt()\n    local playerCharacter = self\n    local playerArmorer = self.type.stats.skills.armorer(self).modified\n    local playerLuck = self.type.stats.attributes.luck(self).modified\n    local playerAgility = self.type.stats.attributes.agility(self).modified\n    local playerIntelligence = self.type.stats.attributes.intelligence(self).modified\n    local playerFatigue = types.Actor.stats.dynamic.fatigue(self).current\n    local playerFatigueMax = types.Actor.stats.dynamic.fatigue(self).base\n\n    local refineAttempt = core.sendGlobalEvent(\"mainWeaponRefinement\",{\n        player=playerCharacter,\n        armorer=playerArmorer,\n        luck=playerLuck,\n        agility=playerAgility,\n        intelligence=playerIntelligence,\n        fatigue=playerFatigue,\n        fatigueMax=playerFatigueMax\n    })\n    types.Actor.stats.dynamic.fatigue(self).current = (playerFatigue - 10)\n    --ui.showMessage(\"Before resolution!\" .. tostring(refineAttempt))\nend\n\n--Tiny method to give the player a skill up when they refine a weapon\nlocal function skillUpFromRefine(data)\n    --Keep this kind of low because you can really easily use refining to make a ton of gold by saving all cheap weapons, refining them a ton, then selling them. ( Aka Skyrim's loop )\n    local params = {\n        skillGain = 0.4,\n        useType = 0\n    }\n    skill.skillUsed(\"armorer\", params)\nend\n\n-- Function to handle the result message from the global script\nlocal function handleResultMessage(data)\n    if data then\n        --ui.showMessage(\"Received data\")\n        -- Debug: Show the entire data structure\n        if data.message then\n            --ui.showMessage(\"Message: \" .. data.message)\n            ui.showMessage(data.message)\n        else\n            ui.showMessage(\"Data does not contain 'message' field\")\n        end\n    else\n        ui.showMessage(\"No data received from global script\")\n    end\nend\n\n--This method checks to see, when we talk to a NPC, if we should give them an anvil that we can buy from them.\n--It does this by checking \nlocal function getMerchant(data)\n    if data.arg ~= nil and --'data.arg' is a NPC. This means we are talking to something\n       data.arg.type == types.NPC and --Get the type of the thing we are talking to, was it a NPC?\n       data.oldMode == nil and --We aren't going from one UI mode to another UI mode. Aka we are initiating this UI mode.\n       data.newMode == \"Dialogue\" then --This UI mode is dialogue. Aka, we are talking to a NPC and have initiated the dialogue window.\n\n        local class = types.NPC.record(data.arg).class\n        --This prints the class to the dialogue box, pretty cool\n        --ui.showMessage(class)\n\n        --If this npc is willing to sell us stuff..\n        if types.NPC.record(data.arg).servicesOffered[\"Barter\"] and \n           --If this NPC is in the fighters guild, or this npc is in our allowed classes likely to want to sell us an anvil, give them an anvil.\n           (types.NPC.getFactionRank(data.arg, \"Fighters Guild\") > 0 or allowedClasses[class]) then\n            data.player = self\n            core.sendGlobalEvent(\"CreateAnvilForMerchant\", data)\n        end\n    end\nend\n\n\nreturn {\n    eventHandlers = {\n        boundWeaponHurtPlayer = BoundWeaponHurtPlayer,\n        attemptRefineWeapon = initiateRefineAttempt,\n        displayResultMessage = handleResultMessage,\n        UiModeChanged = getMerchant,\n        refinePlaySound = RefinePlaySound,\n        SkillUpFromRefine = skillUpFromRefine\n    }\n}"
  }
}