{
  "folder_name": "Timed Directional Attacks (OpenMW Lua)",
  "lua_files": {
    "Solthas Timed Directional Attacks-52195-1-5-1717384647\\SolTimedDirAttacks\\scripts\\SolTimedDirAttacks.lua": "local core = require('openmw.core')\nlocal ui = require('openmw.ui')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal async = require('openmw.async')\nlocal I = require(\"openmw.interfaces\")\n\n-- handle settings\nlocal storage = require('openmw.storage')\n\nI.Settings.registerPage({\n   key = 'SolTimedDirAttacks',\n   l10n = 'SolTimedDirAttacks',\n   name = 'name',\n   description = 'description',\n})\n\n-- default values!\nlocal enabled = true\nlocal verbose = 1\nlocal incRanged = false -- include ranged weapons ?\nlocal buffBase = 10\nlocal tradeOffBase = 50\nlocal fatigueLoss = 15\nlocal paceMult = 1.5\nI.Settings.registerGroup({\n   key = 'Settings_SolTimedDirAttacks',\n   page = 'SolTimedDirAttacks',\n   l10n = 'SolTimedDirAttacks',\n   name = 'group_name',\n   permanentStorage = true,\n   settings = {\n      {\n         key = 'enabled',\n         default = enabled,\n         renderer = 'checkbox',\n         name = 'enabled_name',\n      },\n      {\n         key = 'verbose',\n         default = verbose,\n         renderer = 'number',\n         name = 'verbose_name',\n         description = 'verbose_description',\n         argument = {\n            integer = true,\n            min = 0,\n            max = 2,\n         },\n      },\n      {\n         key = 'incRanged',\n         default = incRanged,\n         renderer = 'checkbox',\n         name = 'incRanged_name',\n      },\n      {\n         key = 'buffBase',\n         default = buffBase,\n         renderer = 'number',\n         name = 'buffBase_name',\n         description = 'buffBase_description',\n         argument = {\n        integer = true,\n            min = 0,\n            max = 100,\n         },\n      },\n      {\n         key = 'tradeOffBase',\n         default = tradeOffBase,\n         renderer = 'number',\n         name = 'tradeOffBase_name',\n         description = 'tradeOffBase_description',\n         argument = {\n        integer = true,\n            min = 0,\n            max = 100,\n         },\n      },\n      {\n         key = 'fatigueLoss',\n         default = fatigueLoss,\n         renderer = 'number',\n         name = 'fatigueLoss_name',\n         description = 'fatigueLoss_description',\n         argument = {\n        integer = true,\n            min = 0,\n            max = 100,\n         },\n      },\n      {\n         key = 'paceMult',\n         default = paceMult,\n         renderer = 'number',\n         name = 'paceMult_name',\n         description = 'paceMult_description',\n         argument = {\n            min = 0.5,\n            max = 3.0,\n         },\n      },\n   },\n})\nlocal settingsGroup = storage.playerSection('Settings_SolTimedDirAttacks')\n\n-- shorthand for convenience\nlocal Weapon = types.Weapon\nlocal attributes = types.Actor.stats.attributes\nlocal skills = types.NPC.stats.skills\nlocal dynamic = types.Actor.stats.dynamic\n\n-- reduce effectiveness of hybrid stances\nlocal function hybridVal(base,mult,count)\n    return math.ceil(base*math.pow(mult,math.max(count,0)))\nend\n\n-- script config\nlocal incH2H = true -- include handtohand?\n  -- if true, must define \"speed\" value for h2h in buff/debuff fncs\n\n-- init to defaults\nlocal buffDuration = 1\nlocal stateNames = {}\nlocal stanceNames = {'','','',''}\n-- update\nlocal function updateSettings()\n  enabled = settingsGroup:get('enabled')\n  verbose = settingsGroup:get('verbose')\n  incRanged = settingsGroup:get('incRanged')\n  buffBase = settingsGroup:get('buffBase')\n  tradeOffBase = settingsGroup:get('tradeOffBase')\n  paceMult = settingsGroup:get('paceMult')\n  -- update pace timer multiplier\n  buffDuration = 6/paceMult -- 3 states, so divide by 3\n    -- actually let's do 6 just to be safe\n  -- update verbose\n  if verbose == 1 then\n    stateNames = {'EARLY', 'GOOD', 'PERFECT'}\n    stanceNames = {'CHOP','SLASH','THRUST','FUMBLE'}\n  elseif verbose == 2 then\n    stateNames  = {'', '', ''}\n    stanceNames = {'ACC','DEF','AGI','FTG, SPD'}\n  end\nend\nlocal function init()\n    updateSettings()\nend\nsettingsGroup:subscribe(async:callback(updateSettings))\n\n-- stance effects \nlocal function chopMod(modSign,modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    skills.axe(self).modifier = math.max(0,skills.axe(self).modifier + modSign*modVal)\n    skills.bluntweapon(self).modifier = math.max(0,skills.bluntweapon(self).modifier + modSign*modVal)\n    skills.handtohand(self).modifier = math.max(0,skills.handtohand(self).modifier + modSign*modVal)\n    skills.longblade(self).modifier = math.max(0,skills.longblade(self).modifier + modSign*modVal)\n    skills.marksman(self).modifier = math.max(0,skills.marksman(self).modifier + modSign*modVal) -- marksman?\n    skills.shortblade(self).modifier = math.max(0,skills.shortblade(self).modifier + modSign*modVal)\n    skills.spear(self).modifier = math.max(0,skills.spear(self).modifier + modSign*modVal)\n  else\n    modVal = math.abs(modVal)\n    skills.axe(self).damage = math.max(0,skills.axe(self).damage + modVal)\n    skills.bluntweapon(self).damage = math.max(0,skills.bluntweapon(self).damage + modSign*modVal)\n    skills.handtohand(self).damage = math.max(0,skills.handtohand(self).damage + modSign*modVal)\n    skills.longblade(self).damage = math.max(0,skills.longblade(self).damage + modSign*modVal)\n    skills.marksman(self).damage = math.max(0,skills.marksman(self).damage + modSign*modVal) -- marksman?\n    skills.shortblade(self).damage = math.max(0,skills.shortblade(self).damage + modSign*modVal)\n    skills.spear(self).damage = math.max(0,skills.spear(self).damage + modSign*modVal)\n  end\nend\nlocal function slashMod(modSign,modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    skills.block(self).modifier = math.max(0,skills.block(self).modifier + modSign*modVal) -- block?\n    skills.heavyarmor(self).modifier = math.max(0,skills.heavyarmor(self).modifier + modSign*modVal)\n    skills.lightarmor(self).modifier = math.max(0,skills.lightarmor(self).modifier + modSign*modVal)\n    skills.mediumarmor(self).modifier = math.max(0,skills.mediumarmor(self).modifier + modSign*modVal)\n    skills.unarmored(self).modifier = math.max(0,skills.unarmored(self).modifier + modSign*modVal)\n  else\n    modVal = math.abs(modVal)\n    skills.block(self).damage = math.max(0,skills.block(self).damage + modSign*modVal) -- block?\n    skills.heavyarmor(self).damage = math.max(0,skills.heavyarmor(self).damage + modSign*modVal)\n    skills.lightarmor(self).damage = math.max(0,skills.lightarmor(self).damage + modSign*modVal)\n    skills.mediumarmor(self).damage = math.max(0,skills.mediumarmor(self).damage + modSign*modVal)\n    skills.unarmored(self).damage = math.max(0,skills.unarmored(self).damage + modSign*modVal)\n  end\nend\nlocal function lungeMod(modSign,modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    attributes.agility(self).modifier = math.max(0,attributes.agility(self).modifier + modSign*modVal)\n       -- offset agility by willpower to keep max fatigue constant\n    attributes.willpower(self).damage = math.max(0,attributes.willpower(self).damage + modSign*modVal)\n    skills.acrobatics(self).modifier = math.max(0,skills.acrobatics(self).modifier + modSign*modVal)\n  else\n    modVal = math.abs(modVal)\n    attributes.agility(self).damage = math.max(0,attributes.agility(self).damage + modSign*modVal)\n       -- offset agility by willpower to keep max fatigue constant\n    attributes.willpower(self).modifier = math.max(0,attributes.willpower(self).modifier + modSign*modVal)\n    skills.acrobatics(self).damage = math.max(0,skills.acrobatics(self).damage + modSign*modVal)\n  end\nend\nlocal function debuffMod(modSign,modVal) -- debuff speed on fumble\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    attributes.speed(self).modifier = math.max(0,attributes.speed(self).modifier + modSign*math.ceil(0.5*modVal))\n\t-- do athletics and acrobatics with speed, but give them each half impact\n    skills.athletics(self).modifier = math.max(0,skills.athletics(self).modifier + modSign*math.ceil(0.5*modVal))\n    skills.acrobatics(self).modifier = math.max(0,skills.acrobatics(self).modifier + modSign*math.ceil(0.5*modVal))\n  else\n    modVal = math.abs(modVal)\n    attributes.speed(self).damage = math.max(0,attributes.speed(self).damage + modSign*math.ceil(0.5*modVal))\n\t-- do athletics and acrobatics with speed, but give them each half impact\n    skills.athletics(self).damage = math.max(0,skills.athletics(self).damage + modSign*math.ceil(0.5*modVal))\n    skills.acrobatics(self).damage = math.max(0,skills.acrobatics(self).damage + modSign*math.ceil(0.5*modVal))\n  end\nend\n\nlocal function weaponCheck()\n  local isWeapon = false\n  if types.Actor.stance(self) == types.Actor.STANCE.Weapon then\n    local usedWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n    if (not usedWeapon) then -- handtohand\n      isWeapon = incH2H\n    else\n      if  not types.Lockpick.objectIsInstance(usedWeapon) and not types.Probe.objectIsInstance(usedWeapon) then\n        local weaponType = Weapon.record(usedWeapon).type\n        if (weaponType < 9) then -- melee weapon\n          isWeapon = true\n        elseif (weaponType <= 13) then -- ranged weapon\n          isWeapon = incRanged\n        elseif (weaponType > 13) then -- unknown weapon\n          isWeapon = true\n        end\n      end\n    end \n  end\n  return(isWeapon)\nend\n\nlocal function getPace()\n  -- get relevant stats\n  local usedWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n  local weapSpeed = 1\n  if (usedWeapon) then -- NOT handtohand\n    weapSpeed = Weapon.record(usedWeapon).speed\n  end\n  -- setup mod\n  local paceTime = 1/weapSpeed\n  return(paceTime)\nend\n\n\nlocal buffTotal = {0,0,0,0}\n-- save state to be removed on load\nlocal function onSave()\n    return{\n      buffTotal = buffTotal\n    }\nend\nlocal function onLoad(data)\n  if data then\n    buffTotal = data.buffTotal\n    chopMod(-1,buffTotal[1])\n    slashMod(-1,buffTotal[2])\n    lungeMod(-1,buffTotal[3])\n    debuffMod(-1,buffTotal[4])    \n    buffTotal = {0,0,0,0}\n  end\nend\n\n-- use a queue to store stance and stage numbers\nlocal circStance = {} -- store which stance was triggered\nlocal circCombo = {} -- store whether stance was eaten by a new input\nlocal weaponWeight = 0\nlocal chargeTime = 0\nlocal doBuff = true\nlocal isCharge = false -- true if trigger input action\nlocal isWeapon = false\nlocal stanceNext = 0\nlocal isBuffed = false\nlocal buffMult = 0\nreturn { \n  engineHandlers = { \n    -- init settings\n    onActive = init,\n    -- save and load handling so you don't get stuck with modified stats\n    onSave = onSave,\n    onLoad = onLoad,\n    \n    onUpdate = function(dt)\n      if core.API_REVISION > 60 and I.UI.getMode() ~= nil then return end\n      if enabled then\n        local isUse = input.isActionPressed(input.ACTION.Use)\n        \n        if isUse and not isCharge then -- on first frame you hit use        \n          isCharge = true -- update stance\n          isWeapon = weaponCheck()\n          -- get dir attack type\n          if isWeapon then -- 0-8 is melee, 9-11 is ranged, 12-13 is ammunition, usedWeapon nil if handtohand\n            -- check movement to determine attack dir\n            local mf = self.controls.movement\n            local ms = self.controls.sideMovement\n            if mf ~= 0 and ms == 0 then -- lunge\n              stanceNext = 3\n            elseif mf == 0 and ms ~= 0 then -- slash\n              stanceNext = 2\n            elseif (mf == 0 and ms == 0) or (mf ~= 0 and ms ~= 0) then -- chop\n              stanceNext = 1\n            end\n            \n            if doBuff then\n              doBuff = false\n              chargeTime = core.getSimulationTime() - chargeTime -- get timer value\n              local paceTime = getPace()\n              local chargeState = math.floor(paceMult*chargeTime/paceTime)    \n        \n              if chargeState == 0 then -- drain fatigue\n                isBuffed = true\n                local cfat = dynamic.fatigue(self).current\n        --        dynamic.fatigue(self).current = math.max(0, dynamic.fatigue(self).current - fatigueLoss)\n                dynamic.fatigue(self).current = math.max(0, cfat - fatigueLoss)\n        -- there's a conflict between this fatigue loss and the loss of agility. It can subtract from your true max fatigue ignoring the loss from agility\n        -- which, once agility returns to normal, can cause your fatigue to go above maximum\n        --        dynamic.fatigue(self).current = math.min(dynamic.fatigue(self).base, dynamic.fatigue(self).current)       \n              elseif chargeState == 1 then -- 1x buff\n                isBuffed = true\n                buffMult = 1\n              elseif chargeState == 2 then -- 2x buff\n                isBuffed = true\n                buffMult = 2\n              else -- nothing\n                isBuffed = false\n              end\n              \n              if isBuffed then\n                -- remove existing buffs\n                chopMod(-1,buffTotal[1])\n                slashMod(-1,buffTotal[2])\n                lungeMod(-1,buffTotal[3])\n                debuffMod(-1,buffTotal[4])\n                buffTotal = {0,0,0,0}\n\n                -- apply new buff\n                if chargeState == 0 then\n                  debuffMod(1,-tradeOffBase)\n                  buffTotal[4] = buffTotal[4] - tradeOffBase\n                  stanceNext = 4\n                else\n                  if stanceNext == 1 then\n                    chopMod(1,buffBase*buffMult)\n                    buffTotal[1] = buffTotal[1] + buffBase*buffMult\n                  elseif stanceNext == 2 then\n                    slashMod(1,buffBase*buffMult)\n                    buffTotal[2] = buffTotal[2] + buffBase*buffMult\n                  elseif stanceNext == 3 then\n                    lungeMod(1,buffBase*buffMult)\n                    buffTotal[3] = buffTotal[3] + buffBase*buffMult\n                  end\n                end\n                -- update queue for timer to call\n                for i,_ in ipairs(circCombo) do\n                  circCombo[i] = false -- set prior entries to not retrigger on their own\n                end\n                table.insert(circCombo,true)\n        \n                if verbose == 1 then\n                  if chargeState == 0 then\n                    ui.showMessage(stateNames[chargeState+1].. ' ' .. stanceNames[4])\n                  else\n                    ui.showMessage(stateNames[chargeState+1].. ' ' .. stanceNames[stanceNext])                  \n                  end\n                elseif verbose == 2 then\n                  if chargeState == 0 then\n                    ui.showMessage(tostring(-fatigueLoss) ..' '.. stanceNames[4] .. ' -' .. tostring(tradeOffBase) .. ' (' .. tostring(math.floor(chargeTime*10)/10) .. ' / ' .. tostring(math.floor(paceTime/paceMult*10)/10)..')')\n                  else\n                    ui.showMessage(stanceNames[stanceNext] .. ' +' .. tostring(buffBase*buffMult) .. ' (' .. tostring(math.floor(chargeTime*10)/10) .. ' / ' .. tostring(math.floor(paceTime/paceMult*10)/10)..')')                \n                  end\n                end\n                \n                -- start end buff timer\n                async:newUnsavableSimulationTimer(\n                  buffDuration*paceTime,\n                  function()\n                    local runDebuff = table.remove(circCombo,1)\n                    if runDebuff then\n                      chopMod(-1,buffTotal[1])\n                      slashMod(-1,buffTotal[2])\n                      lungeMod(-1,buffTotal[3])\n                      debuffMod(-1,buffTotal[4])\n                      buffTotal = {0,0,0,0}\n                    end\n                  end\n                )\n              end\n            end\n          end\n          \n        elseif not isUse and isCharge then -- on first frame you release use\n          isCharge = false\n          if isWeapon then -- only buff if unbuffed\n            doBuff = true\n            chargeTime = core.getSimulationTime() -- start timer\n          end\n        end\n      end\n    end\n  }\n}"
  }
}