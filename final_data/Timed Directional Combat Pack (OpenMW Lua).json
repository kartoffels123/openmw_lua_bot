{
  "folder_name": "Timed Directional Combat Pack (OpenMW Lua)",
  "lua_files": {
    "Solthas Combat Pack-52221-1-11-1717384986\\Solthas Combat Pack\\scripts\\SolBodzStatShaders\\scripts\\SolBodzStatShaders.lua": "local self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal dynamic = types.Actor.stats.dynamic\n\n-- shader\nlocal postprocessing = require('openmw.postprocessing')\nlocal shader = postprocessing.load('HealthFatigueEffect')\n\n-- settings functions\nlocal function boolSetting(sKey, sDef)\n    return {\n        key = sKey,\n        renderer = 'checkbox',\n        name = sKey..'_name',\n        description = sKey..'_desc',\n        default = sDef,\n    }\nend\nlocal function numbSetting(sKey, sDef, sInt, sMin, sMax)\n    return {\n        key = sKey,\n        renderer = 'number',\n        name = sKey..'_name',\n        description = sKey..'_desc',\n        default = sDef,\n    argument = {\n      integer = sInt,\n      min = sMin,\n      max = sMax,\n    },\n    }\nend\n-- handle settings\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\nlocal async = require('openmw.async')\nI.Settings.registerPage({\n   key = 'SolBodzStatShaders',\n   l10n = 'SolBodzStatShaders',\n   name = 'name',\n   description = 'description',\n})\n-- default values!\nlocal enabled = true\nlocal healthIntensity = 1.0\nlocal magicIntensity = 1.0\nlocal fatigueIntensity = 1.0\nlocal updateInteveral = 0.1\nI.Settings.registerGroup({\n  key = 'Settings_SolBodzStatShaders',\n  page = 'SolBodzStatShaders',\n  l10n = 'SolBodzStatShaders',\n  name = 'group_name',\n  permanentStorage = true,\n  settings = {\n    boolSetting('enabled',enabled),\n    numbSetting('healthIntensity',healthIntensity, false,0.0,2.0),\n    numbSetting('magicIntensity',magicIntensity, false,0.0,2.0),\n    numbSetting('fatigueIntensity',fatigueIntensity, false,0.0,2.0),\n    numbSetting('updateInteveral',updateInteveral, false,0.01,1.0),\n  },\n})\nlocal settingsGroup = storage.playerSection('Settings_SolBodzStatShaders')\n-- update\nlocal function updateSettings()\n  enabled = settingsGroup:get('enabled')\n    if enabled then\n      shader:enable()\n\telse\n      shader:disable() -- force disable just in case\n    end\n  healthIntensity = settingsGroup:get('healthIntensity')\n    if healthIntensity == 0.0 then\n      shader:setFloat(\"uHealthFactor\",0.0)\n    end\n  magicIntensity = settingsGroup:get('magicIntensity')\n    if magicIntensity == 0.0 then\n      shader:setFloat(\"uMagickaFactor\",0.0)\n    end\n  fatigueIntensity = settingsGroup:get('fatigueIntensity')\n    if fatigueIntensity == 0.0 then\n      shader:setFloat(\"uFatigueFactor\",0.0)\n    end\n  updateInteveral = settingsGroup:get('updateInteveral')\nend\nlocal function init()\n    updateSettings()\nend\nsettingsGroup:subscribe(async:callback(updateSettings))\n\nlocal maxStat = 0\nlocal pctStat = 0\nlocal updateTime = 0\nreturn {\n  engineHandlers = { \n    -- init settings\n    onActive = init,\n\n    onUpdate = function(dt)\n    if enabled then\n      updateTime = updateTime + dt\n      if updateTime >= updateInteveral then\n        updateTime = 0.0\n        if healthIntensity > 0.0 then\n          local maxStat = dynamic.health(self).base\n\t\t  if maxStat == 0 then\n\t\t    maxStat = 1\n\t\t  end\n          pctStat = math.sqrt(1.0 - math.min(1.0,(2.0*dynamic.health(self).current/maxStat)))\n          shader:setFloat(\"uHealthFactor\",healthIntensity*pctStat)\n        end\n        if magicIntensity > 0.0 then\n          local maxStat = dynamic.magicka(self).base\n\t\t  if maxStat == 0 then\n\t\t    maxStat = 1\n\t\t  end\n          pctStat = math.sqrt(1.0 - math.min(1.0,(2.0*dynamic.magicka(self).current/maxStat)))\n          shader:setFloat(\"uMagickaFactor\",magicIntensity*pctStat)\n        end\n        if fatigueIntensity > 0.0 then\n          local maxStat = dynamic.fatigue(self).base\n\t\t  if maxStat == 0 then\n\t\t    maxStat = 1\n\t\t  end\n          pctStat = math.sqrt(1.0 - math.min(1.0,(2.0*dynamic.fatigue(self).current/maxStat)))\n          shader:setFloat(\"uFatigueFactor\",fatigueIntensity*pctStat)\n        end\n      end\n    end\n  end\n  }\n}\n\n",
    "Solthas Combat Pack-52221-1-11-1717384986\\Solthas Combat Pack\\scripts\\SolBowAimActivate\\scripts\\SolBowAimActivate.lua": "--local core = require('openmw.core')\nlocal camera = require('openmw.camera')\nlocal util = require('openmw.util')\n--local nearby = require('openmw.nearby')\nlocal self = require('openmw.self')\nlocal Actor = require('openmw.types').Actor\nlocal skills = require('openmw.types').NPC.stats.skills\nlocal Weapon = require('openmw.types').Weapon\nlocal input = require('openmw.input')\nlocal dynamic = require('openmw.types').Actor.stats.dynamic\n\n-- settings functions\nlocal function boolSetting(sKey, sDef)\n    return {\n        key = sKey,\n        renderer = 'checkbox',\n        name = sKey..'_name',\n        description = sKey..'_desc',\n        default = sDef,\n    }\nend\nlocal function numbSetting(sKey, sDef, sInt, sMin, sMax)\n    return {\n        key = sKey,\n        renderer = 'number',\n        name = sKey..'_name',\n        description = sKey..'_desc',\n        default = sDef,\n    argument = {\n      integer = sInt,\n      min = sMin,\n      max = sMax,\n    },\n    }\nend\n-- handle settings\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\nlocal async = require('openmw.async')\nI.Settings.registerPage({\n   key = 'SolBowAimActivate',\n   l10n = 'SolBowAimActivate',\n   name = 'name',\n   description = 'description',\n})\n-- default values!\nlocal enabled = true\nlocal includeThrown = false\nlocal fatigueBow = 3.0\nlocal fatigueZoom = 6.0\nlocal enabledFirstPerson = true\nlocal enabledThirdPerson = true\nlocal combatOffsetX = 0\nlocal combatOffsetY = 0\nlocal aimingOffsetX = -10\nlocal aimingOffsetY = -5\nI.Settings.registerGroup({\n  key = 'Settings_SolBowAimActivate',\n  page = 'SolBowAimActivate',\n  l10n = 'SolBowAimActivate',\n  name = 'group_name',\n  permanentStorage = true,\n  settings = {\n    boolSetting('enabled',enabled),\n    boolSetting('includeThrown',includeThrown),\n    numbSetting('fatigueBow',fatigueBow, false,0,10),\n    numbSetting('fatigueZoom',fatigueZoom, false,0,10),\n    boolSetting('enabledFirstPerson',enabledFirstPerson),\n    boolSetting('enabledThirdPerson',enabledThirdPerson),\n    numbSetting('combatOffsetX',combatOffsetX, true,-100,100),\n    numbSetting('combatOffsetY',combatOffsetY, true,-100,100),\n    numbSetting('aimingOffsetX',aimingOffsetX, true,-100,100),\n    numbSetting('aimingOffsetY',aimingOffsetY, true,-100,100),\n  },\n})\nlocal settingsGroup = storage.playerSection('Settings_SolBowAimActivate')\n-- init\nlocal combatOffset = util.vector2(40, -10)\nlocal aimingOffset = util.vector2(10, -20)\n-- update\nlocal function updateSettings()\n  enabled = settingsGroup:get('enabled')\n  includeThrown = settingsGroup:get('includeThrown')\n  fatigueBow = settingsGroup:get('fatigueBow')\n  fatigueZoom = settingsGroup:get('fatigueZoom')\n  enabledFirstPerson = settingsGroup:get('enabledFirstPerson')\n  enabledThirdPerson = settingsGroup:get('enabledThirdPerson')\n  combatOffsetX = settingsGroup:get('combatOffsetX')\n  combatOffsetY = settingsGroup:get('combatOffsetY')\n  aimingOffsetX = settingsGroup:get('aimingOffsetX')\n  aimingOffsetY = settingsGroup:get('aimingOffsetY')\n    combatOffset = util.vector2(combatOffsetX, combatOffsetY)\n    aimingOffset = util.vector2(aimingOffsetX, aimingOffsetY)\nend\nlocal function init()\n    updateSettings()\nend\nsettingsGroup:subscribe(async:callback(updateSettings))\n\n\n\nlocal function isBowPrepared()\n    if Actor.stance(self) ~= Actor.STANCE.Weapon then return false end\n    local item = Actor.equipment(self, Actor.EQUIPMENT_SLOT.CarriedRight)\n    local weaponRecord = item and item.type == Weapon and Weapon.record(item)\n    if not weaponRecord then return false end\n  local returnType = (weaponRecord.type == Weapon.TYPE.MarksmanBow or weaponRecord.type == Weapon.TYPE.MarksmanCrossbow) -- no thrown\n  if includeThrown then\n    returnType = (returnType or weaponRecord.type == Weapon.TYPE.MarksmanThrown)\n  end\n    return returnType\nend\n\n-- hurt logic\nlocal hurtTime = 0\nlocal hurtZoom = 0\nlocal hurtWait = 2\n-- init\nlocal active = false\nlocal counterMin, counterMax = -3, 2\nlocal counter = counterMin\nlocal useAimingOffset = false\nreturn {\n  engineHandlers = { \n    -- init settings\n    onActive = init,\n\n    onUpdate = function(dt)\n      if enabled then\n        -- if arrow drawn and you're using a bow specifically... drain fatigue?\n        if fatigueBow > 0 then\n          -- do isBowPrepared() but specifically for bow\n          if Actor.stance(self) == Actor.STANCE.Weapon then\n            local usedWeapon = Actor.equipment(self, Actor.EQUIPMENT_SLOT.CarriedRight)\n            if (usedWeapon) then -- handtohand\n              local weaponRecord = usedWeapon and usedWeapon.type == Weapon and Weapon.record(usedWeapon)\n              if weaponRecord then\n                -- if bow drawn\n                if weaponRecord.type == Weapon.TYPE.MarksmanBow then -- \n                  if input.isActionPressed(input.ACTION.Use) then\n                    -- drain fatigue on timer\n                    if dynamic.fatigue(self).current > 0 then -- if not out of fatigue\n                      hurtTime = hurtTime + dt\n                      if hurtTime >= hurtWait then -- if enough time has passed\n                        hurtTime = 0\n                        local strength = Actor.stats.attributes.strength(self).modified\n                        local fatigueCost =  math.ceil(fatigueBow*math.sqrt(1 + weaponRecord.weight)*100/(strength+50))\n                        dynamic.fatigue(self).current = math.max(0,dynamic.fatigue(self).current - fatigueCost) -- don't set to below 0\n                      end\n                    end\n                  end\n                end\n              end\n            end\n          end\n        end\n\t\t\n        if fatigueZoom > 0 and active then -- if zoomed in then check this junk\n          -- drain fatigue on timer\n          if dynamic.fatigue(self).current > 0 then -- if not out of fatigue\n            hurtZoom = hurtZoom + dt\n            if hurtZoom >= hurtWait then -- if enough time has passed\n              hurtZoom = 0\n\t\t\t  -- we can assume that you have the correct weapon if the zoom is active\n\t\t\t  --local weaponWeight = Weapon.record(Actor.equipment(self, Actor.EQUIPMENT_SLOT.CarriedRight)).weight\n              local fatigueCost =  math.ceil(fatigueZoom*100/(skills.marksman(self).modified+50))\n              dynamic.fatigue(self).current = math.max(0,dynamic.fatigue(self).current - fatigueCost) -- don't set to below 0\n            end\n          end\n        end\n      \n        local bowCheck = (enabledFirstPerson and camera.getMode() == camera.MODE.FirstPerson) or\n            (enabledThirdPerson and camera.getMode() == camera.MODE.ThirdPerson)\n        --local isSneak = self.controls.sneak -- 0.49 sneak check\n        --if isSneak == nil then\n        --  isSneak = input.isActionPressed(input.ACTION.Sneak) -- 0.48 sneak check\n        --end\n        --if active ~= (bowCheck and isBowPrepared() and isSneak and input.isActionPressed(input.ACTION.Activate)) then -- req sneak and activate\n        if active ~= (bowCheck and isBowPrepared() and input.isActionPressed(input.ACTION.Activate)) then -- req activate only\n          --if active ~= (bowCheck and isBowPrepared() and isSneak) then -- req sneak\n          --if active ~= (bowCheck and isBowPrepared()) then -- original\n          active = not active\n          if active then\n            I.Camera.disableThirdPersonOffsetControl()\n            camera.setFocalTransitionSpeed(5.0)\n            camera.setFocalPreferredOffset(combatOffset)\n          else\n            I.Camera.enableThirdPersonOffsetControl()\n          end\n        end\n        if self.controls.use == 0 or not active then\n          counter = math.max(counterMin, counter - dt * 2.5)\n        else\n          counter = math.min(counterMax, counter + dt * 2.5)\n        end\n        local effect = (math.max(0.1, math.exp(math.min(1, counter)-1)) - 0.1) / 0.9\n        effect = effect*math.min(1.5,(0.5 + skills.marksman(self).modified/100))\n        camera.setFieldOfView(camera.getBaseFieldOfView() * (1 - 0.5 * effect))\n        if camera.getMode() ~= camera.MODE.ThirdPerson then effect = 0 end\n          if useAimingOffset ~= (effect > 0.4) and active then\n            useAimingOffset = effect > 0.4\n          if useAimingOffset then\n            camera.setFocalPreferredOffset(aimingOffset)\n          else\n            camera.setFocalPreferredOffset(combatOffset)\n          end\n        end\n      end\n    end\n  }\n}\n\n",
    "Solthas Combat Pack-52221-1-11-1717384986\\Solthas Combat Pack\\scripts\\SolChargeAttackParry\\scripts\\SolChargeAttackParry.lua": "local core = require('openmw.core')\nlocal ui = require('openmw.ui')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal async = require('openmw.async')\n\n-- settings functions\nlocal function boolSetting(sKey, sDef)\n    return {\n        key = sKey,\n        renderer = 'checkbox',\n        name = sKey..'_name',\n        description = sKey..'_desc',\n        default = sDef,\n    }\nend\nlocal function numbSetting(sKey, sDef, sInt, sMin, sMax)\n    return {\n        key = sKey,\n        renderer = 'number',\n        name = sKey..'_name',\n        description = sKey..'_desc',\n        default = sDef,\n    argument = {\n      integer = sInt,\n      min = sMin,\n      max = sMax,\n    },\n    }\nend\n-- handle settings\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\nI.Settings.registerPage({\n   key = 'SolChargeAttackParry',\n   l10n = 'SolChargeAttackParry',\n   name = 'name',\n   description = 'description',\n})\n-- default values!\nlocal enabled = true\nlocal verbose = 2\nlocal hideChargePopup = true\nlocal incRanged = true -- include ranged weapons ?\nlocal buffControl = 0 -- 0 both, 1 DEF only, 2 AGI only\nlocal buffBase = 2.0\nlocal fatigueMult = 1.0\nlocal tradeOffBase = 5.0\nlocal doSpeedRelease = true\nlocal maxCharge = 2.0\nlocal buffDuration = 0.5\nI.Settings.registerGroup({\n   key = 'Settings_SolChargeAttackParry',\n   page = 'SolChargeAttackParry',\n   l10n = 'SolChargeAttackParry',\n   name = 'group_name',\n   permanentStorage = true,\n   settings = {\n    boolSetting('enabled',enabled),\n    numbSetting('verbose',verbose, true,0,2),\n    boolSetting('hideChargePopup',hideChargePopup),\n    boolSetting('incRanged',incRanged),\n    numbSetting('buffControl',buffControl, true,0,2),\n    numbSetting('buffBase',buffBase, false,0,10),\n    numbSetting('fatigueMult',fatigueMult, false,0,2),\n    numbSetting('tradeOffBase',tradeOffBase, false,0,20),\n    boolSetting('doSpeedRelease',doSpeedRelease),\n    numbSetting('maxCharge',maxCharge, false,1,5),\n    numbSetting('buffDuration',buffDuration, false,0.25,5),\n   },\n})\n\nlocal settingsGroup = storage.playerSection('Settings_SolChargeAttackParry')\n\n-- shorthand for convenience\nlocal Weapon = types.Weapon\nlocal attributes = types.Actor.stats.attributes\nlocal skills = types.NPC.stats.skills\nlocal dynamic = types.Actor.stats.dynamic\n\n-- reduce effectiveness of hybrid stances\nlocal function hybridVal(base,mult,count)\n    return math.ceil(base*math.pow(mult,math.max(count,0)))\nend\n\n-- script config\nlocal modType = 1 --1 skill, -1 debug reset all stat modifiers\nlocal incH2H = true -- include handtohand for heavy charged attacks?\n  -- if true, must define \"weight\" and \"speed\" values for h2h in buff/debuff fncs\n\n-- and store stance idxs for indexing into tables\nlocal stanceIndex = {charge=1, release=2}\nlocal maxStance = 0\nfor _ in pairs(stanceIndex) do\n  maxStance = maxStance + 1\nend\n\n-- init to defaults\nlocal stanceBuff = {-tradeOffBase,buffBase}\nlocal stanceNames = {'',''}\n-- update\nlocal function updateSettings()\n  enabled = settingsGroup:get('enabled')\n  hideChargePopup = settingsGroup:get('hideChargePopup')\n  verbose = settingsGroup:get('verbose')\n    -- update verbose\n    if verbose == 1 then\n    stanceNames = {'DEFENSE UP', 'AGILITY UP', 'CHARGE'}\n    elseif verbose == 2 then\n    stanceNames  = {'DEF+', 'AGI+', 'SPD ETC'}\n    end\n  incRanged = settingsGroup:get('incRanged')\n  buffControl = settingsGroup:get('buffControl')\n  buffBase = settingsGroup:get('buffBase')\n  fatigueMult = settingsGroup:get('fatigueMult')\n  tradeOffBase = settingsGroup:get('tradeOffBase')\n  -- calculate new buff vals\n    stanceBuff = {-tradeOffBase,buffBase}\n  doSpeedRelease = settingsGroup:get('doSpeedRelease')\n  maxCharge = settingsGroup:get('maxCharge')\n  buffDuration = settingsGroup:get('buffDuration')\nend\nlocal function init()\n    updateSettings()\nend\nsettingsGroup:subscribe(async:callback(updateSettings))\n\n-- stance effects \nlocal function chargeMod(modSign,modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    attributes.speed(self).modifier = math.max(0,attributes.speed(self).modifier + modSign*math.ceil(0.5*modVal))\n\t-- do athletics and acrobatics with speed, but give them each half impact\n    skills.athletics(self).modifier = math.max(0,skills.athletics(self).modifier + modSign*math.ceil(0.5*modVal))\n    skills.acrobatics(self).modifier = math.max(0,skills.acrobatics(self).modifier + modSign*math.ceil(0.5*modVal))\n    skills.heavyarmor(self).modifier = math.max(0,skills.heavyarmor(self).modifier + modSign*modVal)\n    skills.lightarmor(self).modifier = math.max(0,skills.lightarmor(self).modifier + modSign*modVal)\n    skills.mediumarmor(self).modifier = math.max(0,skills.mediumarmor(self).modifier + modSign*modVal)\n    skills.unarmored(self).modifier = math.max(0,skills.unarmored(self).modifier + modSign*modVal)\n  else\n    modVal = math.abs(modVal)\n    attributes.speed(self).damage = math.max(0,attributes.speed(self).damage + modSign*math.ceil(0.5*modVal))\n\t-- do athletics and acrobatics with speed, but give them each half impact\n    skills.athletics(self).damage = math.max(0,skills.athletics(self).damage + modSign*math.ceil(0.5*modVal))\n    skills.acrobatics(self).damage = math.max(0,skills.acrobatics(self).damage + modSign*math.ceil(0.5*modVal))\n    skills.heavyarmor(self).damage = math.max(0,skills.heavyarmor(self).damage + modSign*modVal)\n    skills.lightarmor(self).damage = math.max(0,skills.lightarmor(self).damage + modSign*modVal)\n    skills.mediumarmor(self).damage = math.max(0,skills.mediumarmor(self).damage + modSign*modVal)\n    skills.unarmored(self).damage = math.max(0,skills.unarmored(self).damage + modSign*modVal)\n  end\nend\n\nlocal function releaseMod(modSign,modVal,buffType)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    if doSpeedRelease then\n      -- if debuff speed on release\n      attributes.speed(self).damage = math.max(0,attributes.speed(self).damage + tradeOffBase*modSign*modVal)\n      -- do athletics and acrobatics with speed, but give them each half impact\n      skills.athletics(self).damage = math.max(0,skills.athletics(self).damage + tradeOffBase*modSign*modVal)\n      skills.acrobatics(self).damage = math.max(0,skills.acrobatics(self).damage + tradeOffBase*modSign*modVal)\n    end\n    --normal\n    if buffType == 1 then\n      skills.heavyarmor(self).modifier = math.max(0,skills.heavyarmor(self).modifier + modSign*modVal)\n      skills.lightarmor(self).modifier = math.max(0,skills.lightarmor(self).modifier + modSign*modVal)\n      skills.mediumarmor(self).modifier = math.max(0,skills.mediumarmor(self).modifier + modSign*modVal)\n      skills.unarmored(self).modifier = math.max(0,skills.unarmored(self).modifier + modSign*modVal)\n    else\n      attributes.agility(self).modifier = math.max(0,attributes.agility(self).modifier + modSign*modVal)\n       -- offset agility by willpower to keep max fatigue constant\n      attributes.willpower(self).damage = math.max(0,attributes.willpower(self).damage + modSign*modVal)\n    end\n  else -- if negative effect, then damage\n    modVal = math.abs(modVal)\n    if doSpeedRelease then\n      -- if debuff speed on release\n      attributes.speed(self).modifier = math.max(0,attributes.speed(self).modifier + tradeOffBase*modSign*modVal)\n      -- do athletics and acrobatics with speed, but give them each half impact\n      skills.athletics(self).modifier = math.max(0,skills.athletics(self).modifier + tradeOffBase*modSign*modVal)\n      skills.acrobatics(self).modifier = math.max(0,skills.acrobatics(self).modifier + tradeOffBase*modSign*modVal)\n    end\n    --normal\n    if buffType == 1 then\n      skills.heavyarmor(self).damage = math.max(0,skills.heavyarmor(self).damage + modSign*modVal)\n      skills.lightarmor(self).damage = math.max(0,skills.lightarmor(self).damage + modSign*modVal)\n      skills.mediumarmor(self).damage = math.max(0,skills.mediumarmor(self).damage + modSign*modVal)\n      skills.unarmored(self).damage = math.max(0,skills.unarmored(self).damage + modSign*modVal)\n    else\n      attributes.agility(self).damage = math.max(0,attributes.agility(self).damage + modSign*modVal)\n       -- offset agility by willpower to keep max fatigue constant\n      attributes.willpower(self).modifier = math.max(0,attributes.willpower(self).modifier + modSign*modVal)\n    end\n  end\nend\n\n-- init stance total tracking, used for verbose outputs, and for onSave/onLoad tracking\nlocal chargeBuffTotal = {}\nfor i=1,maxStance,1 do \n  chargeBuffTotal[i] = 0\nend\nlocal buffType = 0\n\nlocal function weaponCheck()\n  local isWeapon = false\n  if types.Actor.stance(self) == types.Actor.STANCE.Weapon then\n    local usedWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n    if (not usedWeapon) then -- handtohand\n      isWeapon = incH2H\n    else\n      if not types.Lockpick.objectIsInstance(usedWeapon) and not types.Probe.objectIsInstance(usedWeapon) then\n        local weaponType = Weapon.record(usedWeapon).type\n        if (weaponType < 9) then -- melee weapon\n          isWeapon = true\n        elseif (weaponType <= 13) then -- ranged weapon\n          isWeapon = incRanged\n        elseif (weaponType > 13) then -- unknown weapon\n          isWeapon = true\n        end\n      end\n    end \n  end\n  return(isWeapon)\nend\n\nlocal function getChargeMod()\n  -- get relevant stats\n  local strength = attributes.strength(self).modified\n  local usedWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n  local weapWeight = 1\n  if not (not usedWeapon) then -- NOT handtohand\n    weapWeight = Weapon.record(usedWeapon).weight\n  end\n  -- setup mod\n  --local buffMod = (1 + math.sqrt(weapWeight))*(50/strength)\n  --local buffMod = (1 + math.sqrt(weapWeight))*math.max(0,(2.5-(strength/50)))\n  local buffMod = (1 + math.sqrt(weapWeight))*(100/(strength+50))\n    -- mod up as weapon weight up, with minimum\n    -- mod down as strength up\n  return(buffMod)\nend\n\nlocal function getReleaseMod(chargeTime)\n  -- get relevant stats\n  local usedWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n  local weapSpeed = 1\n  local weapWeight = 1\n  if not (not usedWeapon) then -- NOT handtohand\n    weapSpeed = Weapon.record(usedWeapon).speed\n    weapWeight = Weapon.record(usedWeapon).weight\n  end\n  -- setup mod\n  local buffMod = (1 + math.sqrt(weapWeight))*math.min(maxCharge,(chargeTime*weapSpeed))--/weapSpeed\n    -- mod up as weapon weight up, with minimum\n    -- mod up as charge increases, vs weapon speed\n    -- mod up as weapon speed up?\n  return(buffMod)\nend\n\n-- save state to be removed on load\nlocal function onSave()\n    return{\n      chargeBuffTotal = chargeBuffTotal,\n\t  buffType = buffType\n    }\nend\nlocal function onLoad(data)\n  if data then\n    chargeBuffTotal = data.chargeBuffTotal\n\tbuffType = data.buffType\n    chargeMod(-1,chargeBuffTotal[1])\n    releaseMod(-1,chargeBuffTotal[2],buffType)\n    for i=1,maxStance,1 do\n      chargeBuffTotal[i] = 0\n    end\n  end\nend\n\nlocal weaponWeight = 0\nlocal chargeTime = 0\nlocal doBuff = false\nlocal isCharge = false -- true if trigger input action\nlocal isWeapon = false\nreturn { \n  engineHandlers = { \n    -- init settings\n    onActive = init,\n    -- save and load handling so you don't get stuck with modified stats\n    onSave = onSave,\n    onLoad = onLoad,\n    \n    onUpdate = function(dt)\n      if enabled then\n        local isUse = input.isActionPressed(input.ACTION.Use)\n        \n        if isUse and not isCharge then -- on first frame you hit use        \n--        if isUse and not isCharge and not types.Actor.isOnGround(self) then -- on first frame you hit use        \n          isCharge = true -- update stance\n          isWeapon = weaponCheck()\n          -- apply charge debuff\n          if isWeapon then\n            chargeTime = core.getSimulationTime() -- set timer value\n            local buffNext = hybridVal(stanceBuff[1],getChargeMod(),1)\n            chargeMod(1,buffNext)\n            chargeBuffTotal[1] = chargeBuffTotal[1] + buffNext\n            if verbose>0 and not hideChargePopup then\n              ui.showMessage(stanceNames[3] .. ' ' .. tostring(chargeBuffTotal[1]))\n            end\n          end\n      \n        elseif not isUse and isCharge then -- on first frame you release use\n          isCharge = false\n          -- remove charge debuff\n          chargeMod(-1,chargeBuffTotal[1])\n          chargeBuffTotal[1] = 0\n          if isWeapon and chargeBuffTotal[2]==0 then -- only buff if unbuffed\n            chargeTime = core.getSimulationTime() - chargeTime -- get timer value\n            -- buff DEFENSE or Agility depending on movement and config val\n            local mf = self.controls.movement\n            local ms = self.controls.sideMovement\n            local ig = types.Actor.isOnGround(self)\n            local is = types.Actor.isSwimming(self)\n            local moveType = 0\n            if (ig or is) and mf == -1 then -- backwards component\n              moveType = 1 -- def\n            elseif (ig or is) and mf == 0 and ms ~= 0 then -- sideways only\n              moveType = 2 -- agi\n            end\n            if moveType > 0 then\n              doBuff = true\n            else\n              doBuff = false\n            end\n            \n            if doBuff then\n              -- get release buff\n              local buffNext = hybridVal(stanceBuff[2],getReleaseMod(chargeTime),1)\n              -- fatigue cost\n              local cfat = dynamic.fatigue(self).current\n              local strength = attributes.strength(self).modified\n              local fatigueCost = math.ceil(fatigueMult*buffNext*100/(strength+50))\n              dynamic.fatigue(self).current = math.max(0,cfat - fatigueCost)\n              -- determine what you're buffing\n              if buffControl == 0 then\n                if moveType == 1 then\n                  buffType = 1 -- def\n                elseif moveType == 2 then\n                  buffType = 2 -- agi\n                end\n              else\n                buffType = buffControl\n              end\n              -- apply buff\n              releaseMod(1,buffNext,buffType)\n              chargeBuffTotal[2] = chargeBuffTotal[2] + buffNext\n              -- status info\n              if verbose>0 then\n                local buffMax = hybridVal(stanceBuff[2],getReleaseMod(maxCharge),1)\n                if buffType == 1 then\n                  ui.showMessage(stanceNames[1] .. ' ' .. tostring(chargeBuffTotal[2]) .. ' / ' .. tostring(buffMax))\n                else\n                  ui.showMessage(stanceNames[2] .. ' ' .. tostring(chargeBuffTotal[2]) .. ' / ' .. tostring(buffMax))\n                end\n              end\n              -- start release timer\n              async:newUnsavableSimulationTimer(\n                buffDuration,\n                function()\n                releaseMod(-1,chargeBuffTotal[2],buffType)\n                chargeBuffTotal[2] = 0\n                end\n              )\n            end\n          end\n        end\n      end\n    end\n  } \n}",
    "Solthas Combat Pack-52221-1-11-1717384986\\Solthas Combat Pack\\scripts\\SolJumpAirDash\\scripts\\SolJumpAirDash.lua": "local core = require('openmw.core')\nlocal ui = require('openmw.ui')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal async = require('openmw.async')\n\n-- handle settings\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\n\nI.Settings.registerPage({\n   key = 'SolJumpAirDash',\n   l10n = 'SolJumpAirDash',\n   name = 'name',\n   description = 'description',\n})\n\n-- default values!\nlocal enabled = true\nlocal verbose = false\nlocal requireLanding = true\nlocal dashOnEmpty = true -- 0 = allow dash if low fatigue (tradeoff damage on dash on empty), 1 = no dash on empty, damage when moving in air on empty\nlocal buffSpeed = 1000\nlocal statBreakeven = 50\nlocal fatigueCost = 20\nlocal buffDuration = 0.15\nlocal doHurt = true\nlocal hurtVal = 5\nlocal hurtWait = 2\nI.Settings.registerGroup({\n   key = 'Settings_SolJumpAirDash',\n   page = 'SolJumpAirDash',\n   l10n = 'SolJumpAirDash',\n   name = 'group_name',\n   permanentStorage = true,\n   settings = {\n      {\n         key = 'enabled',\n         default = enabled,\n         renderer = 'checkbox',\n         name = 'enabled_name',\n      },\n      {\n         key = 'verbose',\n         default = verbose,\n         renderer = 'checkbox',\n         name = 'verbose_name',\n      },\n      {\n         key = 'requireLanding',\n         default = requireLanding,\n         renderer = 'checkbox',\n         name = 'requireLanding_name',\n         description = 'requireLanding_description',\n      },\n      {\n         key = 'buffSpeed',\n         default = buffSpeed,\n         renderer = 'number',\n         name = 'buffSpeed_name',\n         description = 'buffSpeed_description',\n         argument = {\n            integer = true,\n            min = 1,\n            max = 10000,\n         },\n      },\n      {\n         key = 'statBreakeven',\n         default = statBreakeven,\n         renderer = 'number',\n         name = 'statBreakeven_name',\n         description = 'statBreakeven_description',\n         argument = {\n            integer = true,\n            min = 0,\n            max = 100,\n         },\n      },\n      {\n         key = 'fatigueCost',\n         default = fatigueCost,\n         renderer = 'number',\n         name = 'fatigueCost_name',\n         description = 'fatigueCost_description',\n         argument = {\n            min = 0,\n            max = 100,\n         },\n      },\n      {\n         key = 'buffDuration',\n         default = buffDuration,\n         renderer = 'number',\n         name = 'buffDuration_name',\n         description = 'buffDuration_description',\n         argument = {\n            min = 0.05,\n            max = 5,\n         },\n      },\n      {\n         key = 'doHurt',\n         default = doHurt,\n         renderer = 'checkbox',\n         name = 'doHurt_name',\n         description = 'doHurt_description',\n      },\n      {\n         key = 'hurtVal',\n         default = hurtVal,\n         renderer = 'number',\n         name = 'hurtVal_name',\n         description = 'hurtVal_description',\n         argument = {\n            integer = true,\n            min = 1,\n            max = 100,\n         },\n      },\n      {\n         key = 'hurtWait',\n         default = hurtWait,\n         renderer = 'number',\n         name = 'hurtWait_name',\n         description = 'hurtWait_description',\n         argument = {\n            integer = true,\n            min = 1,\n            max = 5,\n         },\n      },\n      {\n         key = 'dashOnEmpty',\n         default = dashOnEmpty,\n         renderer = 'checkbox',\n         name = 'dashOnEmpty_name',\n         description = 'dashOnEmpty_description',\n      },\n   },\n})\nlocal settingsGroup = storage.playerSection('Settings_SolJumpAirDash')\n\n-- initialize\nlocal scaleBuff = buffSpeed*statBreakeven/100\nlocal flatBuff = buffSpeed - scaleBuff\n-- update\nlocal function updateSettings()\n  enabled = settingsGroup:get('enabled')\n  verbose = settingsGroup:get('verbose')\n  requireLanding = settingsGroup:get('requireLanding')\n  buffSpeed = settingsGroup:get('buffSpeed')\n  statBreakeven = settingsGroup:get('statBreakeven')\n    scaleBuff = buffSpeed*statBreakeven/100\n    flatBuff = buffSpeed - scaleBuff\n  fatigueCost = settingsGroup:get('fatigueCost')\n  buffDuration = settingsGroup:get('buffDuration')\n  doHurt = settingsGroup:get('doHurt')\n  hurtVal = settingsGroup:get('hurtVal')\n  hurtWait = settingsGroup:get('hurtWait')\n  dashOnEmpty = settingsGroup:get('dashOnEmpty')\n  if not dashOnEmpty then\n    hurtVal = math.ceil(hurtVal/2)\n  end\nend\nlocal function init()\n    updateSettings()\nend\nsettingsGroup:subscribe(async:callback(updateSettings))\n\n-- shorthand for convenience\nlocal attributes = types.Actor.stats.attributes\nlocal skills = types.NPC.stats.skills\nlocal dynamic = types.Actor.stats.dynamic\n\n-- stance effects \nlocal function spdMod(modSign,modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    attributes.speed(self).modifier = math.max(0,attributes.speed(self).modifier + modSign*modVal)\n  else\n    modVal = math.abs(modVal)\n    attributes.speed(self).damage = math.max(0,attributes.speed(self).damage + modSign*modVal)\n  end\nend\n\n-- init stance total tracking, used for verbose outputs, and for onSave/onLoad tracking\nlocal buffTotal = 0\n-- save state to be removed on load\nlocal function onSave()\n    return{\n      buffTotal = buffTotal\n    }\nend\nlocal function onLoad(data)\n  if data then\n    buffTotal = data.buffTotal\n    spdMod(-1,buffTotal)\n    buffTotal = 0\n  end\nend\n\nlocal buffVal = 0\nlocal hurtTime = 0\nlocal lastHurt = 0\nlocal doBuff = true\nlocal didLand = true\nlocal landLogic = true\nlocal hurtLogic = true\nreturn { \n  engineHandlers = { \n    -- init settings\n    onActive = init,\n    -- save and load handling so you don't get stuck with modified stats\n    onSave = onSave,\n    onLoad = onLoad,\n    \n    onInputAction = function(id)\n      if enabled then\n        if id == input.ACTION.Jump then\n          if not types.Actor.isOnGround(self) and not types.Actor.isSwimming(self) then\n\t\t\tlandLogic = (didLand and requireLanding) or (not requireLanding)\n            if landLogic and doBuff then -- don't allow stacking?\n            --if true then -- allow stacking?\n              -- apply fatigue cost\n              local cfat = dynamic.fatigue(self).current\n\t\t\t  hurtLogic = true\n\t\t\t  if not dashOnEmpty and not (cfat >= fatigueCost) then\n\t\t        hurtLogic = false\n\t\t      end\n              if hurtLogic then -- only do buff if enough fatigue for it\n\t\t\t    if doHurt and dashOnEmpty and cfat < fatigueCost then\n\t\t\t\t  ui.showMessage('Low fatigue dash... That hurt!')\n\t\t\t\t  dynamic.health(self).current = math.max(0,dynamic.health(self).current - hurtVal) -- don't set to below 0\n\t\t\t\tend\n\t\t\t\t\n                doBuff = false\n                if requireLanding then\n                  didLand = false\n                end\n                dynamic.fatigue(self).current = math.max(0,cfat - fatigueCost)\n                -- apply buff\n\t\t\t\tbuffVal = flatBuff + scaleBuff*(skills.acrobatics(self).modified)/50\n                spdMod(1,buffVal)\n                buffTotal = buffTotal + buffVal\n          \n                if verbose then\n                  ui.showMessage('DASH!')\n                end\n      \n                -- start release timer\n                async:newUnsavableSimulationTimer(\n                buffDuration,\n                function()\n                  spdMod(-1,buffTotal)\n                  buffTotal = 0\n                  doBuff = true\n                end\n                )\n              end\n            end\n          end\n        end\n      end\n    end,\n\t\n    onUpdate = function(dt)\n\t  if requireLanding and not didLand then -- if you haven't landed but you need to\n\t    if types.Actor.isOnGround(self) then\n\t\t  didLand = true\n\t\tend\n\t  end\n\t  if enabled and doHurt and not dashOnEmpty then -- if running this calc\n\t\tif not types.Actor.isOnGround(self) and not types.Actor.isSwimming(self) then -- if in air\n\t\t  local mf = self.controls.movement\n\t\t  local ms = self.controls.sideMovement\n\t\t  if mf ~= 0 or ms ~= 0 then -- if moving\n\t\t\tif dynamic.fatigue(self).current < 1 then -- if out of fatigue\n\t\t\t  hurtTime = core.getSimulationTime() - lastHurt\n\t\t\t  if hurtTime > hurtWait then -- if enough time has passed\n\t\t\t\tui.showMessage('Air moving while out of fatigue!') -- other hurt message for dashing on empty is in above section.\n\t\t\t\tdynamic.health(self).current = math.max(0,dynamic.health(self).current - hurtVal) -- don't set to below 0\n\t\t\t\tlastHurt = core.getSimulationTime() -- get timer value\n\t\t\t  end\n\t\t\tend\n\t\t  end\n\t\tend\n\t  end\n    end,\n  } \n}",
    "Solthas Combat Pack-52221-1-11-1717384986\\Solthas Combat Pack\\scripts\\SolLoseMoreHealth\\scripts\\SolLoseMoreHealth.lua": "local core = require('openmw.core')\nlocal ui = require('openmw.ui')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal async = require('openmw.async')\n\n-- handle settings\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\n\nI.Settings.registerPage({\n   key = 'SolLoseMoreHealth',\n   l10n = 'SolLoseMoreHealth',\n   name = 'name',\n   description = 'description',\n})\n\n-- default values!\nlocal enabled = true\nlocal verbose = false\nlocal hurtOnGain = true\nlocal hurtPercent = 50\nlocal pctThreshold = 0.05\nI.Settings.registerGroup({\n   key = 'Settings_SolLoseMoreHealth',\n   page = 'SolLoseMoreHealth',\n   l10n = 'SolLoseMoreHealth',\n   name = 'group_name',\n   permanentStorage = false,\n   settings = {\n      {\n         key = 'enabled',\n         default = enabled,\n         renderer = 'checkbox',\n         name = 'enabled_name',\n      },\n      {\n         key = 'verbose',\n         default = verbose,\n         renderer = 'checkbox',\n         name = 'verbose_name',\n      },\n      {\n         key = 'hurtOnGain',\n         default = hurtOnGain,\n         renderer = 'checkbox',\n         name = 'hurtOnGain_name',\n         description = 'hurtOnGain_desc',\n      },\n      {\n         key = 'hurtPercent',\n         default = hurtPercent,\n         renderer = 'number',\n         name = 'hurtPercent_name',\n         description = 'hurtPercent_desc',\n         argument = {\n            min = 0,\n            max = 1000,\n         },\n      },\n      {\n         key = 'pctThreshold',\n         default = pctThreshold,\n         renderer = 'number',\n         name = 'pctThreshold_name',\n         description = 'pctThreshold_desc',\n         argument = {\n            min = 0,\n            max = 1,\n         },\n      },\n   },\n})\nlocal settingsGroup = storage.playerSection('Settings_SolLoseMoreHealth')\n\nhurtMult = {1,1} -- on hurt, on heal\n-- update\nlocal function updateSettings()\n  enabled = settingsGroup:get('enabled')\n  verbose = settingsGroup:get('verbose')\n  hurtOnGain = settingsGroup:get('hurtOnGain')\n  hurtPercent = settingsGroup:get('hurtPercent')\n\thurtMult[1] = 0.01*hurtPercent\n\thurtMult[2] = 1 - 1/(1+0.01*hurtPercent)\n  pctThreshold = settingsGroup:get('pctThreshold')\nend\nlocal function init()\n    updateSettings()\nend\nsettingsGroup:subscribe(async:callback(updateSettings))\n\n-- shorthand for convenience\nlocal dynamic = types.Actor.stats.dynamic\n\n-- init stance total tracking, used for verbose outputs, and for onSave/onLoad tracking\nlocal remainder = 0 \n-- save state to be removed on load\nlocal function onSave()\n    return{\n      remainder = remainder\n    }\nend\nlocal function onLoad(data)\n  if data then\n    remainder = data.remainder\n  end\nend\n\nlocal hurtOrder = 5\n\nlocal curHeal = 0\nlocal oldHeal = 0\nlocal oldMax = 0\nlocal curMax = 0\nlocal doHurt = false\nlocal delHeal = 0\nlocal hurtVal = 0\nlocal hurtApply = 0\nlocal hurtIdx = 1\nreturn { \n  engineHandlers = { \n    -- init settings\n    onActive = init,\n    -- save and load handling so you don't get stuck with modified stats\n    onSave = onSave,\n    onLoad = onLoad,\n    \n    onUpdate = function(dt)\n      if enabled then\n          curHeal = math.ceil(dynamic.health(self).current)\n      \n          if not doHurt then\n            if curHeal ~= oldHeal then -- if health changed check if max changed\n--              ui.printToConsole(tostring(curHeal) ..' '..tostring(oldHeal) ..' '..tostring(hurtVal),ui.CONSOLE_COLOR.Default)\n              if oldHeal == 0 then -- on very first frame get it proper\n                oldHeal = curHeal\n              end\n              curMax = math.ceil(dynamic.health(self).base)\n              if curMax ~= oldMax then\n                if oldMax == 0 then -- on very first frame get it proper\n                  oldMax = curMax\n                end\n                -- if current and old health rations are too similar, do nothing\n                if math.abs(1 - (curHeal/curMax*oldMax/oldHeal)) < pctThreshold then -- make threshold a setting\n                  doHurt = false\n                else\n                  doHurt = true\n                end\n              else\n                if curHeal < oldHeal then\n                  doHurt = true -- definitely hurt is lost health\n\t\t\t\t\thurtIdx = 1\n                --  ui.showMessage('hurt')\n                else\n                  doHurt = hurtOnGain -- make this a setting, to hurt if gained health?\n\t\t\t\t\thurtIdx = 2\n                --  ui.showMessage('heal- ' .. tostring(hurtOnGain))\n                end\n                -- update oldval for next frame\n                oldMax = curMax\n              end\n        \n              -- get updates prior to hurting or not\n              delHeal = math.abs(curHeal - oldHeal)\n              delHeal = (delHeal - math.abs(hurtVal))\n         --     ui.printToConsole(tostring(delHeal) .. ' ' .. tostring(hurtVal),ui.CONSOLE_COLOR.Default)\n\n              if doHurt then\n                if remainder ~= remainder or not remainder then -- if nan or nil\n                  remainder = 0\n                end\n        \n                -- include remainder from last hurt for total hurt val\n                hurtVal = hurtMult[hurtIdx]*delHeal\n\t\t\t\t\n\t\t\t\t-- debug on hurt val accumulation\n            --    ui.printToConsole(tostring(hurtVal) .. ' ' .. tostring(delHeal),ui.CONSOLE_COLOR.Default)\n\t\t\t\n                hurtVal = hurtVal + remainder\n                if hurtVal >= hurtOrder then\n            --    if hurtVal ~= 0 then -- this requires I use more logic to ceil if negative\n                  hurtApply = math.floor(hurtVal)\n\t\t\t\t  \n\t\t\t\t  -- debug on damage take\n\t\t\t\t  if verbose then\n                    ui.printToConsole(tostring(oldHeal) ..' -> '.. tostring(curHeal) ..' -> '.. tostring(curHeal - hurtApply),ui.CONSOLE_COLOR.Default)\n                  end\n\t\t\t\t  \n\t\t\t\t  -- now apply the hurt\n                  curHeal = math.max(0, curHeal - hurtApply) -- dead vs not dead\n                  dynamic.health(self).current = curHeal\n                 else\n                  hurtApply = 0\n                end\n            --    ui.printToConsole(tostring(remainder) ..' = '.. tostring(hurtVal) ..' - '.. tostring(hurtApply),ui.CONSOLE_COLOR.Default)\n                remainder = hurtVal - hurtApply\n                hurtVal = 0\n                doHurt = false\n              end\n              -- update oldval for next frame\n              oldHeal = curHeal\n            end\n          end\n      end\n    end\n\n  } \n}",
    "Solthas Combat Pack-52221-1-11-1717384986\\Solthas Combat Pack\\scripts\\SolModDiffResetStats\\scripts\\SolModDiffResetStats.lua": "local core = require('openmw.core')\nlocal ui = require('openmw.ui')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal async = require('openmw.async')\n\n-- settings functions\nlocal function boolSetting(sKey, sDef)\n    return {\n        key = sKey,\n        renderer = 'checkbox',\n        name = sKey..'_name',\n        description = sKey..'_desc',\n        default = sDef,\n    }\nend\nlocal function numbSetting(sKey, sDef, sInt, sMin, sMax)\n    return {\n        key = sKey,\n        renderer = 'number',\n        name = sKey..'_name',\n        description = sKey..'_desc',\n        default = sDef,\n    argument = {\n      integer = sInt,\n      min = sMin,\n      max = sMax,\n    },\n    }\nend\n-- handle settings\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\nI.Settings.registerPage({\n   key = 'SolModDiffResetStats',\n   l10n = 'SolModDiffResetStats',\n   name = 'name',\n   description = 'description',\n})\n-- default values!\nlocal doRun = false\nlocal raiseDifficulty = false\nlocal lowerDifficulty = false\nlocal difficultyMod = 0.2\nlocal damage = false\nlocal modifier = false\nI.Settings.registerGroup({\n   key = 'Settings_SolModDiffResetStats',\n   page = 'SolModDiffResetStats',\n   l10n = 'SolModDiffResetStats',\n   name = 'group_name',\n   permanentStorage = true,\n   settings = {\n\t\tboolSetting('doRun',doRun),\n\t\tboolSetting('raiseDifficulty',raiseDifficulty),\n\t\tboolSetting('lowerDifficulty',lowerDifficulty),\n\t\tnumbSetting('difficultyMod',difficultyMod, false,0,1),\n\t\tboolSetting('damage',damage),\n\t\tboolSetting('modifier',modifier),\n\t},\n})\n\nlocal settingsGroup = storage.playerSection('Settings_SolModDiffResetStats')\n\n-- shorthand for convenience\nlocal attributes = types.Actor.stats.attributes\nlocal skills = types.NPC.stats.skills\n\n-- init to defaults\nbaseMult = 1\n-- update\nlocal function updateSettings()\n  raiseDifficulty = settingsGroup:get('raiseDifficulty')\n  lowerDifficulty = settingsGroup:get('lowerDifficulty')\n  difficultyMod = settingsGroup:get('difficultyMod')\n  damage = settingsGroup:get('damage')\n  modifier = settingsGroup:get('modifier')\n  -- force run update\n  doRun = settingsGroup:get('doRun')\nend\nlocal function init()\n  updateSettings()\n  \n  -- change base stat modifier\n  baseMult = 1\n  if raiseDifficulty then\n  baseMult = baseMult / (1 + difficultyMod)\n  end\n  if lowerDifficulty then\n  baseMult = baseMult * (1 + difficultyMod)\n  end\n  if raiseDifficulty or lowerDifficulty then\n    -- update settings\n    raiseDifficulty = false\n    settingsGroup:set('raiseDifficulty',false)\n    lowerDifficulty = false\n    settingsGroup:set('lowerDifficulty',false)\n    -- update attributes\n    attributes.strength(self).base = math.floor(math.max(0,baseMult*attributes.strength(self).base))\n    attributes.intelligence(self).base = math.floor(math.max(0,baseMult*attributes.intelligence(self).base))\n    attributes.willpower(self).base = math.floor(math.max(0,baseMult*attributes.willpower(self).base))\n    attributes.agility(self).base = math.floor(math.max(0,baseMult*attributes.agility(self).base))\n    attributes.speed(self).base = math.floor(math.max(0,baseMult*attributes.speed(self).base))\n    attributes.endurance(self).base = math.floor(math.max(0,baseMult*attributes.endurance(self).base))\n    attributes.personality(self).base = math.floor(math.max(0,baseMult*attributes.personality(self).base))\n    attributes.luck(self).base = math.floor(math.max(0,baseMult*attributes.luck(self).base))\n    -- update skills\n    --combat\n    skills.armorer(self).base = math.floor(math.max(0,baseMult*skills.armorer(self).base))\n    skills.athletics(self).base = math.floor(math.max(0,baseMult*skills.athletics(self).base))\n    skills.axe(self).base = math.floor(math.max(0,baseMult*skills.axe(self).base))\n    skills.block(self).base = math.floor(math.max(0,baseMult*skills.block(self).base))\n    skills.bluntweapon(self).base = math.floor(math.max(0,baseMult*skills.bluntweapon(self).base))\n    skills.heavyarmor(self).base = math.floor(math.max(0,baseMult*skills.heavyarmor(self).base))\n    skills.longblade(self).base = math.floor(math.max(0,baseMult*skills.longblade(self).base))\n    skills.mediumarmor(self).base = math.floor(math.max(0,baseMult*skills.mediumarmor(self).base))\n    skills.spear(self).base = math.floor(math.max(0,baseMult*skills.spear(self).base))\n    --magic\n    skills.alchemy(self).base = math.floor(math.max(0,baseMult*skills.alchemy(self).base))\n    skills.alteration(self).base = math.floor(math.max(0,baseMult*skills.alteration(self).base))\n    skills.conjuration(self).base = math.floor(math.max(0,baseMult*skills.conjuration(self).base))\n    skills.destruction(self).base = math.floor(math.max(0,baseMult*skills.destruction(self).base))\n    skills.enchant(self).base = math.floor(math.max(0,baseMult*skills.enchant(self).base))\n    skills.illusion(self).base = math.floor(math.max(0,baseMult*skills.illusion(self).base))\n    skills.mysticism(self).base = math.floor(math.max(0,baseMult*skills.mysticism(self).base))\n    skills.restoration(self).base = math.floor(math.max(0,baseMult*skills.restoration(self).base))\n    skills.unarmored(self).base = math.floor(math.max(0,baseMult*skills.unarmored(self).base))\n    --stealth\n    skills.acrobatics(self).base = math.floor(math.max(0,baseMult*skills.acrobatics(self).base))\n    skills.handtohand(self).base = math.floor(math.max(0,baseMult*skills.handtohand(self).base))\n    skills.lightarmor(self).base = math.floor(math.max(0,baseMult*skills.lightarmor(self).base))\n    skills.marksman(self).base = math.floor(math.max(0,baseMult*skills.marksman(self).base))\n    skills.mercantile(self).base = math.floor(math.max(0,baseMult*skills.mercantile(self).base))\n    skills.security(self).base = math.floor(math.max(0,baseMult*skills.security(self).base))\n    skills.shortblade(self).base = math.floor(math.max(0,baseMult*skills.shortblade(self).base))\n    skills.sneak(self).base = math.floor(math.max(0,baseMult*skills.sneak(self).base))\n    skills.speechcraft(self).base = math.floor(math.max(0,baseMult*skills.speechcraft(self).base))\n  end\n  \n  -- debug case... resetting all relevant modifiers\n  if damage then\n    -- update settings\n    damage = false\n    settingsGroup:set('damage',false)\n    -- update attributes\n    attributes.strength(self).damage = 0\n    attributes.intelligence(self).damage = 0\n    attributes.willpower(self).damage = 0\n    attributes.agility(self).damage = 0\n    attributes.speed(self).damage = 0\n    attributes.endurance(self).damage = 0\n    attributes.personality(self).damage = 0\n    attributes.luck(self).damage = 0\n    -- update skills\n    --combat\n    skills.armorer(self).damage = 0\n    skills.athletics(self).damage = 0\n    skills.axe(self).damage = 0\n    skills.block(self).damage = 0\n    skills.bluntweapon(self).damage = 0\n    skills.heavyarmor(self).damage = 0\n    skills.longblade(self).damage = 0\n    skills.mediumarmor(self).damage = 0\n    skills.spear(self).damage = 0\n    --magic\n    skills.alchemy(self).damage = 0\n    skills.alteration(self).damage = 0\n    skills.conjuration(self).damage = 0\n    skills.destruction(self).damage = 0\n    skills.enchant(self).damage = 0\n    skills.illusion(self).damage = 0\n    skills.mysticism(self).damage = 0\n    skills.restoration(self).damage = 0\n    skills.unarmored(self).damage = 0\n    --stealth\n    skills.acrobatics(self).damage = 0\n    skills.handtohand(self).damage = 0\n    skills.lightarmor(self).damage = 0\n    skills.marksman(self).damage = 0\n    skills.mercantile(self).damage = 0\n    skills.security(self).damage = 0\n    skills.shortblade(self).damage = 0\n    skills.sneak(self).damage = 0\n    skills.speechcraft(self).damage = 0\n  end\n\n  if modifier then\n    -- update settings\n    modifier = false\n    settingsGroup:set('modifier',false)\n    -- update attributes\n    attributes.strength(self).modifier = 0\n    attributes.intelligence(self).modifier = 0\n    attributes.willpower(self).modifier = 0\n    attributes.agility(self).modifier = 0\n    attributes.speed(self).modifier = 0\n    attributes.endurance(self).modifier = 0\n    attributes.personality(self).modifier = 0\n    attributes.luck(self).modifier = 0\n    -- update skills\n    --combat\n    skills.armorer(self).modifier = 0\n    skills.athletics(self).modifier = 0\n    skills.axe(self).modifier = 0\n    skills.block(self).modifier = 0\n    skills.bluntweapon(self).modifier = 0\n    skills.heavyarmor(self).modifier = 0\n    skills.longblade(self).modifier = 0\n    skills.mediumarmor(self).modifier = 0\n    skills.spear(self).modifier = 0\n    --magic\n    skills.alchemy(self).modifier = 0\n    skills.alteration(self).modifier = 0\n    skills.conjuration(self).modifier = 0\n    skills.destruction(self).modifier = 0\n    skills.enchant(self).modifier = 0\n    skills.illusion(self).modifier = 0\n    skills.mysticism(self).modifier = 0\n    skills.restoration(self).modifier = 0\n    skills.unarmored(self).modifier = 0\n    --stealth\n    skills.acrobatics(self).modifier = 0\n    skills.handtohand(self).modifier = 0\n    skills.lightarmor(self).modifier = 0\n    skills.marksman(self).modifier = 0\n    skills.mercantile(self).modifier = 0\n    skills.security(self).modifier = 0\n    skills.shortblade(self).modifier = 0\n    skills.sneak(self).modifier = 0\n    skills.speechcraft(self).modifier = 0\n  end\n  \nend\nsettingsGroup:subscribe(async:callback(updateSettings))\n\nreturn { \n  engineHandlers = { \n    onActive = init,\n    onInputAction = function(id)\n      if doRun then\n        if id == input.ACTION.GameMenu or id == input.ACTION.Use then\n          doRun = false\n          settingsGroup:set('doRun',false) -- turn off here to prevent recursion with init()\n          init()\n        end\n      end\n    end\n  }\n}",
    "Solthas Combat Pack-52221-1-11-1717384986\\Solthas Combat Pack\\scripts\\SolSneakAttackBuff\\scripts\\SolSneakAttackBuff.lua": "local ui = require('openmw.ui')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal async = require('openmw.async')\n\n-- settings functions\nlocal function boolSetting(sKey, sDef)\n    return {\n        key = sKey,\n        renderer = 'checkbox',\n        name = sKey..'_name',\n        description = sKey..'_desc',\n        default = sDef,\n    }\nend\nlocal function numbSetting(sKey, sDef, sInt, sMin, sMax)\n    return {\n        key = sKey,\n        renderer = 'number',\n        name = sKey..'_name',\n        description = sKey..'_desc',\n        default = sDef,\n    argument = {\n      integer = sInt,\n      min = sMin,\n      max = sMax,\n    },\n    }\nend\n-- handle settings\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\nI.Settings.registerPage({\n   key = 'SolSneakAttackBuff',\n   l10n = 'SolSneakAttackBuff',\n   name = 'name',\n   description = 'description',\n})\n-- default values!\nlocal enabled = true\nlocal verbose = false\nlocal buffBase = 1\nlocal fatigueMult = 1\nlocal doSpeedRelease = true\nlocal maxCharge = 2.5\nlocal buffDuration = 2.0\nI.Settings.registerGroup({\n  key = 'Settings_SolSneakAttackBuff',   page = 'SolSneakAttackBuff',\n  l10n = 'SolSneakAttackBuff',\n  name = 'group_name',\n  permanentStorage = true,\n  settings = {\n    boolSetting('enabled',enabled),\n    boolSetting('verbose',verbose),\n    numbSetting('buffBase',buffBase, false,0,2),\n    numbSetting('fatigueMult',fatigueMult, false,0,2),\n    boolSetting('doSpeedRelease',doSpeedRelease),\n    numbSetting('maxCharge',maxCharge, false,1,5),\n    numbSetting('buffDuration',buffDuration, false,0.25,5),\n   },\n})\n\nlocal settingsGroup = storage.playerSection('Settings_SolSneakAttackBuff')\n\n-- shorthand for convenience\nlocal Weapon = types.Weapon\nlocal attributes = types.Actor.stats.attributes\nlocal skills = types.NPC.stats.skills\nlocal dynamic = types.Actor.stats.dynamic\n\n-- reduce effectiveness of hybrid stances\nlocal function hybridVal(base,mult,count)\n    return math.ceil(base*math.pow(mult,math.max(count,0)))\nend\n\n-- update\nlocal function updateSettings()\n  enabled = settingsGroup:get('enabled')\n  verbose = settingsGroup:get('verbose')\n  buffBase = settingsGroup:get('buffBase')\n  fatigueMult = settingsGroup:get('fatigueMult')\n  doSpeedRelease = settingsGroup:get('doSpeedRelease')\n  maxCharge = settingsGroup:get('maxCharge')\n  buffDuration = settingsGroup:get('buffDuration')\nend\nlocal function init()\n    updateSettings()\nend\nsettingsGroup:subscribe(async:callback(updateSettings))\n\n-- stance effects \nlocal function releaseMod(modSign,modVal)\n  if doSpeedRelease then\n    if modSign > 0 then -- expect positive modsign on application of effect\n      input.setControlSwitch(input.CONTROL_SWITCH.Controls,false) -- if buffing, stop movement\n    elseif modSign <= 0 then\n      input.setControlSwitch(input.CONTROL_SWITCH.Controls,true) -- if unbuffing, release movement\n    end\n  end\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    attributes.strength(self).modifier = math.max(0,attributes.strength(self).modifier + modSign*modVal)\n  else\n    modVal = math.abs(modVal)\n    attributes.strength(self).damage = math.max(0,attributes.strength(self).damage + modSign*modVal)\n  end\nend\n\n-- init stance total tracking, used for verbose outputs, and for onSave/onLoad tracking\nlocal chargeBuffTotal = 0\nlocal function weaponCheck()\n  local weaponMult = 0 -- modifier to buff\n  if types.Actor.stance(self) == types.Actor.STANCE.Weapon then\n    local usedWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n    if (not usedWeapon) then -- handtohand\n      weaponMult = 2\n    else\n      if  not types.Lockpick.objectIsInstance(usedWeapon) and not types.Probe.objectIsInstance(usedWeapon) then\n        local weaponType = Weapon.record(usedWeapon).type\n        if (weaponType == 0) then -- short blade\n          weaponMult = 1.75\n        elseif (weaponType <= 8) then -- other melee weapon\n          weaponMult = 1\n        elseif (weaponType == 9) then -- ranged weapon-bow\n          weaponMult = 1.75\n        elseif (weaponType == 10) then -- ranged weapon-crossbow\n          weaponMult = 1.5\n        elseif (weaponType == 11) then -- ranged weapon-throwing\n          weaponMult = 2\n        elseif (weaponType > 13) then -- unknown weapon\n          weaponMult = 1\n        end\n      end\n    end \n  end\n  return(weaponMult)\nend\n\n-- save state to be removed on load\nlocal function onSave()\n    return{\n      chargeBuffTotal = chargeBuffTotal\n    }\nend\n\nlocal function onLoad(data)\n  if data then\n    chargeBuffTotal = data.chargeBuffTotal\n    releaseMod(-1,chargeBuffTotal)\n  end\nend\n\nlocal chargeTime = 0\nlocal doBuff = false\nlocal isCharge = false -- true if trigger input action\nlocal weaponMult = false\nreturn { \n  engineHandlers = { \n    -- init settings\n    onActive = init,\n    -- save and load handling so you don't get stuck with modified stats\n    onSave = onSave,\n    onLoad = onLoad,\n    \n    onUpdate = function(dt)\n      if enabled then\n        local isUse = input.isActionPressed(input.ACTION.Use)\n        \n        local isSneak = self.controls.sneak -- 0.49 sneak check\n        if isSneak == nil then\n            isSneak = input.isActionPressed(input.ACTION.Sneak) -- 0.48 sneak check\n        end\n    \n        if isUse and not isCharge then -- on first frame you hit use        \n          isCharge = true -- update stance\n          weaponMult = weaponCheck()\n          -- apply charge debuff\n          if weaponMult > 0 then\n            chargeTime = 0 -- set timer value\n          end\n          \n        -- do I really need to check every frame it's charging just to let you know when you can release?\n        elseif isUse and isCharge and isSneak and not doBuff then -- if currently charging\n          if weaponMult>0 then\n            chargeTime = chargeTime + dt -- increment timer only if sneaking\n            if chargeTime >= maxCharge then \n              doBuff = true\n              ui.showMessage('Sneak attack buff ready!')\n            end\n          end\n          \n        elseif not isUse and isCharge and isSneak then -- on first frame you release use\n          isCharge = false\n          if weaponMult>0 and chargeBuffTotal==0 then -- only buff if unbuffed\n            if doBuff then\n              -- get release buff\n              local buffNext = hybridVal(skills.sneak(self).modified,(weaponMult*buffBase),1) -- modify strength by your sneak skill x your weapon multiplier\n              -- apply buff\n              releaseMod(1,buffNext)\n              chargeBuffTotal = chargeBuffTotal + buffNext\n\t\t\t  -- fatigue cost\n\t\t\t  local cfat = dynamic.fatigue(self).current\n\t\t\t  local fatigueCost = math.ceil(fatigueMult*math.sqrt(buffNext))\n\t\t\t  -- don't set fatigue here, because buffing strength will mess it up anyway\n              -- status info\n              if verbose then\n                  ui.showMessage('Sneak Attack x' .. tostring(weaponMult) .. ': STR + ' .. tostring(chargeBuffTotal))\n              end\n              -- start release timer\n              async:newUnsavableSimulationTimer(\n                buffDuration,\n                function()\n                  releaseMod(-1,chargeBuffTotal)\n                  chargeBuffTotal = 0\n                  doBuff = false --reset buff counter\n                  dynamic.fatigue(self).current = math.max(0,cfat - fatigueCost)\n                end\n              )\n            end\n          end\n        end\n      end\n    end\n  }\n}",
    "Solthas Combat Pack-52221-1-11-1717384986\\Solthas Combat Pack\\scripts\\SolSneakJumpDodge\\scripts\\SolSneakJumpDodge.lua": "local ui = require('openmw.ui')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal async = require('openmw.async')\n\n-- handle settings\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\n\nI.Settings.registerPage({\n   key = 'SolSneakJumpDodge',\n   l10n = 'SolSneakJumpDodge',\n   name = 'name',\n   description = 'description',\n})\n\n-- default values!\nlocal enabled = true\nlocal verbose = true -- 0 none, 1 stance name, 2 stance stats, 3 consoleDebugInfo\nlocal allowInAir = false\nlocal buffArmor = 10000\nlocal buffSpeed = 500\nlocal fatigueCost = 50\nlocal buffDuration = 0.5\nI.Settings.registerGroup({\n   key = 'Settings_SolSneakJumpDodge',\n   page = 'SolSneakJumpDodge',\n   l10n = 'SolSneakJumpDodge',\n   name = 'group_name',\n   permanentStorage = true,\n   settings = {\n      {\n         key = 'enabled',\n         default = enabled,\n         renderer = 'checkbox',\n         name = 'enabled_name',\n      },\n      {\n         key = 'verbose',\n         default = verbose,\n         renderer = 'checkbox',\n         name = 'verbose_name',\n      },\n      {\n         key = 'allowInAir',\n         default = allowInAir,\n         renderer = 'checkbox',\n         name = 'allowInAir_name',\n      },\n      {\n         key = 'buffArmor',\n         default = buffArmor,\n         renderer = 'number',\n         name = 'buffArmor_name',\n         description = 'buffArmor_description',\n         argument = {\n            integer = true,\n            min = 1,\n            max = 100000,\n         },\n      },\n      {\n         key = 'buffSpeed',\n         default = buffSpeed,\n         renderer = 'number',\n         name = 'buffSpeed_name',\n         description = 'buffSpeed_description',\n         argument = {\n            integer = true,\n            min = 1,\n            max = 1000,\n         },\n      },\n      {\n         key = 'fatigueCost',\n         default = fatigueCost,\n         renderer = 'number',\n         name = 'fatigueCost_name',\n         description = 'fatigueCost_description',\n         argument = {\n            min = 0,\n            max = 100,\n         },\n      },\n      {\n         key = 'buffDuration',\n         default = buffDuration,\n         renderer = 'number',\n         name = 'buffDuration_name',\n         description = 'buffDuration_description',\n         argument = {\n            min = 0.1,\n            max = 5,\n         },\n      },\n   },\n})\nlocal settingsGroup = storage.playerSection('Settings_SolSneakJumpDodge')\n\n-- update\nlocal function updateSettings()\n  enabled = settingsGroup:get('enabled')\n  verbose = settingsGroup:get('verbose')\n  allowInAir = settingsGroup:get('allowInAir')\n  buffArmor = settingsGroup:get('buffArmor')\n  buffSpeed = settingsGroup:get('buffSpeed')\n  fatigueCost = settingsGroup:get('fatigueCost')\n  buffDuration = settingsGroup:get('buffDuration')\nend\nlocal function init()\n    updateSettings()\nend\nsettingsGroup:subscribe(async:callback(updateSettings))\n\n-- shorthand for convenience\nlocal attributes = types.Actor.stats.attributes\nlocal skills = types.NPC.stats.skills\nlocal dynamic = types.Actor.stats.dynamic\n\n-- stance effects \nlocal function phyMod(modSign,modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    skills.heavyarmor(self).modifier = math.max(0,skills.heavyarmor(self).modifier + modSign*modVal)\n    skills.lightarmor(self).modifier = math.max(0,skills.lightarmor(self).modifier + modSign*modVal)\n    skills.mediumarmor(self).modifier = math.max(0,skills.mediumarmor(self).modifier + modSign*modVal)\n    skills.unarmored(self).modifier = math.max(0,skills.unarmored(self).modifier + modSign*modVal)\n  else\n    modVal = math.abs(modVal)\n    skills.heavyarmor(self).damage = math.max(0,skills.heavyarmor(self).damage + modSign*modVal)\n    skills.lightarmor(self).damage = math.max(0,skills.lightarmor(self).damage + modSign*modVal)\n    skills.mediumarmor(self).damage = math.max(0,skills.mediumarmor(self).damage + modSign*modVal)\n    skills.unarmored(self).damage = math.max(0,skills.unarmored(self).damage + modSign*modVal)\n  end\nend\nlocal function spdMod(modSign,modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    attributes.speed(self).modifier = math.max(0,attributes.speed(self).modifier + modSign*modVal)\n    attributes.agility(self).modifier = math.max(0,attributes.agility(self).modifier + modSign*modVal)\n  else\n    modVal = math.abs(modVal)\n    attributes.speed(self).damage = math.max(0,attributes.speed(self).damage + modSign*modVal)\n    attributes.agility(self).damage = math.max(0,attributes.agility(self).damage + modSign*modVal)\n  end\nend\n\n-- init stance total tracking, used for verbose outputs, and for onSave/onLoad tracking\nlocal buffTotal = {0,0}\n-- save state to be removed on load\nlocal function onSave()\n    return{\n      buffTotal = buffTotal\n    }\nend\nlocal function onLoad(data)\n  if data then\n    buffTotal = data.buffTotal\n    phyMod(-1,buffTotal[1])\n    spdMod(-1,buffTotal[2])\n    buffTotal = {0,0}\n  end\nend\n\nlocal cfat = 0\nlocal doBuff = true\nreturn { \n  engineHandlers = { \n    -- init settings\n    onActive = init,\n    -- save and load handling so you don't get stuck with modified stats\n    onSave = onSave,\n    onLoad = onLoad,\n  \n    onUpdate = function(dt)\n      if not doBuff then -- if stop sneaking when currently buffed, debuff\n        local isSneak = self.controls.sneak -- 0.49 sneak check\n        if isSneak == nil then\n          isSneak = input.isActionPressed(input.ACTION.Sneak) -- 0.48 sneak check\n        end\n        if not isSneak then        \n          phyMod(-1,buffTotal[1])\n          spdMod(-1,buffTotal[2])\n          buffTotal = {0,0}\n          doBuff = true\n          dynamic.fatigue(self).current = cfat - fatigueCost\n        end\n      end\n    end,\n    \n    onInputAction = function(id)\n      if enabled then\n        if id == input.ACTION.Jump then\n        \n          local isSneak = self.controls.sneak -- 0.49 sneak check\n          if isSneak == nil then\n            isSneak = input.isActionPressed(input.ACTION.Sneak) -- 0.48 sneak check\n          end\n      \n          if not allowInAir and not types.Actor.isOnGround(self) then\n            isSneak = false\n          end\n\n          if isSneak then\n            if doBuff then\n              -- apply fatigue cost\n              cfat = dynamic.fatigue(self).current\n              if cfat >= fatigueCost then -- only do buff if enough fatigue for it\n                doBuff = false\n                dynamic.fatigue(self).current = cfat - fatigueCost\n                -- apply buff\n                phyMod(1,buffArmor)\n                spdMod(1,buffSpeed)\n                buffTotal[1] = buffTotal[1] + buffArmor\n                buffTotal[2] = buffTotal[2] + buffSpeed\n          \n                if verbose then\n                  ui.showMessage('DODGE!')\n                end\n      \n                -- start release timer\n                async:newUnsavableSimulationTimer(\n                buffDuration,\n                function()\n                  phyMod(-1,buffTotal[1])\n                  spdMod(-1,buffTotal[2])\n                  buffTotal = {0,0}\n                  doBuff = true\n                  dynamic.fatigue(self).current = cfat - fatigueCost\n                end\n                )\n              end\n            end\n          end\n        end\n      end\n    end,\n  } \n}",
    "Solthas Combat Pack-52221-1-11-1717384986\\Solthas Combat Pack\\scripts\\SolSneakStepDrain\\scripts\\SolSneakStepDrain.lua": "local ui = require('openmw.ui')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal async = require('openmw.async')\n-- shorthand for convenience\nlocal attributes = types.Actor.stats.attributes\nlocal skills = types.NPC.stats.skills\n\n-- settings functions\nlocal function boolSetting(sKey, sDef)\n  return {\n    key = sKey,\n    renderer = 'checkbox',\n    name = sKey .. '_name',\n    description = sKey .. '_desc',\n    default = sDef,\n  }\nend\nlocal function numbSetting(sKey, sDef, sInt, sMin, sMax)\n  return {\n    key = sKey,\n    renderer = 'number',\n    name = sKey .. '_name',\n    description = sKey .. '_desc',\n    default = sDef,\n    argument = {\n      integer = sInt,\n      min = sMin,\n      max = sMax,\n    },\n  }\nend\n-- handle settings\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\nI.Settings.registerPage({\n  key = 'SolSneakStepDrain',\n  l10n = 'SolSneakStepDrain',\n  name = 'name',\n  description = 'description',\n})\n-- default values!\nlocal enabled = true\nlocal verbose = false\nlocal uiShow = true\nlocal allowDebuff = true\nlocal buffBase = 0.5\nlocal maxDrain = 9.0\nlocal maxCharge = 3.0\nlocal chargeInterval = 0.5\nlocal uiXcoord = 0.0\nlocal uiYcoord = 1.0\nlocal uiLength = 72\nI.Settings.registerGroup({\n  key = 'Settings_SolSneakStepDrain',\n  page = 'SolSneakStepDrain',\n  l10n = 'SolSneakStepDrain',\n  name = 'group_name',\n  permanentStorage = true,\n  settings = {\n    boolSetting('enabled', enabled),\n    boolSetting('verbose', verbose),\n    boolSetting('uiShow', uiShow),\n    boolSetting('allowDebuff', allowDebuff),\n    numbSetting('buffBase', buffBase, false, 0.1, 2.0),\n    numbSetting('maxCharge', maxCharge, false, 1.0, 20.0),\n    numbSetting('maxDrain', maxDrain, false, 1.0, 20.0),\n    numbSetting('chargeInterval', chargeInterval, false, 0.1, 1.0),\n    numbSetting('uiXcoord', uiXcoord, false, 0.0, 1.0),\n    numbSetting('uiYcoord', uiYcoord, false, 0.0, 1.0),\n    numbSetting('uiLength', uiLength, true, 10, 1000),\n  },\n})\nlocal settingsGroup = storage.playerSection('Settings_SolSneakStepDrain')\n\n\n-- ui junk -- adapted from AttendMe\\scripts\\AttendMe\\hud.lua\nlocal isSneak = false\nlocal util = require('openmw.util')\nlocal uiElement = nil\n-- setup ui table thing\nlocal statSize = util.vector2(61, 8)\nlocal statTexture = ui.texture({ path = 'textures/menu_bar_gray.dds' })\nlocal statColors = util.color.rgb(250 / 255, 250 / 255, 100 / 255) -- bright yellow\nlocal uiLayout = {\n  layer = 'HUD',\n  name = 'sneakBar',\n  template = I.MWUI.templates.boxTransparent,\n  props = {},\n  content = ui.content({\n    {\n      name = 'box',\n      props = {\n        size = statSize,\n      },\n      content = ui.content({\n        {\n          name = 'image',\n          type = ui.TYPE.Image,\n          props = {\n            size = statSize,\n            resource = statTexture,\n            color = statColors,\n            arrange = ui.ALIGNMENT.Start,\n          },\n        },\n      }),\n    },\n  }),\n}\n-- position in bottom left\nlocal hudPosition = util.vector2(0.0, 1.0)\nuiLayout.props.relativePosition = hudPosition\nuiLayout.props.anchor = hudPosition\n--uiLayout.props.position = (util.vector2(1, 1) - hudPosition * 2)\nuiLayout.props.position = (util.vector2(1, 1) - hudPosition * 2):emul(util.vector2(13 + 61 + 8, 12 + 15 * 3))\nlocal function updateUI(current, max)\n  -- update bar size\n  uiLayout.content.box.content.image.props.size = statSize:emul(util.vector2(math.abs((current + max) / (2 * max)), 1)) -- no outline\n  -- ui element update / create / destroy logic\n  if enabled and ((current ~= 0) or (isSneak and current == 0)) then\n    if uiElement then\n      uiElement:update()\n    else\n      uiElement = ui.create(uiLayout)\n    end\n  else\n    if uiElement then\n      uiElement:destroy()\n    end\n    uiElement = nil\n  end\nend\n\n-- okayyyyyyyyyyy back to settings now that I've initialized the ui element\n-- update settings\nlocal function updateSettings()\n  enabled = settingsGroup:get('enabled')\n  verbose = settingsGroup:get('verbose')\n  uiShow = settingsGroup:get('uiShow')\n  allowDebuff = settingsGroup:get('allowDebuff')\n  buffBase = settingsGroup:get('buffBase')\n  maxDrain = settingsGroup:get('maxDrain')\n  maxCharge = settingsGroup:get('maxCharge')\n  chargeInterval = settingsGroup:get('chargeInterval')\n  -- update ui settings...\n  uiLength = settingsGroup:get('uiLength')\n  statSize = util.vector2(uiLength, 8)\n  uiLayout.content.box.props.size = statSize\n  uiLayout.content.box.content.image.props.size = statSize\n  uiXcoord = settingsGroup:get('uiXcoord')\n  uiYcoord = settingsGroup:get('uiYcoord')\n  hudPosition = util.vector2(uiXcoord, uiYcoord)\n  uiLayout.props.relativePosition = hudPosition\n  uiLayout.props.anchor = hudPosition\n  if uiXcoord == 0.0 and uiYcoord == 1.0 then\n    uiLayout.props.position = (util.vector2(1, 1) - hudPosition * 2):emul(util.vector2(13 + 61 + 8, 12 + 15 * 3))\n  else\n    uiLayout.props.position = (util.vector2(1, 1) - hudPosition * 2)\n  end\nend\nlocal function init()\n  updateSettings()\nend\nsettingsGroup:subscribe(async:callback(updateSettings))\n\n-- stance effects\nlocal function sneakMod(modSign, modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    skills.sneak(self).modifier = math.max(0, skills.sneak(self).modifier + modSign * modVal)\n  elseif modVal < 0 then\n    modVal = math.abs(modVal)\n    skills.sneak(self).damage = math.max(0, skills.sneak(self).damage + modSign * modVal)\n  end\nend\n-- get effect of armor etc\nlocal function getWeights()\n  -- get athletics and acrobatics, which help you move quietly\n  local acrob = skills.acrobatics(self).modified\n  local athle = skills.athletics(self).modified\n\n  -- shoes\n  local weightBoots = 0 -- if nothing equipped\n  local weightPants = 0\n  local weightShirt = 0\n  local armorRatio = 0.7 -- fraction for armor, 1-it is fraction for weapon\n  local ratioBoots = 0.6 -- overall fraction: boots\n  local ratioPants = 0.2 -- pants\n  local ratioShirt = 0.2 -- shirt\n  -- armor and clothing records aren't implemented yet in 0.48, so let's test.\n  -- shoes\n  local recordBoots = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.Boots)\n  if recordBoots == nil then                 -- wearing nothing in slot\n    -- no modification\n  elseif recordBoots.type.record == nil then -- 0.48 check\n    -- find a 0.48 viable workaround.\n    ratioBoots = 0.5 * ratioBoots            -- lower ratio because lower confidence\n    weightBoots = 20                         -- assume weight\n  else\n    if recordBoots then                      -- I don't think I need this since I'm checking for it above\n      weightBoots = recordBoots.type.record(recordBoots).weight\n    end\n  end\n  -- pants\n  local recordPants = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.Greaves)\n  -- Due to limited 0.48 functionality where I'll get slot overlap on assuming the armor slot's weight, I will comment this section out.\n  --if recordPants == nil then -- if no greaves, try pants\n  --  recordPants = types.Actor.equipment(self,types.Actor.EQUIPMENT_SLOT.Pants)\n  --end\n  -- what about skirt?\n  if recordPants == nil then                 -- wearing nothing in slot\n    -- no modification\n  elseif recordPants.type.record == nil then -- 0.48 check\n    -- find a 0.48 viable workaround.\n    ratioPants = 0.5 * ratioPants            -- lower ratio because lower confidence\n    weightPants = 20                         -- assume weight\n  else\n    if recordPants then\n      weightPants = recordPants.type.record(recordPants).weight\n    end\n  end\n  -- shirt\n  local recordShirt = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.Cuirass)\n  -- Due to limited 0.48 functionality where I'll get slot overlap on assuming the armor slot's weight, I will comment this section out.\n  --if recordShirt == nil then -- if no cuirass, try shirt\n  --  recordShirt = types.Actor.equipment(self,types.Actor.EQUIPMENT_SLOT.Shirt)\n  --end\n  -- what about robe?\n  if recordShirt == nil then                 -- wearing nothing in slot\n    -- no modification\n  elseif recordShirt.type.record == nil then -- 0.48 check\n    -- find a 0.48 viable workaround.\n    ratioShirt = 0.5 * ratioShirt            -- lower ratio because lower confidence\n    weightShirt = 20                         -- assume weight\n  else\n    if recordShirt then\n      weightShirt = recordShirt.type.record(recordShirt).weight\n    end\n  end\n  -- recalculate total armor ratio, for sake of weapon\n  armorRatio = armorRatio * (ratioBoots + ratioPants + ratioShirt)\n\n  -- if weapon out, get weight of weapon\n  local weightWeapon = 0 -- none, or handtohand\n  if types.Actor.stance(self) == types.Actor.STANCE.Weapon then\n    local recordWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n    if recordWeapon then\n      if not types.Lockpick.objectIsInstance(recordWeapon) and not types.Probe.objectIsInstance(recordWeapon) then\n        weightWeapon = types.Weapon.record(recordWeapon).weight\n      end\n    end\n  end\n\n  -- get total modifier / multiplier for each\n  local modArmor = math.sqrt(1 + ratioBoots * weightBoots + ratioPants * weightPants + ratioShirt * weightShirt)\n  local modWeapon = math.sqrt(1 + weightWeapon)\n  local modAcrob = 100 / (acrob + 50)\n  local modAthle = 100 / (athle + 50)\n  return (armorRatio * modArmor + (1 - armorRatio) * modWeapon) * modAcrob * modAthle\nend\n\nlocal buffTotal = 0\n-- save state to be removed on load\nlocal function onSave()\n  return {\n    buffTotal = buffTotal\n  }\nend\nlocal function onLoad(data)\n  if data then\n    buffTotal = data.buffTotal\n    sneakMod(-1, buffTotal)\n  end\nend\n\nlocal tickCounter = 0\nlocal chargeTime = 0\nlocal chargeHit = false\nlocal buffType = 0\nlocal perTick = 0\nlocal maxMod = 0\nlocal showVerbose = { 1, 0, 1 } -- min, neutral, max -- do not start by showing neutral, as that would trigger immediately\nreturn {\n  engineHandlers = {\n    -- init settings\n    onActive = init,\n    -- save and load handling so you don't get stuck with modified stats\n    onSave = onSave,\n    onLoad = onLoad,\n\n    onUpdate = function(dt)\n      if uiShow then\n        if chargeHit then -- only update ui if chargetime triggered\n          updateUI(buffTotal, maxMod)\n        end\n      else\n        if uiElement then\n          uiElement:destroy()\n        end\n        uiElement = nil\n      end\n\n      if enabled then\n        isSneak = self.controls.sneak                         -- 0.49 sneak check\n        if isSneak == nil then\n          isSneak = input.isActionPressed(input.ACTION.Sneak) -- 0.48 sneak check\n        end\n\n        if isSneak or buffTotal ~= 0 then\n          -- Where to determine max sneak, armor modifier, and timers?\n          -- Do it once on the first frame we press sneak?\n          -- Do it only when timer triggers? Probably.\n          local mf = self.controls.movement\n          local ms = self.controls.sideMovement\n\n          if (mf == 0 and ms == 0) then\n            buffType = 1 -- not moving = increase sneak value over time\n          else\n            buffType = 2 -- moving = reduce sneak value over time\n          end\n          -- if not sneaking... I must return it to neutral\n          if (buffTotal < 0 and not isSneak) then\n            buffType = -1 -- not sneaking, slowly increase back to neutral\n          elseif (buffTotal > 0 and not isSneak) then\n            buffType = -2 -- not sneaking, quickly decrease back to neutral\n          end\n\n          chargeTime = chargeTime + dt -- increment timer only if sneaking\n          if chargeTime >= chargeInterval then\n            chargeHit = true\n            chargeTime = 0\n            -- determine max allowed sneak modifier\n            maxMod = math.ceil(buffBase * (skills.sneak(self).modified - buffTotal)) -- must subtract out this mod's current modifier\n            if math.abs(buffType) == 1 then\n              -- if charging, get change per tick as percentage of charge time\n              --perTick = math.ceil((maxMod/maxCharge)*chargeInterval/math.sqrt(getWeights()))\n              perTick = (maxMod / maxCharge) * chargeInterval / math.sqrt(getWeights())\n              --perTick = ((maxMod/maxCharge)*chargeInterval/math.sqrt(getWeights()))\n              if buffType < 0 then      -- if not sneaking, gain at reduced rate\n                perTick = 0.5 * perTick -- gain at half rate\n              end\n              if buffTotal >= 0 then    -- add modifier, else remove damage\n                -- we want to add modifier, so do not go above max buff\n                perTick = math.min(perTick, maxMod - buffTotal)\n                tickCounter = tickCounter + perTick\n                if tickCounter >= 1 then\n                  perTick = math.floor(tickCounter)\n                  sneakMod(1, perTick)\n                  buffTotal = buffTotal + perTick\n                  tickCounter = tickCounter - perTick\n                end\n              else\n                -- we want to remove damage, so do not go above 0\n                perTick = math.min(perTick, 0 - buffTotal)\n                tickCounter = tickCounter + perTick\n                if tickCounter >= 1 then\n                  perTick = math.floor(tickCounter)\n                  sneakMod(-1, -perTick)\n                  buffTotal = buffTotal + perTick\n                  tickCounter = tickCounter - perTick\n                end\n              end\n            elseif math.abs(buffType) == 2 then\n              -- if releasing, get change per tick as raw drain value\n              --perTick = math.ceil(maxDrain*getWeights()*chargeInterval)\n              --perTick = math.ceil(100*maxDrain*getWeights()*chargeInterval)/100\n              perTick = (maxMod / maxDrain) * chargeInterval * getWeights()\n              --perTick = (maxDrain*getWeights()*chargeInterval)\n              if buffType < 0 then      -- if not sneaking, gain at reduced rate\n                perTick = 1.5 * perTick -- decrease at double rate\n              end\n              if buffTotal <= 0 then    -- add damage, else remove modifier\n                -- we want to add damage, so do not go below negative max buff\n                if allowDebuff then\n                  perTick = math.min(perTick, maxMod + buffTotal)\n                else\n                  perTick = 0\n                end\n                tickCounter = tickCounter + perTick\n                if tickCounter >= 1 then\n                  perTick = math.floor(tickCounter)\n                  sneakMod(1, -perTick)\n                  buffTotal = buffTotal - perTick\n                  tickCounter = tickCounter - perTick\n                end\n              else\n                -- we want to remove modifier, so do not go below 0\n                perTick = math.min(perTick, 0 + buffTotal)\n                tickCounter = tickCounter + perTick\n                if tickCounter >= 1 then\n                  perTick = math.floor(tickCounter)\n                  sneakMod(-1, perTick)\n                  buffTotal = buffTotal - perTick\n                  tickCounter = tickCounter - perTick\n                end\n              end\n            end\n            if verbose then\n              --ui.showMessage('mod '.. tostring(skills.sneak(self).modifier).. ', dmg '.. tostring(skills.sneak(self).damage).. ', buffTotal '.. tostring(buffTotal))\n              if showVerbose[3] == 1 and buffTotal == maxMod then\n                showVerbose = { 1, 1, 0 }\n                ui.showMessage('SNEAK + ' .. tostring(maxMod))\n              elseif showVerbose[2] == 1 and buffTotal == 0 then\n                showVerbose = { 1, 0, 1 }\n                ui.showMessage('SNEAK RESET')\n              elseif showVerbose[1] == 1 and buffTotal == -maxMod then\n                showVerbose = { 0, 1, 1 }\n                ui.showMessage('SNEAK - ' .. tostring(maxMod))\n              end\n            end\n          else\n            chargeHit = false\n          end\n        end\n      end\n    end\n  }\n}\n",
    "Solthas Combat Pack-52221-1-11-1717384986\\Solthas Combat Pack\\scripts\\SolStaffSpellBuffs\\scripts\\SolStaffSpellBuffs.lua": "local core = require('openmw.core')\nlocal ui = require('openmw.ui')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal async = require('openmw.async')\n\n-- handle settings\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\n\nI.Settings.registerPage({\n   key = 'SolStaffSpellBuffs',\n   l10n = 'SolStaffSpellBuffs',\n   name = 'name',\n   description = 'description',\n})\n\n-- default values!\nlocal enabled = true\nlocal onStaffSwap = true -- if you need to swap off staff\nlocal doTradeOffs = true\nlocal verbose = true -- 0 none, 1 stance name, 2 stance stats, 3 consoleDebugInfo\nlocal buffBase = 10\nlocal doInt = true\nlocal doWis = true\nlocal doAgi = true\nlocal doSpd = true\nlocal tradeoffMult = 1.0\nI.Settings.registerGroup({\n   key = 'Settings_sol_StaffSpellBuff',\n   page = 'SolStaffSpellBuffs',\n   l10n = 'SolStaffSpellBuffs',\n   name = 'group_name',\n   permanentStorage = true,\n   settings = {\n      {\n         key = 'enabled',\n         default = enabled,\n         renderer = 'checkbox',\n         name = 'enabled_name',\n      },\n      {\n         key = 'verbose',\n         default = verbose,\n         renderer = 'checkbox',\n         name = 'verbose_name',\n         description = 'verbose_description',\n      },\n      {\n         key = 'onStaffSwap',\n         default = onStaffSwap,\n         renderer = 'checkbox',\n         name = 'onStaffSwap_name',\n         description = 'onStaffSwap_descrption',\n      },\n      {\n         key = 'buffBase',\n         default = buffBase,\n         renderer = 'number',\n         name = 'buffBase_name',\n         description = 'buffBase_description',\n         argument = {\n            integer = true,\n            min = 1,\n            max = 20,\n         },\n      },\n      {\n         key = 'doTradeOffs',\n         default = doTradeOffs,\n         renderer = 'checkbox',\n         name = 'doTradeOffs_name',\n         description = 'doTradeOffs_description',\n      },\n      {\n         key = 'tradeOffMult',\n         default = tradeoffMult,\n         renderer = 'number',\n         name = 'tradeOffMult_name',\n         description = 'tradeOffMult_description',\n         argument = {\n            min = 0,\n            max = 2,\n         },\n      },\n      {\n         key = 'doInt',\n         default = doInt,\n         renderer = 'checkbox',\n         name = 'doInt_name',\n      },\n      {\n         key = 'doWis',\n         default = doWis,\n         renderer = 'checkbox',\n         name = 'doWis_name',\n      },\n      {\n         key = 'doAgi',\n         default = doAgi,\n         renderer = 'checkbox',\n         name = 'doAgi_name',\n      },\n      {\n         key = 'doSpd',\n         default = doSpd,\n         renderer = 'checkbox',\n         name = 'doSpd_name',\n      },\n   },\n})\n\nlocal settingsGroup = storage.playerSection('Settings_sol_StaffSpellBuff')\n\n-- shorthand for convenience\nlocal Weapon = types.Weapon\nlocal attributes = types.Actor.stats.attributes\nlocal skills = types.NPC.stats.skills\n\n-- reduce effectiveness of hybrid stances\nlocal function hybridVal(base,mult,count)\n    return math.ceil(base*math.pow(mult,math.max(count,0)))\nend\n\n-- script config\n-- and store stance idxs for indexing into tables\nlocal stanceIndex = {spell=1, staff=2}\nlocal maxStance = 0\nfor _ in pairs(stanceIndex) do\n  maxStance = maxStance + 1\nend\n\n-- init to defaults\nlocal buffDown = hybridVal(buffBase,-tradeoffMult,1)\nlocal spellBuff = {buffBase,buffDown}\n-- update\nlocal function updateSettings()\n  enabled = settingsGroup:get('enabled')\n  verbose = settingsGroup:get('verbose')\n  onStaffSwap = settingsGroup:get('onStaffSwap')\n  buffBase = settingsGroup:get('buffBase')\n  doInt = settingsGroup:get('doInt')\n  doWis = settingsGroup:get('doWis')\n  doTradeOffs = settingsGroup:get('doTradeOffs')\n  tradeoffMult = settingsGroup:get('tradeOffMult')\n  doAgi = settingsGroup:get('doAgi')\n  doSpd = settingsGroup:get('doSpd')\n  -- calculate new buff vals\n  buffDown = hybridVal(buffBase,-tradeoffMult,1)\n  spellBuff = {buffBase,buffDown}\nend\nlocal function init()\n    updateSettings()\nend\nsettingsGroup:subscribe(async:callback(updateSettings))\n\n-- stance names for verbose\nlocal stanceName = {'SPELL','STAFF'}\n\n-- stance effects \nlocal function magMod(modSign,modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    if doInt then\n      attributes.intelligence(self).modifier = math.max(0,attributes.intelligence(self).modifier + modSign*modVal)\n    end\n    if doWis then\n      attributes.willpower(self).modifier = math.max(0,attributes.willpower(self).modifier + modSign*modVal)\n      if not doAgi then\n        attributes.endurance(self).damage = math.max(0,attributes.endurance(self).damage + modSign*modVal)\n      end\n    end\n  else\n    modVal = math.abs(modVal)\n    if doInt then\n      attributes.intelligence(self).damage = math.max(0,attributes.intelligence(self).damage + modSign*modVal)\n    end\n    if doWis then\n      attributes.willpower(self).damage = math.max(0,attributes.willpower(self).damage + modSign*modVal)\n      if not doAgi then\n        attributes.endurance(self).modifier = math.max(0,attributes.endurance(self).modifier + modSign*modVal)\n      end\n    end\n  end\nend\nlocal function phyMod(modSign,modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    if doSpd then\n      attributes.speed(self).modifier = math.max(0,attributes.speed(self).modifier + modSign*math.ceil(0.5*modVal))\n      -- do athletics and acrobatics with speed, but give them each half impact\n      skills.athletics(self).modifier = math.max(0,skills.athletics(self).modifier + modSign*math.ceil(0.5*modVal))\n      skills.acrobatics(self).modifier = math.max(0,skills.acrobatics(self).modifier + modSign*math.ceil(0.5*modVal))\n    end\n    if doAgi then\n      attributes.agility(self).modifier = math.max(0,attributes.agility(self).modifier + modSign*modVal)\n      if not doWis then\n        attributes.endurance(self).damage = math.max(0,attributes.endurance(self).damage + modSign*modVal)\n      end\n    end\n  else\n    modVal = math.abs(modVal)\n    if doSpd then\n      attributes.speed(self).damage = math.max(0,attributes.speed(self).damage + modSign*math.ceil(0.5*modVal))\n      -- do athletics and acrobatics with speed, but give them each half impact\n      skills.athletics(self).damage = math.max(0,skills.athletics(self).damage + modSign*math.ceil(0.5*modVal))\n      skills.acrobatics(self).damage = math.max(0,skills.acrobatics(self).damage + modSign*math.ceil(0.5*modVal))\n    end\n    if doAgi then\n      attributes.agility(self).damage = math.max(0,attributes.agility(self).damage + modSign*modVal)\n      if not doWis then\n        attributes.endurance(self).modifier = math.max(0,attributes.endurance(self).modifier + modSign*modVal)\n      end\n    end\n  end\nend\n\n-- init stance total tracking, used for verbose outputs, and for onSave/onLoad tracking\nlocal spellBuffTotal = {}\nfor i=1,maxStance,1 do \n  spellBuffTotal[i] = 0\nend\n\n-- save state to be removed on load\nlocal function onSave()\n    return{\n      spellBuffTotal = spellBuffTotal\n    }\nend\n\nlocal function onLoad(data)\n  if data then\n    spellBuffTotal = data.spellBuffTotal\n    magMod(-1,spellBuffTotal[1])\n    phyMod(-1,spellBuffTotal[2])\n    for i=1,maxStance,1 do\n      spellBuffTotal[i] = 0\n    end\n  end\nend\n\nlocal function staffCheck()\n          local bugid = 0\n  local staffEnchant = 0\n  local usedWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n  if usedWeapon then -- not hand to hand\n    if  not types.Lockpick.objectIsInstance(usedWeapon) and not types.Probe.objectIsInstance(usedWeapon) then\n      local weaponType = Weapon.record(usedWeapon).type\n      if weaponType == 5 then\n        staffEnchant = Weapon.record(usedWeapon).value\n        staffEnchant = math.log10(staffEnchant)\n      end\n    end\n  end\n  return(staffEnchant)\nend\n\nlocal function inputCheck(id) -- check if ID corresponds to potentially pulling out a weapon or spell\n  if not core.isWorldPaused() then\n    if id == input.ACTION.ToggleSpell \n    or id == input.ACTION.CycleSpellLeft \n    or id == input.ACTION.CycleSpellRight \n    or id == input.ACTION.ToggleWeapon \n    or id == input.ACTION.CycleWeaponLeft \n    or id == input.ACTION.CycleWeaponRight \n    or id == input.ACTION.QuickKey1 \n    or id == input.ACTION.QuickKey2 \n    or id == input.ACTION.QuickKey3 \n    or id == input.ACTION.QuickKey4 \n    or id == input.ACTION.QuickKey5 \n    or id == input.ACTION.QuickKey6 \n    or id == input.ACTION.QuickKey7 \n    or id == input.ACTION.QuickKey8 \n    or id == input.ACTION.QuickKey9 \n    or id == input.ACTION.QuickKey10 \n    or id == input.ACTION.Inventory then\n      return(true)\n    else\n      return(false)\n    end\n  end\nend\n\nlocal staffEnchant = 1\nlocal isWeapon = false -- true if in weapon stance \nlocal doBuff = false\nreturn { \n  engineHandlers = { \n    -- init settings\n    onActive = init,\n    -- save and load handling so you don't get stuck with modified stats\n    onSave = onSave,\n    onLoad = onLoad,\n    \n    onInputAction = function(id)\n      if enabled then\n        if inputCheck(id) then\n          if types.Actor.stance(self) == types.Actor.STANCE.Weapon then -- weapon ready/unready logic\n            isWeapon = true\n            if verbose and onStaffSwap and staffCheck()~=0 then\n              ui.showMessage(stanceName[2])\n            end\n          elseif types.Actor.stance(self) ~= types.Actor.STANCE.Spell then -- if not weapon or spell\n            isWeapon = false\n        --    if verbose and onStaffSwap and staffCheck()~=0 then\n        --      ui.showMessage('NO ' .. stanceName[2])\n        --    end\n          end          \n          \n          if types.Actor.stance(self) == types.Actor.STANCE.Spell then -- spell ready/unready logic\n      if not doBuff then -- only buff if not buffed yet\n              doBuff = true\n              if onStaffSwap then -- only trigger if had a weapon out when swapped to spell? \n                if isWeapon then\n                  doBuff = true\n                else\n                  doBuff = false\n                end\n              end\n  \n              staffEnchant = staffCheck()\n              if doBuff and staffEnchant~=0 then -- must have staff equipped to buff\n                if verbose then\n                  ui.showMessage(stanceName[1])\n                end\n                local buffNext = hybridVal(spellBuff[1],staffEnchant,1)\n                magMod(1,buffNext)\n                spellBuffTotal[1] = spellBuffTotal[1] + buffNext\n                if doTradeOffs then\n                  buffNext = hybridVal(spellBuff[2],staffEnchant,1)\n                  phyMod(1,buffNext)\n                  spellBuffTotal[2] = spellBuffTotal[2] + buffNext\n                end\n              end\n            end\n          else -- debuff\n            doBuff = false\n            magMod(-1,spellBuffTotal[1])\n            phyMod(-1,spellBuffTotal[2])\n            spellBuffTotal = {0,0}     \n          end\n          \n        end\n      end\n    end\n  } \n}",
    "Solthas Combat Pack-52221-1-11-1717384986\\Solthas Combat Pack\\scripts\\SolSwimBoostDrain\\scripts\\SolSwimBoostDrain.lua": "local core = require('openmw.core')\nlocal ui = require('openmw.ui')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal async = require('openmw.async')\n\n-- handle settings\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\n\nI.Settings.registerPage({\n   key = 'SolSwimBoostDrain',\n   l10n = 'SolSwimBoostDrain',\n   name = 'name',\n   description = 'description',\n})\n\n-- default values!\nlocal enabled = true\nlocal verbose = true\nlocal buffSpeed = 500\nlocal statBreakeven = 50\nlocal fatigueCost = 30\nlocal buffDuration = 0.5\nlocal doHurt = true\nlocal hurtVal = 5\nlocal hurtWait = 2\nI.Settings.registerGroup({\n   key = 'Settings_SolSwimBoostDrain',\n   page = 'SolSwimBoostDrain',\n   l10n = 'SolSwimBoostDrain',\n   name = 'group_name',\n   permanentStorage = true,\n   settings = {\n      {\n         key = 'enabled',\n         default = enabled,\n         renderer = 'checkbox',\n         name = 'enabled_name',\n      },\n      {\n         key = 'verbose',\n         default = verbose,\n         renderer = 'checkbox',\n         name = 'verbose_name',\n      },\n      {\n         key = 'buffSpeed',\n         default = buffSpeed,\n         renderer = 'number',\n         name = 'buffSpeed_name',\n         description = 'buffSpeed_description',\n         argument = {\n            integer = true,\n            min = 1,\n            max = 1000,\n         },\n      },\n      {\n         key = 'statBreakeven',\n         default = statBreakeven,\n         renderer = 'number',\n         name = 'statBreakeven_name',\n         description = 'statBreakeven_description',\n         argument = {\n            integer = true,\n            min = 0,\n            max = 100,\n         },\n      },\n      {\n         key = 'fatigueCost',\n         default = fatigueCost,\n         renderer = 'number',\n         name = 'fatigueCost_name',\n         description = 'fatigueCost_description',\n         argument = {\n            min = 0,\n            max = 100,\n         },\n      },\n      {\n         key = 'buffDuration',\n         default = buffDuration,\n         renderer = 'number',\n         name = 'buffDuration_name',\n         description = 'buffDuration_description',\n         argument = {\n            min = 0.1,\n            max = 5,\n         },\n      },\n      {\n         key = 'doHurt',\n         default = doHurt,\n         renderer = 'checkbox',\n         name = 'doHurt_name',\n      },\n      {\n         key = 'hurtVal',\n         default = hurtVal,\n         renderer = 'number',\n         name = 'hurtVal_name',\n         description = 'hurtVal_description',\n         argument = {\n            integer = true,\n            min = 1,\n            max = 100,\n         },\n      },\n      {\n         key = 'hurtWait',\n         default = hurtWait,\n         renderer = 'number',\n         name = 'hurtWait_name',\n         description = 'hurtWait_description',\n         argument = {\n            integer = true,\n            min = 1,\n            max = 5,\n         },\n      },\n   },\n})\nlocal settingsGroup = storage.playerSection('Settings_SolSwimBoostDrain')\n\n-- initialize\nlocal scaleBuff = buffSpeed*statBreakeven/100\nlocal flatBuff = buffSpeed - scaleBuff\n-- update\nlocal function updateSettings()\n  enabled = settingsGroup:get('enabled')\n  verbose = settingsGroup:get('verbose')\n  buffSpeed = settingsGroup:get('buffSpeed')\n  statBreakeven = settingsGroup:get('statBreakeven')\n    scaleBuff = buffSpeed*statBreakeven/100\n    flatBuff = buffSpeed - scaleBuff\n  fatigueCost = settingsGroup:get('fatigueCost')\n  buffDuration = settingsGroup:get('buffDuration')\n  doHurt = settingsGroup:get('doHurt')\n  hurtVal = settingsGroup:get('hurtVal')\n  hurtWait = settingsGroup:get('hurtWait')\nend\nlocal function init()\n    updateSettings()\nend\nsettingsGroup:subscribe(async:callback(updateSettings))\n\n-- shorthand for convenience\nlocal attributes = types.Actor.stats.attributes\nlocal skills = types.NPC.stats.skills\nlocal dynamic = types.Actor.stats.dynamic\n\n-- stance effects \nlocal function spdMod(modSign,modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    attributes.speed(self).modifier = math.max(0,attributes.speed(self).modifier + modSign*modVal)\n  else\n    modVal = math.abs(modVal)\n    attributes.speed(self).damage = math.max(0,attributes.speed(self).damage + modSign*modVal)\n  end\nend\n\n-- init stance total tracking, used for verbose outputs, and for onSave/onLoad tracking\nlocal buffTotal = 0\n-- save state to be removed on load\nlocal function onSave()\n    return{\n      buffTotal = buffTotal\n    }\nend\nlocal function onLoad(data)\n  if data then\n    buffTotal = data.buffTotal\n    spdMod(-1,buffTotal)\n    buffTotal = 0\n  end\nend\n\nlocal buffVal = 0\nlocal hurtTime = 0\nlocal doBuff = true\nreturn { \n  engineHandlers = { \n    -- init settings\n    onActive = init,\n    -- save and load handling so you don't get stuck with modified stats\n    onSave = onSave,\n    onLoad = onLoad,\n    \n    onInputAction = function(id)\n      if enabled then\n        if id == input.ACTION.Jump then\n          if types.Actor.isSwimming(self) then\n            if doBuff then\n              -- apply fatigue cost\n              local cfat = dynamic.fatigue(self).current\n              --if cfat >= fatigueCost then -- only do buff if enough fatigue for it\n              if cfat >= 1 then -- Allow to boost to empty, but not to boost on empty\n                doBuff = false\n                dynamic.fatigue(self).current = math.max(0,cfat - fatigueCost)\n                -- apply buff\n                buffVal = flatBuff + scaleBuff*(skills.athletics(self).modified)/50\n                spdMod(1,buffVal)\n                buffTotal = buffTotal + buffVal\n          \n                if verbose then\n                  ui.showMessage('BOOST!')\n                end\n      \n                -- start release timer\n                async:newUnsavableSimulationTimer(\n                buffDuration,\n                function()\n                  spdMod(-1,buffTotal)\n                  buffTotal = 0\n                  doBuff = true\n                end\n                )\n              end\n            end\n          end\n        end\n      end\n    end,\n  \n    onUpdate = function(dt)\n      if enabled and doHurt then -- if running this calc\n        if types.Actor.isSwimming(self) then -- if in water\n          local mf = self.controls.movement\n          local ms = self.controls.sideMovement\n          if mf ~= 0 or ms ~= 0 then -- if moving\n            if dynamic.fatigue(self).current == 0 then -- if out of fatigue\n              hurtTime = hurtTime + dt\n              if hurtTime > hurtWait then -- if enough time has passed\n                ui.showMessage('Swimming while out of fatigue!')\n                dynamic.health(self).current = math.max(0,dynamic.health(self).current - hurtVal) -- don't set to below 0\n                hurtTime = 0\n              end\n            end\n          end\n        end\n      end\n    end,\n  } \n}",
    "Solthas Combat Pack-52221-1-11-1717384986\\Solthas Combat Pack\\scripts\\SolTimedDirAttacks\\scripts\\SolTimedDirAttacks.lua": "local core = require('openmw.core')\nlocal ui = require('openmw.ui')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal async = require('openmw.async')\nlocal I = require(\"openmw.interfaces\")\n\n-- handle settings\nlocal storage = require('openmw.storage')\n\nI.Settings.registerPage({\n   key = 'SolTimedDirAttacks',\n   l10n = 'SolTimedDirAttacks',\n   name = 'name',\n   description = 'description',\n})\n\n-- default values!\nlocal enabled = true\nlocal verbose = 1\nlocal incRanged = false -- include ranged weapons ?\nlocal buffBase = 10\nlocal tradeOffBase = 50\nlocal fatigueLoss = 15\nlocal paceMult = 1.5\nI.Settings.registerGroup({\n   key = 'Settings_SolTimedDirAttacks',\n   page = 'SolTimedDirAttacks',\n   l10n = 'SolTimedDirAttacks',\n   name = 'group_name',\n   permanentStorage = true,\n   settings = {\n      {\n         key = 'enabled',\n         default = enabled,\n         renderer = 'checkbox',\n         name = 'enabled_name',\n      },\n      {\n         key = 'verbose',\n         default = verbose,\n         renderer = 'number',\n         name = 'verbose_name',\n         description = 'verbose_description',\n         argument = {\n            integer = true,\n            min = 0,\n            max = 2,\n         },\n      },\n      {\n         key = 'incRanged',\n         default = incRanged,\n         renderer = 'checkbox',\n         name = 'incRanged_name',\n      },\n      {\n         key = 'buffBase',\n         default = buffBase,\n         renderer = 'number',\n         name = 'buffBase_name',\n         description = 'buffBase_description',\n         argument = {\n        integer = true,\n            min = 0,\n            max = 100,\n         },\n      },\n      {\n         key = 'tradeOffBase',\n         default = tradeOffBase,\n         renderer = 'number',\n         name = 'tradeOffBase_name',\n         description = 'tradeOffBase_description',\n         argument = {\n        integer = true,\n            min = 0,\n            max = 100,\n         },\n      },\n      {\n         key = 'fatigueLoss',\n         default = fatigueLoss,\n         renderer = 'number',\n         name = 'fatigueLoss_name',\n         description = 'fatigueLoss_description',\n         argument = {\n        integer = true,\n            min = 0,\n            max = 100,\n         },\n      },\n      {\n         key = 'paceMult',\n         default = paceMult,\n         renderer = 'number',\n         name = 'paceMult_name',\n         description = 'paceMult_description',\n         argument = {\n            min = 0.5,\n            max = 3.0,\n         },\n      },\n   },\n})\nlocal settingsGroup = storage.playerSection('Settings_SolTimedDirAttacks')\n\n-- shorthand for convenience\nlocal Weapon = types.Weapon\nlocal attributes = types.Actor.stats.attributes\nlocal skills = types.NPC.stats.skills\nlocal dynamic = types.Actor.stats.dynamic\n\n-- reduce effectiveness of hybrid stances\nlocal function hybridVal(base,mult,count)\n    return math.ceil(base*math.pow(mult,math.max(count,0)))\nend\n\n-- script config\nlocal incH2H = true -- include handtohand?\n  -- if true, must define \"speed\" value for h2h in buff/debuff fncs\n\n-- init to defaults\nlocal buffDuration = 1\nlocal stateNames = {}\nlocal stanceNames = {'','','',''}\n-- update\nlocal function updateSettings()\n  enabled = settingsGroup:get('enabled')\n  verbose = settingsGroup:get('verbose')\n  incRanged = settingsGroup:get('incRanged')\n  buffBase = settingsGroup:get('buffBase')\n  tradeOffBase = settingsGroup:get('tradeOffBase')\n  paceMult = settingsGroup:get('paceMult')\n  -- update pace timer multiplier\n  buffDuration = 6/paceMult -- 3 states, so divide by 3\n    -- actually let's do 6 just to be safe\n  -- update verbose\n  if verbose == 1 then\n    stateNames = {'EARLY', 'GOOD', 'PERFECT'}\n    stanceNames = {'CHOP','SLASH','THRUST','FUMBLE'}\n  elseif verbose == 2 then\n    stateNames  = {'', '', ''}\n    stanceNames = {'ACC','DEF','AGI','FTG, SPD'}\n  end\nend\nlocal function init()\n    updateSettings()\nend\nsettingsGroup:subscribe(async:callback(updateSettings))\n\n-- stance effects \nlocal function chopMod(modSign,modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    skills.axe(self).modifier = math.max(0,skills.axe(self).modifier + modSign*modVal)\n    skills.bluntweapon(self).modifier = math.max(0,skills.bluntweapon(self).modifier + modSign*modVal)\n    skills.handtohand(self).modifier = math.max(0,skills.handtohand(self).modifier + modSign*modVal)\n    skills.longblade(self).modifier = math.max(0,skills.longblade(self).modifier + modSign*modVal)\n    skills.marksman(self).modifier = math.max(0,skills.marksman(self).modifier + modSign*modVal) -- marksman?\n    skills.shortblade(self).modifier = math.max(0,skills.shortblade(self).modifier + modSign*modVal)\n    skills.spear(self).modifier = math.max(0,skills.spear(self).modifier + modSign*modVal)\n  else\n    modVal = math.abs(modVal)\n    skills.axe(self).damage = math.max(0,skills.axe(self).damage + modVal)\n    skills.bluntweapon(self).damage = math.max(0,skills.bluntweapon(self).damage + modSign*modVal)\n    skills.handtohand(self).damage = math.max(0,skills.handtohand(self).damage + modSign*modVal)\n    skills.longblade(self).damage = math.max(0,skills.longblade(self).damage + modSign*modVal)\n    skills.marksman(self).damage = math.max(0,skills.marksman(self).damage + modSign*modVal) -- marksman?\n    skills.shortblade(self).damage = math.max(0,skills.shortblade(self).damage + modSign*modVal)\n    skills.spear(self).damage = math.max(0,skills.spear(self).damage + modSign*modVal)\n  end\nend\nlocal function slashMod(modSign,modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    skills.block(self).modifier = math.max(0,skills.block(self).modifier + modSign*modVal) -- block?\n    skills.heavyarmor(self).modifier = math.max(0,skills.heavyarmor(self).modifier + modSign*modVal)\n    skills.lightarmor(self).modifier = math.max(0,skills.lightarmor(self).modifier + modSign*modVal)\n    skills.mediumarmor(self).modifier = math.max(0,skills.mediumarmor(self).modifier + modSign*modVal)\n    skills.unarmored(self).modifier = math.max(0,skills.unarmored(self).modifier + modSign*modVal)\n  else\n    modVal = math.abs(modVal)\n    skills.block(self).damage = math.max(0,skills.block(self).damage + modSign*modVal) -- block?\n    skills.heavyarmor(self).damage = math.max(0,skills.heavyarmor(self).damage + modSign*modVal)\n    skills.lightarmor(self).damage = math.max(0,skills.lightarmor(self).damage + modSign*modVal)\n    skills.mediumarmor(self).damage = math.max(0,skills.mediumarmor(self).damage + modSign*modVal)\n    skills.unarmored(self).damage = math.max(0,skills.unarmored(self).damage + modSign*modVal)\n  end\nend\nlocal function lungeMod(modSign,modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    attributes.agility(self).modifier = math.max(0,attributes.agility(self).modifier + modSign*modVal)\n       -- offset agility by willpower to keep max fatigue constant\n    attributes.willpower(self).damage = math.max(0,attributes.willpower(self).damage + modSign*modVal)\n    skills.acrobatics(self).modifier = math.max(0,skills.acrobatics(self).modifier + modSign*modVal)\n  else\n    modVal = math.abs(modVal)\n    attributes.agility(self).damage = math.max(0,attributes.agility(self).damage + modSign*modVal)\n       -- offset agility by willpower to keep max fatigue constant\n    attributes.willpower(self).modifier = math.max(0,attributes.willpower(self).modifier + modSign*modVal)\n    skills.acrobatics(self).damage = math.max(0,skills.acrobatics(self).damage + modSign*modVal)\n  end\nend\nlocal function debuffMod(modSign,modVal) -- debuff speed on fumble\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    attributes.speed(self).modifier = math.max(0,attributes.speed(self).modifier + modSign*math.ceil(0.5*modVal))\n\t-- do athletics and acrobatics with speed, but give them each half impact\n    skills.athletics(self).modifier = math.max(0,skills.athletics(self).modifier + modSign*math.ceil(0.5*modVal))\n    skills.acrobatics(self).modifier = math.max(0,skills.acrobatics(self).modifier + modSign*math.ceil(0.5*modVal))\n  else\n    modVal = math.abs(modVal)\n    attributes.speed(self).damage = math.max(0,attributes.speed(self).damage + modSign*math.ceil(0.5*modVal))\n\t-- do athletics and acrobatics with speed, but give them each half impact\n    skills.athletics(self).damage = math.max(0,skills.athletics(self).damage + modSign*math.ceil(0.5*modVal))\n    skills.acrobatics(self).damage = math.max(0,skills.acrobatics(self).damage + modSign*math.ceil(0.5*modVal))\n  end\nend\n\nlocal function weaponCheck()\n  local isWeapon = false\n  if types.Actor.stance(self) == types.Actor.STANCE.Weapon then\n    local usedWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n    if (not usedWeapon) then -- handtohand\n      isWeapon = incH2H\n    else\n      if  not types.Lockpick.objectIsInstance(usedWeapon) and not types.Probe.objectIsInstance(usedWeapon) then\n        local weaponType = Weapon.record(usedWeapon).type\n        if (weaponType < 9) then -- melee weapon\n          isWeapon = true\n        elseif (weaponType <= 13) then -- ranged weapon\n          isWeapon = incRanged\n        elseif (weaponType > 13) then -- unknown weapon\n          isWeapon = true\n        end\n      end\n    end \n  end\n  return(isWeapon)\nend\n\nlocal function getPace()\n  -- get relevant stats\n  local usedWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n  local weapSpeed = 1\n  if (usedWeapon) then -- NOT handtohand\n    weapSpeed = Weapon.record(usedWeapon).speed\n  end\n  -- setup mod\n  local paceTime = 1/weapSpeed\n  return(paceTime)\nend\n\n\nlocal buffTotal = {0,0,0,0}\n-- save state to be removed on load\nlocal function onSave()\n    return{\n      buffTotal = buffTotal\n    }\nend\nlocal function onLoad(data)\n  if data then\n    buffTotal = data.buffTotal\n    chopMod(-1,buffTotal[1])\n    slashMod(-1,buffTotal[2])\n    lungeMod(-1,buffTotal[3])\n    debuffMod(-1,buffTotal[4])    \n    buffTotal = {0,0,0,0}\n  end\nend\n\n-- use a queue to store stance and stage numbers\nlocal circStance = {} -- store which stance was triggered\nlocal circCombo = {} -- store whether stance was eaten by a new input\nlocal weaponWeight = 0\nlocal chargeTime = 0\nlocal doBuff = true\nlocal isCharge = false -- true if trigger input action\nlocal isWeapon = false\nlocal stanceNext = 0\nlocal isBuffed = false\nlocal buffMult = 0\nreturn { \n  engineHandlers = { \n    -- init settings\n    onActive = init,\n    -- save and load handling so you don't get stuck with modified stats\n    onSave = onSave,\n    onLoad = onLoad,\n    \n    onUpdate = function(dt)\n      if core.API_REVISION > 60 and I.UI.getMode() ~= nil then return end\n      if enabled then\n        local isUse = input.isActionPressed(input.ACTION.Use)\n        \n        if isUse and not isCharge then -- on first frame you hit use        \n          isCharge = true -- update stance\n          isWeapon = weaponCheck()\n          -- get dir attack type\n          if isWeapon then -- 0-8 is melee, 9-11 is ranged, 12-13 is ammunition, usedWeapon nil if handtohand\n            -- check movement to determine attack dir\n            local mf = self.controls.movement\n            local ms = self.controls.sideMovement\n            if mf ~= 0 and ms == 0 then -- lunge\n              stanceNext = 3\n            elseif mf == 0 and ms ~= 0 then -- slash\n              stanceNext = 2\n            elseif (mf == 0 and ms == 0) or (mf ~= 0 and ms ~= 0) then -- chop\n              stanceNext = 1\n            end\n            \n            if doBuff then\n              doBuff = false\n              chargeTime = core.getSimulationTime() - chargeTime -- get timer value\n              local paceTime = getPace()\n              local chargeState = math.floor(paceMult*chargeTime/paceTime)    \n        \n              if chargeState == 0 then -- drain fatigue\n                isBuffed = true\n                local cfat = dynamic.fatigue(self).current\n        --        dynamic.fatigue(self).current = math.max(0, dynamic.fatigue(self).current - fatigueLoss)\n                dynamic.fatigue(self).current = math.max(0, cfat - fatigueLoss)\n        -- there's a conflict between this fatigue loss and the loss of agility. It can subtract from your true max fatigue ignoring the loss from agility\n        -- which, once agility returns to normal, can cause your fatigue to go above maximum\n        --        dynamic.fatigue(self).current = math.min(dynamic.fatigue(self).base, dynamic.fatigue(self).current)       \n              elseif chargeState == 1 then -- 1x buff\n                isBuffed = true\n                buffMult = 1\n              elseif chargeState == 2 then -- 2x buff\n                isBuffed = true\n                buffMult = 2\n              else -- nothing\n                isBuffed = false\n              end\n              \n              if isBuffed then\n                -- remove existing buffs\n                chopMod(-1,buffTotal[1])\n                slashMod(-1,buffTotal[2])\n                lungeMod(-1,buffTotal[3])\n                debuffMod(-1,buffTotal[4])\n                buffTotal = {0,0,0,0}\n\n                -- apply new buff\n                if chargeState == 0 then\n                  debuffMod(1,-tradeOffBase)\n                  buffTotal[4] = buffTotal[4] - tradeOffBase\n                  stanceNext = 4\n                else\n                  if stanceNext == 1 then\n                    chopMod(1,buffBase*buffMult)\n                    buffTotal[1] = buffTotal[1] + buffBase*buffMult\n                  elseif stanceNext == 2 then\n                    slashMod(1,buffBase*buffMult)\n                    buffTotal[2] = buffTotal[2] + buffBase*buffMult\n                  elseif stanceNext == 3 then\n                    lungeMod(1,buffBase*buffMult)\n                    buffTotal[3] = buffTotal[3] + buffBase*buffMult\n                  end\n                end\n                -- update queue for timer to call\n                for i,_ in ipairs(circCombo) do\n                  circCombo[i] = false -- set prior entries to not retrigger on their own\n                end\n                table.insert(circCombo,true)\n        \n                if verbose == 1 then\n                  if chargeState == 0 then\n                    ui.showMessage(stateNames[chargeState+1].. ' ' .. stanceNames[4])\n                  else\n                    ui.showMessage(stateNames[chargeState+1].. ' ' .. stanceNames[stanceNext])                  \n                  end\n                elseif verbose == 2 then\n                  if chargeState == 0 then\n                    ui.showMessage(tostring(-fatigueLoss) ..' '.. stanceNames[4] .. ' -' .. tostring(tradeOffBase) .. ' (' .. tostring(math.floor(chargeTime*10)/10) .. ' / ' .. tostring(math.floor(paceTime/paceMult*10)/10)..')')\n                  else\n                    ui.showMessage(stanceNames[stanceNext] .. ' +' .. tostring(buffBase*buffMult) .. ' (' .. tostring(math.floor(chargeTime*10)/10) .. ' / ' .. tostring(math.floor(paceTime/paceMult*10)/10)..')')                \n                  end\n                end\n                \n                -- start end buff timer\n                async:newUnsavableSimulationTimer(\n                  buffDuration*paceTime,\n                  function()\n                    local runDebuff = table.remove(circCombo,1)\n                    if runDebuff then\n                      chopMod(-1,buffTotal[1])\n                      slashMod(-1,buffTotal[2])\n                      lungeMod(-1,buffTotal[3])\n                      debuffMod(-1,buffTotal[4])\n                      buffTotal = {0,0,0,0}\n                    end\n                  end\n                )\n              end\n            end\n          end\n          \n        elseif not isUse and isCharge then -- on first frame you release use\n          isCharge = false\n          if isWeapon then -- only buff if unbuffed\n            doBuff = true\n            chargeTime = core.getSimulationTime() -- start timer\n          end\n        end\n      end\n    end\n  }\n}",
    "Solthas Combat Pack-52221-1-11-1717384986\\Solthas Combat Pack\\scripts\\SolWeightyChargeAttacks\\scripts\\SolWeightyChargeAttacks.lua": "local core = require('openmw.core')\nlocal ui = require('openmw.ui')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal async = require('openmw.async')\nlocal I = require(\"openmw.interfaces\")\n\n-- settings functions\nlocal function boolSetting(sKey, sDef)\n    return {\n        key = sKey,\n        renderer = 'checkbox',\n        name = sKey..'_name',\n        description = sKey..'_desc',\n        default = sDef,\n    }\nend\nlocal function numbSetting(sKey, sDef, sInt, sMin, sMax)\n    return {\n        key = sKey,\n        renderer = 'number',\n        name = sKey..'_name',\n        description = sKey..'_desc',\n        default = sDef,\n    argument = {\n      integer = sInt,\n      min = sMin,\n      max = sMax,\n    },\n    }\nend\n-- handle settings\nlocal storage = require('openmw.storage')\nI.Settings.registerPage({\n   key = 'SolWeightyChargeAttacks',\n   l10n = 'SolWeightyChargeAttacks',\n   name = 'name',\n   description = 'description',\n})\n-- default values!\nlocal enabled = true\nlocal verbose = 2\nlocal hideChargePopup = true\nlocal incRanged = true -- include ranged weapons ?\nlocal integrateParry = true\nlocal buffControl = 0 -- 0 both, 1 str only, 2 acc only\nlocal buffBase = 2\nlocal fatigueMult = 1.0\nlocal tradeOffBase = 5\nlocal doSpeedRelease = true\nlocal maxCharge = 2\nlocal buffDuration = 0.5\nI.Settings.registerGroup({\n   key = 'Settings_SolWeightyChargeAttacks',\n   page = 'SolWeightyChargeAttacks',\n   l10n = 'SolWeightyChargeAttacks',\n   name = 'group_name',\n   permanentStorage = true,\n   settings = {\n    boolSetting('enabled',enabled),\n    boolSetting('integrateParry',integrateParry),\n    numbSetting('verbose',verbose, true,0,2),\n    boolSetting('hideChargePopup',hideChargePopup),\n    boolSetting('incRanged',incRanged),\n    numbSetting('buffControl',buffControl, true,0,2),\n    numbSetting('buffBase',buffBase, false,0,10),\n    numbSetting('fatigueMult',fatigueMult, false,0,2),\n    numbSetting('tradeOffBase',tradeOffBase, false,0,20),\n    boolSetting('doSpeedRelease',doSpeedRelease),\n    numbSetting('maxCharge',maxCharge, false,1,5),\n    numbSetting('buffDuration',buffDuration, false,0.25,5),\n   },\n})\n\nlocal settingsGroup = storage.playerSection('Settings_SolWeightyChargeAttacks')\n\n-- shorthand for convenience\nlocal Weapon = types.Weapon\nlocal attributes = types.Actor.stats.attributes\nlocal skills = types.NPC.stats.skills\nlocal dynamic = types.Actor.stats.dynamic\n\n-- reduce effectiveness of hybrid stances\nlocal function hybridVal(base,mult,count)\n    return math.ceil(base*math.pow(mult,math.max(count,0)))\nend\n\n-- script config\nlocal modType = 1 --1 skill, -1 debug reset all stat modifiers\nlocal incH2H = true -- include handtohand for heavy charged attacks?\n  -- if true, must define \"weight\" and \"speed\" values for h2h in buff/debuff fncs\n\n-- and store stance idxs for indexing into tables\nlocal stanceIndex = {charge=1, release=2}\nlocal maxStance = 0\nfor _ in pairs(stanceIndex) do\n  maxStance = maxStance + 1\nend\n\n-- init to defaults\nlocal stanceBuff = {-tradeOffBase,buffBase}\nlocal stanceNames = {'',''}\n-- update\nlocal function updateSettings()\n  enabled = settingsGroup:get('enabled')\n  hideChargePopup = settingsGroup:get('hideChargePopup')\n  verbose = settingsGroup:get('verbose')\n    -- update verbose\n    if verbose == 1 then\n    stanceNames = {'STRENGTH UP', 'SKILL UP', 'CHARGE'}\n    elseif verbose == 2 then\n    stanceNames  = {'STR+', 'ACC+', 'SPD etc'}\n    end\n  integrateParry = settingsGroup:get('integrateParry')\n  incRanged = settingsGroup:get('incRanged')\n  buffControl = settingsGroup:get('buffControl')\n  buffBase = settingsGroup:get('buffBase')\n  fatigueMult = settingsGroup:get('fatigueMult')\n  tradeOffBase = settingsGroup:get('tradeOffBase')\n    -- calculate new buff vals\n    stanceBuff = {-tradeOffBase,buffBase}\n  doSpeedRelease = settingsGroup:get('doSpeedRelease')\n  maxCharge = settingsGroup:get('maxCharge')\n  buffDuration = settingsGroup:get('buffDuration')\nend\nlocal function init()\n    updateSettings()\nend\nsettingsGroup:subscribe(async:callback(updateSettings))\n\n-- stance effects \nlocal function chargeMod(modSign,modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    attributes.speed(self).modifier = math.max(0,attributes.speed(self).modifier + modSign*math.ceil(0.5*modVal))\n\t-- do athletics and acrobatics with speed, but give them each half impact\n    skills.athletics(self).modifier = math.max(0,skills.athletics(self).modifier + modSign*math.ceil(0.5*modVal))\n    skills.acrobatics(self).modifier = math.max(0,skills.acrobatics(self).modifier + modSign*math.ceil(0.5*modVal))\n    attributes.agility(self).modifier = math.max(0,attributes.agility(self).modifier + modSign*modVal)\n     -- offset agility by willpower to keep max fatigue constant\n    attributes.willpower(self).damage = math.max(0,attributes.willpower(self).damage + modSign*modVal)\n  else\n    modVal = math.abs(modVal)\n    attributes.speed(self).damage = math.max(0,attributes.speed(self).damage + modSign*math.ceil(0.5*modVal))\n\t-- do athletics and acrobatics with speed, but give them each half impact\n    skills.athletics(self).damage = math.max(0,skills.athletics(self).damage + modSign*math.ceil(0.5*modVal))\n    skills.acrobatics(self).damage = math.max(0,skills.acrobatics(self).damage + modSign*math.ceil(0.5*modVal))\n    attributes.agility(self).damage = math.max(0,attributes.agility(self).damage + modSign*modVal)\n     -- offset agility by willpower to keep max fatigue constant\n    attributes.willpower(self).modifier = math.max(0,attributes.willpower(self).modifier + modSign*modVal)\n  end\nend\nlocal function releaseMod(modSign,modVal,buffType)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    if doSpeedRelease then\n      -- if debuff speed on release\n      attributes.speed(self).damage = math.max(0,attributes.speed(self).damage + tradeOffBase*modSign*modVal)\n      -- do athletics and acrobatics with speed, but give them each half impact\n      skills.athletics(self).damage = math.max(0,skills.athletics(self).damage + tradeOffBase*modSign*modVal)\n      skills.acrobatics(self).damage = math.max(0,skills.acrobatics(self).damage + tradeOffBase*modSign*modVal)\n    end\n    --normal\n    if buffType == 1 then\n      attributes.strength(self).modifier = math.max(0,attributes.strength(self).modifier + modSign*modVal)\n       -- offset strength by willpower to keep max fatigue constant\n      attributes.willpower(self).damage = math.max(0,attributes.willpower(self).damage + modSign*modVal)\n    else\n      skills.axe(self).modifier = math.max(0,skills.axe(self).modifier + modSign*modVal)\n      skills.bluntweapon(self).modifier = math.max(0,skills.bluntweapon(self).modifier + modSign*modVal)\n      skills.handtohand(self).modifier = math.max(0,skills.handtohand(self).modifier + modSign*modVal)\n      skills.longblade(self).modifier = math.max(0,skills.longblade(self).modifier + modSign*modVal)\n      skills.marksman(self).modifier = math.max(0,skills.marksman(self).modifier + modSign*modVal)\n      skills.shortblade(self).modifier = math.max(0,skills.shortblade(self).modifier + modSign*modVal)\n      skills.spear(self).modifier = math.max(0,skills.spear(self).modifier + modSign*modVal)\n    end\n  else -- if negative effect, then damage\n    modVal = math.abs(modVal)\n    if doSpeedRelease then\n      -- if debuff speed on release\n      attributes.speed(self).modifier = math.max(0,attributes.speed(self).modifier + tradeOffBase*modSign*modVal)\n      -- do athletics and acrobatics with speed, but give them each half impact\n      skills.athletics(self).modifier = math.max(0,skills.athletics(self).modifier + tradeOffBase*modSign*modVal)\n      skills.acrobatics(self).modifier = math.max(0,skills.acrobatics(self).modifier + tradeOffBase*modSign*modVal)\n    end\n    --normal\n    if buffType == 1 then\n      attributes.strength(self).damage = math.max(0,attributes.strength(self).damage + modSign*modVal)\n       -- offset strength by willpower to keep max fatigue constant\n      attributes.willpower(self).modifier = math.max(0,attributes.willpower(self).modifier + modSign*modVal)\n    else\n      skills.axe(self).damage = math.max(0,skills.axe(self).damage + modSign*modVal)\n      skills.bluntweapon(self).damage = math.max(0,skills.bluntweapon(self).damage + modSign*modVal)\n      skills.handtohand(self).damage = math.max(0,skills.handtohand(self).damage + modSign*modVal)\n      skills.longblade(self).damage = math.max(0,skills.longblade(self).damage + modSign*modVal)\n      skills.marksman(self).damage = math.max(0,skills.marksman(self).damage + modSign*modVal)\n      skills.shortblade(self).damage = math.max(0,skills.shortblade(self).damage + modSign*modVal)\n      skills.spear(self).damage = math.max(0,skills.spear(self).damage + modSign*modVal)\n    end\n  end\nend\n\n-- init stance total tracking, used for verbose outputs, and for onSave/onLoad tracking\nlocal chargeBuffTotal = {}\nfor i=1,maxStance,1 do \n  chargeBuffTotal[i] = 0\nend\nlocal buffType = 0\n\nlocal function weaponCheck()\n  local isWeapon = false\n  if types.Actor.stance(self) == types.Actor.STANCE.Weapon then\n    local usedWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n    if (not usedWeapon) then -- handtohand\n      isWeapon = incH2H\n    else\n      if  not types.Lockpick.objectIsInstance(usedWeapon) and not types.Probe.objectIsInstance(usedWeapon) then\n        local weaponType = Weapon.record(usedWeapon).type\n        if (weaponType < 9) then -- melee weapon\n          isWeapon = true\n        elseif (weaponType <= 13) then -- ranged weapon\n          isWeapon = incRanged\n        elseif (weaponType > 13) then -- unknown weapon\n          isWeapon = true\n        end\n      end\n    end \n  end\n  return(isWeapon)\nend\n\nlocal function getChargeMod()\n  -- get relevant stats\n  local strength = attributes.strength(self).modified\n  local usedWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n  local weapWeight = 1\n  if not (not usedWeapon) then -- NOT handtohand\n  weapWeight = Weapon.record(usedWeapon).weight\n  end\n  -- setup mod\n  --local buffMod = (1 + math.sqrt(weapWeight))*(50/strength)\n  --local buffMod = (1 + math.sqrt(weapWeight))*math.max(0,(2.5-(strength/50)))\n  local buffMod = (1 + math.sqrt(weapWeight))*(100/(strength+50))\n    -- mod up as weapon weight up, with minimum\n    -- mod down as strength up\n  return(buffMod)\nend\n\nlocal function getReleaseMod(chargeTime)\n  -- get relevant stats\n  local usedWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n  local weapSpeed = 1\n  local weapWeight = 1\n  if not (not usedWeapon) then -- NOT handtohand\n  weapSpeed = Weapon.record(usedWeapon).speed\n  weapWeight = Weapon.record(usedWeapon).weight\n  end\n  -- setup mod\n  local buffMod = (1 + math.sqrt(weapWeight))*math.min(maxCharge,(chargeTime*weapSpeed))--/weapSpeed\n    -- mod up as weapon weight up, with minimum\n    -- mod up as charge increases, vs weapon speed\n    -- mod up as weapon speed up?\n  return(buffMod)\nend\n\n-- save state to be removed on load\nlocal function onSave()\n    return{\n      chargeBuffTotal = chargeBuffTotal,\n\t  buffType = buffType\n    }\nend\n\nlocal function onLoad(data)\n  if data then\n    chargeBuffTotal = data.chargeBuffTotal\n\tbuffType = data.buffType\n    chargeMod(-1,chargeBuffTotal[1])\n    releaseMod(-1,chargeBuffTotal[2],buffType)\n    for i=1,maxStance,1 do\n      chargeBuffTotal[i] = 0\n    end\n  end\nend\n\nlocal weaponWeight = 0\nlocal chargeTime = 0\nlocal doBuff = false\nlocal isCharge = false -- true if trigger input action\nlocal isWeapon = false\nreturn { \n  engineHandlers = { \n    -- init settings\n    onActive = init,\n    -- save and load handling so you don't get stuck with modified stats\n    onSave = onSave,\n    onLoad = onLoad,\n    \n    onUpdate = function(dt)\n      if core.API_REVISION > 60 and I.UI.getMode() ~= nil then return end\n      if enabled then\n        local isUse = input.isActionPressed(input.ACTION.Use)\n        \n        if isUse and not isCharge then -- on first frame you hit use        \n--        if isUse and not isCharge and not types.Actor.isOnGround(self) then -- on first frame you hit use        \n          isCharge = true -- update stance\n          isWeapon = weaponCheck()\n          -- apply charge debuff\n          if isWeapon then\n            chargeTime = core.getSimulationTime() -- set timer value\n            local buffNext = hybridVal(stanceBuff[1],getChargeMod(),1)\n            chargeMod(1,buffNext)\n            chargeBuffTotal[1] = chargeBuffTotal[1] + buffNext\n            if verbose>0 and not integrateParry and not hideChargePopup then\n              ui.showMessage(stanceNames[3] .. ' ' .. tostring(chargeBuffTotal[1]))\n            end\n          end\n          \n        elseif not isUse and isCharge then -- on first frame you release use\n          isCharge = false\n          -- remove charge debuff\n          chargeMod(-1,chargeBuffTotal[1])\n          chargeBuffTotal[1] = 0\n          if isWeapon and chargeBuffTotal[2]==0 then -- only buff if unbuffed\n            chargeTime = core.getSimulationTime() - chargeTime -- get timer value\n            -- check if applying buff\n            doBuff = true\n            if integrateParry then\n              local ig = types.Actor.isOnGround(self)\n              local is = types.Actor.isSwimming(self)\n              local mf = self.controls.movement\n              local ms = self.controls.sideMovement\n              if (ig or is) and mf == -1 then -- backwards component\n                doBuff = false -- def\n              elseif (ig or is) and mf == 0 and ms ~= 0 then -- sideways only\n                doBuff = false -- agi\n              end\n            end\n      \n            if doBuff then\n              -- get release buff\n              local buffNext = hybridVal(stanceBuff[2],getReleaseMod(chargeTime),1)\n              -- fatigue cost\n              local cfat = dynamic.fatigue(self).current\n              local strength = attributes.strength(self).modified\n              local fatigueCost = math.ceil(fatigueMult*buffNext*100/(strength+50))\n              dynamic.fatigue(self).current = math.max(0,cfat - fatigueCost)\n              -- buff accuracy or strength depending on isGrounded and config val\n              if buffControl == 0 then\n                if (types.Actor.isOnGround(self) or types.Actor.isSwimming(self)) then\n                  buffType = 2 -- acc\n                else\n                  buffType = 1 -- str\n                end\n              else\n                buffType = buffControl\n              end\n              -- apply buff\n              releaseMod(1,buffNext,buffType)\n              chargeBuffTotal[2] = chargeBuffTotal[2] + buffNext\n              -- status info\n              if verbose>0 then\n                local buffMax = hybridVal(stanceBuff[2],getReleaseMod(maxCharge),1)\n                if buffType == 1 then\n                  ui.showMessage(stanceNames[1] .. ' ' .. tostring(chargeBuffTotal[2]) .. ' / ' .. tostring(buffMax))\n                else\n                  ui.showMessage(stanceNames[2] .. ' ' .. tostring(chargeBuffTotal[2]) .. ' / ' .. tostring(buffMax))\n                end\n              end\n              -- start release timer\n              async:newUnsavableSimulationTimer(\n                buffDuration,\n                function()\n                  releaseMod(-1,chargeBuffTotal[2],buffType)\n                  chargeBuffTotal[2] = 0\n                end\n              )\n            end\n          end\n        end\n      end\n    end\n  }\n}"
  }
}