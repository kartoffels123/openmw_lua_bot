{
  "folder_name": "SME - Useful Widgets - Actor Info - Health Bar - Hit Chance",
  "lua_files": {
    "Show Me Everything-53996-1-2-1-1708168299\\Scripts\\sme_hitchance.lua": "local async = require(\"openmw.async\")\nlocal camera = require(\"openmw.camera\")\nlocal core = require(\"openmw.core\")\nlocal I = require(\"openmw.interfaces\")\nlocal nearby = require(\"openmw.nearby\")\nlocal self = require(\"openmw.self\")\nlocal types = require(\"openmw.types\")\nlocal ui = require(\"openmw.ui\")\nlocal util = require(\"openmw.util\")\nlocal storage = require('openmw.storage')\n\nlocal hitChanceLogicTimer = 0\nlocal hitChanceLogicTime = 0.1\nlocal hitChanceUpdateTimer = 0\nlocal hitChanceUpdateTime = 5\nlocal distance = 0\nlocal focusTimer = 0\nlocal focusTime = 0.3\nlocal timeToFadeOut = false\nlocal fadeOutTimer = 0\nlocal fadeOutTime = 1\nlocal widgetIsShowing = false\nlocal lastUpdateTime = 0\nlocal updateInterval = 1\nlocal showingTime = 0\n\nlocal settings = {\n    behavior = storage.playerSection('SMESettingsBh'),\n    style = storage.playerSection('SMESettingsSt'),\n    hitChance = storage.playerSection('SMEHitChanceSettings'),\n}\n\nlocal weaponSkillMap = {\n\t[types.Weapon.TYPE.AxeOneHand] = \"axe\",\n\t[types.Weapon.TYPE.AxeTwoHand] = \"axe\",\n\t[types.Weapon.TYPE.BluntOneHand] = \"bluntweapon\",\n\t[types.Weapon.TYPE.BluntTwoClose] = \"bluntweapon\",\n\t[types.Weapon.TYPE.BluntTwoWide] = \"bluntweapon\",\n\t[types.Weapon.TYPE.LongBladeOneHand] = \"longblade\",\n\t[types.Weapon.TYPE.LongBladeTwoHand] = \"longblade\",\n\t[types.Weapon.TYPE.MarksmanBow] = \"marksman\",\n\t[types.Weapon.TYPE.MarksmanCrossbow] = \"marksman\",\n\t[types.Weapon.TYPE.MarksmanThrown] = \"marksman\",\n\t[types.Weapon.TYPE.ShortBladeOneHand] = \"shortblade\",\n\t[types.Weapon.TYPE.SpearTwoWide] = \"spear\",\n}\n\nlocal function calcHitChance(weapon)\n\tlocal weaponSkill =\n\t\ttypes.NPC.stats.skills[weapon and weaponSkillMap[types.Weapon.record(weapon).type] or \"handtohand\"](self).modified\n\tlocal agility = types.Actor.stats.attributes.agility(self).modified\n\tlocal luck = types.Actor.stats.attributes.luck(self).modified\n\tlocal fatigueCurrent = types.Actor.stats.dynamic.fatigue(self).current\n\tlocal fatigueBase = types.Actor.stats.dynamic.fatigue(self).base\n\tlocal fortifyAttack = types.Actor.activeEffects(self):getEffect(core.magic.EFFECT_TYPE.FortifyAttack)\n\tlocal blind = types.Actor.activeEffects(self):getEffect(core.magic.EFFECT_TYPE.Blind)\n\treturn (weaponSkill + (agility / 5) + (luck / 10)) * (0.75 + (0.5 * (fatigueCurrent / fatigueBase)))\n\t\t+ (fortifyAttack and fortifyAttack.magnitude or 0)\n\t\t+ (blind and blind.magnitude or 0)\nend\n\nlocal function calcEvasion(target)\n\tlocal agility = types.Actor.stats.attributes.agility(target).modified\n\tlocal luck = types.Actor.stats.attributes.luck(target).modified\n\tlocal fatigueCurrent = types.Actor.stats.dynamic.fatigue(target).current\n\tlocal fatigueBase = types.Actor.stats.dynamic.fatigue(target).base\n\tlocal sanctuary = types.Actor.activeEffects(target):getEffect(core.magic.EFFECT_TYPE.Sanctuary)\n\treturn ((agility / 5) + (luck / 10)) * (0.75 + (0.5 * (fatigueCurrent / fatigueBase)))\n\t\t+ (sanctuary and sanctuary.magnitude or 0)\nend\n\nlocal hitChanceReticleElement = {\n\ttype = ui.TYPE.Image,\n\tprops = {\n\t\tresource = ui.texture({ path = 'Textures/targetHitChance.png' }),\n\t\t--color = util.color.rgb(65 / 255, 65 / 255, 65 / 255),\n\t\tsize = util.vector2(38, 38),\n\t\t-- position in the top right corner\n\t\trelativePosition = util.vector2(0.5, 0.5),\n\t\t-- position is for the top left corner of the widget by default\n\t\t-- change it to align exactly to the top right corner of the screen\n\t\tanchor = util.vector2(0.5, 0.5),\n\t\t--visible = false,\n\t},\n}\n\nlocal hitChanceReticle = ui.create({\n\tlayer = \"HUD\",\n\ttype = ui.TYPE.Image,\n\tprops = {\n\t\tresource = ui.texture({ path = 'Textures/targetHitChance.png' }),\n\t\t--color = util.color.rgb(65 / 255, 65 / 255, 65 / 255),\n\t\tsize = util.vector2(26, 26),\n\t\t-- position in the top right corner\n\t\trelativePosition = util.vector2(0.5, 0.5),\n\t\t-- position is for the top left corner of the widget by default\n\t\t-- change it to align exactly to the top right corner of the screen\n\t\tanchor = util.vector2(0.5, 0.5),\n\t\tvisible = false,\n\t},\n})\n\nlocal hitChanceWidgetPercent = ui.content {\n    {\n        name = \"hitChanceContainer\",\n        props = {\n            -- suspicious, probably this should be aligned within a Flex widget of some kind instead\n            relativePosition = util.vector2(0.8, 0.63),\n            anchor = util.vector2(0.5, 0.5),\n            size = util.vector2(50, 20),\n        },\n        content = ui.content {\n            {\n                name = \"hitChanceBG\",\n                type = ui.TYPE.Image,\n                props = {\n                    alpha = 0.8,\n                    resource = ui.texture({ path = 'White' }),\n                    color = util.color.rgb(1 / 255, 1 / 255, 1 / 255),\n                    relativeSize = util.vector2(1, 1),\n                },\n            },\n            {\n\n                name = \"hitChanceText\",\n                type = ui.TYPE.Text,\n                props = {\n                    text = \"%\",\n                    textColor = util.color.rgba(1, 1, 1, 1),\n                    textSize = 14,\n                    relativePosition = util.vector2(0.5, 0.5),\n                    anchor = util.vector2(0.5, 0.5),\n                },\n            },\n        },\n    },\n}\n\nlocal hitChanceWidgetCircle = ui.content {\n    {\n        name = \"hitChanceWidget\",\n        type = ui.TYPE.Image,\n            props = {\n            resource = ui.texture({ path = 'Textures/hitIndicator.png' }),\n            --color = util.color.rgb(65 / 255, 65 / 255, 65 / 255),\n            size = util.vector2(8, 8),\n            -- position in the top right corner\n            relativePosition = util.vector2(0.6, 0.6),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0.5),\n            --visible = false,\n        },\n    },\n}\n\nlocal hitChanceWidgetScale = ui.content {\n    {\n        name = \"hitChanceWidgetBG\",\n        type = ui.TYPE.Image,\n            props = {\n\t\t\talpha = 0.8,\n            resource = ui.texture({ path = 'White' }),\n            color = util.color.rgb(1 / 255, 1 / 255, 1 / 255),\n            size = util.vector2(10, 45),\n            -- position in the top right corner\n            relativePosition = util.vector2(0.65, 0.5),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0.5),\n            --visible = false,\n        },\n    },\n\t{\n        name = \"hitChanceWidgetScale\",\n        type = ui.TYPE.Image,\n            props = {\n\t\t\talpha = 0.8,\n            resource = ui.texture({ path = 'White' }),\n            color = util.color.rgb(244 / 255, 198 / 255, 0 / 255),\n            size = util.vector2(6, 40),\n            -- position in the top right corner\n            relativePosition = util.vector2(0.65, 0.5),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0.5),\n            --visible = false,\n        },\n    },\n}\n\nlocal hitChanceWidget = ui.create {\n\tname = 'TutorialNotifyMenu',\n\tl10n = 'UITutorial',\n\tlayer = 'HUD',\n\t-- This is a helper template, which sets up this interface element in the style of Morrowind.\n\t-- Reference: https://openmw.readthedocs.io/en/latest/reference/lua-scripting/interface_mwui.html\n\t--template = I.MWUI.templates.boxTransparent,\n\ttype = ui.TYPE.Widget,\n    props = {\n\t\tanchor = util.vector2(0.5, 0.5),\n\t\trelativePosition = util.vector2(0.5, 0.5),\n\t\tvisible = false,\n\t\tsize = util.vector2(150, 150),\n        template = I.MWUI.templates.boxTransparent,\n\t\t-- Menu positioning props:\n\t\t-- Reference: https://openmw.readthedocs.io/en/latest/reference/lua-scripting/widgets/widget.html\n\n\t\t-- Pin the bottom center (50% X 100% Y) of this container to ...\n\t\t----anchor = util.vector2(0.5, 1),\n\t\t\n\t\t-- the screen horizontal center and near the bottom of the screen (50% X 95% Y).\n        ----relativePosition = util.vector2(0.5, 0.95),\n\t},\n\t-- Use ui.content for every content field.\n\tcontent = hitChanceWidgetScale,\n}\n\nlocal function updateWidgetStyle()\n\tif settings.hitChance:get('SMEhitChanceWidget') == 'Percent' then\n        hitChanceWidget.layout.content = hitChanceWidgetPercent\n\telseif settings.hitChance:get('SMEhitChanceWidget') == 'Circle' then\n\t\thitChanceWidget.layout.content = hitChanceWidgetCircle\n\telseif settings.hitChance:get('SMEhitChanceWidget') == 'Scale' then\n\t\thitChanceWidget.layout.content = hitChanceWidgetScale\n\tend\nend\n\nlocal function disableHitChance()\n\tif not settings.hitChance:get('hitChanceIsActive') then\n\t\tif settings.hitChance:get('SMEhitChanceReticle') then\n\t\t\thitChanceReticle.layout.props.visible = false\n\t\t\thitChanceReticle:update()\n\t\tend\n\t--hitChanceElement:update()\n\t\thitChanceWidget.layout.props.visible = false\n\t\tfadeOutTimer = 0\n\t\thitChanceWidget:update()\n\tend\nend\n\nlocal function disableColoredReticle()\n\tif not settings.hitChance:get('SMEhitChanceReticle') then\n\t\thitChanceReticle.layout.props.visible = false\n\t\thitChanceReticle:update()\n\tend\nend\n\nupdateWidgetStyle()\ndisableHitChance()\ndisableColoredReticle()\n\nsettings.hitChance:subscribe(async:callback(updateWidgetStyle))\nsettings.hitChance:subscribe(async:callback(disableHitChance))\nsettings.hitChance:subscribe(async:callback(disableColoredReticle))\n\nlocal tooltipTarget\nlocal barSize = util.vector2(6, 40)\n\nlocal function getTooltipTarget(dt)\n    local from = camera.getPosition()\n    local to\n\n    if types.Weapon.objectIsInstance(types.Actor.getEquipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)) then\n        -- Check if the carried right weapon is of the marksman group\n        local weaponType = types.Weapon.record(types.Actor.getEquipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)).type\n        local isMarksmanWeapon = weaponSkillMap[weaponType] == \"marksman\"\n\n        -- Adjust raycast length based on weapon type\n        local raycastLength = isMarksmanWeapon and 4000 or 192\n        to = from + camera.viewportToWorldVector(util.vector2(0.5, 0.5)) * raycastLength\n    else\n        -- Default raycast length for non-weapon cases\n        to = from + camera.viewportToWorldVector(util.vector2(0.5, 0.5)) * 192\n    end\n\n    nearby.asyncCastRenderingRay(\n        async:callback(function(result)\n            tooltipTarget = result.hitObject\n        end),\n        from,\n        to\n    )\nend\n\nlocal function displayWidget(elementColour, hitChance)\n\tfocusTimer = focusTime\n\ttimetoFadeOut = false\n\twidgetIsShowing = true\n\t--hitChanceElement.layout.props.alpha = 1.0\n\thitChanceWidget.layout.props.alpha = 1.0\n\t\n\tif hitChanceWidget.layout.content == hitChanceWidgetPercent then\n\t\thitChanceWidget.layout.content[\"hitChanceContainer\"].content[\"hitChanceText\"].props.textColor = util.color.rgba(table.unpack(elementColour))\n\telseif hitChanceWidget.layout.content == hitChanceWidgetCircle then\n\t\thitChanceWidget.layout.content[\"hitChanceWidget\"].props.color = util.color.rgba(table.unpack(elementColour))\n\tend\n\n\tif settings.hitChance:get('SMEhitChanceReticle') then\n\t\thitChanceReticle.layout.props.alpha = 1.0\n\t\thitChanceReticle.layout.props.visible = true\n\t\thitChanceReticle.layout.props.color = util.color.rgba(table.unpack(elementColour))\n\tend\n\n\tif hitChanceWidget.layout.content == hitChanceWidgetScale then\n\t\thitChanceWidget.layout.content[\"hitChanceWidgetScale\"].props.color = util.color.rgba(table.unpack(elementColour))\n\t\tlocal hitChanceRounded = math.min(hitChance, 100)\n\t\tlocal ratio = hitChanceRounded / 100\n        hitChanceWidget.layout.content[\"hitChanceWidgetScale\"].props.size = barSize:emul(util.vector2(1, ratio))\n\tend\n\t\n\t--hitChanceElement.layout.props.visible = true\n\thitChanceWidget.layout.props.visible = true\n\tfadeOutTimer = 0\n\t--hitChanceElement:update()\n\thitChanceWidget:update()\n\thitChanceReticle:update()\nend\n\nlocal function displayHitChance(dt)\n\thitChanceLogicTimer = hitChanceLogicTimer + dt\n\n\tif hitChanceLogicTimer >= hitChanceLogicTime then\n\t\tif camera.getMode() == camera.MODE.FirstPerson then\n            \n            if settings.behavior:get('SMEisActive') and settings.hitChance:get('hitChanceIsActive') then\n                tooltipTarget = I.SME_CORE.getRaycastTarget()\n                distance = I.SME_CORE.getDistance()\n            else\n\t\t\t    getTooltipTarget()\n            end\n\t\telse\n\t\t\ttooltipTarget = nil\n\t\tend\n\t\tif\n\t\t\ttooltipTarget\n\t\t\tand (types.NPC.objectIsInstance(tooltipTarget) or types.Creature.objectIsInstance(tooltipTarget))\n\t\t\tand types.Actor.getStance(self) == types.Actor.STANCE.Weapon\n\t\t\tand not types.Actor.isDead(tooltipTarget)\n\t\tthen\n\t\t\tlocal carriedRight = types.Actor.getEquipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n\t\t\tif carriedRight and types.Weapon.objectIsInstance(carriedRight) or carriedRight == nil then\n\t\t\t\tlocal hitChance = math.max(0, calcHitChance(carriedRight) - calcEvasion(tooltipTarget))\n\t\t\t\tif hitChanceWidget.layout.content == hitChanceWidgetPercent then\n\t\t\t\t\thitChanceWidget.layout.content[\"hitChanceContainer\"].content[\"hitChanceText\"].props.text = string.format(\"%d%%\", util.round(hitChance * 100) / 100)\n\t\t\t\tend\n\t\t\t\tlocal elementColour\n\t\t\t\tif hitChance <= 25 then\n\t\t\t\t\telementColour = { 193 / 255, 63 / 255, 55 / 255, 1 }\n\t\t\t\telseif hitChance <= 50 then\n\t\t\t\t\telementColour = { 255 / 255, 220 / 255, 95 / 255, 1 }\n\t\t\t\telseif hitChance <= 75 then\n\t\t\t\t\telementColour = { 1, 1, 1, 1 }\n\t\t\t\telseif hitChance <= 100 then\n\t\t\t\t\telementColour = { 180 / 255, 255 / 255, 158 / 255, 1 }\n\t\t\t\telse\n\t\t\t\t\telementColour = { 184 / 255, 102 / 255, 211 / 255, 1 }\n\t\t\t\tend\n                if settings.behavior:get('SMEisActive') then \n                    local weaponType = types.Weapon.record(types.Actor.getEquipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)).type\n                    local isMarksmanWeapon = weaponSkillMap[weaponType] == \"marksman\"\n                    if distance < 193 and not isMarksmanWeapon then\n\t\t\t\t\t\tdisplayWidget(elementColour, hitChance)\n\t\t\t\t\t\t\n\t\t\t\t\telseif isMarksmanWeapon then\n\t\t\t\t\t\tdisplayWidget(elementColour, hitChance)\n                    end\n                else\n\t\t\t\t\tdisplayWidget(elementColour, hitChance)\n                end\n\t\t\tend\n\t\tend\n\tend\n\n\nend\n\n\n\n\nlocal function hitChanceFadeOut(dt)\n\tfadeOutTimer = fadeOutTimer + dt\n\t\t\n\t-- Gradually lower alpha to 0 over fadeOutTime\n\tlocal alphaPercentage = 1.0 - fadeOutTimer / fadeOutTime\n\n\tif settings.hitChance:get('SMEhitChanceReticle') then\n\t\thitChanceReticle.layout.props.alpha = math.max(0, alphaPercentage)\n\t\thitChanceReticle:update()\n\tend\n\thitChanceWidget.layout.props.alpha =  math.max(0, alphaPercentage)\n\n\t\n\thitChanceWidget:update()\n\tif fadeOutTimer >= fadeOutTime then\n\n\t\tif settings.hitChance:get('SMEhitChanceReticle') then\n\t\t\thitChanceReticle.layout.props.visible = false\n\t\t\thitChanceReticle.layout.props.alpha = 1\n\t\t\thitChanceReticle:update()\n\t\tend\n\t\t\n\t\thitChanceWidget.layout.props.visible = false\n\t\t\n\t\thitChanceWidget.layout.props.alpha = 1.0\n\t\t\n\t\thitChanceWidget:update()\n\t\t\n\t\tfadeOutTimer = 0\n\n\t\ttimetoFadeOut = false\n\t\twidgetIsShowing = false\n\tend\nend\n\nlocal function onUpdate(dt)\n    if not settings.hitChance:get('hitChanceIsActive') then return end\n\n\tdisplayHitChance(dt)\n\n\tif focusTimer > 0 then\n\t\tfocusTimer = focusTimer - dt\n\tend\n\n\tif focusTimer <= 0 and widgetIsShowing then\n\t\ttimetoFadeOut = true\n\tend\n\n\tif timetoFadeOut then\n\t\thitChanceFadeOut(dt)\n\tend\nend\n\nreturn { engineHandlers = { onUpdate = onUpdate } }",
    "Show Me Everything-53996-1-2-1-1708168299\\Scripts\\sme_settings.lua": "local storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\nlocal async = require('openmw.async')\n\nI.Settings.registerPage {\n    key = \"SMESettingsBehavior\",\n    l10n = \"SMESettingsBehavior\",\n    name = \"Show Me Everything: Actor UI\",\n    description = \"Behavior settings for the widget.\"\n}\n\nI.Settings.registerPage {\n    key = \"SMESettingsStyle\",\n    l10n = \"SMESettingsStyle\",\n    name = \"Show Me Everything: Visual\",\n    description = \"Style settings for the widget.\"\n}\n\nI.Settings.registerPage {\n    key = \"SMEhitChance\",\n    l10n = \"SMEhitChance\",\n    name = \"Show Me Everything: Hit Chance\",\n    description = \"Hit chance widget. Base of the code and idea by Safeicus Boxius.\"\n}\n\nI.Settings.registerGroup({\n    key = 'SMESettingsBh', \n    page = 'SMESettingsBehavior',\n    l10n = 'SMESettingsBehavior',\n    name = 'Behavior',\n    permanentStorage = true,\n    settings = {\n        {\n            key = \"SMEisActive\",\n            renderer = \"checkbox\",\n            name = \"Modification is enabled\",\n            description =\n            \"Uncheck to disable Show Me Everything widget. This setting controls whether the modification is active or not.\",\n            default = true\n        },\n        {\n            key = \"SMEClass\",\n            renderer = \"checkbox\",\n            name = \"Show NPC class\",\n            description =\n            \"If enabled, the widget will show the class of the NPC.\",\n            default = true\n        },\n        {\n            key = 'SMELevel',\n            renderer = \"checkbox\",\n            name = \"Show NPC level\",\n            description =\n            \"If enabled, the widget will show the level of the NPC.\",\n            default = true\n        },\n        {\n            key = 'SMEHealth',\n            renderer = \"checkbox\",\n            name = \"Show NPC health values\",\n            description =\n            \"If enabled, the widget will show the health values of the NPC.\",\n            default = true\n        },\n        {\n            key = 'SMEDamage',\n            renderer = \"checkbox\",\n            name = \"Show damage widget\",\n            description =\n            \"If enabled, every time you attack an NPC, damage values will be shown.\",\n            default = true\n        },\n        {\n            key = 'SMERaycastLength',\n            name = 'Raycast length',\n            description = 'Controls the length of the Raycast. Higher values will let you pick farther targets but may cost you some performance. Default is 3000, values are from 1000 to 6000.',\n            default = 3000,\n            renderer = 'number',\n            argument = {\n                min = 1000,\n                max = 6000,\n                integer = true,\n            },\n        },\n        {\n            key = 'SMEShowDistance',\n            name = 'Widget display distance',\n            description = 'Controls the distance at which the widget will be displayed when looking at actors. Set to 192 for a display range similar to the vanilla game on activation. Values are from 192 to 1000.',\n            default = 500,\n            renderer = 'number',\n            argument = {\n                min = 192,\n                max = 1000,\n                integer = true,\n            },\n        },\n        {\n            key = 'SMEStance',\n            renderer = \"checkbox\",\n            name = \"Only show in combat stance\",\n            description =\n            \"If enabled, the widget logic will be working in the background, but the widget will only be shown when you are in a combat stance or someone in the focus is taking damage.\",\n            default = false\n        },\n        {\n            key = 'SMEonHit',\n            renderer = \"checkbox\",\n            name = \"Only show on damage\",\n            description =\n            \"If enabled, the widget will only be shown when you hit an actor and deal damage to them. Overrides the previous setting\",\n            default = false\n        },\n        {\n            key = 'SMEnotForDead',\n            renderer = \"checkbox\",\n            name = \"Show the widget for dead actors\",\n            description =\n            \"If disabled, all dead actors will be ignored and widget will be shown only for alive (or undead) ones.\",\n            default = true\n        },\n    },\n})\n\nI.Settings.registerGroup({\n    key = 'SMESettingsSt', \n    page = 'SMESettingsStyle',\n    l10n = 'SMESettingsStyle',\n    name = 'Visuals',\n    permanentStorage = true,\n    settings = {\n        {\n            key = 'SMEWidgetStyle',\n            name = 'Visual preset for the widget',\n            description = 'Here you can choose one of two presets for the widget.',\n            default = 'Vanilla', \n            renderer = 'select',\n            argument = {\n                disabled = false,\n                l10n = 'LocalizationContext', \n                items = {'Vanilla', 'Skyrim', 'Sky Nostalgy', 'Flat', 'Minimal Vanilla', 'Sixth House'},\n            },\n        },\n    },\n})\n\nI.Settings.registerGroup({\n    key = 'SMEHitChanceSettings', \n    page = 'SMEhitChance',\n    l10n = 'SMEhitChance',\n    name = 'Hit Chance widget settings.',\n    permanentStorage = true,\n    settings = {\n        {\n            key = \"hitChanceIsActive\",\n            renderer = \"checkbox\",\n            name = \"Hit Chance indicator switch\",\n            description =\n            \"Uncheck to disable Hit Chance indicator. This setting controls whether the indicator will be shown or not.\",\n            default = true\n        },\n        {\n            key = 'SMEhitChanceWidget',\n            name = 'Visual preset for the Hit Chance widget',\n            description = 'Here you can choose one of several presets for the widget.',\n            default = 'Percent',\n            renderer = 'select',\n            argument = {\n                disabled = false,\n                l10n = 'LocalizationContext', \n                items = {'Percent', 'Circle', 'Scale'},\n            },\n        },\n        {\n            key = \"SMEhitChanceReticle\",\n            renderer = \"checkbox\",\n            name = \"Hit Chance colored reticle\",\n            description =\n            \"If enabled, the reticle will be colored accordingly to the hit chance.\",\n            default = false\n        },\n    },\n})\n\n\nlocal settings = {\n    behavior = storage.playerSection('SMESettingsBh'),\n    style = storage.playerSection('SMESettingsSt'),\n    hitChance = storage.playerSection('SMEHitChanceSettings'),\n}\n\nlocal stanceIsEnabled = false\nlocal onHitIsEnabled = false\n\nlocal function disableModification()\n    local disabled = not settings.behavior:get('SMEisActive')\n    I.Settings.updateRendererArgument('SMESettingsBh', 'SMEClass', {disabled = disabled})\n    I.Settings.updateRendererArgument('SMESettingsBh', 'SMELevel', {disabled = disabled})\n    I.Settings.updateRendererArgument('SMESettingsBh', 'SMEHealth', {disabled = disabled})\n    I.Settings.updateRendererArgument('SMESettingsBh', 'SMEDamage', {disabled = disabled})\n    I.Settings.updateRendererArgument('SMESettingsBh', 'SMEStance', {disabled = disabled})\n    I.Settings.updateRendererArgument('SMESettingsBh', 'SMEonHit', {disabled = disabled})\n    I.Settings.updateRendererArgument('SMESettingsBh', 'SMEnotForDead', {disabled = disabled})\n    I.Settings.updateRendererArgument('SMESettingsBh', 'SMERaycastLength', {disabled = disabled})\n    I.Settings.updateRendererArgument('SMESettingsBh', 'SMEShowDistance', {disabled = disabled})\n    I.Settings.updateRendererArgument('SMESettingsSt', 'SMEWidgetStyle', {disabled = disabled, l10n = 'randomValue', items = {'Vanilla', 'Skyrim', 'Sky Nostalgy', 'Flat', 'Minimal Vanilla', 'Sixth House'}})\n    \n    \nend\n\nlocal function disableHitChance()\n    local disabled = not settings.hitChance:get('hitChanceIsActive')\n    I.Settings.updateRendererArgument('SMEHitChanceSettings', 'SMEhitChanceReticle', {disabled = disabled})\n    I.Settings.updateRendererArgument('SMEHitChanceSettings', 'SMEhitChanceWidget', {disabled = disabled, l10n = 'randomValue', items = {'Percent', 'Circle', 'Scale'}})\n    \n    \nend\n\n\ndisableModification()\ndisableHitChance()\n\n\nsettings.behavior:subscribe(async:callback(disableModification))\nsettings.hitChance:subscribe(async:callback(disableHitChance))\n\n\nlocal mxRaycastLengthLastCheck = 0\nlocal mxRaycastLengthThisCheck = 0\nlocal raycastLength = 0\nlocal timeToUpdateSettings = 0\nlocal activateLength = 0\nlocal onHitThisFrame\nlocal onHitLastFrame\nlocal onStanceThisFrame\nlocal onStanceLastFrame\n\n\nlocal function onFrame(dt)\n\n    if I.UI.getMode() == 'SettingsMenu' then\n        timeToUpdateSettings = timeToUpdateSettings + 1\n    end\n\n    if timeToUpdateSettings > 20 and I.UI.getMode() == 'SettingsMenu' then\n        \n        raycastLength = settings.behavior:get('SMERaycastLength')\n        activateLength = settings.behavior:get('SMEShowDistance')\n\n        if settings.behavior:get('SMERaycastLength') and raycastLength > 6000 then\n            settings.behavior:set('SMERaycastLength', 6000)\n        elseif settings.behavior:get('SMERaycastLength') and raycastLength < 1000 then\n            settings.behavior:set('SMERaycastLength', 1000)\n        end\n\n        if settings.behavior:get('SMEShowDistance') and activateLength > 1000 then\n            settings.behavior:set('SMEShowDistance', 1000)\n        elseif settings.behavior:get('SMEShowDistance') and activateLength < 192 then\n            settings.behavior:set('SMEShowDistance', 192)\n        end\n        onStanceThisFrame = settings.behavior:get('SMEStance')\n\n        if settings.behavior:get('SMEonHit') and onStanceThisFrame == onStanceLastFrame and settings.behavior:get('SMEStance') then\n            print(settings.behavior:get('SMEonHit'), settings.behavior:get('SMEStance'), onStanceThisFrame, onStanceLastFrame)\n            settings.behavior:set('SMEStance', false)\n            \n        elseif settings.behavior:get('SMEonHit') and settings.behavior:get('SMEStance') then\n            print(settings.behavior:get('SMEonHit'), settings.behavior:get('SMEStance'), onStanceThisFrame, onStanceLastFrame)\n            settings.behavior:set('SMEonHit', false)\n        end\n        onStanceLastFrame = onStanceThisFrame\n        timeToUpdateSettings = 0\n    end\n\nend\n\nreturn {\n    engineHandlers = {\n        dt = dt,\n        onUpdate = onUpdate,\n        onFrame = onFrame,\n        onLoad = onLoad,\n    },\n}\n",
    "Show Me Everything-53996-1-2-1-1708168299\\Scripts\\sme_style_settings.lua": "local async = require(\"openmw.async\")\nlocal camera = require(\"openmw.camera\")\nlocal core = require(\"openmw.core\")\nlocal I = require(\"openmw.interfaces\")\nlocal nearby = require(\"openmw.nearby\")\nlocal self = require(\"openmw.self\")\nlocal types = require(\"openmw.types\")\nlocal ui = require(\"openmw.ui\")\nlocal util = require(\"openmw.util\")\nlocal storage = require('openmw.storage')\n\nlocal settings = {\n    behavior = storage.playerSection('SMESettingsBh'),\n    style = storage.playerSection('SMESettingsSt'),\n}\n\nlocal healthBarSkyrimStyle = ui.content {\n        {\n            name = \"hbBG\",\n            type = ui.TYPE.Image,\n                props = {\n                resource = ui.texture({ path = 'Textures/HbSkyrimBG.png' }),\n                --color = util.color.rgb(8 / 255, 8 / 255, 8 / 255),\n                size = util.vector2(250, 12),\n                -- position in the top right corner\n                relativePosition = util.vector2(0.50, 0.18),\n                -- position is for the top left corner of the widget by default\n                -- change it to align exactly to the top right corner of the screen\n                anchor = util.vector2(0.5, 0),\n                --visible = false,\n            },\n        },\n        {\n            name = \"hbBarAnim\",\n            type = ui.TYPE.Image,\n            props = {\n                resource = ui.texture({ path = 'Textures/HbSkyrimAnim.png' }),\n                color = util.color.rgb(200 / 255, 200 / 255, 200 / 255),\n                size = util.vector2(250, 12),\n                -- position in the top right corner\n                align = ui.ALIGNMENT.Center,\n                relativePosition = util.vector2(0.5, 0.18),\n                -- position is for the top left corner of the widget by default\n                -- change it to align exactly to the top right corner of the screen\n                anchor = util.vector2(0.5, 0),\n                --visible = false,\n            },\n        },\n        {\n            name = \"hbBar\",\n            type = ui.TYPE.Image,\n            props = {\n                resource = ui.texture({ path = 'Textures/HbSkyrimHealth.png' }),\n                color = util.color.rgb(135 / 255, 36 / 255, 32 / 255),\n                size = util.vector2(250, 12),\n                -- position in the top right corner\n                align = ui.ALIGNMENT.Center,\n                relativePosition = util.vector2(0.5, 0.18),\n                -- position is for the top left corner of the widget by default\n                -- change it to align exactly to the top right corner of the screen\n                anchor = util.vector2(0.5, 0),\n                --visible = false,\n            },\n        },\n        {\n            name = \"hbOL\",\n            type = ui.TYPE.Image,\n            props = {\n                resource = ui.texture({ path = 'Textures/HbSkyrimOverlay.png' }),\n                size = util.vector2(290, 20),\n                -- position in the top right corner\n                relativePosition = util.vector2(0.5, 0.1115),\n                -- position is for the top left corner of the widget by default\n                -- change it to align exactly to the top right corner of the screen\n                anchor = util.vector2(0.5, 0),\n            },\n        },\n}\n\nlocal healthBarSkyNostalgic = ui.content {   \n    {\n        name = \"hbBG\",\n        type = ui.TYPE.Image,\n            props = {\n            resource = ui.texture({ path = 'Textures/HbNostalgicBg.png' }),\n            alpha = 0.8,\n            color = util.color.rgb(8 / 255, 8 / 255, 8 / 255),\n            size = util.vector2(307, 10),\n            -- position in the top right corner\n            relativePosition = util.vector2(0.50, 0.18),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0),\n            --visible = false,\n        },\n    },\n    {\n        name = \"hbBarAnim\",\n        type = ui.TYPE.Image,\n        props = {\n            resource = ui.texture({ path = 'Textures/HbNostalgicAnim.png' }),\n            --color = util.color.rgb(170 / 255, 170 / 255, 170 / 255),\n            size = util.vector2(330, 12),\n            -- position in the top right corner\n            align = ui.ALIGNMENT.Center,\n            relativePosition = util.vector2(0.5, 0.18),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0),\n            --visible = false,\n        },\n    },\n    {\n        name = \"hbBar\",\n        type = ui.TYPE.Image,\n        props = {\n            resource = ui.texture({ path = 'Textures/HbNostalgicHealth.png' }),\n            --color = util.color.rgb(135 / 255, 36 / 255, 32 / 255),\n            size = util.vector2(330, 12),\n            -- position in the top right corner\n            align = ui.ALIGNMENT.Center,\n            relativePosition = util.vector2(0.5, 0.18),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0),\n            --visible = false,\n        },\n    },\n    {\n        name = \"hbOL\",\n        type = ui.TYPE.Image,\n        props = {\n            resource = ui.texture({ path = 'Textures/HbNostalgicOverlay.png' }),\n            size = util.vector2(340, 20),\n            -- position in the top right corner\n            relativePosition = util.vector2(0.5, 0.1115),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0),\n        },\n    },\n}\n\nlocal healthBarMorrowindStyle = ui.content {\n    {\n        name = \"hbBG\",\n        type = ui.TYPE.Image,\n            props = {\n            resource = ui.texture({ path = 'Textures/HbVanillaBg.png' }),\n            --color = util.color.rgb(30 / 255, 30 / 255, 30 / 255),\n            size = util.vector2(260, 20),\n            -- position in the top right corner\n            relativePosition = util.vector2(0.50, 0.1),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0),\n            --visible = false,\n        },\n    },\n    {\n        name = \"hbBarAnim\",\n        type = ui.TYPE.Image,\n        props = {\n            resource = ui.texture({ path = 'Textures/HbVanillaAnim.png' }),\n            color = util.color.rgb(200 / 255, 200 / 255, 200 / 255),\n            size = util.vector2(260, 20),\n            -- position in the top right corner\n            align = ui.ALIGNMENT.Center,\n            relativePosition = util.vector2(0.5, 0.135),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0),\n            --visible = false,\n        },\n    },\n    {\n        name = \"hbBar\",\n        type = ui.TYPE.Image,\n        props = {\n            resource = ui.texture({ path = 'Textures/HbVanillaHealth.png' }),\n            color = util.color.rgb(135 / 255, 36 / 255, 32 / 255),\n            size = util.vector2(260, 20),\n            -- position in the top right corner\n            --align = ui.ALIGNMENT.Center,\n            relativePosition = util.vector2(0.5, 0.135),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0),\n            --visible = false,\n        },\n    },\n    {\n        name = \"hbOL\",\n        template = I.MWUI.templates.borders,\n        props = {\n            size = util.vector2(260, 20),\n            -- position in the top right corner\n            relativePosition = util.vector2(0.5, 0.1115),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0),\n        },\n    },\n    \n}\n\nlocal healthBarFlatStyle = ui.content {   \n        {\n            name = \"hbBG\",\n            type = ui.TYPE.Image,\n                props = {\n                alpha = 0.8,\n                resource = ui.texture({ path = 'White' }),\n                color = util.color.rgb(1 / 255, 1 / 255, 1 / 255),\n                size = util.vector2(310, 25),\n                -- position in the top right corner\n                relativePosition = util.vector2(0.50, 0.2),\n                -- position is for the top left corner of the widget by default\n                -- change it to align exactly to the top right corner of the screen\n                anchor = util.vector2(0.5, 0),\n                --visible = false,\n            },\n        },\n        {\n            name = \"hbBarAnim\",\n            type = ui.TYPE.Image,\n            props = {\n                resource = ui.texture({ path = 'Textures/HbFlatHealth.png' }),\n                color = util.color.rgb(135 / 255, 36 / 255, 32 / 255),\n                size = util.vector2(280, 20),\n                -- position in the top right corner\n                align = ui.ALIGNMENT.Center,\n                relativePosition = util.vector2(0.5, 0.28),\n                -- position is for the top left corner of the widget by default\n                -- change it to align exactly to the top right corner of the screen\n                anchor = util.vector2(0.5, 0),\n                --visible = false,\n            },\n        },\n        {\n            name = \"hbBar\",\n            type = ui.TYPE.Image,\n            props = {\n                resource = ui.texture({ path = 'Textures/HbFlatAnim.png' }),\n                color = util.color.rgb(170 / 255, 170 / 255, 170 / 255),\n                size = util.vector2(290, 20),\n                -- position in the top right corner\n                --align = ui.ALIGNMENT.Center,\n                relativePosition = util.vector2(0.5, 0.28),\n                -- position is for the top left corner of the widget by default\n                -- change it to align exactly to the top right corner of the screen\n                anchor = util.vector2(0.5, 0),\n                --visible = false,\n            },\n        },\n        {\n            name = \"hbOL\",\n            type = ui.TYPE.Image,\n            props = {\n                resource = ui.texture({ path = 'Textures/HbFlatOverlay.png' }),\n                color = util.color.rgb(135 / 255, 36 / 255, 32 / 255),\n                size = util.vector2(300, 17.5),\n                -- position in the top right corner\n                --align = ui.ALIGNMENT.Center,\n                relativePosition = util.vector2(0.5, 0.28),\n                -- position is for the top left corner of the widget by default\n                -- change it to align exactly to the top right corner of the screen\n                anchor = util.vector2(0.5, 0),\n                --visible = false,\n            },\n        },\n        {\n            name = \"healthBG\",\n            type = ui.TYPE.Image,\n                props = {\n                resource = ui.texture({ path = 'Textures/HbFlatHealthCounterBg.png' }),\n                alpha = 0.8,\n                color = util.color.rgb(8 / 255, 8 / 255, 8 / 255),\n                size = util.vector2(100, 40),\n                -- position in the top right corner\n                relativePosition = util.vector2(0.50, 0.54),\n                -- position is for the top left corner of the widget by default\n                -- change it to align exactly to the top right corner of the screen\n                anchor = util.vector2(0.5, 0),\n                visible = true,\n            },\n        },\n}\n\nlocal healthBarMinimalStyle = ui.content {\n    {\n        name = \"hbBG\",\n        type = ui.TYPE.Image,\n            props = {\n            alpha = 0.8,\n            resource = ui.texture({ path = 'White' }),\n            color = util.color.rgb(1 / 255, 1 / 255, 1 / 255),\n            size = util.vector2(180, 16),\n            -- position in the top right corner\n            relativePosition = util.vector2(0.50, 0.5),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0),\n            --visible = false,\n        },\n    },\n    {\n        name = \"hbBarAnim\",\n        type = ui.TYPE.Image,\n        props = {\n            resource = ui.texture({ path = 'textures/menu_bar_gray.dds' }),\n            color = util.color.rgb(50 / 255, 50 / 255, 50 / 255),\n            size = util.vector2(280, 20),\n            -- position in the top right corner\n            align = ui.ALIGNMENT.Center,\n            relativePosition = util.vector2(0.5, 0.5),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0),\n            --visible = false,\n        },\n    },\n    {\n        name = \"hbBar\",\n        type = ui.TYPE.Image,\n        props = {\n            resource = ui.texture({ path = 'textures/menu_bar_gray.dds' }),\n            color = util.color.rgb(204 / 255, 153 / 255, 0 / 255),\n            size = util.vector2(290, 20),\n            -- position in the top right corner\n            --align = ui.ALIGNMENT.Center,\n            relativePosition = util.vector2(0.5, 0.5),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0),\n            --visible = false,\n        },\n    },\n    {\n        name = \"hbOL\",\n        template = I.MWUI.templates.borders,\n        props = {\n            size = util.vector2(180, 16),\n            -- position in the top right corner\n            relativePosition = util.vector2(0.5, 0.5),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0),\n        },\n    },\n    \n}\n\nlocal healthBarSixthHouse = ui.content {\n    {\n        name = \"hbBG\",\n        type = ui.TYPE.Image,\n            props = {\n            resource = ui.texture({ path = 'Textures/HbStoneBg.png' }),\n            color = util.color.rgb(65 / 255, 65 / 255, 65 / 255),\n            size = util.vector2(275, 16),\n            -- position in the top right corner\n            relativePosition = util.vector2(0.50, 0.44),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0),\n            --visible = false,\n        },\n    },\n    {\n        name = \"hbBarAnim\",\n        type = ui.TYPE.Image,\n        props = {\n            resource = ui.texture({ path = 'Textures/HbStoneHealthbar.png' }),\n            color = util.color.rgb(80 / 255, 80 / 255, 80 / 255),\n            size = util.vector2(220, 16),\n            -- position in the top right corner\n            align = ui.ALIGNMENT.Center,\n            relativePosition = util.vector2(0.5, 0.44),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0),\n            --visible = false,\n        },\n    },\n    {\n        name = \"hbBar\",\n        type = ui.TYPE.Image,\n        props = {\n            resource = ui.texture({ path = 'Textures/HbStoneAnim.png' }),\n            color = util.color.rgb(50 / 255, 50 / 255, 50 / 255),\n            size = util.vector2(220, 16),\n            -- position in the top right corner\n            align = ui.ALIGNMENT.Center,\n            relativePosition = util.vector2(0.5, 0.44),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0),\n            --visible = false,\n        },\n    },\n    {\n        name = \"hbOL\",\n        template = I.MWUI.templates.borders,\n        props = {\n            size = util.vector2(275, 20),\n            -- position in the top right corner\n            relativePosition = util.vector2(0.5, 0.4),\n            -- position is for the top left corner of the widget by default\n            -- change it to align exactly to the top right corner of the screen\n            anchor = util.vector2(0.5, 0),\n        },\n    },    \n}\n\nlocal function getStyleVanilla()\n    return healthBarMorrowindStyle\nend\n\nlocal function getStyleSkyrim()\n    return healthBarSkyrimStyle\nend\n\nlocal function getStyleNostalgy()\n    return healthBarSkyNostalgic\nend\n\nlocal function getStyleFlat()\n    return healthBarFlatStyle\nend\n\nlocal function getStyleMinimal()\n    return healthBarMinimalStyle\nend\n\nlocal function getStyleSixthHouse()\n    return healthBarSixthHouse\nend\n\n\nreturn { \n    engineHandlers = \n    { \n        onUpdate = onUpdate \n    },\n    interfaceName = \"SME_STYLE\",\n    interface = {\n        getStyleVanilla = getStyleVanilla,\n        getStyleSkyrim = getStyleSkyrim,\n        getStyleNostalgy = getStyleNostalgy,\n        getStyleFlat = getStyleFlat,\n        getStyleMinimal = getStyleMinimal,\n        getStyleSixthHouse = getStyleSixthHouse,\n    },\n}",
    "Show Me Everything-53996-1-2-1-1708168299\\Scripts\\sme_widget.lua": "local async = require(\"openmw.async\")\nlocal camera = require(\"openmw.camera\")\nlocal core = require(\"openmw.core\")\nlocal I = require(\"openmw.interfaces\")\nlocal nearby = require(\"openmw.nearby\")\nlocal self = require(\"openmw.self\")\nlocal types = require(\"openmw.types\")\nlocal ui = require(\"openmw.ui\")\nlocal util = require(\"openmw.util\")\nlocal storage = require('openmw.storage')\n\nlocal settings = {\n    behavior = storage.playerSection('SMESettingsBh'),\n    style = storage.playerSection('SMESettingsSt'),\n}\n\n\nlocal raycastCurrentLength\n\nlocal fadeOutTimer = 0\nlocal fadeOutTime = 1\nlocal isFadeOut = false\nlocal timeToShow = 0\nlocal focusTime = 1\nlocal combatTime = 3\nlocal widgetIsShowing = false\n\nlocal barSize = util.vector2(252, 12)\n\nlocal npcRecord\n\n\nlocal isNPC = types.NPC.objectIsInstance\nlocal isCreature = types.Creature.objectIsInstance\n\nlocal cachedActorTickTime = 0.1\nlocal cachedActorTickTimer = 0\n\nlocal lastNPCTable = {}\nlocal lastNPCMaxTableSize = 7\nlocal tableTimerMaxTime = 60\n\nlocal healthAnimTimeBase = 0.8\n\nlocal healthText\n\nlocal commonTimer = 0\nlocal commonCheckTime = 0.1\nlocal isShowTime = false\n\nlocal overridingTimer = 0\nlocal isOverridingTime = false\n\nlocal healthBarSize = util.vector2(252, 12)\n\nlocal currentActorInFocus = nil\n\nlocal timerToUpdateAfterWater = 0\nlocal standartWidgetPos\nlocal needToUpdateWhileSwimming = true\nlocal timeToUpdateAfterWater = 3\nlocal actorHealth = types.Actor.stats.dynamic.health\nlocal tooltipTarget\nlocal actorLevel\n\nlocal healthBarElement = ui.create {\n    name = 'healthBarContent',\n    props = {\n        visible = false,\n        relativeSize = util.vector2(1, 1),\n        relativePosition = util.vector2(0.5, 0.5),\n      },\n    content = I.SME_STYLE.getStyleVanilla(),\n}\n\nlocal damageElement = ui.create {\n\ttype = ui.TYPE.Text,\n\tprops = {\n\t  relativePosition = util.vector2(0, 0),\n\t  anchor = util.vector2(0.5, 0.5),\n\t  text = '',\n\t  textSize = 14,\n\t  textShadow = true,\n\t  textShadowColor =\tutil.color.rgb(0, 0, 0),\n\t  textColor = util.color.rgb(200 / 255, 200 / 255, 200 / 255),\n\t  visible = false,\n\t},\n  }\n\n  local nameElement = ui.create {\n\t-- important not to forget the layer\n\t-- by default widgets are not attached to any layer and are not visible\n\ttype = ui.TYPE.Text,\n\tprops = {\n\t  -- position in the top right corner\n\t  relativePosition = util.vector2(0.5, 0.08),\n\t  -- position is for the top left corner of the widget by default\n\t  -- change it to align exactly to the top right corner of the screen\n\t  anchor = util.vector2(0.5, 0),\n\t  text = '',\n\t  textSize = 19,\n\t  textShadow = true,\n\t  textShadowColor =\tutil.color.rgb(0, 0, 0),\n\t  -- default black text color isn't always visible\n\t  textColor = util.color.rgb(200 / 255, 200 / 255, 200 / 255),\n\t  visible = true,\n\t},\n  }\n\n  local healthTextElement = ui.create {\n\t-- important not to forget the layer\n\t-- by default widgets are not attached to any layer and are not visible\n\ttype = ui.TYPE.Text,\n\tprops = {\n\t  -- position in the top right corner\n\t  --relativePosition = util.vector2(0.50, 0.113),\n\t  -- position is for the top left corner of the widget by default\n\t  -- change it to align exactly to the top right corner of the screen\n\t  anchor = util.vector2(0.5, 0),\n\t  text = '',\n\t  textSize = 14,\n\t  textShadow = true,\n\t  textShadowColor =\tutil.color.rgb(0, 0, 0),\n\t  -- default black text color isn't always visible\n\t  textColor = util.color.rgb(1, 1, 1, 1),\n\t  visible = true,\n\t},\n  }\n\nlocal healthBarFull = ui.create {\n\tname = 'TutorialNotifyMenu',\n\tl10n = 'UITutorial',\n\tlayer = 'HUD',\n\t-- This is a helper template, which sets up this interface element in the style of Morrowind.\n\t-- Reference: https://openmw.readthedocs.io/en/latest/reference/lua-scripting/interface_mwui.html\n\t--template = I.MWUI.templates.boxTransparent,\n\ttype = ui.TYPE.Widget,\n    props = {\n\t\tanchor = util.vector2(0.5, 0),\n\t\trelativePosition = util.vector2(0.5, 0.035),\n\t\tvisible = true,\n\t\tsize = util.vector2(256, 24),\n        --template = I.MWUI.templates.boxTransparent,\n\t\t-- Menu positioning props:\n\t\t-- Reference: https://openmw.readthedocs.io/en/latest/reference/lua-scripting/widgets/widget.html\n\n\t\t-- Pin the bottom center (50% X 100% Y) of this container to ...\n\t\t----anchor = util.vector2(0.5, 1),\n\t\t\n\t\t-- the screen horizontal center and near the bottom of the screen (50% X 95% Y).\n        ----relativePosition = util.vector2(0.5, 0.95),\n\t},\n\t-- Use ui.content for every content field.\n\tcontent = ui.content \n    {\n        healthBarElement,\n        damageElement,\n        nameElement,\n        healthTextElement,\n    },\n}\n\n\n\n\n--UI UPDATE FUNCTIONS\nlocal function disableHealthValues()\n    local disabled = not settings.behavior:get('SMEHealth')\n    healthTextElement.layout.props.text = ''\n    local healthBarContent = healthBarElement.layout.content\n    if healthBarContent == I.SME_STYLE.getStyleFlat() and not settings.behavior:get('SMEHealth') then\n        healthBarContent[\"healthBG\"].props.visible = false\n    elseif healthBarContent == I.SME_STYLE.getStyleFlat() then\n        healthBarContent[\"healthBG\"].props.visible = true\n    end\nend\n\nlocal function updateFlatHealthBG()\n    local healthBarContent = healthBarElement.layout.content\n    if healthBarContent == I.SME_STYLE.getStyleFlat() and not settings.behavior:get('SMEHealth') then\n        healthBarContent[\"healthBG\"].props.visible = false\n    elseif healthBarContent == I.SME_STYLE.getStyleFlat() then\n        healthBarContent[\"healthBG\"].props.visible = true\n    end\nend\n\nlocal function updateStandartPositions()\n    standartWidgetPos = healthBarFull.layout.props.relativePosition\nend\n\nlocal function updateWidgetStyle()\n    if settings.style:get('SMEWidgetStyle') == 'Vanilla' then\n        healthBarElement.layout.content = I.SME_STYLE.getStyleVanilla()\n        healthBarFull.layout.props.size = util.vector2(450, 70)\n        healthBarFull.layout.content[1].layout.props.relativePosition = util.vector2(0, 0.29)\n        barSize = util.vector2(260, 16)\n        damageElement.layout.props.relativePosition = util.vector2(0.735, 0.83)\n        healthTextElement.layout.props.relativePosition = util.vector2(0.50, 0.429)\n        nameElement.layout.props.textSize = 17.5\n        nameElement.layout.props.relativePosition = util.vector2(0.5, 0.047)\n    elseif settings.style:get('SMEWidgetStyle') == 'Skyrim' then\n        healthBarElement.layout.content = I.SME_STYLE.getStyleSkyrim()\n        healthBarFull.layout.props.size = util.vector2(450, 60)\n        healthBarFull.layout.content[1].layout.props.relativePosition = util.vector2(0, 0.29)\n        barSize = util.vector2(252, 12)\n        damageElement.layout.props.relativePosition = util.vector2(0.735, 0.87)\n        healthTextElement.layout.props.relativePosition = util.vector2(0.50, 0.432)\n        nameElement.layout.props.textSize = 18\n        nameElement.layout.props.relativePosition = util.vector2(0.5, 0.03)\n    elseif settings.style:get('SMEWidgetStyle') == 'Sky Nostalgy' then\n        healthBarElement.layout.content = I.SME_STYLE.getStyleNostalgy()\n        barSize = util.vector2(307, 10)\n        healthBarFull.layout.props.size = util.vector2(450, 60)\n        healthTextElement.layout.props.relativePosition = util.vector2(0.50, 0.43)\n        healthBarFull.layout.content[1].layout.props.relativePosition = util.vector2(0, 0.29)\n        nameElement.layout.props.textSize = 17\n        nameElement.layout.props.relativePosition = util.vector2(0.5, 0.052)\n        damageElement.layout.props.relativePosition = util.vector2(0.76, 0.87)\n    elseif settings.style:get('SMEWidgetStyle') == 'Flat' then\n        healthBarElement.layout.content = I.SME_STYLE.getStyleFlat()\n        barSize = util.vector2(300, 16)\n        healthBarFull.layout.props.size = util.vector2(450, 65)\n        healthTextElement.layout.props.relativePosition = util.vector2(0.50, 0.735)\n        healthBarFull.layout.content[1].layout.props.relativePosition = util.vector2(0, 0.15)\n        nameElement.layout.props.textSize = 18\n        nameElement.layout.props.relativePosition = util.vector2(0.5, 0)\n        damageElement.layout.props.relativePosition = util.vector2(0.9, 0.548)\n    elseif settings.style:get('SMEWidgetStyle') == 'Minimal Vanilla' then\n        healthBarElement.layout.content = I.SME_STYLE.getStyleMinimal()\n        barSize = util.vector2(180, 30)\n        healthBarFull.layout.props.size = util.vector2(250, 40)\n        healthBarFull.layout.content[1].layout.props.relativePosition = util.vector2(0, 0.14)\n        healthTextElement.layout.props.relativePosition = util.vector2(0.50, 0.65)\n        nameElement.layout.props.textSize = 16\n        nameElement.layout.props.relativePosition = util.vector2(0.5, 0.067)\n        damageElement.layout.props.relativePosition = util.vector2(0.94, 0.83)\n    elseif settings.style:get('SMEWidgetStyle') == 'Sixth House' then\n        healthBarElement.layout.content = I.SME_STYLE.getStyleSixthHouse()\n        barSize = util.vector2(275, 18)\n        healthTextElement.layout.props.relativePosition = util.vector2(0.50, 0.45)\n        healthBarFull.layout.props.size = util.vector2(400, 70)\n        healthBarFull.layout.content[1].layout.props.relativePosition = util.vector2(0, 0)\n        nameElement.layout.props.textSize = 16\n        nameElement.layout.props.relativePosition = util.vector2(0.5, 0.077)\n        damageElement.layout.props.relativePosition = util.vector2(0.78, 0.85)\n    end\n    updateStandartPositions()\nend\n\nlocal function updateStance()\n    if settings.behavior:get('SMEStance') and types.Actor.getStance(self) == types.Actor.STANCE.Nothing then\n        nameElement.layout.props.visible = false\n\t    healthTextElement.layout.props.visible = false\n\t    healthBarFull.layout.props.visible = false\n        healthTextElement:update()\n        healthBarFull:update()\n        nameElement:update()\n    end\nend\n\ndisableHealthValues()\nupdateWidgetStyle()\nupdateFlatHealthBG()\nupdateStance()\n\nsettings.behavior:subscribe(async:callback(disableHealthValues))\nsettings.behavior:subscribe(async:callback(updateStance))\nsettings.style:subscribe(async:callback(updateWidgetStyle))\nsettings.style:subscribe(async:callback(updateFlatHealthBG))\n--UI UPDATE FUNCTIONS\n\n\n--UI VISIBILITY FUNCTIONS\nlocal function setOpacityFull()\n    nameElement.layout.props.alpha = 1.0\n    healthTextElement.layout.props.alpha = 1.0\n    healthBarFull.layout.props.alpha = 1.0\n    healthBarFull.layout.content[1].layout.props.alpha = 1.0\nend\n\nlocal function enableVisibility()\n\tnameElement.layout.props.visible = true\n\thealthTextElement.layout.props.visible = true\n\thealthBarFull.layout.props.visible = true\n    healthBarFull.layout.content[1].layout.props.visible = true\nend\n\nlocal function hideElements()\n\tnameElement.layout.props.visible = false\n\thealthTextElement.layout.props.visible = false\n\thealthBarFull.layout.props.visible = false\n    healthBarFull.layout.content[1].layout.props.visible = false\nend\n\nlocal function updateAllElements()\n        healthTextElement:update()\n        healthBarFull:update()\n        nameElement:update()\n        healthBarFull.layout.content[1]:update()\nend\n\nlocal function hideAfterFadeOut()\n\n    nameElement.layout.props.visible = false\n    healthBarFull.layout.props.visible = false\n    healthTextElement.layout.props.visible = false\n\n    fadeOutTimer = 0\n    isFadeOut = false\n    widgetIsShowing = false\n\n    updateAllElements()\n    setOpacityFull()\n    \nend\n\nlocal function fadeOutElements(dt)\n\tfadeOutTimer = fadeOutTimer + dt\n\t\t\n\t-- Gradually lower alpha to 0 over fadeOutTime\n\tlocal alphaPercentage = 1.0 - fadeOutTimer / fadeOutTime\n\tnameElement.layout.props.alpha = math.max(0, alphaPercentage)\n\thealthTextElement.layout.props.alpha = math.max(0, alphaPercentage)\n\thealthBarFull.layout.props.alpha = math.max(0, alphaPercentage)\n\n\tupdateAllElements()\n\n\tif fadeOutTimer >= fadeOutTime then\n\t\thideAfterFadeOut()\n\tend\nend\n--UI VISIBILITY FUNCTIONS\n\n\n--Casting a raycast and getting our actors\nlocal function getTooltipTarget(dt)\n\nlocal from = camera.getPosition()\nlocal to = from + camera.viewportToWorldVector(util.vector2(0.5, 0.5)) * settings.behavior:get('SMERaycastLength')\nnearby.asyncCastRenderingRay(\n    async:callback(function(result)\n        tooltipTarget = result.hitObject\n        if result.hitPos ~= nil then\n            raycastCurrentLength = (result.hitPos - from):length()\n        end\n    end),\n    from,\n    to\n)\nend\n\n--Adding our actors to our table\nlocal function addNPC(raycastActor)\n    -- Check if the NPC is already in the table    \n    -- If the NPC is not in the table, add it as a new NPC\n    \n    local npc = {\n        actor = raycastActor,\n        timer = tableTimerMaxTime,  -- Initial timer value (in seconds)\n        lastHealth = nil,\n        damage = 0,  -- Initial damage value\n        damageTimer = 0, -- Initial damage timer value\n        isTakingDamage = false,\n        healthBeforeDamage = nil,\n        interpolationWidth = 0,\n        healthInterpolationTime = false,\n        animTimer = 0,\n        currentAnimHealthWidth = nil,\n        isDead = actorHealth(raycastActor).current <= 0,\n    }\n\n    table.insert(lastNPCTable, npc)\n    -- Check if the table exceeds the specified size\n    if #lastNPCTable > lastNPCMaxTableSize then\n        table.remove(lastNPCTable, 1)  -- Remove the oldest NPC\n    end\nend\n\n\n--Rendering name, taking NPC\nlocal function getName(actor)\n    if isNPC(actor) then\n\t\tnpcRecord = types.NPC.record(actor)\n\telseif isCreature(actor) then\n\t\tnpcRecord = types.Creature.record(actor)\n        actorLevel = types.NPC.stats.level(actor).current\n\tend\n\n    local name = npcRecord.name\n    \n    if settings.behavior:get('SMEClass') then\n        local class = npcRecord.class\n\n        if isNPC(actor) then\n            if string.match(class, \"^t_glb_\") then\n                -- String starts with \"t_glb\", clean the class\n                class = string.gsub(class, \"^t_glb_\", \"\")\n            end\n        end\n        name = name .. (class and (\", \" .. class) or \"\")\n    end\n\n    if settings.behavior:get('SMELevel') then\n        name = name .. \" (\" .. types.Actor.stats.level(actor).current .. \")\"\n    end\n\n    return name\n\nend\n\n\n\n--Getting health Values\nlocal function getHealthBar(actor)\n\tlocal healthCurrent = actorHealth(actor).current\n    local healthBase = actorHealth(actor).base\n    if healthCurrent <= 0 then\n        if settings.behavior:get('SMEHealth') then\n\t\t    healthTextElement.layout.props.text = \"Dead\"\n        end\n\t\thealthBarSize = util.vector2(0, 1)\n\t\treturn healthBarSize\n\t\t--healthTextElement.props.text = \"Health: \" .. util.round(actorHealth(tooltipTarget).current) .. \" / \" .. actorHealth(tooltipTarget).base\n\telse\n\t\t--healthTextElement.props.text = \"Dead\"\n\t\tlocal ratio = healthCurrent / healthBase\n        healthBarSize = barSize:emul(util.vector2(ratio, 1))\n        return healthBarSize\n\tend\nend\n\n\n--Getting health text values\nlocal function getHealthText(actor)\n\tlocal healthCurrent = util.round(actorHealth(actor).current)\n\tlocal healthBase = actorHealth(actor).base\n    if healthCurrent <= 0 then\n        local healthText = \"Dead\"\n        return healthText\n    else\n        -- Convert health values to strings\n        local strHealthCurrent = tostring(healthCurrent)\n        local strHealthBase = tostring(healthBase)\n\n        -- Calculate the number of digits in each value\n        local numDigitsCurrent = string.len(strHealthCurrent)\n        local numDigitsBase = string.len(strHealthBase)\n\n        -- If the number of digits in healthBase is greater, add spaces to healthCurrent\n        if numDigitsBase > numDigitsCurrent then\n            local numSpacesToAdd = numDigitsBase - numDigitsCurrent\n            local spaces = string.rep(\" \", numSpacesToAdd)\n            healthCurrent = spaces .. strHealthCurrent\n        end\n\n        -- Create the healthText with the adjusted healthCurrent\n        local healthText = healthCurrent .. \" / \" .. strHealthBase\n        return healthText\n    end\t\nend\n\nlocal function getAnimHealthBar(npc, healthBar)\n    local animHealthBarWidth\n    \n    if npc.isTakingDamage then\n        animHealthBarWidth = npc.interpolationWidth\n    else\n        animHealthBarWidth = healthBar\n    end\n    return animHealthBarWidth\nend\n\n--Function to renew widgets time and resetting the fadeout if in process\nlocal function renewWidget(time)\n    widgetIsShowing = true\n    isFadeOut = false\n    fadeOutTimer = 0\n    timeToShow = time\nend\n\n--Function to turn on the main widgets\nlocal function showWidgets(npc)\n\n    if currentActorInFocus and npc.actor == currentActorInFocus then\n        local name = getName(npc.actor)\n        local healthBar = getHealthBar(npc.actor)\n\n        if settings.behavior:get('SMEHealth') then\n            healthText = getHealthText(npc.actor)\n            healthTextElement.layout.props.text = healthText\n        end\n\n        if not npc.healthInterpolationTime then\n            local animHealthBar = getAnimHealthBar(npc, healthBar)\n            healthBarFull.layout.content[1].layout.content[\"hbBarAnim\"].props.size = animHealthBar\n        end\n        nameElement.layout.props.text = name\n        \n        healthBarFull.layout.content[1].layout.content[\"hbBar\"].props.size = healthBar\n\n        enableVisibility()\n        setOpacityFull()\n        updateAllElements()\n    end\nend\n\nlocal function rayCastChecker()\n\n    if tooltipTarget and (isNPC(tooltipTarget) or isCreature(tooltipTarget)) and tooltipTarget.recordId ~= 'player' then\n\n        if not settings.behavior:get('SMEnotForDead') and types.Actor.isDead(tooltipTarget) then\n            return\n        end\n\n        local isTargetInTable = false\n        for _, npc in ipairs(lastNPCTable) do\n            if npc.actor == tooltipTarget then\n            isTargetInTable = true\n            break\n            end\n        end\n        if not isTargetInTable then\n            addNPC(tooltipTarget)\n        end\n        if raycastCurrentLength < settings.behavior:get('SMEShowDistance') then\n\t\t\t--Updating timers and bool that our timer is shown\n\t\t\tfor _, npc in ipairs(lastNPCTable) do\n                if npc.actor == tooltipTarget then\n                    currentActorInFocus = npc.actor\n                    if (types.Actor.getStance(self) == types.Actor.STANCE.Nothing and settings.behavior:get('SMEStance')) or settings.behavior:get('SMEonHit') then\n                        overridingTimer = focusTime\n                        isOverridingTime = true\n                    else\n                        showWidgets(npc)\n                        renewWidget(focusTime)\n                        overridingTimer = focusTime\n                        isOverridingTime = true\n                        if not npc.isTakingDamage then\n                            damageElement.layout.props.text = ''\n                            damageElement.layout.props.visible = false\n                            damageElement:update()\n                        end\n                    end\n                    \n                    break\n                end\n            end\n        end\n    end\nend\n\n--if timer is zero or less, return true\nlocal function hasShowingTimeEnded(dt)\n    if timeToShow > 0 then\n        timeToShow = timeToShow - dt\n    end\n    return timeToShow <= 0\nend\n\n--if timer \nlocal function widgetHideHandler()\n    if not isShowTime and widgetIsShowing then\n        isFadeOut = true\n    end\nend\n\nlocal function showDamageWidget(damage, actor)\n    -- Find the NPC in lastNPCTable\n    for _, npc in ipairs(lastNPCTable) do\n        if npc.actor == actor then\n            if npc.actor == currentActorInFocus and npc.isTakingDamage then\n                damageElement.layout.props.text = tostring(util.round(npc.damage))\n                damageElement.layout.props.visible = true\n                damageElement:update()\n            end\n\n            return  -- Exit the function once the update is done\n        end\n    end\nend\n\nlocal function calculateStartingAnimWidth(npc)\n    \n    local baseHealth = actorHealth(npc.actor).base\n    local ratio = npc.healthBeforeDamage / baseHealth\n    local healthBarSize = barSize:emul(util.vector2(ratio, 1))\n    npc.interpolationWidth = barSize:emul(util.vector2(ratio, 1))\n    npc.currentAnimHealthWidth = npc.interpolationWidth\n\nend\n\nlocal function updateDamageInfo(npc, actor, health)\n    if health < npc.lastHealth then\n        local damageAmount = npc.lastHealth - health\n        for _, npc in ipairs(lastNPCTable) do\n            if npc.actor == actor then\n                npc.damageTimer = 1\n                npc.isTakingDamage = true\n                npc.damage = npc.damage + damageAmount\n                if npc.healthBeforeDamage == nil then\n                    npc.healthBeforeDamage = npc.lastHealth\n                    calculateStartingAnimWidth(npc)\n                end\n                if settings.behavior:get('SMEDamage') then\n                    showDamageWidget(damageAmount, actor)\n                end\n                break\n            end\n        end\n\n    end\n    if overridingTimer <= 0 or actor == currentActorInFocus then\n        showWidgets(npc)\n        renewWidget(combatTime)\n    end\nend\n\nlocal function updateActorInFocus(npc, actor, health)\n\n    if overridingTimer <= 0 then\n        currentActorInFocus = actor \n    end\nend\n\n\nlocal function updateIndividualHealth(npc)\n    local actor = npc.actor\n    if not (isNPC(actor) or isCreature(actor)) then\n        return\n    end\n    local health = actorHealth(actor).current\n\n    if npc.lastHealth and npc.lastHealth ~= health then\n        local currentRecord\n\n        if isNPC(actor) then\n            currentRecord = types.NPC.record(actor)\n        elseif isCreature(actor) then\n            currentRecord = types.Creature.record(actor)\n        end\n\n        if health ~= npc.lastHealth then\n            updateActorInFocus(npc, actor, health)\n            updateDamageInfo(npc, actor, health)\n        end\n    end\n\n    \n\n    npc.lastHealth = health\nend\n\n\nlocal function updateHealth(dt)\n    if #lastNPCTable == 0 then\n        return\n    end\n\n    cachedActorTickTimer = cachedActorTickTimer + dt\n\n    if cachedActorTickTimer < cachedActorTickTime then\n        return\n    end\n\n    cachedActorTickTimer = 0\n    for _, npc in ipairs(lastNPCTable) do\n        updateIndividualHealth(npc)\n    end\nend\n\nlocal function updateDamageTimers(commonTimer)\n    if #lastNPCTable > 0 then\n        for _, npc in ipairs(lastNPCTable) do\n            if npc.isTakingDamage then\n                npc.damageTimer = npc.damageTimer - commonTimer\n\n                if npc.damageTimer <= 0 then\n                    npc.damage = 0 -- Reset damage when the timer expires\n                    npc.isTakingDamage = false -- Reset the flag\n                    npc.healthInterpolationTime = true\n                    \n                    if settings.behavior:get('SMEDamage') then\n                        damageElement.layout.props.text = ''\n                        damageElement.layout.props.visible = false\n                        damageElement:update()\n                    end\n\n                end\n            end\n        end\n    end\nend\n\nlocal function healthAnimation(dt)\n    for _, npc in ipairs(lastNPCTable) do\n        if npc.healthInterpolationTime then\n            npc.animTimer = npc.animTimer + dt\n\n            local finalHealthForInterpolation = actorHealth(npc.actor).current\n            local maxIntActorHealth = actorHealth(npc.actor).base\n            \n            local ratio = finalHealthForInterpolation / maxIntActorHealth\n            local amount = npc.healthBeforeDamage - finalHealthForInterpolation\n            local lostPercent = (amount / maxIntActorHealth) * 100\n            \n            local animTime = math.max(healthAnimTimeBase * (lostPercent / 100), 0.2)\n\n\n            local finalSize = barSize:emul(util.vector2(ratio, 1))\n            local sizeDifference = npc.interpolationWidth.x - finalSize.x\n            local timeDifference = animTime / dt\n            local step = sizeDifference / timeDifference\n\n\n\n            npc.currentAnimHealthWidth = util.vector2(npc.currentAnimHealthWidth.x - step, barSize.y)\n\n\n            if npc.actor == currentActorInFocus then\n                healthBarFull.layout.content[1].layout.content[\"hbBarAnim\"].props.size = npc.currentAnimHealthWidth\n                updateAllElements()\n            end\n\n            if npc.isTakingDamage then\n                npc.animTimer = 0\n                npc.healthInterpolationTime = false\n                npc.interpolationWidth = healthBarFull.layout.content[1].layout.content[\"hbBarAnim\"].props.size\n            elseif npc.animTimer >= animTime then\n                npc.animTimer = 0\n                npc.healthBeforeDamage = nil\n                npc.healthInterpolationTime = false -- Сбрасываем флаг\n                npc.currentAnimHealthWidth = nil\n            end\n        end\n    end\nend\n\nlocal function updateWhileSwimming(dt)\n    if not types.Actor.isSwimming(self) and not needToUpdateWhileSwimming then\n\t\t\n\t\t\n\n\t\ttimerToUpdateAfterWater = timerToUpdateAfterWater + dt\n\t\t\t\n\t\tif timerToUpdateAfterWater > timeToUpdateAfterWater then\n\t\t\tif types.Actor.isSwimming(self) then\n\t\t\t\treturn\n\t\t\telse\n\t\t\t\tif not standartWidgetPos then\n                    updateStandartPositions()\n                end\n                healthBarFull.layout.props.relativePosition = standartWidgetPos\n\t\t\t\tupdateAllElements()\n\t\t\t\tneedToUpdateWhileSwimming = true\n\t\t\t\ttimerToUpdateAfterWater = 0\n\t\t\tend\n\t\tend\n\t\t\n\tend\n\n\tif types.Actor.isSwimming(self) and needToUpdateWhileSwimming then\n\t\tneedToUpdateWhileSwimming = false\n        if not standartWidgetPos then\n            updateStandartPositions()\n        end\n\t\thealthBarFull.layout.props.relativePosition = util.vector2(standartWidgetPos.x, standartWidgetPos.y + 0.07)\n\t\tupdateAllElements()\n\tend\nend\n\n\nlocal function getRaycastTarget()\n    if tooltipTarget then\n        return tooltipTarget\n    end\nend\n\n\nlocal function getDistance()\n    if raycastCurrentLength and raycastCurrentLength > 0 then\n        return raycastCurrentLength\n    end\nend\n\n\nlocal function onUpdate(dt)\n\n    if not settings.behavior:get('SMEisActive') then\n        return\n    end\n    --Firing a raycast and returning distance and actor\n    getTooltipTarget()\n    --Handling Raycast, adding NPCs to the table, showind a \n    rayCastChecker()\n    \n    --functions that should fire once per 0.1 seconds for perfomance\n    commonTimer = commonTimer + dt\n    if commonTimer >= commonCheckTime then\n        if overridingTimer > 0 then\n            overridingTimer = overridingTimer - commonTimer\n        end\n        if overridingTimer <= 0 and isOverridingTime == true then\n            -- Если таймер закончился, сбросим npc.actorInFocus\n            --currentActorInFocus = nil\n            isOverridingTime = false\n        end\n\n        isShowTime = not hasShowingTimeEnded(commonTimer)\n        updateDamageTimers(commonTimer)\n        widgetHideHandler()\n        commonTimer = 0\n        \n        \n\n    end\n\n    if isFadeOut then\n        fadeOutElements(dt)\n    end\n\n    updateHealth(dt)\n    \n\n    for _, npc in ipairs(lastNPCTable) do\n        if npc.healthInterpolationTime then\n            healthAnimation(dt)\n        end\n    end\n\n    updateWhileSwimming(dt)\n\nend\n\nreturn { \n    engineHandlers = \n    { \n        onUpdate = onUpdate,\n    },\n    interfaceName = \"SME_CORE\",\n    interface = {\n        getRaycastTarget = getRaycastTarget,\n        getDistance = getDistance,\n    },\n}"
  }
}