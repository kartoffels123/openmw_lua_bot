{
  "folder_name": "Zack's Lua Multimark Mod",
  "lua_files": {
    "Zack's Lua Multimark-53260-1-5-1-1723427382\\scripts\\LuaMultiMark\\Effect_Checker.lua": "local core = require(\"openmw.core\")\n\nif not core.magic then\n    return {checkValues = function ()return true\n        \n    end}--no way to check in older versions\nend\nlocal effects = {\n    [\"SummonCreature04\"] = { name = \"Greater Mark\", school = \"mysticism\" },\n    [\"SummonCreature05\"] = { name = \"Greater Recall\", school = \"mysticism\" },\n\n}\nlocal function isEqual(table1, table2)\n    for key, value in pairs(table2) do\n        if table1[key] ~= value then\n            return false\n        end\n    end\n    return true\nend\nreturn {\n    checkValues = function()\n        local effect4 = core.magic.effects.records[\"SummonCreature04\"]\n        local effect5 = core.magic.effects.records[\"SummonCreature05\"]\n        if not isEqual(effect4, effects[\"SummonCreature04\"]) then\n            return false\n        elseif not isEqual(effect5, effects[\"SummonCreature05\"]) then\n            return false\n        end\n\n        return true\n    end\n}\n",
    "Zack's Lua Multimark-53260-1-5-1-1723427382\\scripts\\LuaMultiMark\\GMST_Checker.lua": "\nlocal core = require(\"openmw.core\")\n\n\nlocal gmstChecker = {}\nlocal values = {\n    [\"sEffectSummonCreature04\"] = \"Greater Mark\",\n    [\"sEffectSummonCreature05\"] = \"Greater Recall\",\n    [\"sMagicCreature04ID\"] = \"Teleport_summonMark\",\n    [\"sMagicCreature05ID\"] = \"Teleport_summonRecall\",\n}\nfunction gmstChecker.checkValues()\n    for key, value in pairs(values) do\n        if  core.getGMST(key) ~= value then\n            print(\"INCORRECT:\" .. key,core.getGMST(key),value)\n            return false\n        end\n    end\n    return true\nend\n\nreturn gmstChecker",
    "Zack's Lua Multimark-53260-1-5-1-1723427382\\scripts\\LuaMultiMark\\lmm_actor.lua": "local nearby = require(\"openmw.nearby\")\nlocal self = require(\"openmw.self\")\nlocal core = require(\"openmw.core\")\nlocal I = require(\"openmw.interfaces\")\nlocal function getPlayer()\n    for index, value in ipairs(nearby.actors) do\n        if value.recordId == \"player\" then\n            return value\n        end\n    end\nend\nlocal isFollowingPlayerTrue = false\nlocal function isFollowingPlayer()\n    isFollowingPlayerTrue = false\n    local func = function(param) if param.target == getPlayer() and param.type == \"Follow\" then isFollowingPlayerTrue = true end end\n    I.AI.forEachPackage(func)\n    return isFollowingPlayerTrue\nend\nlocal function teleportFollower(data)\n    if isFollowingPlayer() then\n        core.sendGlobalEvent(\"LMM_TeleportToCell\",\n            {\n                item = self,\n                cellname = data.destCell,\n                position = data.destPos,\n                rotation = data.destRot\n            })\n    end\nend\nlocal function onActive()\n    local package = I.AI.getActivePackage()\n    if self.recordId:lower() == \"teleport_summonmark\" and isFollowingPlayer() then\n     --   print(\"Mark\")\n        local player = getPlayer()\n        player:sendEvent(\"saveMarkLoc\")\n    elseif self.recordId:lower() == \"teleport_summonrecall\" and isFollowingPlayer() then\n        local player = getPlayer()\n        player:sendEvent(\"openMarkMenu\")\n    end\nend\nreturn { engineHandlers = { onActive = onActive }, eventHandlers = { teleportFollower = teleportFollower } }\n",
    "Zack's Lua Multimark-53260-1-5-1-1723427382\\scripts\\LuaMultiMark\\lmm_bindings.lua": "local input = require(\"openmw.input\")\nlocal keys = input.KEY\nlocal ctrl = input.CONTROLLER_BUTTON\nreturn   {\n    finishTextEdit = {\n        key = keys.Enter,\n        ctrl = ctrl.A,\n        label = \"Set Name\",\n        context = { \"rename\" }\n    },\n    selectMarkDest = {\n        key = keys.Enter,\n        key2 = keys.E,\n        ctrl = ctrl.A,\n        label = \"Teleport\",\n        context = { \"normal\" },\n        inputAction = input.ACTION.Use\n    },\n    selectMarkOverwrite = {\n        key = keys.Enter,\n        key2 = keys.E,\n        ctrl = ctrl.A,\n        label = \"Save Marked Location over Selected Mark\",\n        context = { \"overwrite\" },\n        inputAction = input.ACTION.Use\n    },\n    navUp = {\n        key = keys.UpArrow,\n        ctrl = ctrl.DPadUp,\n        inputAction = input.ACTION.ZoomOut,\n        inputAction2 = input.ACTION.MoveForward\n    },\n    navDown = {\n        key = keys.DownArrow,\n        ctrl = ctrl.DPadDown,\n        inputAction = input.ACTION.ZoomIn,\n        inputAction2 = input.ACTION.MoveBackward\n    },\n    enterEditMode = {\n        key = keys.R,\n        ctrl = ctrl.Y,\n        label = \"Rename Marked Location\",\n        context = { \"normal\" }\n    },\n    deleteItem = {\n        key = keys.D,\n        ctrl = ctrl.X,\n        label = \"Delete Marked Location\",\n        context = { \"normal\" }\n    },\n    cancelMenu = {\n        key = keys.Backspace,\n        ctrl = ctrl.Back,\n        label = \"Cancel Recall\",\n        context = { \"normal\" }\n    },\n    cancelMenuOverwrite = {\n        key = keys.Backspace,\n        ctrl = ctrl.Back,\n        label = \"Cancel Mark\",\n        context = { \"overwrite\" }\n    },\n    controllerMode = false\n}",
    "Zack's Lua Multimark-53260-1-5-1-1723427382\\scripts\\LuaMultiMark\\lmm_g.lua": "local world = require(\"openmw.world\")\nlocal types = require(\"openmw.types\")\nlocal core = require(\"openmw.core\")\nlocal function LMM_SetTimeScale(val)\n    if core.API_REVISION > 30 then\n        return\n    end\n    world.setSimulationTimeScale(val)\nend\n\nlocal function getPlayer()\n    for index, value in ipairs(world.activeActors) do\n        if value.recordId == \"player\" then\n            return value\n        end\n    end\n    return nil\nend\nlocal function paralyzePlayer(state,cell)\n    \n   -- local desiredActor = \"zhac_creature_paralyze_start\"\n--if state == \"end\" then\n--    desiredActor = \"zhac_creature_paralyze_end\"\n--elseif state == \"endtp\" then\n--        desiredActor = \"zhac_creature_paralyze_endtp\"\n--end\n--for index, value in ipairs(world.getCellByName(\"ZHAC_Multimark_holdingcell\"):getAll()) do\n--    if value.recordId == desiredActor then\n--        local player = getPlayer()\n--        if not cell then\n--            cell = player.cell.name\n---        end\n--        value:teleport(cell,player.position)\n--        return\n--    end\n--end\n\nend\nlocal function LMM_TeleportToCell(data)\n    --Simple function to teleport an object to any cell.\n\n    if (data.cellname.name ~= nil) then\n        data.cellname = data.cellname.name\n    end\n    if data.item.type == types.Player then\n        paralyzePlayer(\"endtp\",data.cellname)\n    end\n    data.item:teleport(data.cellname, data.position, data.rotation)\nend\nlocal function onActorActive(actor)\n    if actor.recordId:lower() == \"teleport_summonmark\" then\n\n    elseif actor.recordId:lower() == \"teleport_summonrecall\" then\n\n    end\nend\nlocal function fixTime()\n    if core.API_REVISION > 30 then\n        return\n    end\n    if world.getSimulationTimeScale() == 0 then\n\n        world.setSimulationTimeScale(1)\n    end\nend\nreturn {\n    eventHandlers = {\n        LMM_SetTimeScale = LMM_SetTimeScale,\n        LMM_TeleportToCell = LMM_TeleportToCell,\n        LMM_paralyzePlayer = paralyzePlayer,\n    },\n    engineHandlers = {\n        onActorActive = onActorActive,\n        onSave = fixTime,\n        onLoad = fixTime,\n    }\n}\n",
    "Zack's Lua Multimark-53260-1-5-1-1723427382\\scripts\\LuaMultiMark\\lmm_p.lua": "local ui = require(\"openmw.ui\")\nlocal I = require(\"openmw.interfaces\")\n\nlocal v2 = require(\"openmw.util\").vector2\nlocal util = require(\"openmw.util\")\nlocal cam = require(\"openmw.interfaces\").Camera\nlocal core = require(\"openmw.core\")\nlocal self = require(\"openmw.self\")\nlocal nearby = require(\"openmw.nearby\")\nlocal types = require(\"openmw.types\")\nlocal Camera = require(\"openmw.camera\")\nlocal camera = require(\"openmw.camera\")\nlocal input = require(\"openmw.input\")\nlocal async = require(\"openmw.async\")\nlocal storage = require(\"openmw.storage\")\nlocal editMode = false\nlocal keys = input.KEY\nlocal ctrl = input.CONTROLLER_BUTTON\nlocal markData = {}\nlocal lastPosData = nil\nlocal menuMode = false\nlocal markCount = 1\nlocal recallWindow = nil -- Define a comparison function to compare the 'numVal' property\nlocal bindingsWin = nil\nlocal zutilsUI = require(\"scripts.luamultimark.zu_ui\")\n--local camera_controller = require(\"scripts.LuaMultiMark.camera_controller\")\nlocal gmst_checker = require(\"scripts.LuaMultiMark.GMST_Checker\")\n\nlocal effect_checker = require(\"scripts.LuaMultiMark.Effect_Checker\")\n\nlocal function getMarkDataLength()\n    local count = 0\n    for index, value in pairs(markData) do\n        count = count + 1\n    end\n    return count\nend\n\nlocal isValid = gmst_checker.checkValues()\nlocal isValid2 = effect_checker.checkValues()\nlocal timePassed = 0\nif not isValid or not isValid2 then\n    I.Settings.registerPage {\n        key = \"SettingsMultiMark\",\n        l10n = \"SettingsMultiMark\",\n        name = \"Multimark Lua\",\n        description = \"Your game settings are not set as expected, likely due to a load order issue. Please ensure that the mod is loaded after the base game and any other mods that may affect the GMSTs sEffectSummonCreature04, sEffectSummonCreature05, sMagicCreature04ID, and sMagicCreature05ID.\"\n    }\n    return {\n        engineHandlers = {\n            onUpdate = function(dt)\n                timePassed = timePassed + dt\n                if timePassed > 1 then\n                    timePassed = 0\n                    ui.showMessage(\n                    \"Lua MultiMark: Game settings are not set correctly. Check your load order, for more info open your mod settings menu.\")\n                end\n            end\n\n        }\n    }\nelse\n    print(\"GMSTs are valid\")\nend\nI.Settings.registerPage {\n    key = \"SettingsMultiMark\",\n    l10n = \"SettingsMultiMark\",\n    name = \"Multimark Lua\",\n    description = \"These settings allow you to modify the behavior of multimark.\"\n}\nlocal itemWindowLocs = {\n    TopLeft = \"Top Left\",\n    TopRight = \"Top Right\",\n    BottomLeft = \"Bottom Left\",\n    BottomRight = \"Bottom Right\",\n    Disabled = \"Disabled\"\n}\nlocal function getWindowLocs()\n    local ret = {}\n    for key, value in pairs(itemWindowLocs) do\n        table.insert(ret, value)\n    end\n    return ret\nend\n\nlocal function closeWindows()\n    if recallWindow then\n        recallWindow:destroy()\n        --recallWindow = nil\n    end\n    if bindingsWin then\n        bindingsWin:destroy()\n        bindingsWin = nil\n    end\nend\nI.Settings.registerGroup {\n    key = \"SettingsMultiMark\",\n    page = \"SettingsMultiMark\",\n    l10n = \"SettingsMultiMark\",\n    name = \"Main Settings\",\n    permanentStorage = true,\n    settings = {\n\n        {\n            key = \"levelsPerMark\",\n            renderer = \"number\",\n            name = \"Skill Requirement Per Mark\",\n            description =\n            \"How many points of Mysticism will be required per mark location. If this is set to 5, and you have 25 Mysticism, you will have 5 mark points.\",\n            default = 5\n        },\n        {\n            key = \"baseMarkCount\",\n            renderer = \"number\",\n            name = \"Base Mark Count\",\n            description =\n            \"How many mark points will be available at level 0. May be negative. If this is set to 5, and you have 25 Mysticism, you will have 10 mark points. If it is set to -5, you will have not have any mark points until you hit 30 mysticism.\",\n            default = 0\n        },\n        {\n            key = \"enableFollowerTP\",\n            renderer = \"checkbox\",\n            name = \"Allow Follower Teleportation\",\n            description =\n            \"If enabled, will allow followers to teleport with you when you cast recall.\",\n            default = true\n        },\n        -- {\n        --     key = \"enableCameraFreeze\",\n        --     renderer = \"checkbox\",\n        --     name = \"Enable Camera Freeze\",\n        --      description =\n        --     \"If enabled, will freeze the camera while in the recall menu. May cause you to be frozen when leaving that menu, so turn it off if you have issues.\",\n        --     default = false\n        -- },\n        {\n            key = \"InfoWindowLocation\",\n            renderer = \"select\",\n            l10n = \"AshlanderArchitectButtons\",\n            name = \"Info Window Location\",\n            description =\n            \"Allows you to change the window that will display the button information, also allows you to disable it.\",\n            default = \"Top Left\",\n            argument = {\n                disabled = false,\n                l10n = \"AshlanderArchitectButtons\",\n                items = getWindowLocs()\n            },\n        },\n    },\n\n}\n\nlocal playerSettings = storage.playerSection(\"SettingsMultiMark\")\nlocal function compareNumVal(a, b)\n    return a.numVal < b.numVal\nend\nlocal camData = nil\nlocal playerRot = nil\n\nlocal function canTeleport()\n    if types.Player.isTeleportingEnabled ~= nil then --0.49(recent)\n        local check = types.Player.isTeleportingEnabled(self)\n        if not check then\n            ui.showMessage(core.getGMST(\"sTeleportDisabled\"))\n            return false\n        else\n            return true\n        end\n    end\n    if self.cell.name == \"Akulakhan's Chamber\" then\n        return false\n    end\n    return true\nend\nlocal function setPauseMode(val)\n    menuMode = val\n    if core.API_REVISION > 30 then\n        if val then\n            I.UI.setMode('Interface', { windows = {} })\n        else\n            I.UI.setMode()\n        end\n        return\n    end\n    local timeScale = 1\n    if (val) then --pausing\n        timeScale = 0\n        if playerSettings:get(\"enableCameraFreeze\") == true then\n            core.sendGlobalEvent(\"LMM_paralyzePlayer\", \"Start\")\n        end\n        playerRot = self.rotation\n        camData = { yaw = camera.getYaw(), pitch = camera.getPitch(), roll = camera.getRoll(), mode = camera.getMode() }\n        camera.setMode(camera.MODE.Static)\n        camera.setRoll(camData.roll)\n        camera.setPitch(camData.pitch)\n        camera.setYaw(camData.yaw)\n\n        core.sendGlobalEvent(\"LMM_TeleportToCell\",\n            {\n                item = self,\n                cellname = self.cell.name,\n                position = self.position,\n                rotation = playerRot\n            })\n    else\n        local newMode\n        if camData then\n            newMode = camData.mode or camera.MODE.ThirdPerson\n        else\n            newMode = camera.MODE.ThirdPerson\n        end\n        camera.setMode(newMode)\n        timeScale = 1\n    end\n    core.sendGlobalEvent(\"LMM_SetTimeScale\", timeScale)\n    input.setControlSwitch(input.CONTROL_SWITCH.Controls, not val)\n    input.setControlSwitch(input.CONTROL_SWITCH.Looking, not val)\nend\nlocal lastWinState = false\nlocal keyBindings = require(\"scripts.LuaMultiMark.lmm_bindings\")\nlocal function contextCheck(keyBinding, context)\n    for index, value in ipairs(keyBinding.context) do\n        if value:lower() == context:lower() then\n            return true\n        end\n    end\n    return false\nend\nfunction keyBindings.getButtonLabel(bindingName, controllerMode)\n    local binding = bindingName\n    if not binding then return \"nothing\" end\n    if not controllerMode then\n        for key, value in pairs(input.KEY) do\n            if value == binding.key then\n                return key\n            end\n        end\n    else\n        for key, value in pairs(input.CONTROLLER_BUTTON) do\n            if value == binding.ctrl then\n                return key\n            end\n        end\n    end\nend\n\nlocal inputAction = nil\nlocal function checkBinding(kbinding, key, ctrl)\n    if kbinding.context ~= nil then\n        if not contextCheck(kbinding, recallWindow.context) then\n            return false\n        end\n    end\n    if key == kbinding.key or ctrl == kbinding.ctrl or (inputAction == kbinding.inputAction and inputAction ~= nil) then\n        return true\n    elseif (inputAction == kbinding.inputAction2 and inputAction ~= nil) then\n        return true\n    elseif kbinding.key2 and key == kbinding.key2 then\n        return true\n    else\n        return false\n    end\nend\nlocal function enterEditMode()\n    editMode = true\n\n    recallWindow.editMode = true\n    recallWindow.editLine = recallWindow:getItemAt(recallWindow.selectedPosX, recallWindow.selectedPosY).label\nend\nlocal function getSelectedMarkIndex()\n    local mindex = 1\n    if not recallWindow then\n        return -1\n    end\n    local data = recallWindow:getItemAt(recallWindow.selectedPosX, recallWindow.selectedPosY)\n    if data then\n        for index, value in ipairs(markData) do\n            if value == data then\n                return mindex\n            else\n                mindex = mindex + 1\n            end\n        end\n    end\n    return -1\nend\nlocal function doRecall(index, iw)\n    if not iw then\n        iw = recallWindow\n    end\n    if not iw and not recallWindow then return end\n    local data = recallWindow:getItemAt(index, iw.selectedPosY)\n    if data then\n        if playerSettings:get(\"enableFollowerTP\") == true then\n            for index, value in ipairs(nearby.actors) do\n                if value.type ~= self.type then\n                    value:sendEvent(\"teleportFollower\",\n                        { destPos = data.position, destCell = data.cell, destRot = data.rotation })\n                end\n            end\n        end\n        core.sendGlobalEvent(\"LMM_TeleportToCell\",\n            {\n                item = self,\n                cellname = data.cell,\n                position = data.position,\n                rotation = data.rotation\n            })\n    end\n    closeWindows()\n    setPauseMode(false)\nend\nlocal function saveMarkOverwrite(selectedx, selectedy)\n    if not recallWindow then\n        return\n    end\n    local data = recallWindow:getItemAt(selectedx, selectedy)\n    local useMark = 0\n    local usePosition = -1\n    if data then\n        for index, value in ipairs(markData) do\n            if value == data then\n                table.remove(markData, index)\n                usePosition = index\n                useMark = value.numVal\n                table.sort(markData, compareNumVal)\n                recallWindow.list = markData\n                if not recallWindow:getItemAt(selectedx, selectedy) then\n                    recallWindow.selectedPosX = recallWindow.selectedPosX - 1\n                end\n                break\n            end\n        end\n    end\n    if playerSettings:get(\"enableCameraFreeze\") == true then\n        core.sendGlobalEvent(\"LMM_paralyzePlayer\", \"end\")\n    end\n    I.LMM.saveMarkLoc(useMark, true, usePosition)\n\n    closeWindows()\n\n    setPauseMode(false)\nend\nlocal function processInput(key, ctrl, str, action)\n    local id = ctrl\n    if ctrl then\n        keyBindings.controllerMode = true\n    else\n        keyBindings.controllerMode = false\n    end\n    inputAction = action\n    if editMode then\n        if checkBinding(keyBindings.finishTextEdit, key, ctrl) or key == keys.Enter then\n            editMode = false\n            recallWindow.editMode = false\n            local line = recallWindow.editLine\n            local data = recallWindow:getItemAt(recallWindow.selectedPosX, recallWindow.selectedPosY)\n            if data then\n                for index, value in ipairs(markData) do\n                    if value == data then\n                        -- table.remove(markData, index)\n                        recallWindow.list = markData\n                        data.label = line\n                        -- table.insert(markData, data)\n                        table.sort(markData, compareNumVal)\n                        break\n                    end\n                end\n            end\n        elseif key == keys.Backspace then\n            recallWindow.editLine = recallWindow.editLine:sub(1, -2)\n        else\n            local char = str\n            if char and char ~= \"\" then\n                if input.isShiftPressed() then\n                    char = char:upper()\n                end\n                recallWindow.editLine = recallWindow.editLine .. char\n            end\n        end\n        recallWindow:reDraw()\n        return\n    end\n\n    if not recallWindow or editMode then\n        lastWinState = recallWindow == nil\n        return\n    end\n    local selectedx = recallWindow.selectedPosX\n    local selectedy = recallWindow.selectedPosY\n    if (checkBinding(keyBindings.navUp, key, ctrl)) then\n        if (recallWindow.listMode) then\n            if (recallWindow.selectedPosX > 1 and recallWindow:getItemAt(recallWindow.selectedPosX - 1, selectedy) ~= nil) then\n                recallWindow.selectedPosX = selectedx - 1\n            else\n                if (recallWindow.scrollOffset > 0) then\n                    recallWindow.scrollOffset = (recallWindow.scrollOffset - 1)\n                end\n            end\n        end\n    elseif (checkBinding(keyBindings.navDown, key, ctrl)) then\n        if (recallWindow.listMode) then\n            if (selectedx < 9 and recallWindow:getItemAt(selectedx + 1, selectedy) ~= nil) then\n                recallWindow.selectedPosX = selectedx + 1\n            elseif recallWindow.selectedPosX > recallWindow.rowCountY - 2 and recallWindow:getItemAt(selectedx + 1, selectedy) then\n                recallWindow.scrollOffset = (recallWindow.scrollOffset + 1)\n            end\n        end\n    elseif checkBinding(keyBindings.selectMarkOverwrite, key, ctrl) and lastWinState == false then\n        saveMarkOverwrite(selectedx, selectedy)\n        return\n    elseif tonumber(str) then\n        local data = recallWindow:getItemAt(tonumber(str), selectedy)\n        if data then\n            if playerSettings:get(\"enableFollowerTP\") == true then\n                for index, value in ipairs(nearby.actors) do\n                    if value.type ~= self.type then\n                        value:sendEvent(\"teleportFollower\",\n                            { destPos = data.position, destCell = data.cell, destRot = data.rotation })\n                    end\n                end\n            end\n            core.sendGlobalEvent(\"LMM_TeleportToCell\",\n                {\n                    item = self,\n                    cellname = data.cell,\n                    position = data.position,\n                    rotation = data.rotation\n                })\n        end\n\n        closeWindows()\n        setPauseMode(false)\n        return\n    elseif checkBinding(keyBindings.selectMarkDest, key, ctrl) and lastWinState == false and recallWindow.context == \"normal\" then\n        if not canTeleport() then return end\n        doRecall(recallWindow.selectedPosX)\n        return\n    elseif checkBinding(keyBindings.enterEditMode, key, ctrl) and recallWindow:getItemAt(selectedx, selectedy) and not editMode then\n        enterEditMode()\n    elseif checkBinding(keyBindings.deleteItem, key, ctrl) then\n        local data = recallWindow:getItemAt(selectedx, selectedy)\n        if data then\n            for index, value in ipairs(markData) do\n                if value == data then\n                    table.remove(markData, index)\n\n\n                    table.sort(markData, compareNumVal)\n                    recallWindow.list = markData\n                    if not recallWindow:getItemAt(selectedx, selectedy) then\n                        recallWindow.selectedPosX = recallWindow.selectedPosX - 1\n                    end\n                    break\n                end\n            end\n        end\n    elseif checkBinding(keyBindings.cancelMenu, key, ctrl) or checkBinding(keyBindings.cancelMenuOverwrite, key, ctrl) then\n        closeWindows()\n        setPauseMode(false)\n        if playerSettings:get(\"enableCameraFreeze\") == true then\n            core.sendGlobalEvent(\"LMM_paralyzePlayer\", \"end\")\n        end\n        return\n    end\n    recallWindow:reDraw()\n    lastWinState = recallWindow == nil\nend\nlocal lastChange = 0\nlocal passedTime = 0\nlocal function drawListMenu(buttonTable)\n    --closeWindows()\n    local winLoc = playerSettings:get(\"InfoWindowLocation\")\n    local wx = 0\n    local wy = 0\n    local align = nil\n    local anchor = nil\n    if winLoc == itemWindowLocs.TopLeft then\n        wx = 0\n        wy = 0\n        align = ui.ALIGNMENT.Start\n    elseif winLoc == itemWindowLocs.TopRight then\n        wx = 1\n        wy = 0\n        anchor = util.vector2(1, 0)\n        align = ui.ALIGNMENT.End\n    elseif winLoc == itemWindowLocs.BottomLeft then\n        wx = 0\n        wy = 1\n        anchor = util.vector2(0, 1)\n        align = ui.ALIGNMENT.End\n    elseif winLoc == itemWindowLocs.BottomRight then\n        wx = 1\n        wy = 1\n        anchor = util.vector2(1, 1)\n        align = ui.ALIGNMENT.Start\n    elseif winLoc == itemWindowLocs.Disabled then\n        return\n    end\n    bindingsWin = zutilsUI.renderItemChoice(buttonTable, wx, wy, align, anchor)\nend\nlocal function openMarkMenu(context)\n    if not canTeleport() then return end\n    if getMarkDataLength() == 0 then\n        ui.showMessage(\"There are no marked locations. Cast the spell mark before casting recall.\")\n        return\n    end\n    table.sort(markData, compareNumVal)\n    recallWindow = I.LMM_Window.createItemWindow(markData, 0.5, 0.5, keyBindings, context)\n\n    local buttonTable = {}\n    local kb = I.LMM.getKeyBindings()\n    if kb.controllerMode then\n        table.insert(buttonTable, \"DPad: Navigate\")\n    else\n        table.insert(buttonTable, \"Arrow Keys: Navigate\")\n    end\n    for index, value in pairs(I.LMM.getKeyBindings()) do\n        if value and value ~= kb.getButtonLabel and value ~= kb.controllerMode and value.label and contextCheck(value, recallWindow.context) then\n            table.insert(buttonTable, value.label .. \": \" .. kb.getButtonLabel(value, kb.controllerMode))\n        end\n    end\n    drawListMenu(buttonTable)\n    recallWindow:setGridSize(20, 10)\n    recallWindow.selected = true\n    setPauseMode(true)\nend\nlocal function trim(s)\n    return s:match '^()%s*$' and '' or s:match '^%s*(.*%S)'\nend\nlocal function formatRegion(regionString)\n    -- remove the word \"region\"\n    -- capitalize the first letter of each word\n    regionString = string.gsub(regionString, \"(%a)([%w_']*)\", function(first, rest)\n        return first:upper() .. rest:lower()\n    end)\n    -- trim any leading/trailing whitespace\n    regionString = trim(regionString)\n    return regionString\nend\nlocal function getAvailableSlot()\n    local i = 1\n    table.sort(markData, compareNumVal)\n    if markData[1] == nil then\n        return 1\n    end\n    local lowest = markData[1].numVal -- Initialize lowest with the first element's numVal\n    for i = 2, getMarkDataLength() do\n        if markData[i] and markData[i].numVal < lowest then\n            lowest = markData[i].numVal -- Update lowest if a smaller value is found\n        end\n    end\n\n    return lowest\nend\nlocal function getMaxSlots()\n    local baseMark = playerSettings:get(\"baseMarkCount\")\n    local skillMult = playerSettings:get(\"levelsPerMark\")\n    if skillMult == 0 then\n        return 800\n    end\n    local myMyst = types.NPC.stats.skills[\"mysticism\"](self).modified\n    local totalSlots = (myMyst / skillMult) + baseMark\n    return math.floor(totalSlots)\nend\nlocal function saveMarkLoc(useMarkCount, force, usePosition)\n    if not canTeleport() then return end\n    if usePosition == -1 then\n        usePosition = nil\n    end\n    local firstLabel = self.cell.name\n    if firstLabel == \"\" or firstLabel == nil then\n        firstLabel = formatRegion(self.cell.region)\n    end\n    if firstLabel == \"\" or firstLabel == nil then\n        firstLabel = \"Wilderness\"\n    end\n    if I.CellGen2_Labels then\n        local check = I.CellGen2_Labels.getLabelForCell()\n        if check then\n            firstLabel = check\n        end\n    end\n    if getMaxSlots() <= 0 then\n        ui.showMessage(\"Your mysticism level is too low to use this spell.\")\n        return\n    elseif getMarkDataLength() >= getMaxSlots() and not force then\n        ui.showMessage(\"Your mysticism level is too low to save another marked location.\")\n        openMarkMenu(\"overwrite\")\n        return\n    end\n\n    if not useMarkCount then\n        useMarkCount = markCount\n    end\n    ui.showMessage(\"Location marked as \" .. firstLabel)\n    local data = {\n        position = self.position,\n        rotation = self.rotation,\n        cell = self.cell.name,\n        label = firstLabel,\n        numVal = useMarkCount\n    }\n    if usePosition then\n        table.insert(markData, usePosition,\n            data)\n    else\n        table.insert(markData,\n            data)\n    end\n\n    table.sort(markData, compareNumVal)\n    markCount = markCount + 1\nend\nlocal lastAxis = 0\nlocal threshHold = 0.3\nlocal lastRightPress = false\nlocal function onUpdate(dt)\n    if not markData then\n        markData = {}\n    end\n\n    if menuMode then\n        local controllerAxis = input.getAxisValue(input.CONTROLLER_AXIS.LeftY)\n        if controllerAxis > threshHold and lastAxis < threshHold then\n            processInput(nil, nil, nil, input.ACTION.ZoomIn)\n        elseif controllerAxis > -threshHold and lastAxis < -threshHold then\n            processInput(nil, nil, nil, input.ACTION.ZoomOut)\n        end\n        lastAxis = controllerAxis\n        local rightButtonPressed = input.isMouseButtonPressed(3)\n        if rightButtonPressed and not lastRightPress then\n            closeWindows()\n            setPauseMode(false)\n        end\n        lastRightPress = rightButtonPressed\n    end\nend\nlocal function createRotation(x, y, z)\n    if (core.API_REVISION < 40) then\n        return util.vector3(x, y, z)\n    else\n        local rotate = util.transform.rotateZ(z)\n        return rotate\n    end\nend\nlocal function onLoad(data)\n    if data then\n        markData = data.markData\n        if data.revVer <= 40 and data.revVer ~= core.API_REVISION then\n            --   markData = data.markData\n            for index, value in ipairs(markData) do --Apparently this is not needed\n                -- value.rotation = createRotation(0,0,0)\n            end\n        end\n        if data.markCount then\n            markCount = data.markCount\n        end\n    end\nend\nlocal function onSave()\n    if menuMode == true then\n        closeWindows()\n        setPauseMode(false)\n    end\n    return { markData = markData, markCount = markCount, revVer = core.API_REVISION }\nend\nlocal lastPress = 0\nlocal function onControllerButtonPress(ctrl)\n    if menuMode == true then\n        if (core.getRealTime() < lastPress + 0.002) then\n            return\n        end\n        processInput(nil, ctrl)\n        lastPress = core.getRealTime()\n    end\nend\nlocal function onControllerButtonRelease(ctrl)\n\nend\nlocal function onKeyPress(key)\n    if menuMode == true then\n        processInput(key.code, nil, key.symbol)\n    end\nend\nlocal function onInputAction(action)\n    if menuMode == true then\n        processInput(nil, nil, nil, action)\n    end\nend\nreturn {\n    interfaceName = \"LMM\",\n    interface = {\n        version = 1,\n        openMarkMenu = openMarkMenu,\n        saveMarkLoc = saveMarkLoc,\n        getKeyBindings = function() return keyBindings end,\n        getMarkDataLength = getMarkDataLength,\n        getMaxSlots = getMaxSlots,\n        getSelectedMarkIndex = getSelectedMarkIndex,\n        doRecall = doRecall,\n        enterEditMode = enterEditMode,\n        processInput = processInput,\n        saveMarkOverwrite = saveMarkOverwrite,\n\n    },\n    eventHandlers = {\n        openMarkMenu = openMarkMenu,\n        saveMarkLoc = saveMarkLoc,\n        UiModeChanged = function(data)\n            -- print('LMMUiModeChanged to', data.newMode, '(' .. tostring(data.arg) .. ')')\n            if recallWindow ~= nil and data.newMode == nil then\n                closeWindows()\n                recallWindow = nil\n                setPauseMode(false)\n            elseif recallWindow == nil then\n                --    print(\"RCW is nil\")\n            elseif data.newMode ~= nil then\n                --    print(\"newMode is nnil\")\n            end\n        end,\n    },\n    engineHandlers = {\n        onControllerButtonPress = onControllerButtonPress,\n        onKeyPress = onKeyPress,\n        onUpdate = onUpdate,\n        onSave = onSave,\n        onLoad = onLoad,\n        onInputAction = onInputAction,\n    }\n}\n",
    "Zack's Lua Multimark-53260-1-5-1-1723427382\\scripts\\LuaMultiMark\\lmm_win.lua": "local ui = require(\"openmw.ui\")\nlocal I = require(\"openmw.interfaces\")\n\nlocal v2 = require(\"openmw.util\").vector2\nlocal util = require(\"openmw.util\")\nlocal cam = require(\"openmw.interfaces\").Camera\nlocal core = require(\"openmw.core\")\nlocal self = require(\"openmw.self\")\nlocal nearby = require(\"openmw.nearby\")\nlocal types = require(\"openmw.types\")\nlocal Camera = require(\"openmw.camera\")\nlocal camera = require(\"openmw.camera\")\nlocal input = require(\"openmw.input\")\nlocal async = require(\"openmw.async\")\nlocal storage = require(\"openmw.storage\")\nlocal iconsize = 40\nlocal iconsizegrow = iconsize + 10\nlocal windowType = { inventory = 1, magic = 2, skills = 3, stats = 4 }\nlocal itemCheck = \"ebony_dagger_mehrunes\"\nlocal keyBindings = nil\nlocal function getEnchantment(id)\n    return core.magic.enchantments[id]\nend\nlocal function mouseClick(mouseEvent, data)\n    if data.props.selected then\n        if data.props.iw.context == \"overwrite\" then\n            I.LMM.saveMarkOverwrite(data.props.iw.selectedPosX, data.props.iw.selectedPosY)\n        else\n            if mouseEvent.button == 1 then\n                I.LMM.doRecall(data.props.index, data.props.iw)\n            elseif mouseEvent.button == 3 then\n                I.LMM.enterEditMode()\n            end\n        end\n    elseif data.props.iw.selectedPosX ~= data.props.index then\n        data.props.iw.selectedPosX = data.props.index\n        data.props.iw:reDraw()\n    end\nend\nlocal function boxedTextEditContent(text, callback, textScale, width)\n    if textScale == nil then\n        textScale = 1\n    end\n    if width == nil then\n        width = 400\n    end\n    return {\n        type = ui.TYPE.Container,\n        content = ui.content {\n            {\n                template = I.MWUI.templates.box,\n                props = {\n                    anchor = util.vector2(0, -0.5),\n                    size = util.vector2(400, 10),\n                },\n                content = ui.content {\n                    {\n                        type = ui.TYPE.TextEdit,\n                        template = I.MWUI.templates.textEditLine,\n                        events = { textChanged = callback },\n                        props = {\n                            text = text,\n                            size = util.vector2(width, 30),\n                            textAlignH = 15,\n                            textSize = 25,\n                            align = ui.ALIGNMENT.Center,\n                        }\n                    }\n                }\n            }\n        }\n    }\nend\nlocal function padString(str, length)\n    local strLength = string.len(str)\n\n    if strLength >= length then\n        return str -- No need to pad if the string is already longer or equal to the desired length\n    end\n\n    local padding = length - strLength                   -- Calculate the number of spaces needed\n    local paddedString = str .. string.rep(\" \", padding) -- Concatenate the string with the required number of spaces\n\n    return paddedString\nend\nlocal function setWindowType(iw, type)\n    if (type == windowType.inventory) then\n        iw.catTypes = { \"All\", \"Weapon\", \"Apparel\", \"Magic\", \"Misc\" }\n        iw.typeFilter = {\n            [\"All\"] = {},\n            [\"Weapon\"] = { types.Weapon },\n            [\"Apparel\"] = { types.Clothing, types.Armor },\n            [\"Magic\"] = { types.Ingredient, types.Potion },\n            [\"Misc\"] = { types.Apparatus, types.Book, types.Miscellaneous, types.Probe, types.Repair }\n        }\n        iw.listMode = false\n    elseif type == windowType.magic then\n        iw.catTypes = { \"All\", \"Alteration\", \"Conjuration\", \"Destruction\", \"Illusion\", \"Mysticism\", \"Restoration\" }\n        iw.listMode = true\n    end\n    iw.windowType = type\nend\nlocal function formatNumber(num)\n    local threshold = 1000\n    print(num)\n    local millionThreshold = 1000000\n\n    if num >= millionThreshold then\n        local formattedNum = math.floor(num / millionThreshold)\n        return string.format(\"%dm\", formattedNum)\n    elseif num >= threshold then\n        local formattedNum = math.floor(num / threshold)\n        return string.format(\"%dk\", formattedNum)\n    else\n        return tostring(num)\n    end\nend\nlocal function FindEnchant(item)\n    if (item == nil or item.type == nil or item.type.records[item.recordId] == nil or item.type.records[item.recordId].enchant == nil or item.type.records[item.recordId].enchant == \"\") then\n        return nil\n    end\n    return item.type.records[item.recordId].enchant\nend\n\nlocal function FindEnchantment(item)\n    if (item == nil or item.type == nil or item.type.records[item.recordId] == nil or item.type.records[item.recordId].enchant == nil or item.type.records[item.recordId].enchant == \"\") then\n        return nil\n    end\n    return getEnchantment(item.type.records[item.recordId].enchant)\nend\nlocal function getAllEnchantments(actorInv, onlyCastable)\n    local ret = {}\n    for index, value in ipairs(actorInv:getAll()) do\n        local ench = FindEnchantment(value)\n        if (ench and not onlyCastable) then\n            table.insert(ret, { enchantment = ench, item = value })\n        elseif ench and onlyCastable and (ench.type == core.magic.ENCHANTMENT_TYPE.CastOnUse or ench.type == core.magic.ENCHANTMENT_TYPE.CastOnce) then\n            table.insert(ret, { enchantment = ench, item = value })\n        end\n    end\n    return ret\nend\nlocal function getEffectIcon(effect)\n    --local strWithoutSpaces = string.gsub(effect.name, \"%s\", \"\")\n    -- if( effectData[strWithoutSpaces] == nil) then\n    --    print(strWithoutSpaces)\n    --  end\n    --strWithoutSpaces= string.sub(effectData[strWithoutSpaces], 1, -4) .. \"dds\"\n    -- print(strWithoutSpaces)\n    return effect.icon\nend\nlocal function textContent(text, template, color)\n    local tsize = 15\n    if not color then\n        template = I.MWUI.templates.textNormal\n        color = template.props.textColor\n    elseif color == \"red\" then\n        template = I.MWUI.templates.textNormal\n        color = util.color.rgba(5, 0, 0, 1)\n    else\n        template = I.MWUI.templates.textHeader\n        color = template.props.textColor\n        --  tsize = 20\n    end\n\n    return {\n        type = ui.TYPE.Text,\n        template = template,\n        props = {\n            text = tostring(text),\n            textSize = tsize,\n            arrange = ui.ALIGNMENT.Center,\n            align = ui.ALIGNMENT.Center,\n            textColor = color\n        }\n    }\nend\nlocal lineLength = 60\nlocal function renderListItem(iw, selected, textx, item, diffFont, index)\n    local itemIcon = nil\n    local resource2\n\n    local text = \"\"\n    if not diffFont then diffFont = false end\n\n    local resources = nil\n    if (iw.windowType == windowType.inventory and true == false) then\n\n    elseif iw.windowType == windowType.magic and item then\n    elseif item and iw.editMode and selected then\n        if iw.context == \"overwrite\" then\n            diffFont = \"red\"\n        elseif selected then\n            diffFont = \"white\"\n        end\n        if iw.drawLine then\n            resources = ui.content {\n                textContent(padString(iw.editLine .. \"_\", lineLength), nil, diffFont)\n            }\n        else\n            resources = ui.content {\n                textContent(padString(iw.editLine, lineLength), nil, diffFont)\n            }\n        end\n    elseif item then\n        if iw.context == \"overwrite\" and selected then\n            diffFont = \"red\"\n        elseif selected then\n            diffFont = \"white\"\n        end\n        resources = ui.content {\n            textContent(padString(item, lineLength), nil, diffFont)\n        }\n    else\n        if iw.context == \"overwrite\" and selected then\n            diffFont = \"red\"\n        elseif selected then\n            diffFont = \"white\"\n        end\n        resources = ui.content {\n            textContent(padString(\"\", lineLength), nil, diffFont)\n        }\n    end\n    -- resource2 = ui.texture({ path = \"icons\\\\selected.tga\" })\n\n    local rowCountX = 1\n    if (selected and item) then\n        return {\n            type = ui.TYPE.Container,\n            props = {\n                size = util.vector2(iconsize, iconsizegrow * rowCountX),\n                index = index,\n                autoSize = false,\n                selected = true,\n                iw = iw,\n            },\n            events = {\n                mousePress = async:callback(mouseClick),\n                -- mouseRelease = async:callback(clickMeStop),\n                --mouseMove = async:callback(mouseMove)\n            },\n            content = ui.content {\n                {\n                    template = I.MWUI.templates.box,\n                    props = {\n                        size = util.vector2(iconsize, iconsizegrow * rowCountX)\n                    },\n                    alignment = ui.ALIGNMENT.Center,\n                    content = resources\n                }\n            }\n        }\n    end\n    return {\n        type = ui.TYPE.Container,\n        props = {\n            size = util.vector2(iconsize, iconsizegrow * rowCountX),\n            autoSize = false,\n            selected = false,\n            index = index,\n            iw = iw,\n        },\n        events = {\n            mousePress = async:callback(mouseClick),\n            -- mouseRelease = async:callback(clickMeStop),\n            --   mouseMove = async:callback(mouseMove)\n        },\n        content = ui.content {\n            {\n                template = I.MWUI.templates.padding,\n                alignment = ui.ALIGNMENT.Center,\n                content = resources\n            }\n        }\n    }\nend\nlocal function generateListItems(iw, spellList, enchantList)\n    local ret = {}\n    local createListItem = function(strig, iconTable, spell)\n        return { name = strig, icon = iconTable, spell = spell }\n    end\n    if iw.windowType == windowType.magic then\n        local spells = types.Actor.spells(self)\n        if (spellList ~= nil) then\n            spells = spellList\n\n            enchantList = getAllEnchantments(types.Actor.inventory(self), true)\n        end\n        for index, spell in ipairs(spells) do\n            if spell.type == core.magic.SPELL_TYPE.Power or spell.type == core.magic.SPELL_TYPE.Spell then\n                local listItem = createListItem(spell.name, getEffectIcon(spell.effects[1].effect), spell)\n                table.insert(ret, listItem)\n            end\n        end\n        enchantList = getAllEnchantments(types.Actor.inventory(self), true)\n        for index, ench in ipairs(enchantList) do\n            local name = ench.item.type.record(ench.item).name\n            local listItem = createListItem(name, getEffectIcon(ench.enchantment.effects[1].effect), ench.item)\n            table.insert(ret, listItem)\n        end\n    end\n    return ret\nend\nlocal function renderGridIcon(item, selected, listMode)\n    local itemIcon = nil\n    local resource2\n\n    resource2 = ui.texture({ path = \"icons\\\\selected.tga\" })\n    local magicIcon = nil\n    if (FindEnchant(item) and FindEnchant(item) ~= \"\") then\n        magicIcon = ui.texture({ path = \"textures\\\\menu_icon_magic_mini.dds\" })\n    end\n    local text = \"\"\n    if (item) then\n        local record = I.ZackUtils.findItemIcon(item)\n        if (item.count > 1) then\n            text = formatNumber(item.count)\n        end\n        itemIcon = ui.texture({ path = record })\n    end\n    if (selected and item) then\n        return {\n            type = ui.TYPE.Container,\n            props = {\n                size = util.vector2(iconsize, iconsize)\n            },\n            content = ui.content {\n                {\n                    template = I.MWUI.templates.box,\n                    alignment = ui.ALIGNMENT.Center,\n                    content = ui.content {\n                        I.ZackUtilsUI_ci.imageContent(magicIcon),\n                        I.ZackUtilsUI_ci.imageContent(itemIcon),\n                        I.ZackUtilsUI_ci.imageContent(resource2),\n                        I.ZackUtilsUI_ci.textContent(tostring(text))\n                    }\n                }\n            }\n        }\n    end\n    return {\n        type = ui.TYPE.Container,\n        props = {\n            size = util.vector2(iconsize, iconsize)\n        },\n        content = ui.content {\n            {\n                template = I.MWUI.templates.padding,\n                alignment = ui.ALIGNMENT.Center,\n                content = ui.content {\n                    I.ZackUtilsUI_ci.imageContent(magicIcon),\n                    I.ZackUtilsUI_ci.imageContent(itemIcon),\n                    I.ZackUtilsUI_ci.textContent(tostring(text))\n                }\n            }\n        }\n    }\n\n    --TODO:Make this not suck\nend\n\nlocal function itemIsEquipped(item, actor)\n    --Checks if item record is equipped on the specified actor\n    if (actor == nil) then actor = self end\n    if (actor.type ~= types.NPC and actor.type ~= types.Creature and actor.type ~=\n            types.Player) then\n        print(\"invalid type\")\n        return false\n    end\n    for slot = 1, 17 do\n        if (types.Actor.equipment(actor, slot)) then\n            if (item.id == types.Actor.equipment(actor, slot).id) then\n                return true\n            end\n        end\n    end\n    return false\nend\nlocal function filterItems(iw, itemList, skipItem, actor)\n    local key = iw.catTypes[I.ControllerInterface.getCurrentCat()]\n    print(key)\n    if (key == nil) then\n        I.ControllerInterface.setCurrentCat(1)\n        key = iw.catTypes[I.ControllerInterface.getCurrentCat()]\n    end\n    local ret = {}\n    if (iw.windowType == windowType.magic) then\n        if (key == \"All\") then\n            local ench = getAllEnchantments(types.Actor.inventory(self), true)\n            return generateListItems(iw)\n        else\n            local ench = getAllEnchantments(types.Actor.inventory(self), true)\n            for index, en in ipairs(ench) do\n\n            end\n            for index, spell in ipairs(types.Actor.spells(self)) do\n                local effect = spell.effects[1].effect --types.Actor.spells(self)[22].effects[1].effect\n                if (effect.school == core.magic.SCHOOL[key]) then\n                    table.insert(ret, spell)\n                end\n            end\n        end\n        return generateListItems(iw, ret)\n    end\n    local filter = iw.typeFilter[key]\n    if (skipItem == nil) then\n        skipItem = itemCheck\n    else\n        skipItem = skipItem.recordId\n    end\n    for index, value in ipairs(itemList) do\n        if (value.recordId == itemCheck) then\n            core.sendGlobalEvent(\"clearContainerCheck\", value)\n        end\n    end\n    if (key == \"All\") then\n        for index, value in ipairs(itemList) do\n            if (value.recordId ~= skipItem and itemIsEquipped(value, actor) and value.count == 1) then\n                table.insert(ret, value)\n            end\n        end\n        for index, value in ipairs(itemList) do\n            if (value.recordId ~= skipItem and itemIsEquipped(value, actor) == false) then\n                table.insert(ret, value)\n            end\n        end\n        return ret\n    end\n    for index, value in ipairs(itemList) do\n        local valid = false\n        for k, type in ipairs(filter) do\n            if (value.type == type) then\n                valid = true\n            end\n        end\n        if (key == \"Magic\" and valid == false) then\n            if (value.type == types.Weapon or value.type == types.Book or value.type == types.Armor or value.type == types.Clothing) then\n                if (value.type.record(value).enchant ~= nil and value.type.record(value).enchant ~= \"\") then\n                    valid = true\n                end\n            end\n        end\n        if (value.recordId ~= skipItem and valid and itemIsEquipped(value, actor) and value.count == 1) then\n            table.insert(ret, value)\n        end\n    end\n    for index, value in ipairs(itemList) do\n        local valid = false\n        for k, type in ipairs(filter) do\n            if (value.type == type) then\n                valid = true\n            end\n        end\n        if (key == \"Magic\" and valid == false) then\n            if (value.type == types.Weapon or value.type == types.Book or value.type == types.Armor or value.type == types.Clothing) then\n                if (value.type.record(value).enchant ~= nil and value.type.record(value).enchant ~= \"\") then\n                    valid = true\n                end\n            end\n        end\n        if (value.recordId ~= skipItem and valid and itemIsEquipped(value, actor) == false) then\n            table.insert(ret, value)\n        end\n    end\n    return ret\nend\nlocal function renderItemList(iw)\n    local itemList = iw.list\n\n    local name = \"ItemGrid\"\n\n    local counter = 0\n    local contents = {}\n\n    for x = 1, iw.rowCountY - 1 do\n        local content = {} -- Create a new table for each value of x\n        --  for y = 1, iw.rowCountY do\n        local index = (x) + iw.scrollOffset\n\n        --print(tostring(getScrollOffset(isPlayer)))\n        --print(index)\n        if index <= #itemList then\n            local item = itemList[index]\n            -- if (item.recordId == itemCheck) then\n            --     core.sendGlobalEvent(\"clearContainerCheck\", item)\n            ----    item = nil\n            ---end\n            local linetext\n            local icon\n            if (item == nil) then\n                print(index)\n                print(#itemList)\n                return\n            end\n            item = item.label\n            local itemLayout = nil\n            if iw.context == \"override\" then\n\n            end\n            if iw.selectedPosX == x then\n                iw.selectedInvItem = item\n                itemLayout = renderListItem(iw, true, nil, item, nil, index)\n            else\n                itemLayout = renderListItem(iw, false, nil, item, nil, index)\n            end\n\n            --itemLayout.template = I.MWUI.templates.padding\n            table.insert(content, itemLayout)\n        else\n            if iw.selectedPosX == x and iw.selected then\n                iw.selectedInvItem = nil\n                local itemLayout = renderListItem(iw, true, \"\")\n                itemLayout.template = I.MWUI.templates.padding\n                table.insert(content, itemLayout)\n            else\n                local itemLayout = renderListItem(iw, false, \"\")\n                itemLayout.template = I.MWUI.templates.padding\n                table.insert(content, itemLayout)\n            end\n        end\n\n        --    end\n        table.insert(contents, content)\n    end\n    local contentinfo = {} -- Create a new table for each value of x\n    if iw.editMode then\n        local infoitemLayout = renderListItem(iw, false, nil,\n            \"Type to change the mark name.\", true)\n        table.insert(contentinfo, infoitemLayout)\n        table.insert(contents, contentinfo)\n    else\n        local selected = iw:getItemAt(iw.selectedPosX, iw.selectedPosY)\n        local sindex = 1\n        local str = \"Available Marks: \" ..\n            tostring(I.LMM.getMaxSlots() - I.LMM.getMarkDataLength()) ..\n            \"      \" ..\n            \"Selected Mark: \" .. tostring(I.LMM.getSelectedMarkIndex()) .. \"/\" .. tostring(I.LMM.getMarkDataLength())\n\n        local kb = I.LMM.getKeyBindings()\n\n        local infoitemLayout = renderListItem(iw, false, nil,\n            str, true)\n        table.insert(contentinfo, infoitemLayout)\n        table.insert(contents, contentinfo)\n    end\n\n    for _, item in ipairs(itemList) do\n        counter = counter + 1\n    end\n    local table_contents = {} -- Table to hold the generated items\n    if (#contents == 0) then\n        error(\"No content items\")\n    end\n\n    for index, contentx in ipairs(contents) do\n        local item = {\n            type = ui.TYPE.Flex,\n            content = ui.content(contentx),\n            props = {\n                size = util.vector2(450, iconsize),\n                position = v2(0.8, 25 * (index - 1)),\n                vertical = true,\n                arrange = ui.ALIGNMENT.Start,\n                autoSize = false\n            },\n            external = {\n                -- grow = iconsize + 10\n            }\n        }\n        table.insert(table_contents, item)\n    end\n    return ui.create {\n        layer = \"Windows\",\n        template = I.MWUI.templates.boxTransparent,\n        events = {\n            -- mousePress = async:callback(clickMe),\n            -- mouseRelease = async:callback(clickMeStop),\n            -- mouseMove = async:callback(clickMeMove)\n        },\n        props = {\n            -- relativePosition = v2(0.65, 0.8),\n            anchor = util.vector2(0.5, 0.5),\n            size = v2(1, 1),\n            relativePosition = v2(iw.posX, iw.posY),\n            arrange = ui.ALIGNMENT.Center,\n            align = ui.ALIGNMENT.Center,\n            autoSize = false,\n            vertical = true,\n            name = name,\n        },\n        content = ui.content(table_contents)\n    }\nend\nlocal function renderItemGrid(iw)\n    local posX = iw.posX\n    local posY = iw.posY\n    local itemList = iw:filterItems(iw.inventory:getAll(), nil, iw.parentObject)\n    local vertical = 80\n    local myData = nil\n    local name = \"ItemGrid\"\n\n    local counter = 0\n    local contents = {}\n\n    for x = 1, iw.rowCountX do\n        local content = {} -- Create a new table for each value of x\n        for y = 1, iw.rowCountY do\n            local index = (x - 1) * iw.rowCountY + y + iw.scrollOffset\n\n            --print(tostring(getScrollOffset(isPlayer)))\n            --print(index)\n            if index <= #itemList then\n                local item = itemList[index]\n                -- if (item.recordId == itemCheck) then\n                --     core.sendGlobalEvent(\"clearContainerCheck\", item)\n                ----    item = nil\n                ---end\n                local itemLayout = nil\n                if iw.selectedPosX == x and iw.selectedPosY == y and iw.selected then\n                    iw.selectedInvItem = item\n                    itemLayout = renderGridIcon(item, true)\n                else\n                    itemLayout = renderGridIcon(item, false)\n                end\n\n                if itemIsEquipped(item, iw.parentObject) then\n                    itemLayout.template = I.MWUI.templates.box\n                    print(\"equipped\")\n                else\n                    itemLayout.template = I.MWUI.templates.padding\n                end\n                table.insert(content, itemLayout)\n            else\n                if iw.selectedPosX == x and iw.selectedPosY == y and iw.selected then\n                    iw.selectedInvItem = nil\n                    local itemLayout = renderGridIcon(nil, true)\n                    itemLayout.template = I.MWUI.templates.padding\n                    table.insert(content, itemLayout)\n                else\n                    local itemLayout = renderGridIcon(nil, false)\n                    itemLayout.template = I.MWUI.templates.padding\n                    table.insert(content, itemLayout)\n                end\n            end\n        end\n        table.insert(contents, content)\n    end\n\n    for _, item in ipairs(itemList) do\n        counter = counter + 1\n    end\n    local table_contents = {} -- Table to hold the generated items\n\n    for index, contentx in ipairs(contents) do\n        local item = {\n            type = ui.TYPE.Flex,\n            content = ui.content(contentx),\n            props = {\n                size = util.vector2(iconsize, iconsize),\n                position = v2(50 * (index - 1), 0.8),\n                vertical = false,\n                arrange = ui.ALIGNMENT.Center,\n            },\n            external = {\n                grow = iconsize + 15\n            }\n        }\n        table.insert(table_contents, item)\n    end\n    return ui.create {\n        layer = \"Windows\",\n        template = I.MWUI.templates.boxTransparent,\n        events = {\n            -- mousePress = async:callback(clickMe),\n            -- mouseRelease = async:callback(clickMeStop),\n            -- mouseMove = async:callback(clickMeMove)\n        },\n        props = {\n            -- relativePosition = v2(0.65, 0.8),\n            anchor = util.vector2(0.5, 0.5),\n            size = v2(iconsizegrow * iw.rowCountX, iconsizegrow * iw.rowCountY),\n            relativePosition = v2(iw.posX, iw.posY),\n            arrange = ui.ALIGNMENT.Center,\n            align = ui.ALIGNMENT.Center,\n            name = name,\n        },\n        content = ui.content(table_contents)\n    }\nend\nlocal function getInventory(object)\n    --Quick way to get the inventory of an object, regardless of type\n    if (object.type == types.NPC or object.type == types.Creature or object.type == types.Player) then\n        return types.Actor.inventory(object)\n    elseif (object.type == types.Container) then\n        return types.Container.content(object)\n    end\n    return nil --Not any of the above types, so no inv\nend\nlocal function createParentUi(content, horizontal, vertical, name, isHorizontal, iw)\n    if (isHorizontal == nil) then\n        isHorizontal = false\n    end\n    local ret = {\n        layer = \"Windows\",\n        template = I.MWUI.templates.boxTransparent,\n        --    type = ui.TYPE.Flex,\n        events = {\n            --    mousePress = async:callback(clickMe),\n            --   mouseRelease = async:callback(clickMeStop),\n            --     mouseMove = async:callback(clickMeMove)\n        },\n        props = {\n            -- relativePosition = v2(0.65, 0.8),\n            anchor = v2(0.5, 0.5),\n            relativePosition = v2(0.5, iw.posY + vertical),\n            -- position = v2(horizontal, vertical),\n            vertical = not isHorizontal,\n            arrange = ui.ALIGNMENT.Center,\n            align = ui.ALIGNMENT.Center,\n            name = name\n        },\n        content = ui.content {\n            {\n                type = ui.TYPE.Flex,\n                content = ui.content(content),\n                props = {\n                    size = v2(iconsizegrow * iw.rowCountX, 40),\n                    horizontal = isHorizontal,\n                    align = ui.ALIGNMENT.Center,\n                    arrange = ui.ALIGNMENT.Center\n                }\n            }\n        }\n    }\n    local myData = nil\n    --  if (invMode) then\n    --     myData = locDataInvMode[name]\n    --  else\n    --      myData = locData[name]\n    --  end\n\n\n    if (myData ~= nil) then\n        ret.props = {\n            -- relativePosition = v2(0.65, 0.8),\n            position = v2(myData.xpos, myData.ypos),\n            vertical = not isHorizontal,\n            arrange = ui.ALIGNMENT.Center,\n            align = ui.ALIGNMENT.Center,\n            name = name\n        }\n    end\n    return ui.create(ret)\nend\nlocal function renderCatWindow(iw)\n    local topContent = {}\n\n\n\n    local horizontal = 600\n    local vertical = 100\n\n    for index, cat in ipairs(iw.catTypes) do\n        table.insert(topContent,\n            I.ZackUtilsUI_ci.boxedTextContent(cat, iw.catTypes[I.ControllerInterface.getCurrentCat()]))\n    end\n    return createParentUi(topContent, horizontal, -0.25, \"CatChooser\", true, iw)\nend\n\nlocal function renderInfoWindow(iw)\n    local topContent = {}\n\n\n\n    local horizontal = 600\n    local vertical = 100\n\n    if (iw.selectedInvItem == nil) then\n        return\n    end\n    if (iw.windowType == windowType.inventory) then\n        local record = iw.selectedInvItem.type.record(iw.selectedInvItem)\n\n        table.insert(topContent,\n            I.ZackUtilsUI_ci.boxedTextContent(padString(record.name, 15), nil))\n        table.insert(topContent,\n            I.ZackUtilsUI_ci.boxedTextContent(padString(\"Value: \" .. tostring(record.value), 15), nil))\n    elseif iw.windowType == windowType.magic then\n\n    end\n    return createParentUi(topContent, horizontal, 0.25, \"CatChooser\", true, iw)\nend\nlocal function createItemWindow(list, posX, posY, keyBindingsx, context)\n    keyBindings = keyBindingsx\n    local itemWindow = {}\n    itemWindow.parentObject = nil\n    itemWindow.selected = true\n    itemWindow.inventory = nil\n    itemWindow.ui = nil\n    itemWindow.headerUi = nil\n    itemWindow.infoUi = nil\n    itemWindow.list = list\n    itemWindow.windowType = 0\n    itemWindow.context = \"normal\"\n    if context then\n        itemWindow.context = context\n    end\n    itemWindow.listMode = true\n    itemWindow.posX = posX\n    itemWindow.posY = posY\n    itemWindow.rowCountX = 10\n    itemWindow.rowCountY = 25\n    itemWindow.editMode = false\n    itemWindow.drawLine = false\n    itemWindow.selectedText = list[1]\n    itemWindow.selectedPosX = 1\n    itemWindow.filterItems = filterItems\n    itemWindow.selectedPosY = 1\n    itemWindow.scrollOffset = 0\n    itemWindow.drawWindow = function(iw)\n        if (iw.listMode) then\n            iw.ui = renderItemList(iw)\n        else\n            iw.ui = renderItemGrid(iw)\n        end\n\n        -- iw.headerUi = renderCatWindow(iw)\n        --  iw.infoUi = renderInfoWindow(iw)\n    end\n    itemWindow.fixCursorPos = function(iw)\n        local currentItem = iw:getItemAt(iw.selectedPosX, iw.selectedPosY)\n        if (currentItem ~= nil) then\n            return\n        end\n        local itemList = iw:filterItems(iw.inventory:getAll(), nil, iw.parentObject)\n        if (#itemList == 0) then\n            return\n        end\n\n        local index = (iw.selectedPosX - 1) * iw.rowCountY + iw.selectedPosY + iw.scrollOffset\n        local lastItem = nil\n        if (index > #itemList) then\n            iw.selectedPosX = 1\n            iw.selectedPosY = 1\n        end\n    end\n    itemWindow.setGridSize = function(iw, x, y)\n        iw.rowCountX = x\n        iw.rowCountY = y\n        iw:reDraw()\n    end\n\n    itemWindow.reDraw = function(iw)\n        iw.ui:destroy()\n        if (iw.headerUi) then\n            iw.headerUi:destroy()\n        end\n        if (iw.infoUi) then\n            iw.infoUi:destroy()\n        end\n        if (iw.listMode) then\n            iw.ui = renderItemList(iw)\n        else\n            iw.ui = renderItemGrid(iw)\n        end\n        if (iw.selected) then\n        end\n    end\n    itemWindow.getItemAt = function(iw, x, y)\n        local itemList = iw.list\n        if (iw.listMode) then\n            local index = (x) + iw.scrollOffset\n            if index <= #itemList then\n                local item = itemList[index]\n                if not item then\n                    print(\"Item is nil\")\n                end\n                return item\n            end\n            return nil\n        end\n        local index = (x - 1) * iw.rowCountY + y + iw.scrollOffset\n        if index <= #itemList then\n            local item = itemList[index]\n\n            return item\n        end\n        return nil\n    end\n    itemWindow.setSelectedItem = function(iw, item)\n        local itemList = iw:filterItems(iw.inventory:getAll(), nil, iw.parentObject)\n        local index = (x - 1) * iw.rowCountY + y + iw.scrollOffset\n        if index <= #itemList then\n            local item = itemList[index]\n\n            return item\n        end\n        return nil\n    end\n    itemWindow.updateSelection = function(iw, x, y)\n        --validate the specified position is valid, return if it is or not\n    end\n    itemWindow.setSelected = function(iw, select)\n        iw.selected = select\n    end\n    itemWindow.destroy = function(iw)\n        if iw.ui then\n            iw.ui:destroy()\n            iw.ui = nil\n        end\n        if (iw.headerUi) then\n            iw.headerUi:destroy()\n        end\n        if (iw.infoUi) then\n            iw.infoUi:destroy()\n        end\n    end\n    itemWindow:drawWindow()\n    return itemWindow\nend\nreturn {\n    interfaceName = \"LMM_Window\",\n    interface = {\n        version = 1,\n        createItemWindow = createItemWindow,\n\n    },\n    eventHandlers = {\n        sendMessage = sendMessage,\n        returnActivators = returnActivators,\n        ClickedContainer = ClickedContainer,\n        upDateinvWins = upDateinvWins,\n        ClickedActor = ClickedActor,\n    },\n    engineHandlers = {\n        onConsoleCommand = onConsoleCommand,\n        onFrame = onFrame,\n        onActive = onActive,\n        onControllerButtonPress = onControllerButtonPress,\n        onInputAction = onInputAction,\n        onSave = onSave,\n        onKeyPress = onKeyPress,\n        onLoad = onLoad,\n        onControllerButtonRelease = onControllerButtonRelease,\n    }\n}\n",
    "Zack's Lua Multimark-53260-1-5-1-1723427382\\scripts\\LuaMultiMark\\zu_ui.lua": "local ui = require(\"openmw.ui\")\nlocal I = require(\"openmw.interfaces\")\n\nlocal v2 = require(\"openmw.util\").vector2\nlocal util = require(\"openmw.util\")\nlocal cam = require(\"openmw.interfaces\").Camera\nlocal core = require(\"openmw.core\")\nlocal self = require(\"openmw.self\")\nlocal nearby = require(\"openmw.nearby\")\nlocal types = require(\"openmw.types\")\nlocal Camera = require(\"openmw.camera\")\nlocal input = require(\"openmw.input\")\nlocal storage = require(\"openmw.storage\")\nlocal ui = require(\"openmw.ui\")\nlocal async = require(\"openmw.async\")\nlocal I = require(\"openmw.interfaces\")\n\nlocal v2 = require(\"openmw.util\").vector2\nlocal util = require(\"openmw.util\")\nlocal cam = require(\"openmw.interfaces\").Camera\nlocal core = require(\"openmw.core\")\nlocal self = require(\"openmw.self\")\nlocal nearby = require(\"openmw.nearby\")\nlocal types = require(\"openmw.types\")\nlocal Camera = require(\"openmw.camera\")\nlocal input = require(\"openmw.input\")\nlocal storage = require(\"openmw.storage\")\nlocal acti = require(\"openmw.interfaces\").Activation\n\nlocal function lerp(x, x1, x2, y1, y2)\n    return y1 + (x - x1) * ((y2 - y1) / (x2 - x1))\nend\nlocal function calculateTextScale()\n    local screenSize = ui.screenSize()\n    local width = screenSize.x\n    local scale = lerp(width, 1280, 2560, 1.3, 1.8)\n    return scale\nend\nlocal function renderItemBold(item, bold)\n    return {\n        type = ui.TYPE.Container,\n        props = {\n            --  anchor = util.vector2(-1,0),\n            align = ui.ALIGNMENT.Center,\n            relativePosition = util.vector2(1, 0.5),\n            arrange = ui.ALIGNMENT.Center,\n        },\n        content = ui.content {\n            {\n                template = I.MWUI.templates.padding,\n                alignment = ui.ALIGNMENT.Center,\n                content = ui.content {\n                    {\n                        type = ui.TYPE.Text,\n                        template = I.MWUI.templates.textHeader,\n                        props = {\n                            text = item,\n                            textSize = 10 * calculateTextScale(),\n                            relativePosition = v2(0.5, 0.5),\n                            arrange = ui.ALIGNMENT.Center,\n                            align = ui.ALIGNMENT.Center,\n                        }\n                    }\n                }\n            }\n        }\n    }\nend\n\nlocal function renderItem(item, bold)\n    return {\n        type = ui.TYPE.Container,\n        content = ui.content {\n            {\n                template = I.MWUI.templates.padding,\n                alignment = ui.ALIGNMENT.Center,\n                content = ui.content {\n                    {\n                        type = ui.TYPE.Text,\n                        template = I.MWUI.templates.textNormal,\n                        props = {\n                            text = item,\n                            textSize = 10 * calculateTextScale(),\n                            arrange = ui.ALIGNMENT.Center\n                        }\n                    }\n                }\n            }\n        }\n    }\nend\nlocal function renderItemChoice(itemList, horizontal, vertical, align, anchor)\n    local content = {}\n    for _, item in ipairs(itemList) do\n        local itemLayout = renderItem(item)\n        itemLayout.template = I.MWUI.templates.padding\n        table.insert(content, itemLayout)\n    end\n    return ui.create {\n        layer = \"HUD\",\n        template = I.MWUI.templates.boxTransparent,\n        props = {\n            -- relativePosition = v2(0.65, 0.8),\n            anchor = anchor,\n            relativePosition = v2(horizontal, vertical),\n            arrange = align,\n            align = align,\n        },\n        content = ui.content {\n            {\n                type = ui.TYPE.Flex,\n                content = ui.content(content),\n                props = {\n                    vertical = true,\n                    arrange = align,\n                    align = align,\n                }\n            }\n        }\n    }\nend\n\n\nreturn {renderItemChoice = renderItemChoice,renderItemBold = renderItemBold}"
  }
}