{
  "folder_name": "CO.RE - Comprehensive Rebalance",
  "lua_files": {
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\combat_attack_types.lua": "-- implement once a proper combat UI becomes available.\n-- TODO: Make each of the attack types unique, slash vs light armour, thrust vs heavy etc",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\disable_backwards_running.lua": "local self = require('openmw.self')\n--local ui = require('openmw.ui')\nlocal settings = require(\"scripts.comprehensive_rebalance.lib.settings\")\n\nlocal function runHandler()\n    local section = settings.GetSection(\"misc\")\n\tif self.controls.run == true and section:get(\"noBackwardsRunning\") and self.controls.movement < 0 then\n\t\tself.controls.run = false  -- prevent running\n\t\t--ui.showMessage(\"why are u running?\")\n\tend\nend\n\nreturn\n{\n\tengineHandlers =\n\t{\n\t\tonFrame = runHandler\n\t}\n}\n",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\rebalance_attribute_levelup.lua": "local ui = require('openmw.ui')\nlocal storage = require('openmw.storage')\n\nlocal MOD_NAME = \"comprehensive_rebalance\"\nlocal playerSettings = storage.globalSection(\"SettingsGlobal\" .. MOD_NAME .. \"char\")\n\nlocal function SetRealtimeMenus(data)\n\tif data.newMode == 'LevelUp' then\n\t\t--ui.showMessage('Opened LevelUp')\n\tend\nend\n\nreturn {\n    eventHandlers = {\n\t\tUiModeChanged = SetRealtimeMenus\n\t}\n}",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\rebalance_enchant.lua": "-- Coming soon\n-- As soon as changing GMST stuff is implemented",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\rebalance_health_formula.lua": "-- will be done once Skill Editing is available\n\nlocal ui = require('openmw.ui')\nlocal core = require(\"openmw.core\")\nlocal Player = require('openmw.types').Player\nlocal NPC = require('openmw.types').NPC\nlocal self = require('openmw.self')\nlocal settings = require(\"scripts.comprehensive_rebalance.lib.settings\")\nlocal section = settings.GetSection(\"char\")\n\n-- Vanilla Health Formula is\n-- ((lvl 1 Strength + lvl 1 Endurance) / 2) + 10% of END per level, calculated per level\n-- We want to make it\n-- ((lvl 1 Strength + lvl 1 Endurance) / 2) + (END / 10 * level - 1)\n\n\nlocal current_base = 0\n\nlocal function onSave()\n    return {\n        current_max = current_max\n    }\nend\n\nlocal function onLoad(savedData, initData)\n    current_max = savedData.current_max\nend\n\nlocal function GetClassAttributeBonus(attribute)\n\tlocal class = NPC.classes.record(NPC.record(self).class)\n\t\n    for _, attr in ipairs(class.attributes) do\n        if attr == attribute then\n            print (attr)\n            return 10\n        end\n    end\n\n    return 0\n\nend\n\n--These are filthy dirty hacks until we get proper support for Race and Class records\nlocal function GetLevel1Strength()\n\n\tlocal race = NPC.record(self).race\n\tlocal isMale = NPC.record(self).isMale\n\n\tlocal total = 40\n\n\t-- race\n\tif race == 'breton' and not isMale then\n\t\ttotal = 30\n\telseif race == 'high elf' then\n\t\ttotal = 30\n\telseif race == 'khajiit' and not isMale then\n\t\ttotal = 30\n\telseif race == 'nord' then\n\t\ttotal = 50\n\telseif race == 'orc' then\n\t\ttotal = 45\n\telseif race == 'redguard' and isMale then\n\t\ttotal = 50\n\telseif race == 'wood elf' then\n\t\ttotal = 30\n\tend\n    \n    --add class bonus\n    total = total + GetClassAttributeBonus('strength')\n\treturn total\n\nend\n\n--These are filthy dirty hacks until we get proper support for Race and Class records\nlocal function GetLevel1Endurance()\n\t\n\tlocal race = NPC.record(self).race\n\tlocal isMale = NPC.record(self).isMale\n\n\tlocal total = 40\n\n\tif race == 'argonian' or race == 'breton' or race == 'wood elf' then\n\t\ttotal = 30\n\telseif race == 'dark elf' and not isMale then\n\t\ttotal = 30\n\telseif race == 'high elf' and not isMale then\n\t\ttotal = 30\n\telseif race == 'khajiit' and not isMale then\n\t\ttotal = 30\n\telseif race == 'nord' and isMale then\n\t\ttotal = 50\n\telseif race == 'orc' or race == 'redguard' then\n\t\ttotal = 50\n\tend\n\n    --add class bonus\n    total = total + GetClassAttributeBonus('endurance')\n    return total\n\nend\n\nlocal function RecalculateHealth()\n\n\tlocal baseEND = Player.stats.attributes[\"endurance\"](self).base\n\tlocal baseSTR = Player.stats.attributes[\"strength\"](self).base\n\tlocal currentLevel = Player.stats.level(self).current\n\tlocal scale = section:get(\"newHealthFormulaScale\")\n\t\t\n\t--calculate level 1 health value\n\tlocal lvl1STR = GetLevel1Strength()\n\tlocal lvl1END = GetLevel1Endurance()\n\tlocal lvl1Health = (lvl1STR + lvl1END) * 0.5\n\t\n\tlocal totalEnd = 0\n\t\n\t--ui.showMessage('lvl1End: ' .. lvl1END)\n\t\n\t--get base health at lvl 1\n\tlocal newBaseHealth = lvl1Health\n\t\n\t--now \"level up\" as if we put the maximum amount into endurance each level up\n\tlocal calcLevel = 2\n\twhile calcLevel <= currentLevel do\n\t\n\t\t--get the amount of endurance we will have this level\n\t\tlocal levelEnd = lvl1END + ((calcLevel - 1) * scale)\n\t\t\n\t\t--clamp it to our max end\n\t\tif (levelEnd > baseEND) then\n\t\t\tlevelEnd = baseEND\n\t\tend\n\t\t\n\t\ttotalEnd = levelEnd\n\t\t\t\t\n\t\t--calculate health for that level and add it to our base health\n\t\t--todo: use GMST fLevelUpHealthEndMult instead of 0.1\n\t\tnewBaseHealth = newBaseHealth + levelEnd * 0.1\n\t\t\n\t\t--ui.showMessage('At level ' .. calcLevel .. ', endurance will be ' .. levelEnd .. ', resulting in ' .. newBaseHealth .. ' health')\n\t\t\n\t\tcalcLevel = calcLevel + 1\n\tend\n\t\n\t--calculate health for any remaining endurance\n\tlocal remaining = baseEND - totalEnd\n\t--ui.showMessage('remaining endurance: ' .. remaining)\n\tif remaining > 0 then\n\t\t--ui.showMessage('Add any extra Endurance (from books etc): ' .. remaining)\n\t\tnewBaseHealth = newBaseHealth + remaining * 0.1\n\tend\n\t\n\treturn newBaseHealth\n\nend\n\nlocal function SetPlayerHealth(value)\n    local actualHealth = Player.stats.dynamic.health(self).base\n    local difference = value - actualHealth\n\n    Player.stats.dynamic.health(self).base = value\n    Player.stats.dynamic.health(self).current = Player.stats.dynamic.health(self).current + difference\n\n    current_max = value\nend\n\nlocal function SetHealthFormula(data)\n\tif data.newMode == \"Interface\" or data.oldMode == \"LevelUp\" then\n\t\tif section:get(\"newHealthFormula\") then\n\t\t\n\t\t\tlocal health = RecalculateHealth()\n            if health ~= current_max then\n                --ui.showMessage('recalc health - new formula. Health is ' .. health)\n                SetPlayerHealth(health)\n            end\n\t\tend\n\tend\nend\n\nreturn {\n    engineHandlers = {\n        onLoad = onLoad,\n        onSave = onSave\n    },\n\n    eventHandlers = {\n\t\tUiModeChanged = SetHealthFormula\n\t}\n}\n",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\settings.lua": "local I = require(\"openmw.interfaces\")\nlocal settings = require(\"scripts.comprehensive_rebalance.lib.settings\")\n\nI.Settings.registerGroup {\n    key = \"SettingsGlobal\" .. settings.MOD_NAME .. \"misc\",\n\tl10n = settings.MOD_NAME,\n    name = \"settings_modCategory5_name\",\n    page = settings.MOD_NAME,\n    description = \"settings_modCategory5_desc\",\n    permanentStorage = true,\n    settings = {\n\t\tsettings.doAddonText(\"noEnchantAutoRecharge\",5,1,\"enchant_no_recharge\"),\n\t\tsettings.doCheckbox(\"noBackwardsRunning\",5,2,true),\n\t\tsettings.doCheckbox(\"noDeathFromAbove\",5,3,true),\n    }\n}\n\nI.Settings.registerGroup {\n    key = \"SettingsGlobal\" .. settings.MOD_NAME .. \"saving\",\n\tl10n = settings.MOD_NAME,\n    name = \"settings_modCategory6_name\",\n    page = settings.MOD_NAME,\n    description = \"settings_modCategory6_desc\",\n    permanentStorage = true,\n    settings = {\n\t\tsettings.doComingSoon(\"noSavingWilderness\",6,1,true),\n\t\tsettings.doComingSoon(\"noSavingInTown\",6,2,true),\n\t\tsettings.doComingSoon(\"freeSaveInterval\",6,3,true),\n    }\n}\n\nI.Settings.registerGroup {\n    key = \"SettingsGlobal\" .. settings.MOD_NAME .. \"rest\",\n\tl10n = settings.MOD_NAME,\n    name = \"settings_modCategory1_name\",\n    page = settings.MOD_NAME,\n    --description = \"settings_modCategory1_desc\",\n    permanentStorage = true,\n    settings = {\n\t\tsettings.doCheckbox(\"noTresspassSleep\",4,1,true),\n\t\t--settings.doCheckbox(\"factionBedCosts\",4,2,true),\n\t\tsettings.doCheckbox(\"noRepeatedSleeping\",4,3,true),\n\t\tsettings.doNumber(\"noRepeatedSleepingTimer\",4,4,20,1,nil),\n\t\tsettings.doSelection(\"disableRestMode\",1,1,{ \"disabled\", \"enabled\", \"show_time\" },\"enabled\"),\n\t\tsettings.doSelection(\"disableWaitMode\",1,2,{ \"disabled\", \"enabled\", \"show_time\" },\"disabled\"),\n    }\n}\n\nI.Settings.registerGroup {\n    key = \"SettingsGlobal\" .. settings.MOD_NAME .. \"menus\",\n\tl10n = settings.MOD_NAME,\n    name = \"settings_modCategory2_name\",\n    page = settings.MOD_NAME,\n    description = \"settings_modCategory2_desc\",\n    permanentStorage = true,\n    settings = {\n\t\tsettings.doCheckbox(\"realtimeInterface\",2,1,true),\n\t\tsettings.doCheckbox(\"realtimeDialogue\",2,2,true),\n\t\tsettings.doCheckbox(\"realtimeContainer\",2,3,true),\n\t\tsettings.doCheckbox(\"realtimeReading\",2,4,true),\n\t\tsettings.doCheckbox(\"realtimeJournal\",2,5,true),\n\t\tsettings.doCheckbox(\"realtimeInteractions\",2,6,true),\n\t\tsettings.doCheckbox(\"realtimeQuickKeysMenu\",2,7,false),\n\t\tsettings.doCheckbox(\"realtimeMisc\",2,8,false),\n    }\n}\n\nI.Settings.registerGroup {\n    key = \"SettingsGlobal\" .. settings.MOD_NAME .. \"char\",\n\tl10n = settings.MOD_NAME,\n    name = \"settings_modCategory3_name\",\n    page = settings.MOD_NAME,\n    description = \"settings_modCategory3_desc\",\n    permanentStorage = true,\n    settings = {\n\t\tsettings.doCheckbox(\"newHealthFormula\",3,1,true),\n\t\tsettings.doNumber(\"newHealthFormulaScale\",3,2,3),\n\t\tsettings.doComingSoon(\"skillDegredation\",3,3,true),\n\t\tsettings.doAddonText(\"trainersOnly\",3,4,\"no_skill_levelling\"),\n\t\t--settings.doCheckbox(\"noTrainers\",3,7,false),\n\t\tsettings.doComingSoon(\"standardisedAttributes\",3,5,true),\n\t\t--settings.doNumber(\"standardisedAttributesValue\",3,6,2),\n\t\tsettings.doAddonText(\"fatigueChanges\",3,8,\"fatigue_changes\"),\n\t\tsettings.doSelection(\"convenientFatigueSetting\",3,9,{\"disabled\", \"slow\", \"fast\"}, \"slow\"),\n\t\tsettings.doNumber(\"convenientFatigueDelay\",3,10,4,0,nil),\n\t}\n}\n\nI.Settings.registerGroup {\n    key = \"SettingsGlobal\" .. settings.MOD_NAME .. \"armour\",\n\tl10n = settings.MOD_NAME,\n    name = \"settings_modCategory7_name\",\n    page = settings.MOD_NAME,\n    description = \"settings_modCategory7_desc\",\n    permanentStorage = true,\n    settings = {\n\t\t--settings.doCheckbox(\"mediumArmorBuff\",7,6,true),\n\t\tsettings.doAddonText(\"mediumArmorBuff\",7,6,\"med_armour_buff\"),\n\t\tsettings.doAddonText(\"mediumArmorBuffLeFemme\",7,7,\"med_armour_lefemme\"),\n\t\tsettings.doAddonText(\"mediumArmorBuffEBQ\",7,8,\"med_armour_EBQ\"),\n\t\tsettings.doSelection(\"bulkyShieldsMode\",7,1,{\"disabled\",\"penalty\",\"bonus\",\"both\"},\"penalty\"),\n\t\tsettings.doCheckbox(\"bulkyArmour\",7,2,true),\n\t\tsettings.doNumber(\"bulkyArmourMult\",7,3,3,1,5),\n\t\tsettings.doCheckbox(\"implacableArmour\",7,4,false),\n\t}\n}\n\nI.Settings.registerGroup {\n    key = \"SettingsGlobal\" .. settings.MOD_NAME .. \"economy\",\n\tl10n = settings.MOD_NAME,\n    name = \"settings_modCategory8_name\",\n    page = settings.MOD_NAME,\n    description = \"settings_modCategory8_desc\",\n    permanentStorage = true,\n    settings = {\n\t\tsettings.doAddonText(\"higherTravelPrices\",8,1,\"higher_travel_prices\"),\n\t\t--settings.doAddonText(\"crimeDoesntPay\",8,2,\"crime_doesnt_pay\"),\n\t\t--settings.doAddonText(\"moreExpensiveEconomy\",8,3,\"more_expensive_economy\"),\n\t\tsettings.doAddonText(\"creatureNPCBalance\",8,4,\"creeper_mudcrab_balance\"),\n\t\tsettings.doAddonText(\"merchantsGoldLimit\",8,5,\"merchants_gold_limit\"),\n\t}\n}\n",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\settings_p.lua": "local I = require(\"openmw.interfaces\")\nlocal core = require(\"openmw.core\")\n\nlocal MOD_NAME = \"comprehensive_rebalance\"\n\nI.Settings.registerPage {\n    key = MOD_NAME,\n    l10n = MOD_NAME,\n    name = \"settings_modName\",\n    description = \"settings_modDesc\"\n}",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\armour_penalties\\player.lua": "local core = require('openmw.core')\nlocal types = require('openmw.types')\nlocal self = require('openmw.self')\nlocal ui = require('openmw.ui');\nlocal settings = require(\"scripts.comprehensive_rebalance.lib.settings\")\nlocal spells = require(\"scripts.comprehensive_rebalance.lib.spells\")\n\nlocal Actor = types.Actor\nlocal Armor = types.Armor\nlocal Weapon = types.Weapon\n\n--this sucks. There's no good way to get armor type\nlocal function getArmourType(armour)\n    if not armour or not Armor.objectIsInstance(armour) then\n        return 0\n    end\n\n    local r = Armor.record(armour)\n\n    --Account for armours that provide no AR\n    --This allows for other mods to add things like hats,\n    --Which use the head/helmet slot\n    --They will not count towards bulky or implacable armour\n    if (r.baseArmor == 0) then\n        return 0;\n    end\n\n    if (r.type == Armor.TYPE.Cuirass) then\n        if r.weight > 27 then\n            return 3\n        elseif r.weight > 18 then\n            return 2\n        end\n    elseif (r.type == Armor.TYPE.LGauntlet or r.type == Armor.TYPE.RGauntlet or r.type == Armor.TYPE.Helmet or r.type == Armor.TYPE.LBracer or r.type == Armor.TYPE.RBracer) then\n        if r.weight > 4.5 then\n            return 3\n        elseif r.weight > 3 then\n            return 2\n        end\n    elseif (r.type == Armor.TYPE.LPauldron or r.type == Armor.TYPE.RPauldron) then\n        if r.weight > 9 then\n            return 3\n        elseif r.weight > 6 then\n            return 2\n        end\n    elseif (r.type == Armor.TYPE.Greaves or r.type == Armor.TYPE.Shield) then\n        if r.weight > 13.5 then\n            return 3\n        elseif r.weight > 9 then\n            return 2\n        end\n    elseif (r.type == Armor.TYPE.Boots) then\n        if r.weight > 18 then\n            return 3\n        elseif r.weight > 12 then\n            return 2\n        end\n    end\n\n    return 1\nend\n\nlocal previousValue = 0\nlocal previousImplac = 0\n\nlocal function onSave(initData)\n    return {\n        pV = previousValue,\n        pI = previousImplac,\n    }\nend\n\nlocal function onLoad(data)\n    previousValue = data.pV\n    previousImplac = data.pI\nend\n\n\n--This is horribly inefficient, but\n--ItemUsage.addHandlerForType(type, handler)\n--https://openmw.readthedocs.io/en/latest/reference/lua-scripting/interface_item_usage.html\n--is not really usable currently, as\n--it only sends inventory events (no hotkeys, AI equip etc),\n--and doesn't send any unequip events\nlocal function equipHandler()\n    \n    local section = settings.GetSection(\"armour\")\n\t\n    local slots = Actor.getEquipment(self)\n\tlocal shield_slot = slots[Actor.EQUIPMENT_SLOT.CarriedLeft]\n\tlocal weapon = slots[Actor.EQUIPMENT_SLOT.CarriedRight]\n\n    local shield = nil\n    if shield_slot and Armor.objectIsInstance(shield_slot) then\n        shield = shield_slot\n    end\n\n    local boots = slots[Actor.EQUIPMENT_SLOT.Boots]\n    local cuirass = slots[Actor.EQUIPMENT_SLOT.Cuirass]\n    local greaves = slots[Actor.EQUIPMENT_SLOT.Greaves]\n    local helmet = slots[Actor.EQUIPMENT_SLOT.Helmet]\n    local leftGauntlet = slots[Actor.EQUIPMENT_SLOT.LeftGauntlet]\n    local leftPauldron = slots[Actor.EQUIPMENT_SLOT.LeftPauldron]\n    local rightGauntlet = slots[Actor.EQUIPMENT_SLOT.RightGauntlet]\n    local rightPauldron = slots[Actor.EQUIPMENT_SLOT.RightPauldron]\n\n    --ui.showMessage(\"boots type \" .. type)\n\n    local bulkyShield = section:get(\"bulkyShieldsMode\")\n    local penalty = bulkyShield == \"penalty\" or bulkyShield == \"both\"\n    local bonus = bulkyShield == \"bonus\" or bulkyShield == \"both\"\n\n    spells.addOrRemoveSpell('shield bulk',shield and penalty)\n    spells.addOrRemoveSpell('shield empty reward',not shield and bonus)\n\n    local t_b = getArmourType(boots)\n    local t_c = getArmourType(cuirass)\n    local t_g = getArmourType(greaves)\n    local t_h = getArmourType(helmet)\n    local t_lg = getArmourType(leftGauntlet)\n    local t_rg = getArmourType(rightGauntlet)\n    local t_lp = getArmourType(leftPauldron)\n    local t_rp = getArmourType(rightPauldron)\n    local t_s = getArmourType(shield)\n\n    local implacable = section:get(\"implacableArmour\") \n    local bulky = section:get(\"bulkyArmour\") \n    local mult = section:get(\"bulkyArmourMult\") \n\n    local value = 0\n\n    if (bulky) then\n        value = value + t_b * mult\n        value = value + t_c * mult\n        value = value + t_g * mult\n        value = value + t_h * mult\n        value = value + t_lg * mult\n        value = value + t_rg * mult\n        value = value + t_lp * mult\n        value = value + t_rp * mult\n        value = value + t_s * mult\n    end\n\n    --print(\"value is \" .. tostring(value))\n\n    if previousValue ~= value then\n        if previousValue > 0 then\n            spells.addOrRemoveSpell('armor magic penalty ' .. tostring(previousValue),false)\n        end\n        previousValue = value\n        if value > 0 then\n            spells.addOrRemoveSpell('armor magic penalty ' .. tostring(value),true)\n        end\n    end\n\n    --stop awful magic sound\n    if previousValue ~= 0 then\n        core.sound.stopSound3d(\"magic sound\", self)\n    end\n    \n    --do implacable\n    local i = 0\n    if implacable then\n        if t_b == 3 then\n            i = i + 1\n        end\n        if t_c == 3 then\n            i = i + 2\n        end\n        if t_g == 3 then\n            i = i + 1\n        end\n        if t_h == 3 then\n            i = i + 1\n        end\n        if t_lg == 3 then\n            i = i + 1\n        end\n        if t_rg == 3 then\n            i = i + 1\n        end\n        if t_lp == 3 then\n            i = i + 1\n        end\n        if t_rp == 3 then\n            i = i + 1\n        end\n        if t_s == 3 then\n            i = i + 1\n        end\n    end\n\n    if previousImplac ~= i then\n        if previousImplac > 0 then\n            spells.addOrRemoveSpell('armor slow ' .. tostring(previousImplac),false)\n        end\n        previousImplac = i\n        if i > 0 then\n            spells.addOrRemoveSpell('armor slow ' .. tostring(i),true)\n        end\n    end\n\n\t--[[\n    spells.addOrRemoveSpell('armor absorption BL',allow and t_boots == 'light')\n    spells.addOrRemoveSpell('armor absorption BM',allow and t_boots == 'medium')\n    spells.addOrRemoveSpell('armor absorption BH',allow and t_boots == 'heavy')\n    spells.addOrRemoveSpell('armor absorption CL',allow and t_cuirass == 'light')\n    spells.addOrRemoveSpell('armor absorption CM',allow and t_cuirass == 'medium')\n    spells.addOrRemoveSpell('armor absorption CH',allow and t_cuirass == 'heavy')\n    spells.addOrRemoveSpell('armor absorption GL',allow and t_greaves == 'light')\n    spells.addOrRemoveSpell('armor absorption GM',allow and t_greaves == 'medium')\n    spells.addOrRemoveSpell('armor absorption GH',allow and t_greaves == 'heavy')\n    spells.addOrRemoveSpell('armor absorption HL',allow and t_helmet == 'light')\n    spells.addOrRemoveSpell('armor absorption HM',allow and t_helmet == 'medium')\n    spells.addOrRemoveSpell('armor absorption HH',allow and t_helmet == 'heavy')\n    spells.addOrRemoveSpell('armor absorption SL',allow and t_s == 'light')\n    spells.addOrRemoveSpell('armor absorption SM',allow and t_s == 'medium')\n    spells.addOrRemoveSpell('armor absorption SH',allow and t_s == 'heavy')\n\n    --gauntlets\n    spells.addOrRemoveSpell('armor absorption GLL',allow and t_lg == 'light')\n    spells.addOrRemoveSpell('armor absorption GLM',allow and t_lg == 'medium')\n    spells.addOrRemoveSpell('armor absorption GLH',allow and t_lg == 'heavy')\n    spells.addOrRemoveSpell('armor absorption GRL',allow and t_rg == 'light')\n    spells.addOrRemoveSpell('armor absorption GRM',allow and t_rg == 'medium')\n    spells.addOrRemoveSpell('armor absorption GRH',allow and t_rg == 'heavy')\n    \n    --pauldrons\n    spells.addOrRemoveSpell('armor absorption PLL',allow and t_lp == 'light')\n    spells.addOrRemoveSpell('armor absorption PLM',allow and t_lp == 'medium')\n    spells.addOrRemoveSpell('armor absorption PLH',allow and t_lp == 'heavy')\n    spells.addOrRemoveSpell('armor absorption PRL',allow and t_rp == 'light')\n    spells.addOrRemoveSpell('armor absorption PRM',allow and t_rp == 'medium')\n    spells.addOrRemoveSpell('armor absorption PRH',allow and t_rp == 'heavy')\n\n    --IMPLACABLE\n    local implacable = section:get(\"implacableArmour\") \n    spells.addOrRemoveSpell('armor slow BH',implacable and t_boots == 'heavy')\n    spells.addOrRemoveSpell('armor slow CH',implacable and t_cuirass == 'heavy')\n    spells.addOrRemoveSpell('armor slow GH',implacable and t_greaves == 'heavy')\n    spells.addOrRemoveSpell('armor slow HH',implacable and t_helmet == 'heavy')\n    spells.addOrRemoveSpell('armor slow LGH',implacable and t_lg == 'heavy')\n    spells.addOrRemoveSpell('armor slow LPH',implacable and t_lp == 'heavy')\n    spells.addOrRemoveSpell('armor slow RGH',implacable and t_rg == 'heavy')\n    spells.addOrRemoveSpell('armor slow RPH',implacable and t_rp == 'heavy')\n    spells.addOrRemoveSpell('armor slow SH',implacable and t_s == 'heavy')\n    ]]--\n\n\t--[[\n\tlocal spell = Actor.spells(self)['armor slow SH']\n\tprint('SPELL: '..spell.name)\n\tfor _, effect in pairs(spell.effects) do\n\t\tprint('  -> effects['..tostring(effect)..']:')\n\t\tprint('       id: '..tostring(effect.id))\n\t\tprint('       name: '..tostring(effect.name))\n\t\tprint('       affectedSkill: '..tostring(effect.affectedSkill))\n\t\tprint('       affectedAttribute: '..tostring(effect.affectedAttribute))\n\t\tprint('       magnitudeThisFrame: '..tostring(effect.magnitudeThisFrame))\n\t\tprint('       minMagnitude: '..tostring(effect.minMagnitude))\n\t\tprint('       maxMagnitude: '..tostring(effect.maxMagnitude))\n\t\tprint('       duration: '..tostring(effect.duration))\n\t\tprint('       durationLeft: '..tostring(effect.durationLeft))\n\tend\n\t]]--\n\t\n\t--[[\n\tlocal spell = Actor.spells(self)['armor slow SH']\n\tif (spell) then\n\t\tfor _, effect in pairs(spell.effects) do\n\t\t\tprint('       minMagnitude: '..tostring(effect.magnitudeMin))\n\t\t\tprint('       maxMagnitude: '..tostring(effect.magnitudeMax))\n\t\t\teffect.magnitudeMax = 99\n\t\t\teffect.magnitudeMin = 99\n\t\tend\n\tend\n\t]]--\n\n\t--[[\n    --Actor.activeEffects(self):set(10, \"sound\")\n\tfor id, params in pairs(Actor.activeSpells(self)) do\n\t\tprint('active spell '..tostring(params.id)..':')\n\t\tif (tostring(params.id) == 'armor slow sh') then\n\t\t\tfor _, effect in pairs(params.effects) do\n\t\t\t\teffect.magnitudeThisFrame = 20;\n\t\t\t\tprint('  -> effects['..tostring(effect)..']:')\n\t\t\t\tprint('       id: '..tostring(effect.id))\n\t\t\t\tprint('       name: '..tostring(effect.name))\n\t\t\t\tprint('       affectedSkill: '..tostring(effect.affectedSkill))\n\t\t\t\tprint('       affectedAttribute: '..tostring(effect.affectedAttribute))\n\t\t\t\tprint('       magnitudeThisFrame: '..tostring(effect.magnitudeThisFrame))\n\t\t\t\tprint('       minMagnitude: '..tostring(effect.minMagnitude))\n\t\t\t\tprint('       maxMagnitude: '..tostring(effect.maxMagnitude))\n\t\t\t\tprint('       duration: '..tostring(effect.duration))\n\t\t\t\tprint('       durationLeft: '..tostring(effect.durationLeft))\n\t\t\tend\n\t\tend\n\t\t]]--\n\t\t--[[\n\t\tprint('active spell '..tostring(id)..':')\n\t\tprint('  name: '..tostring(params.name))\n\t\tprint('  id: '..tostring(params.id))\n\t\tprint('  item: '..tostring(params.item))\n\t\tprint('  caster: '..tostring(params.caster))\n\t\tprint('  effects: '..tostring(params.effects))\n\t\tfor _, effect in pairs(params.effects) do\n\t\t\tprint('  -> effects['..tostring(effect)..']:')\n\t\t\tprint('       id: '..tostring(effect.id))\n\t\t\tprint('       name: '..tostring(effect.name))\n\t\t\tprint('       affectedSkill: '..tostring(effect.affectedSkill))\n\t\t\tprint('       affectedAttribute: '..tostring(effect.affectedAttribute))\n\t\t\tprint('       magnitudeThisFrame: '..tostring(effect.magnitudeThisFrame))\n\t\t\tprint('       minMagnitude: '..tostring(effect.minMagnitude))\n\t\t\tprint('       maxMagnitude: '..tostring(effect.maxMagnitude))\n\t\t\tprint('       duration: '..tostring(effect.duration))\n\t\t\tprint('       durationLeft: '..tostring(effect.durationLeft))\n\t\tend\n\tend\n\t]]--\nend\n\nreturn\n{\n\tengineHandlers =\n\t{\n\t\tonUpdate = equipHandler,\n        onSave = onSave,\n        onLoad = onLoad,\n\t}\n}\n",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\armour_rebalance\\global.lua": "local records = require(\"scripts.comprehensive_rebalance.lib.records\")\n\nrecords.createRecord(nill)\n",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\convenient_fatigue\\player.lua": "local self = require('openmw.self')\nlocal types = require('openmw.types')\n\nlocal settings = require(\"scripts.comprehensive_rebalance.lib.settings\")\nlocal Actor = types.Actor\n\nlocal delay = 0\nlocal actorSpells = Actor.spells(self)\n\nlocal function removeSpell()\n    actorSpells:remove('fatigue resting')\n    actorSpells:remove('fatigue resting faster')\nend\n\nlocal function addSpell(faster)\n    if faster then\n        actorSpells:add('fatigue resting faster')\n    else\n        actorSpells:add('fatigue resting')\n    end\nend\n\nlocal function restHandler(dt)\n    local section = settings.GetSection(\"char\")\n    local convenientSetting = section:get(\"convenientFatigueSetting\")\n\tif self.controls.sneak == true and Actor.getStance(self) == Actor.STANCE.Nothing and convenientSetting ~= \"disabled\" and self.controls.movement == 0 and self.controls.sideMovement == 0 then\n        delay = delay + dt\n    else\n        delay = 0\n        removeSpell()\n    end\n\n    --if we've been crouched and still for 2 seconds, allow recharging\n    if delay > section:get(\"convenientFatigueDelay\") then\n        addSpell(convenientSetting == \"fast\")\n    end\nend\n\nreturn\n{\n\tengineHandlers =\n\t{\n\t\tonUpdate = restHandler,\n        --onSave = onSave,\n        --onLoad = onLoad,\n\t}\n}\n\n",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\disable_saving\\global.lua": "local menu = require('openmw.menu')\nlocal I = require('openmw.interfaces')\n\nlocal function handleSaveEvent(data)\n\tI.Saving.enableSave(false)\n\tworld.saveGame(\"testsave\",\"testsave\")\n\t--print(tostring(data.origin))\nend\n\nreturn\n{\n\teventHandlers =\n\t{\n\t\tplayerSaved = handleSaveEvent\n\t},\n}",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\disable_saving\\player.lua": "local ui = require('openmw.ui')\nlocal core = require('openmw.core')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal I = require('openmw.interfaces')\nlocal Saving = require('openmw.interfaces').Saving\n\nlocal function PressX(key)\n\tif key.symbol == 'x' then\n\t\tui.showMessage('Save Restrictions - Player has pressed \"X\"')\n\t\tcore.sendGlobalEvent('playerSaved', {origin = self.object})\n    end\nend\n\nlocal function processSave(id)\n\tif id == input.ACTION.QuickSave then\n\t\t--core.sendGlobalEvent(\"playerSaved\")\n\t\tui.showMessage('Save Restrictions - You have quicksaved')\n\tend\nend\n\nreturn {\n\n    engineHandlers = {\n\t\tonKeyPress = PressX,\n\t\tonInputAction = processSave\n    }\n}",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\disable_training\\npc.lua": "local self = require(\"openmw.self\")\n\nlocal settings = require(\"scripts.comprehensive_rebalance.lib.settings\")\nlocal NPC = require(\"openmw.types\").NPC\n\nlocal offersTraining = false\nlocal processed = false\nlocal record = nil\nlocal section = settings.GetSection(\"char\")\n\n--does not work\n--servicesOffered is writable but doesn't do anything\n--TODO: Update this when they finally add record modification support\nlocal function processTraining()\n    local train = offersTraining and not section:get(\"noTrainers\") \n    print (\"Setting training settings for \" .. tostring(self) .. ' to ' .. tostring(train))\n    record.servicesOffered['Training'] = train\nend\n\nlocal function onActive()\n    local npc = NPC.objectIsInstance(self)\n    if (npc and not processed) then\n        record = NPC.record(self)\n        if (record) then\n            local training = record.servicesOffered['Training']\n            offersTraining = training\n            processTraining()\n        end\n    end\n    if npc then\n    end\n    processed = true\nend\n\nlocal function onActivated(actor)\n    processTraining()\nend\n\nreturn {\n    engineHandlers = {\n\t\tonActivated = onActivated,\n        onActive = onActive,\n\t}\n}\n\n",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\flight_nerf\\player.lua": "local core = require('openmw.core')\nlocal types = require('openmw.types')\nlocal self = require('openmw.self')\nlocal ui = require('openmw.ui');\nlocal settings = require(\"scripts.comprehensive_rebalance.lib.settings\")\nlocal spells = require(\"scripts.comprehensive_rebalance.lib.spells\")\n\nlocal Actor = types.Actor\nlocal Player = types.Player\nlocal Effects = core.magic.EFFECT_TYPE\nlocal SpellType = core.magic.SPELL_TYPE\n\nlocal function flightHandler()\n\n    local section = settings.GetSection(\"misc\")\n\n    local noDeathFromAbove = section:get(\"noDeathFromAbove\")\n    local grounded = Actor.isOnGround(self);\n\n    --If we are in levitation or slowfall, we can't use weapons,\n    local stance = Actor.getStance(self)\n    local flyingSpell = false\n\n    for _, spell in pairs(Actor.activeSpells(self)) do\n        if spell.type ~= SpellType.Ability then\n            for _, effect in pairs(spell.effects) do\n                if effect.id == Effects.Levitate or effect.id == Effects.SlowFall then\n                    if stance == Actor.STANCE.Weapon and noDeathFromAbove then\n                        Actor.activeSpells(self):remove(spell.activeSpellId)\n                    else\n                        flyingSpell = noDeathFromAbove;\n                    end\n                end\n            end\n        end\n    end\n\n    --if we are using one of these spells, add a 100% cast rate penalty\n    --TODO: Make this work whenever the player is not on the ground (Actor.isOnGround(self).\n    --Currently disabled due to occasional \"pop\" sounds when AddSpell tries to remove the awful Sound effect.\n    --When it's possible to dynamically remove the effect from the Sound magic effect, then do it.\n    --OR just simply remove that sound entirely, idk\n    --spells.addOrRemoveSpell('flying cast penalty',not Actor.isOnGround(self))\n    spells.addOrRemoveSpell('flying cast penalty',flyingSpell)\n    --Player.setControlSwitch(self, Player.CONTROL_SWITCH.Magic, not flyingSpell)\n    flyingSpell = false;\nend\n\nreturn\n{\n\tengineHandlers =\n\t{\n\t\tonUpdate = flightHandler,\n\t}\n}\n",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\gold_weight\\global.lua": "local Misc = require('openmw.types').Miscellaneous\n\nlocal function setGoldWeight(initData)\n    local gold = Misc.record('Gold_001')\n    if gold then\n        print (\"Gold weight is \" .. tostring(gold.weight))\n        gold.weight = 300\n    else\n        print(\"Something on this I don't like\")\n    end\nend\n\nlocal function onLoad(savedData, initData)\n    setGoldWeight(savedData)\nend\n\nreturn\n{\n\tengineHandlers =\n\t{\n\t\tonInit = setGoldWeight,\n\t\tonLoad = onLoad,\n\t}\n}\n\n",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\lib\\records.lua": "\ncreatedRecords = nil\n\nlocal function onSave()\n    return {\n        createdRecords = createdRecords\n    }\nend\n\nlocal function onLoad(data)\n    createdRecords = data.createdRecords\n    print (\"loaded\")\nend\n\nlocal records = {\n    engineHandlers = {\n        onLoad = onLoad,\n        onSave = onSave,\n    },\n}\n\nfunction records.createRecord(oldRecord)\n    print(\"Creating record\")\nend\n\nreturn records\n",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\lib\\settings.lua": "local core = require(\"openmw.core\")\nlocal storage = require('openmw.storage')\n\nlocal settings = {}\n\nsettings.MOD_NAME = \"comprehensive_rebalance\"\nsettings.MOD_NAME_ADDON = settings.MOD_NAME .. \".omwaddon\"\nsettings.strings = core.l10n(settings.MOD_NAME)\n\nfunction settings.GetSection(name)\n    return storage.globalSection(\"SettingsGlobal\" .. settings.MOD_NAME .. name)\nend\n\nfunction settings.GetAddonInstallText(addon)\n\tlocal installed = core.contentFiles.has(addon..\".omwaddon\")\n\tif installed then\n\t\treturn settings.strings(\"settings_addon_installed\")\n\telse\n\t\treturn settings.strings(\"settings_addon_not_installed\")\n\tend\nend\n\nfunction settings.doCheckbox(key, category, num, defaultValue)\n\treturn\n\t{\n\t\tkey = key,\n\t\tname = \"settings_modCategory\" .. category .. \"_setting\" .. num .. \"_name\",\n\t\trenderer = \"checkbox\",\n\t\tdefault = defaultValue,\n\t\tdescription = \"settings_modCategory\" .. category .. \"_setting\" .. num .. \"_desc\",\n\t\t\n\t}\nend\n\nfunction settings.doNumber(key, category, num, defaultValue, vMin, vMax)\n\treturn\n\t{\n\t\tkey = key,\n\t\tname = \"settings_modCategory\" .. category .. \"_setting\" .. num .. \"_name\",\n\t\trenderer = \"number\",\n\t\tdefault = defaultValue,\n\t\tdescription = \"settings_modCategory\" .. category .. \"_setting\" .. num .. \"_desc\",\n        argument = {\n            min = vMin,\n            max = vMax,\n            integer = true,\n        },\n\t}\nend\n\nfunction settings.doSelection(key, category, num, values, defaultValue)\n    return\n    {\n\t\tkey = key,\n        l10n = settings.MOD_NAME,\n\t\tname = \"settings_modCategory\" .. category .. \"_setting\" .. num .. \"_name\",\n\t\trenderer = \"select\",\n\t\tdescription = \"settings_modCategory\" .. category .. \"_setting\" .. num .. \"_desc\",\n        default = defaultValue,\n        argument = {\n            items = values,\n            l10n = settings.MOD_NAME,\n        },\n    }\nend\n\nfunction settings.doComingSoon(key, category, num, defaultValue)\n\treturn\n\t{\n\t\tkey = key,\n\t\tname = \"settings_modCategory\" .. category .. \"_setting\" .. num .. \"_name\",\n\t\trenderer = \"checkbox\",\n\t\tdefault = defaultValue,\n\t\tdescription = \"settings_modCategory\" .. category .. \"_setting\" .. num .. \"_desc\",\n\t\targument = {\n                trueLabel = settings.strings(\"settings_coming_soon\"),\n                falseLabel = settings.strings(\"settings_coming_soon\"),\n            }\n\t}\nend\n\nfunction settings.doAddonText(key, category, num, addonName)\n\treturn\n\t{\n\t\tkey = key,\n\t\tname = \"settings_modCategory\" .. category .. \"_setting\" .. num .. \"_name\",\n\t\trenderer = \"checkbox\",\n\t\tdescription = \"settings_modCategory\" .. category .. \"_setting\" .. num .. \"_desc\",\n\t\targument = {\n\t\t\ttrueLabel = settings.GetAddonInstallText(addonName),\n\t\t\tfalseLabel = settings.GetAddonInstallText(addonName),\n\t\t}\n\t}\nend\n\nreturn settings\n",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\lib\\spells.lua": "local core = require('openmw.core')\nlocal types = require('openmw.types')\nlocal self = require('openmw.self')\n\nlocal Actor = types.Actor\n\nlocal actorSpells = Actor.spells(self)\n\n\nlocal spells = {}\n\nfunction spells.addOrRemoveSpell(spell,add)\n    if add then\n        actorSpells:add(spell)\n        core.sound.stopSound3d(\"magic sound\", self) --dirty hack\n        --ui.showMessage(\"adding \" .. spell)\n    else\n        actorSpells:remove(spell)\n        --ui.showMessage(\"removing \" .. spell)\n    end\nend\n\nreturn spells\n",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\realtime_menus\\npc.lua": "local self = require('openmw.self')\nlocal util = require('openmw.util')\n\nlocal target = nil\n\n--adapted from UI Modes\nlocal function LookAtTarget(deltatime)\n\tlocal deltaPos = target.position - self.position\n\tlocal destVec = util.vector2(deltaPos.x, deltaPos.y):rotate(self.rotation:getYaw())\n\tlocal deltaYaw = math.atan2(destVec.x, destVec.y)\n\tif math.abs(deltaYaw) < math.rad(10) then\n\t\tself.controls.yawChange = 0\n\telse\n\t\tself.controls.yawChange = util.clamp(deltaYaw, -deltatime * 2.5, deltatime * 2.5)\n\tend\nend\n\nlocal function OnDialogStarted(t)\n    self:enableAI(false) --attempted fix for guards repeatedly talking to you when you get arrested. This sucks though because it stops \"surprise\" attacks in dialogue\n\ttarget = t\n\t--print(\"Received Started Event\")\nend\n\nlocal function OnDialogStopped(t)\n    self:enableAI(true)\n\ttarget = nil\n\t--print(\"Received Stopped Event\")\nend\n\nlocal function onUpdate(deltatime)\n    if target then\n        self.controls.movement = 0\n        self.controls.sideMovement = 0\n\t\tLookAtTarget(deltatime)\n    end\nend\n\nreturn {\n    eventHandlers = {\n        DialogueStarted = OnDialogStarted,\n        DialogueStopped = OnDialogStopped,\n    },\n    engineHandlers = {\n        onUpdate = onUpdate,\n    },\n}\n",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\realtime_menus\\player.lua": "-- This will disable pause mode for using interfaces\nlocal I = require('openmw.interfaces')\nlocal self = require('openmw.self')\nlocal ui = require('openmw.ui')\n\nlocal storage = require('openmw.storage')\nlocal MOD_NAME = \"comprehensive_rebalance\"\nlocal playerSettings = storage.globalSection(\"SettingsGlobal\" .. MOD_NAME .. \"menus\")\n\nlocal currentTarget = nil\n\nlocal function SetRealtimeMenus()\n\n\tI.UI.setPauseOnMode('Interface', playerSettings:get(\"realtimeInterface\") == false)\n\tI.UI.setPauseOnMode('Dialogue', playerSettings:get(\"realtimeDialogue\") == false)\n\tI.UI.setPauseOnMode('Container', playerSettings:get(\"realtimeContainer\") == false)\n\tI.UI.setPauseOnMode('Scroll', playerSettings:get(\"realtimeReading\") == false)\n\tI.UI.setPauseOnMode('Book', playerSettings:get(\"realtimeReading\") == false)\n\tI.UI.setPauseOnMode('Journal', playerSettings:get(\"realtimeJournal\") == false)\n\tI.UI.setPauseOnMode('QuickKeysMenu', playerSettings:get(\"realtimeQuickKeysMenu\") == false)\n\tI.UI.setPauseOnMode('Travel', playerSettings:get(\"realtimeInteractions\") == false)\n\tI.UI.setPauseOnMode('Alchemy', playerSettings:get(\"realtimeInteractions\") == false)\n\tI.UI.setPauseOnMode('Companion', playerSettings:get(\"realtimeInteractions\") == false)\n\tI.UI.setPauseOnMode('Barter', playerSettings:get(\"realtimeInteractions\") == false)\n\tI.UI.setPauseOnMode('SpellBuying', playerSettings:get(\"realtimeInteractions\") == false)\n\tI.UI.setPauseOnMode('MerchantRepair', playerSettings:get(\"realtimeInteractions\") == false)\n\tI.UI.setPauseOnMode('Repair', playerSettings:get(\"realtimeInteractions\") == false)\n\tI.UI.setPauseOnMode('Recharge', playerSettings:get(\"realtimeInteractions\") == false)\n\tI.UI.setPauseOnMode('Training', playerSettings:get(\"realtimeInteractions\") == false)\n\tI.UI.setPauseOnMode('Enchanting', playerSettings:get(\"realtimeInteractions\") == false)\n\tI.UI.setPauseOnMode('SpellCreating', playerSettings:get(\"realtimeInteractions\") == false)\n\tI.UI.setPauseOnMode('Rest', playerSettings:get(\"realtimeMisc\") == false)\n\tI.UI.setPauseOnMode('Jail', playerSettings:get(\"realtimeMisc\") == false)\n\tI.UI.setPauseOnMode('LevelUp', playerSettings:get(\"realtimeMisc\") == false)\nend\n\n--if we have realtime dialogue menu, we need to send an event to our target to make them stop\nlocal function HandleDialogueNPC(data)\n\tif playerSettings:get(\"realtimeDialogue\") and data.newMode == \"Dialogue\" and data.arg ~= nil then\n\t\tdata.arg:sendEvent('DialogueStarted', self)\n\t\tcurrentTarget = data.arg\n\t\t--print(\"opened dialog\")\n\telseif currentTarget and data.newMode == nil then\n\t\tcurrentTarget:sendEvent('DialogueStopped', self)\n\t\tcurrentTarget = nil\n\t\t--print(\"stopped dialog\")\n\tend\nend\n\nlocal function OnGUI(data)\n\n\tSetRealtimeMenus()\n\tHandleDialogueNPC(data)\n\nend\n\nSetRealtimeMenus()\nreturn {\n    eventHandlers = {\n\t\tUiModeChanged = OnGUI\n\t}\n}\n",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\resting\\global.lua": "local activation = require(\"openmw.interfaces\").Activation\nlocal types = require(\"openmw.types\")\nlocal core = require(\"openmw.core\")\nlocal storage = require('openmw.storage')\nlocal world = require('openmw.world')\n\n--you can't sleep in someone elses bed!\nlocal bedMessageGMST = \"sNotifyMessage64\"\n\nlocal MOD_NAME = \"comprehensive_rebalance\"\nlocal settings = storage.globalSection(\"SettingsGlobal\" .. MOD_NAME .. \"rest\")\nlocal strings = core.l10n(MOD_NAME)\n\n--holds when the player last rested\n--TODO: Handle this for every player (in the case of multiplayer)\nlocal lastRested = 0\n\nlocal function handleRestTimeEvent(data)\n\tlastRested = data.restTime\nend\n\nlocal function isBed(object)\n\tlocal scrName = types.Activator.record(object.recordId).mwscript\n\treturn scrName == \"bed_standard\"\nend\n\nlocal function isInFaction(id, actor)\n\tfor _, value in ipairs(types.NPC.getFactions(actor)) do\n\t\tif value == id then\n\t\t\treturn types.NPC.getFactionRank(actor, id)\n\t\tend\n\tend\n\treturn -1\nend\n\nlocal function canSleep(bed, actor)\n\n\tlocal message = core.getGMST(bedMessageGMST)\n\n\t--prevent re-using beds so soon!\n    if settings:get('noRepeatedSleeping') and lastRested + (settings:get('noRepeatedSleepingTimer') * 60) > world.getSimulationTime() then\n        actor:sendEvent(\"showMessage\", strings(\"not_tired\"))\n        return false\n    end\n\n\t--check global variable, for renting\n\tif bed.globalVariable and world.mwscript.getGlobalVariables then\n\t\tif world.mwscript.getGlobalVariables(actor)[bed.globalVariable] ~= 1 then\n\t\t\treturn false\n\t\tend\n\n\t--if bed is owned, we can't use it\n\telseif bed.ownerRecordId and settings:get(\"noTresspassSleep\") then\n\t\t--actor:sendEvent(\"showMessage\", \"owned\")\n\t\tactor:sendEvent(\"showMessage\", message)\n\t\treturn false\n\t\t\n\t--we must be in the same faction as the bed owner, and be the right rank\n\telseif bed.ownerFactionId then\n\t\tlocal rank = isInFaction(bed.ownerFactionId, actor)\n\t\t\n\t\tif (rank == -1 or rank < bed.ownerFactionRank) and settings:get(\"noTresspassSleep\") then\n\t\t\t--actor:sendEvent(\"showMessage\", \"rank too low\")\n\t\t\tactor:sendEvent(\"showMessage\", message)\n\t\t\treturn false\n\t\tend\n\tend\n\t\n\tactor:sendEvent(\"handleBed\")\n\treturn true\n\nend\n\nlocal function activateHandler(activator, actor)\n\t\n\tif isBed(activator) and not canSleep(activator, actor) then\n\t\treturn false\n\telse\n\t\tsleepTimer = world.getSimulationTime()\n\t\treturn true\n  end\nend\n\nactivation.addHandlerForType(types.Activator, activateHandler)\n\nreturn\n{\n\teventHandlers =\n\t{\n\t\tUiModeChanged = setLastSleep,\n\t\tplayerRested = handleRestTimeEvent\n\t},\n}",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\resting\\player.lua": "local ui = require('openmw.ui')\nlocal input = require('openmw.input')\nlocal I = require('openmw.interfaces')\nlocal calendar = require('openmw_aux.calendar')\nlocal self = require('openmw.self')\nlocal core = require(\"openmw.core\")\nlocal storage = require('openmw.storage')\n\nlocal MOD_NAME = \"comprehensive_rebalance\"\nlocal settings = storage.globalSection(\"SettingsGlobal\" .. MOD_NAME .. \"rest\")\nlocal strings = core.l10n(MOD_NAME)\n\nlocal startedRestMenuTime = 0\nlocal lastRestTime = 0\n\n--log whenever we last slept\nlocal function setLastSleep(data)\n\n\tif data.newMode == 'Rest' then\n\t\tstartedRestMenuTime = core.getGameTime()\n\telseif data.oldMode == 'Rest' and core.getGameTime() >= startedRestMenuTime + 3600 then\n\t\t\t--ui.showMessage(\"Update last rest time...\")\n\t\t\tlastRestTime = core.getSimulationTime()\n\t\t\tcore.sendGlobalEvent('playerRested', {origin = self.object, restTime = lastRestTime})\n\tend\nend\n\n--handle pressing T and trying to rest\nlocal function processRest(id)\n\t\n\tif id == input.ACTION.Rest and I.UI.getMode() == 'Rest' then\n        \n        local restMode = settings:get(\"disableRestMode\")\n        local waitMode = settings:get(\"disableWaitMode\")\n\n\t\tlocal myCell = self.object.cell\n\t\tlocal noSleep = myCell:hasTag(\"NoSleep\")\n\n\t\tlocal gameTime = calendar.formatGameTime(\"%d %B\\n%I %p\")\n\t\tlocal restString = \"\";\n\t\t\n\t\tif restMode ~= \"disabled\" and not noSleep then\n\t\t\tI.UI.removeMode('Rest')\n\t\t\trestString = strings(\"no_rest\")\n\t\t\tif restMode == \"show_time\" then\n\t\t\t\t--restString = restString .. '\\n\\n' .. gameTime\n\t\t\t\trestString = gameTime\n\t\t\tend\n\t\telseif waitMode ~= \"disabled\" and noSleep then\n\t\t\tI.UI.removeMode('Rest')\n\t\t\trestString = strings(\"no_wait\")\n\t\t\tif waitMode == \"show_time\" then\n\t\t\t\t--restString = restString .. '\\n\\n' .. gameTime\n\t\t\t\trestString = gameTime\n\t\t\tend\n\t\telseif not noSleep and settings:get('noRepeatedSleeping') and lastRestTime + (settings:get('noRepeatedSleepingTimer') * 60) > core.getSimulationTime() then\n\t\t\tI.UI.removeMode('Rest')\n\t\t\trestString = strings(\"not_tired\")\n\t\tend\n\t\tui.showMessage(restString)\n\tend\nend\n\nlocal function onSave()\n    return {\n        lastRest = lastRestTime\n    }\nend\n\nlocal function onLoad(data)\n    if data then\n\t\tlastRestTime = data.lastRest\n\tend\nend\n\nreturn {\n    engineHandlers = {\n\t\tonInputAction = processRest,\n\t\tonSave = onSave,\n        onLoad = onLoad,\n    },\n\teventHandlers = {\n\t\tUiModeChanged = setLastSleep,\n\t\thandleBed = handleBedEvent\n\t},\n}\n",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\_core\\global.lua": "local settings = require(\"scripts.comprehensive_rebalance.lib.settings\")\n\nlocal core = require('openmw.core')\nlocal time = require(\"openmw_aux.time\")\nlocal stopFn = nil\n\nlocal function pluginCheck(player)\n    if not core.contentFiles.has(settings.MOD_NAME_ADDON) then\n        stopFn = time.runRepeatedly(\n            function ()\n                player:sendEvent(\"showMessage\", \"PLUGIN NOT INSTALLED!\\n\\nPlease enable \".. settings.MOD_NAME_ADDON ..\" in the launcher!\")\n                print(\"comprehensive_rebalance.owmaddon is not installed!\")\n            end,\n        time.second * 1\n        )\n    end\nend\n\nreturn {\n    engineHandlers = {\n        onPlayerAdded = pluginCheck\n    }\n}\n",
    "Comprehensive Rebalance 0.6-53663-0-6-1723003350\\scripts\\comprehensive_rebalance\\_core\\player.lua": "--global events registered to player, can be called by any part of comprehensive rebalance\n\nlocal ui = require('openmw.ui')\n\nlocal function showMessageEvent(msg)\n\tif msg then\n\t\tui.showMessage(msg)\n\telse\n\t\tprint(\"Blank message was shown!\")\n\tend\nend\n\nlocal function showErrorEvent(msg)\n\terror(msg)\nend\n\nreturn {\n    eventHandlers = {\n        showMessage = showMessageEvent,\n        showError = showErrorEvent\n    }\n}"
  }
}