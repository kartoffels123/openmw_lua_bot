{
  "folder_name": "Sneak Step Drain (OpenMW Lua)",
  "lua_files": {
    "Solthas Sneak Step Drain-52382-1-4-1717384505\\SolSneakStepDrain\\scripts\\SolSneakStepDrain.lua": "local ui = require('openmw.ui')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal async = require('openmw.async')\n-- shorthand for convenience\nlocal attributes = types.Actor.stats.attributes\nlocal skills = types.NPC.stats.skills\n\n-- settings functions\nlocal function boolSetting(sKey, sDef)\n  return {\n    key = sKey,\n    renderer = 'checkbox',\n    name = sKey .. '_name',\n    description = sKey .. '_desc',\n    default = sDef,\n  }\nend\nlocal function numbSetting(sKey, sDef, sInt, sMin, sMax)\n  return {\n    key = sKey,\n    renderer = 'number',\n    name = sKey .. '_name',\n    description = sKey .. '_desc',\n    default = sDef,\n    argument = {\n      integer = sInt,\n      min = sMin,\n      max = sMax,\n    },\n  }\nend\n-- handle settings\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\nI.Settings.registerPage({\n  key = 'SolSneakStepDrain',\n  l10n = 'SolSneakStepDrain',\n  name = 'name',\n  description = 'description',\n})\n-- default values!\nlocal enabled = true\nlocal verbose = false\nlocal uiShow = true\nlocal allowDebuff = true\nlocal buffBase = 0.5\nlocal maxDrain = 9.0\nlocal maxCharge = 3.0\nlocal chargeInterval = 0.5\nlocal uiXcoord = 0.0\nlocal uiYcoord = 1.0\nlocal uiLength = 72\nI.Settings.registerGroup({\n  key = 'Settings_SolSneakStepDrain',\n  page = 'SolSneakStepDrain',\n  l10n = 'SolSneakStepDrain',\n  name = 'group_name',\n  permanentStorage = true,\n  settings = {\n    boolSetting('enabled', enabled),\n    boolSetting('verbose', verbose),\n    boolSetting('uiShow', uiShow),\n    boolSetting('allowDebuff', allowDebuff),\n    numbSetting('buffBase', buffBase, false, 0.1, 2.0),\n    numbSetting('maxCharge', maxCharge, false, 1.0, 20.0),\n    numbSetting('maxDrain', maxDrain, false, 1.0, 20.0),\n    numbSetting('chargeInterval', chargeInterval, false, 0.1, 1.0),\n    numbSetting('uiXcoord', uiXcoord, false, 0.0, 1.0),\n    numbSetting('uiYcoord', uiYcoord, false, 0.0, 1.0),\n    numbSetting('uiLength', uiLength, true, 10, 1000),\n  },\n})\nlocal settingsGroup = storage.playerSection('Settings_SolSneakStepDrain')\n\n\n-- ui junk -- adapted from AttendMe\\scripts\\AttendMe\\hud.lua\nlocal isSneak = false\nlocal util = require('openmw.util')\nlocal uiElement = nil\n-- setup ui table thing\nlocal statSize = util.vector2(61, 8)\nlocal statTexture = ui.texture({ path = 'textures/menu_bar_gray.dds' })\nlocal statColors = util.color.rgb(250 / 255, 250 / 255, 100 / 255) -- bright yellow\nlocal uiLayout = {\n  layer = 'HUD',\n  name = 'sneakBar',\n  template = I.MWUI.templates.boxTransparent,\n  props = {},\n  content = ui.content({\n    {\n      name = 'box',\n      props = {\n        size = statSize,\n      },\n      content = ui.content({\n        {\n          name = 'image',\n          type = ui.TYPE.Image,\n          props = {\n            size = statSize,\n            resource = statTexture,\n            color = statColors,\n            arrange = ui.ALIGNMENT.Start,\n          },\n        },\n      }),\n    },\n  }),\n}\n-- position in bottom left\nlocal hudPosition = util.vector2(0.0, 1.0)\nuiLayout.props.relativePosition = hudPosition\nuiLayout.props.anchor = hudPosition\n--uiLayout.props.position = (util.vector2(1, 1) - hudPosition * 2)\nuiLayout.props.position = (util.vector2(1, 1) - hudPosition * 2):emul(util.vector2(13 + 61 + 8, 12 + 15 * 3))\nlocal function updateUI(current, max)\n  -- update bar size\n  uiLayout.content.box.content.image.props.size = statSize:emul(util.vector2(math.abs((current + max) / (2 * max)), 1)) -- no outline\n  -- ui element update / create / destroy logic\n  if enabled and ((current ~= 0) or (isSneak and current == 0)) then\n    if uiElement then\n      uiElement:update()\n    else\n      uiElement = ui.create(uiLayout)\n    end\n  else\n    if uiElement then\n      uiElement:destroy()\n    end\n    uiElement = nil\n  end\nend\n\n-- okayyyyyyyyyyy back to settings now that I've initialized the ui element\n-- update settings\nlocal function updateSettings()\n  enabled = settingsGroup:get('enabled')\n  verbose = settingsGroup:get('verbose')\n  uiShow = settingsGroup:get('uiShow')\n  allowDebuff = settingsGroup:get('allowDebuff')\n  buffBase = settingsGroup:get('buffBase')\n  maxDrain = settingsGroup:get('maxDrain')\n  maxCharge = settingsGroup:get('maxCharge')\n  chargeInterval = settingsGroup:get('chargeInterval')\n  -- update ui settings...\n  uiLength = settingsGroup:get('uiLength')\n  statSize = util.vector2(uiLength, 8)\n  uiLayout.content.box.props.size = statSize\n  uiLayout.content.box.content.image.props.size = statSize\n  uiXcoord = settingsGroup:get('uiXcoord')\n  uiYcoord = settingsGroup:get('uiYcoord')\n  hudPosition = util.vector2(uiXcoord, uiYcoord)\n  uiLayout.props.relativePosition = hudPosition\n  uiLayout.props.anchor = hudPosition\n  if uiXcoord == 0.0 and uiYcoord == 1.0 then\n    uiLayout.props.position = (util.vector2(1, 1) - hudPosition * 2):emul(util.vector2(13 + 61 + 8, 12 + 15 * 3))\n  else\n    uiLayout.props.position = (util.vector2(1, 1) - hudPosition * 2)\n  end\nend\nlocal function init()\n  updateSettings()\nend\nsettingsGroup:subscribe(async:callback(updateSettings))\n\n-- stance effects\nlocal function sneakMod(modSign, modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    skills.sneak(self).modifier = math.max(0, skills.sneak(self).modifier + modSign * modVal)\n  elseif modVal < 0 then\n    modVal = math.abs(modVal)\n    skills.sneak(self).damage = math.max(0, skills.sneak(self).damage + modSign * modVal)\n  end\nend\n-- get effect of armor etc\nlocal function getWeights()\n  -- get athletics and acrobatics, which help you move quietly\n  local acrob = skills.acrobatics(self).modified\n  local athle = skills.athletics(self).modified\n\n  -- shoes\n  local weightBoots = 0 -- if nothing equipped\n  local weightPants = 0\n  local weightShirt = 0\n  local armorRatio = 0.7 -- fraction for armor, 1-it is fraction for weapon\n  local ratioBoots = 0.6 -- overall fraction: boots\n  local ratioPants = 0.2 -- pants\n  local ratioShirt = 0.2 -- shirt\n  -- armor and clothing records aren't implemented yet in 0.48, so let's test.\n  -- shoes\n  local recordBoots = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.Boots)\n  if recordBoots == nil then                 -- wearing nothing in slot\n    -- no modification\n  elseif recordBoots.type.record == nil then -- 0.48 check\n    -- find a 0.48 viable workaround.\n    ratioBoots = 0.5 * ratioBoots            -- lower ratio because lower confidence\n    weightBoots = 20                         -- assume weight\n  else\n    if recordBoots then                      -- I don't think I need this since I'm checking for it above\n      weightBoots = recordBoots.type.record(recordBoots).weight\n    end\n  end\n  -- pants\n  local recordPants = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.Greaves)\n  -- Due to limited 0.48 functionality where I'll get slot overlap on assuming the armor slot's weight, I will comment this section out.\n  --if recordPants == nil then -- if no greaves, try pants\n  --  recordPants = types.Actor.equipment(self,types.Actor.EQUIPMENT_SLOT.Pants)\n  --end\n  -- what about skirt?\n  if recordPants == nil then                 -- wearing nothing in slot\n    -- no modification\n  elseif recordPants.type.record == nil then -- 0.48 check\n    -- find a 0.48 viable workaround.\n    ratioPants = 0.5 * ratioPants            -- lower ratio because lower confidence\n    weightPants = 20                         -- assume weight\n  else\n    if recordPants then\n      weightPants = recordPants.type.record(recordPants).weight\n    end\n  end\n  -- shirt\n  local recordShirt = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.Cuirass)\n  -- Due to limited 0.48 functionality where I'll get slot overlap on assuming the armor slot's weight, I will comment this section out.\n  --if recordShirt == nil then -- if no cuirass, try shirt\n  --  recordShirt = types.Actor.equipment(self,types.Actor.EQUIPMENT_SLOT.Shirt)\n  --end\n  -- what about robe?\n  if recordShirt == nil then                 -- wearing nothing in slot\n    -- no modification\n  elseif recordShirt.type.record == nil then -- 0.48 check\n    -- find a 0.48 viable workaround.\n    ratioShirt = 0.5 * ratioShirt            -- lower ratio because lower confidence\n    weightShirt = 20                         -- assume weight\n  else\n    if recordShirt then\n      weightShirt = recordShirt.type.record(recordShirt).weight\n    end\n  end\n  -- recalculate total armor ratio, for sake of weapon\n  armorRatio = armorRatio * (ratioBoots + ratioPants + ratioShirt)\n\n  -- if weapon out, get weight of weapon\n  local weightWeapon = 0 -- none, or handtohand\n  if types.Actor.stance(self) == types.Actor.STANCE.Weapon then\n    local recordWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n    if recordWeapon then\n      if not types.Lockpick.objectIsInstance(recordWeapon) and not types.Probe.objectIsInstance(recordWeapon) then\n        weightWeapon = types.Weapon.record(recordWeapon).weight\n      end\n    end\n  end\n\n  -- get total modifier / multiplier for each\n  local modArmor = math.sqrt(1 + ratioBoots * weightBoots + ratioPants * weightPants + ratioShirt * weightShirt)\n  local modWeapon = math.sqrt(1 + weightWeapon)\n  local modAcrob = 100 / (acrob + 50)\n  local modAthle = 100 / (athle + 50)\n  return (armorRatio * modArmor + (1 - armorRatio) * modWeapon) * modAcrob * modAthle\nend\n\nlocal buffTotal = 0\n-- save state to be removed on load\nlocal function onSave()\n  return {\n    buffTotal = buffTotal\n  }\nend\nlocal function onLoad(data)\n  if data then\n    buffTotal = data.buffTotal\n    sneakMod(-1, buffTotal)\n  end\nend\n\nlocal tickCounter = 0\nlocal chargeTime = 0\nlocal chargeHit = false\nlocal buffType = 0\nlocal perTick = 0\nlocal maxMod = 0\nlocal showVerbose = { 1, 0, 1 } -- min, neutral, max -- do not start by showing neutral, as that would trigger immediately\nreturn {\n  engineHandlers = {\n    -- init settings\n    onActive = init,\n    -- save and load handling so you don't get stuck with modified stats\n    onSave = onSave,\n    onLoad = onLoad,\n\n    onUpdate = function(dt)\n      if uiShow then\n        if chargeHit then -- only update ui if chargetime triggered\n          updateUI(buffTotal, maxMod)\n        end\n      else\n        if uiElement then\n          uiElement:destroy()\n        end\n        uiElement = nil\n      end\n\n      if enabled then\n        isSneak = self.controls.sneak                         -- 0.49 sneak check\n        if isSneak == nil then\n          isSneak = input.isActionPressed(input.ACTION.Sneak) -- 0.48 sneak check\n        end\n\n        if isSneak or buffTotal ~= 0 then\n          -- Where to determine max sneak, armor modifier, and timers?\n          -- Do it once on the first frame we press sneak?\n          -- Do it only when timer triggers? Probably.\n          local mf = self.controls.movement\n          local ms = self.controls.sideMovement\n\n          if (mf == 0 and ms == 0) then\n            buffType = 1 -- not moving = increase sneak value over time\n          else\n            buffType = 2 -- moving = reduce sneak value over time\n          end\n          -- if not sneaking... I must return it to neutral\n          if (buffTotal < 0 and not isSneak) then\n            buffType = -1 -- not sneaking, slowly increase back to neutral\n          elseif (buffTotal > 0 and not isSneak) then\n            buffType = -2 -- not sneaking, quickly decrease back to neutral\n          end\n\n          chargeTime = chargeTime + dt -- increment timer only if sneaking\n          if chargeTime >= chargeInterval then\n            chargeHit = true\n            chargeTime = 0\n            -- determine max allowed sneak modifier\n            maxMod = math.ceil(buffBase * (skills.sneak(self).modified - buffTotal)) -- must subtract out this mod's current modifier\n            if math.abs(buffType) == 1 then\n              -- if charging, get change per tick as percentage of charge time\n              --perTick = math.ceil((maxMod/maxCharge)*chargeInterval/math.sqrt(getWeights()))\n              perTick = (maxMod / maxCharge) * chargeInterval / math.sqrt(getWeights())\n              --perTick = ((maxMod/maxCharge)*chargeInterval/math.sqrt(getWeights()))\n              if buffType < 0 then      -- if not sneaking, gain at reduced rate\n                perTick = 0.5 * perTick -- gain at half rate\n              end\n              if buffTotal >= 0 then    -- add modifier, else remove damage\n                -- we want to add modifier, so do not go above max buff\n                perTick = math.min(perTick, maxMod - buffTotal)\n                tickCounter = tickCounter + perTick\n                if tickCounter >= 1 then\n                  perTick = math.floor(tickCounter)\n                  sneakMod(1, perTick)\n                  buffTotal = buffTotal + perTick\n                  tickCounter = tickCounter - perTick\n                end\n              else\n                -- we want to remove damage, so do not go above 0\n                perTick = math.min(perTick, 0 - buffTotal)\n                tickCounter = tickCounter + perTick\n                if tickCounter >= 1 then\n                  perTick = math.floor(tickCounter)\n                  sneakMod(-1, -perTick)\n                  buffTotal = buffTotal + perTick\n                  tickCounter = tickCounter - perTick\n                end\n              end\n            elseif math.abs(buffType) == 2 then\n              -- if releasing, get change per tick as raw drain value\n              --perTick = math.ceil(maxDrain*getWeights()*chargeInterval)\n              --perTick = math.ceil(100*maxDrain*getWeights()*chargeInterval)/100\n              perTick = (maxMod / maxDrain) * chargeInterval * getWeights()\n              --perTick = (maxDrain*getWeights()*chargeInterval)\n              if buffType < 0 then      -- if not sneaking, gain at reduced rate\n                perTick = 1.5 * perTick -- decrease at double rate\n              end\n              if buffTotal <= 0 then    -- add damage, else remove modifier\n                -- we want to add damage, so do not go below negative max buff\n                if allowDebuff then\n                  perTick = math.min(perTick, maxMod + buffTotal)\n                else\n                  perTick = 0\n                end\n                tickCounter = tickCounter + perTick\n                if tickCounter >= 1 then\n                  perTick = math.floor(tickCounter)\n                  sneakMod(1, -perTick)\n                  buffTotal = buffTotal - perTick\n                  tickCounter = tickCounter - perTick\n                end\n              else\n                -- we want to remove modifier, so do not go below 0\n                perTick = math.min(perTick, 0 + buffTotal)\n                tickCounter = tickCounter + perTick\n                if tickCounter >= 1 then\n                  perTick = math.floor(tickCounter)\n                  sneakMod(-1, perTick)\n                  buffTotal = buffTotal - perTick\n                  tickCounter = tickCounter - perTick\n                end\n              end\n            end\n            if verbose then\n              --ui.showMessage('mod '.. tostring(skills.sneak(self).modifier).. ', dmg '.. tostring(skills.sneak(self).damage).. ', buffTotal '.. tostring(buffTotal))\n              if showVerbose[3] == 1 and buffTotal == maxMod then\n                showVerbose = { 1, 1, 0 }\n                ui.showMessage('SNEAK + ' .. tostring(maxMod))\n              elseif showVerbose[2] == 1 and buffTotal == 0 then\n                showVerbose = { 1, 0, 1 }\n                ui.showMessage('SNEAK RESET')\n              elseif showVerbose[1] == 1 and buffTotal == -maxMod then\n                showVerbose = { 0, 1, 1 }\n                ui.showMessage('SNEAK - ' .. tostring(maxMod))\n              end\n            end\n          else\n            chargeHit = false\n          end\n        end\n      end\n    end\n  }\n}\n"
  }
}