{
  "folder_name": "Racer Riding (OpenMW)",
  "lua_files": {
    "Racer Riding (OpenMW)-54741-1-1-1716731893\\scripts\\RacerRiding\\cliffracer.lua": "local self = require(\"openmw.self\")\nlocal types = require(\"openmw.types\")\nlocal nearby = require(\"openmw.nearby\")\nlocal trans = require(\"openmw.util\").transform\nlocal AI = require(\"openmw.interfaces\").AI\n\nreturn {\n  eventHandlers = {\n    RacerRidingStart = function()\n      self:enableAI(false)\n      AI.removePackages(\"Combat\")\n    end,\n    RacerRidingStop = function()\n      self:enableAI(true)\n    end,\n    RacerRidingControl = function(data)\n      -- Racer has to be in control when attacking target\n      if data.inCombat then\n        if not AI.getActiveTarget(\"Combat\") then\n          self.controls.yawChange = 0\n          self.controls.pitchChange = 0\n          data.player:sendEvent(\"RacerRidingTargetDead\")\n        end\n        return\n      end\n\n      self.controls.yawChange = data.yawChange\n      self.controls.pitchChange = data.pitchChange\n\n      -- Check if the are moving downwards. Note that side movement moves cliff racers forward in some cases, so that is checked for here as well.\n      if (data.movement ~= 0 or data.sideMovement ~= 0) and self.rotation:getPitch() + data.pitchChange > 0 then\n        local res = nearby.castRay(self.position, trans.move(0, 0, -50) * self.position, { collisionType = nearby.COLLISION_TYPE.Water + nearby.COLLISION_TYPE.World })\n        if res.hit then\n          -- If no hit object, we are trying to move into water\n          if not res.hitObject then\n            return\n          end\n          local script = types.Activator.objectIsInstance(res.hitObject) and types.Activator.record(res.hitObject).mwscript\n          if script == \"lava\" then\n            return\n          end\n        end\n      end\n\n      self.controls.sideMovement = data.sideMovement\n      self.controls.movement = data.movement\n    end,\n    RemoveAIPackages = function()\n      self:enableAI(false)\n    end,\n    StartAIPackage = function()\n      self:enableAI(true)\n    end,\n  },\n  engineHandlers = {\n    onActivated = function(actor)\n      if actor.recordId == \"player\" then\n        actor:sendEvent(\"RacerRidingActivated\", { racer = self })\n      end\n    end\n  },\n}\n",
    "Racer Riding (OpenMW)-54741-1-1-1716731893\\scripts\\RacerRiding\\global.lua": "local util = require(\"openmw.util\")\nlocal world = require(\"openmw.world\")\n\nlocal teleporting = false\n\nlocal function teleport(player, racer, force)\n  local position = racer.position + util.vector3(0, 0, 500)\n  local script = world.mwscript.getGlobalScript(\"racerridingteleportscript\", player)\n  if script and not force then\n    -- If moving the player through mwscript, we can just set the position directly\n    script.variables.doMove = 1\n    script.variables.x = position.x\n    script.variables.y = position.y\n    script.variables.z = position.z\n  else\n    -- If moving the player through lua, we can't move every frame because the\n    -- the cliff racer will not move when the player is teleporting, so only\n    -- teleport once the cliff racer gets too far away from the player.\n    local distance = (player.position - racer.position):length()\n    if force or (not teleporting and distance > 2000 or distance < 50) then\n      teleporting = true\n      player:teleport(player.cell, position, racer.rotation)\n    else\n      teleporting = false\n    end\n  end\nend\n\nreturn {\n  eventHandlers = {\n    RacerRidingTeleport = function(data)\n      teleport(data.player, data.racer)\n    end,\n    RacerRidingStart = function(data)\n      data.player:setScale(0.001)\n      teleport(data.player, data.racer, true)\n    end,\n    RacerRidingStop = function(data)\n      data.player:setScale(data.scale)\n      data.player:teleport(data.player.cell, data.position, data.rotation)\n      teleporting = false\n    end,\n  },\n}\n",
    "Racer Riding (OpenMW)-54741-1-1-1716731893\\scripts\\RacerRiding\\player.lua": "local self = require(\"openmw.self\")\nlocal async = require(\"openmw.async\")\nlocal nearby = require(\"openmw.nearby\")\nlocal util = require(\"openmw.util\")\nlocal core = require(\"openmw.core\")\nlocal input = require(\"openmw.input\")\nlocal camera = require(\"openmw.camera\")\nlocal types = require(\"openmw.types\")\nlocal storage = require(\"openmw.storage\")\nlocal ui = require(\"openmw.ui\")\nlocal I = require(\"openmw.interfaces\")\nlocal trans = util.transform\n\n---@class openmw.interfaces.interfaces\n---@field RacerRiding RacerRiding.Interface\n\n---@type openmw.core.GameObject?\nlocal racer\nlocal scale\nlocal autoMove = false\nlocal cameraMode\nlocal inCombat\n\nlocal diseaseTimer = 0\nlocal showInterface = false\nlocal yawCorrector = nil\nlocal pitchCorrector = nil\n\nI.Settings.registerPage {\n  key = \"RacerRidingPage\",\n  l10n = \"RacerRiding\",\n  name = \"Racer Riding\",\n}\n\nI.Settings.registerGroup {\n  key = \"SettingsRacerRidingCamera\",\n  page = \"RacerRidingPage\",\n  l10n = \"RacerRiding\",\n  name = \"Camera\",\n  permanentStorage = true,\n  settings = {\n    {\n      key = \"InvertX\",\n      renderer = \"checkbox\",\n      name = \"InvertX\",\n      default = false,\n    },\n    {\n      key = \"InvertY\",\n      renderer = \"checkbox\",\n      name = \"InvertY\",\n      default = false,\n    },\n  }\n}\n\nI.Settings.registerGroup {\n  key = \"SettingsRacerRidingGameplay\",\n  page = \"RacerRidingPage\",\n  l10n = \"RacerRiding\",\n  name = \"Gameplay\",\n  permanentStorage = true,\n  settings = {\n    {\n      key = \"DiseaseContactInterval\",\n      renderer = \"number\",\n      name = \"DiseaseContactInterval\",\n      description = \"DiseaseContactIntervalDescription\",\n      default = 1,\n      argument = { min = 0 }\n    },\n  }\n}\n\nlocal cameraSettings = storage.playerSection(\"SettingsRacerRidingCamera\")\nlocal invertX, invertY\nlocal function updateCameraSettings()\n  invertX, invertY = cameraSettings:get('InvertX'), cameraSettings:get('InvertY')\nend\nupdateCameraSettings()\ncameraSettings:subscribe(async:callback(updateCameraSettings))\n\nlocal gameplaySettings = storage.playerSection(\"SettingsRacerRidingGameplay\")\nlocal diseaseContactInterval\nlocal function updateGameplaySettings()\n  diseaseContactInterval = gameplaySettings:get('DiseaseContactInterval')\nend\nupdateGameplaySettings()\ngameplaySettings:subscribe(async:callback(updateGameplaySettings))\n\n\nlocal function setControls(val)\n  types.Player.setControlSwitch(self, types.Player.CONTROL_SWITCH.Fighting, val)\n  types.Player.setControlSwitch(self, types.Player.CONTROL_SWITCH.Jumping, val)\n  types.Player.setControlSwitch(self, types.Player.CONTROL_SWITCH.Magic, val)\n  types.Player.setControlSwitch(self, types.Player.CONTROL_SWITCH.VanityMode, val)\n  types.Player.setControlSwitch(self, types.Player.CONTROL_SWITCH.ViewMode, val)\n  types.Player.setControlSwitch(self, types.Player.CONTROL_SWITCH.Controls, val)\nend\n\nlocal function createCorrector(correction)\n  return {\n    apply = function(corrector, angle, dt)\n      local change = math.max(0.2, math.abs(correction)) * 6 * dt\n      if correction < 0 then change = -change end\n\n      if math.max(0.001, math.abs(change)) >= math.abs(correction) then\n        return angle + correction, nil\n      else\n        correction = correction - change\n        return angle + change, corrector\n      end\n    end\n  }\nend\n\nlocal function startRiding(cliffRacer)\n  racer = cliffRacer\n  scale = self.scale\n\n  racer:sendEvent(\"RacerRidingStart\")\n  core.sendGlobalEvent(\"RacerRidingStart\", { racer = racer, player = self })\n  setControls(false)\n  cameraMode = camera.getMode()\n\n  types.Actor.activeEffects(self):modify(1, \"invisibility\")\n  types.Actor.activeEffects(self):modify(1, \"levitate\")\nend\n\nlocal function stopRiding()\n  if racer then\n    types.Actor.activeEffects(self):modify(-1, \"invisibility\")\n    types.Actor.activeEffects(self):modify(-1, \"levitate\")\n\n    racer:sendEvent(\"RacerRidingStop\")\n    local z, x = camera.getYaw(), camera.getPitch()\n    core.sendGlobalEvent(\"RacerRidingStop\", { racer = racer, player = self, scale = scale, position = camera.getPosition(), rotation = trans.rotateZ(z) * trans.rotateX(x) })\n    racer = nil\n    setControls(true)\n    camera.setMode(cameraMode)\n    camera.showCrosshair(true)\n\n    diseaseTimer = 0\n  end\nend\n\nlocal function startCombat(target)\n  if racer then\n    racer:sendEvent(\"StartAIPackage\", { type = \"Combat\", target = target })\n    inCombat = target\n  end\nend\n\nlocal function stopCombat()\n  if racer then\n    racer:sendEvent(\"RemoveAIPackages\", \"Combat\")\n    if not yawCorrector then\n      yawCorrector = createCorrector(util.normalizeAngle(camera:getYaw() - racer.rotation:getYaw()))\n    end\n    if not pitchCorrector then\n      pitchCorrector = createCorrector(util.normalizeAngle(camera:getPitch() - racer.rotation:getPitch()))\n    end\n  end\n  inCombat = nil\nend\n\ninput.registerTriggerHandler(\"AutoMove\", async:callback(function()\n  if racer then\n    autoMove = not autoMove\n  end\nend))\n\ninput.registerTriggerHandler(\"Jump\", async:callback(function()\n  if racer then\n    stopRiding()\n  end\nend))\n\ninput.registerActionHandler(\"Use\", async:callback(function (pressed)\n  if racer then\n    if I.UI.getMode() then\n      return\n    end\n    camera.showCrosshair(pressed)\n    if not pressed then\n      local from = camera.getPosition()\n      local to = trans.move(from) * trans.rotateZ(camera.getYaw()) * trans.rotateX(camera.getPitch()) * util.vector3(0, 10000, 0)\n      local res = nearby.castRay(from, to, { collisionType = nearby.COLLISION_TYPE.Actor, ignore = racer })\n      if res.hit and res.hitObject and not types.Actor.isDead(res.hitObject) then\n        startCombat(res.hitObject)\n      else\n        stopCombat()\n      end\n    else\n    end\n  end\nend))\n\ninput.registerTriggerHandler(\"Inventory\", async:callback(function()\n  if racer then\n    if showInterface then I.UI.removeMode(\"Interface\") else I.UI.addMode(\"Interface\") end\n    showInterface = not showInterface\n  end\nend))\n\ninput.registerActionHandler(\"TogglePOV\", async:callback(function(value)\n  if racer and not inCombat then\n    if value then\n      yawCorrector = nil\n      pitchCorrector = nil\n    else\n      yawCorrector = createCorrector(util.normalizeAngle(camera:getYaw() - racer.rotation:getYaw()))\n      pitchCorrector = createCorrector(util.normalizeAngle(camera:getPitch() - racer.rotation:getPitch()))\n    end\n  end\nend))\n\nlocal function diseaseContact(actor)\n  -- Apply contact with each disease the cliff racer has\n  for _, spell in pairs(types.Actor.spells(actor)) do\n    if (spell.type == core.magic.SPELL_TYPE.Disease or spell.type == core.magic.SPELL_TYPE.Blight) and not types.Actor.spells(self)[spell.id] then\n      local diseaseXferChance = core.getGMST(\"fDiseaseXferChance\")\n\n      local activeEffects = types.Actor.activeEffects(self)\n      local disease = core.magic.spells.records[spell.id]\n      local resistMag = activeEffects:getEffect(disease.type == core.magic.SPELL_TYPE.Disease and core.magic.EFFECT_TYPE.ResistCommonDisease or core.magic.EFFECT_TYPE.ResistBlightDisease).magnitude\n      local weaknessMag = activeEffects:getEffect(disease.type == core.magic.SPELL_TYPE.Disease and core.magic.EFFECT_TYPE.WeaknessToCommonDisease or core.magic.EFFECT_TYPE.WeaknessToBlightDisease).magnitude\n      local resist = 1.0 - (0.01 * (resistMag - weaknessMag))\n      local x = math.floor(diseaseXferChance * 100 * resist)\n      if math.random(0, 9999) < x then\n        ui.showMessage(string.format(core.getGMST(\"sMagicContractDisease\"), disease.name))\n        types.Actor.spells(self):add(disease.id)\n      end\n    end\n  end\nend\n\nlocal rideable = {\n  [\"cliff racer\"] = true,\n  [\"cliff racer_blighted\"] = true,\n  [\"cliff racer_diseased\"] = true,\n  [\"racerridingjockeyracer\"] = true,\n}\n\nreturn {\n  engineHandlers = {\n    onUpdate = function(dt)\n      if racer then\n        if I.UI.getMode() then\n          return\n        end\n\n        if types.Actor.isDead(racer) then\n          stopRiding()\n          return\n        end\n\n        if camera.getMode() ~= camera.MODE.Static then\n          camera.setMode(camera.MODE.Static, true)\n          camera.setYaw(racer.rotation:getYaw())\n          camera.setPitch(racer.rotation:getPitch())\n          camera.showCrosshair(false)\n        end\n\n        if diseaseContactInterval > 0 then\n          diseaseTimer = diseaseTimer + dt\n          if diseaseTimer >= diseaseContactInterval then\n            diseaseContact(racer)\n            diseaseTimer = 0\n          end\n        end\n\n        self.controls.yawChange = self.controls.yawChange * (invertX and -1 or 1)\n        self.controls.pitchChange = self.controls.pitchChange * (invertY and -1 or 1)\n\n        local position = I.RacerRiding.getCameraPosition(racer)\n        camera.setStaticPosition(position)\n        camera.setYaw(camera.getYaw() + self.controls.yawChange)\n        camera.setPitch(camera.getPitch() + self.controls.pitchChange)\n\n        local movement = input.getRangeActionValue(\"MoveForward\") ~= 0 and 1 or input.getRangeActionValue(\"MoveBackward\") ~= 0 and -1 or 0\n        local sideMovement = input.getRangeActionValue(\"MoveRight\") ~= 0 and 1 or input.getRangeActionValue(\"MoveLeft\") ~= 0 and -1 or 0\n\n        -- Disable auto move if the player manually moves again\n        autoMove = autoMove and movement == 0\n        movement = autoMove and 1 or movement\n\n        local togglepov = input.getBooleanActionValue('TogglePOV')\n\n        local yawChange = togglepov and 0 or self.controls.yawChange\n        local pitchChange = togglepov and 0 or self.controls.pitchChange\n\n        if yawCorrector then\n          yawChange, yawCorrector = yawCorrector:apply(yawChange, dt)\n        end\n\n        if pitchCorrector then\n          pitchChange, pitchCorrector = pitchCorrector:apply(pitchChange, dt)\n        end\n\n        racer:sendEvent(\"RacerRidingControl\", { yawChange = yawChange, pitchChange = pitchChange, movement = movement, sideMovement = sideMovement, inCombat = inCombat, player = self })\n        core.sendGlobalEvent(\"RacerRidingTeleport\", { racer = racer, player = self })\n      end\n    end,\n    onSave = function()\n      return {\n        racer = racer,\n        cameraMode = cameraMode,\n        scale = scale,\n        autoMove = autoMove,\n        inCombat = inCombat\n      }\n    end,\n    onLoad = function(data)\n      if not data then\n        return\n      end\n\n      racer = data.racer\n      cameraMode = data.cameraMode\n      scale = data.scale\n      autoMove = data.autoMove\n      if racer then\n        core.sendGlobalEvent(\"RacerRidingStart\", { racer = racer, player = self })\n        racer:sendEvent(\"RacerRidingStart\")\n        if data.inCombat then\n          startCombat(data.inCombat)\n        end\n      end\n    end,\n  },\n  eventHandlers = {\n    RacerRidingTargetDead = function()\n      stopCombat()\n    end,\n    RacerRidingActivated = function(data)\n      if not racer and not types.Actor.isDead(data.racer) and I.RacerRiding.canRide(data.racer) then\n        startRiding(data.racer)\n      end\n    end\n  },\n  interfaceName = \"RacerRiding\",\n  ---@class RacerRiding.Interface\n  interface = {\n    version = 1,\n    canRide = function(actor)\n      return rideable[actor.recordId]\n    end,\n    getCameraPosition = function(actor)\n      return trans.move(actor.position) * trans.rotateZ(camera:getYaw()) * trans.move(0, -105, 0) * trans.rotateX(camera.getPitch() * 0.25) * util.vector3(0, 0, 430)\n    end,\n    setRideable = function(recordId, v)\n      rideable[recordId] = v or nil\n    end\n  },\n}\n"
  }
}