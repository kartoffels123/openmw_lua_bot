{
  "folder_name": "OpenMW Animated Pickup and Sneak to Steal",
  "lua_files": {
    "OpenMW Animated Pickup and Shop Around-54585-1-21a-1725831953\\scripts\\AnimatedPickup\\directPurchase.lua": "local types = require(\"openmw.types\")\nlocal core = require(\"openmw.core\")\nlocal world = require(\"openmw.world\")\nlocal util = require(\"openmw.util\")\nlocal l10n = core.l10n(\"AnimatedPickup\")\n\n\nlocal M = {}\n\nlocal player\nlocal merchants = {}\nlocal purchase = {}\n\nlocal function getOwner(reference)\n    local id = reference.owner.recordId\n    local owner = merchants[id]\n    if owner then\n        local o = owner.object\n        if o and o:isValid() and o.count ~= 0 then\n            if o.cell ~= reference.cell then o = nil end\n            return o\n        end\n    end\n    if owner and owner.scanned == reference.cell then return end\n    print(\"SCAN for merchant \"..id)\n    local actor\n    for _, v in ipairs(world.activeActors) do\n        if v.recordId == id then actor = v end\n    end\n    merchants[id] = {scanned=reference.cell}\n    if actor then merchants[id].object = actor end\n    return actor\nend\n\nlocal typeToService = {\n\t[types.Apparatus] = \"Apparatus\",\n\t[types.Armor] = \"Armor\",\n--\t[types.Book] = \"Books\",\n\t[types.Clothing] = \"Clothing\",\n\t[types.Ingredient] = \"Ingredients\",\n\t[types.Light] = \"Lights\",\n\t[types.Lockpick] = \"Picks\",\n\t[types.Miscellaneous] = \"Misc\",\n\t[types.Potion] = \"Potions\",\n\t[types.Probe] = \"Probes\",\n\t[types.Repair] = \"RepairItems\",\n\t[types.Weapon] = \"Weapon\"\n\t}\n\nlocal function tradesItemType(id, item)\n    local services = types.NPC.record(id).servicesOffered\n    if not services.Barter then return false end\n    if types.Item.itemData(item).enchantmentCharge then\n        if services.MagicItems then return true end\n        return false\n    end\n--    if services.MagicItems and types.Ingredient.objectIsInstance(item) then return true end\n    local serviceType = typeToService[item.type]\n    return services[serviceType]\nend\n\nlocal condition = { wpnArm = { [types.Weapon] = true, [types.Armor] = true },\n    others = { [types.Lockpick] = true, [types.Probe] = true, [types.Repair] = true } }\n\n--- Barter math courtesy of ZackUtils by ZackHasACat\nlocal function getBarterOffer(npc, item, buying)\n    -- Calculate base price\n    local rec = item.type.record(item)\n    local data = types.Item.itemData(item)\n    local basePrice = 1\n    if data.condition then\n        if condition.wpnArm[item.type] then basePrice = (data.condition / rec.health) end\n        if condition.others[item.type] then basePrice = (data.condition / rec.maxCondition) end\n    end\n    if data.soul then basePrice = types.Creature.record(data.soul).soulValue end\n    basePrice = basePrice * rec.value\n    \n    local self = player\n    local playerMerc = types.NPC.stats.skills.mercantile(self).modified\n\n    local playerLuck = types.Actor.stats.attributes.luck(self).modified\n    local playerPers = types.Actor.stats.attributes.personality(self).modified\n\n    local playerFatigueTerm = 1.25\n    local npcFatigueTerm = 1.25\n\n    -- Calculate the remaining parts of the function using the provided variables/methods\n    local clampedDisposition = util.clamp(types.NPC.getDisposition(npc, self), 0, 100)\n    local a = math.min(playerMerc, 100)\n    local b = math.min(0.1 * playerLuck, 10)\n    local c = math.min(0.2 * playerPers, 10)\n    local d = math.min(types.NPC.stats.skills.mercantile(npc).modified, 100)\n    local e =\n        math.min(0.1 * types.Actor.stats.attributes.luck(npc).modified, 10)\n    local f = math.min(0.2 *\n        types.Actor.stats.attributes.personality(npc)\n        .modified, 10)\n    local pcTerm = (clampedDisposition - 50 + a + b + c) * playerFatigueTerm\n    local npcTerm = (d + e + f) * npcFatigueTerm\n    local buyTerm = 0.01 * (100 - 0.5 * (pcTerm - npcTerm))\n    local sellTerm = 0.01 * (50 - 0.5 * (npcTerm - pcTerm))\n    local offerPrice = math.floor(basePrice * item.count * (buying and buyTerm or sellTerm))\n    return math.max(1, offerPrice)\nend\n\nfunction M.uiMessageMenu(e)\n    if e == 2 then player:sendEvent(\"ambientPlaySound\", {id=\"Menu Click\"}) return end\n    player:sendEvent(\"ambientPlaySound\", {id=\"Item Gold Up\"})\n    player:sendEvent(\"anpResetTooltip\")\n    local item, npc = purchase.item, purchase.npc\n    item.owner.recordId = nil\n    local gold = types.Actor.inventory(player):find(\"gold_001\")\n    local pay = gold:split(purchase.price)\n    pay:moveInto(npc)\n    if item.parentContainer then\n\titem:moveInto(player)\n    else\n        item:activateBy(player)\n    end\n                    --Add <barter success> disposition to NPC\n    types.NPC.modifyBaseDisposition(npc, player, core.getGMST(\"iBarterSuccessDisposition\"))\nend\n\n---Open the dialog to purchase an item\n---@param itemRef tes3reference\n---@param owner tes3mobileNPC\n---@param price number\nlocal function openPurchaseMenu(itemRef, owner, price)\n    print(\"Opening purchase menu for\", itemRef.recordId)\n    local itemName = itemRef.type.record(itemRef).name\n    if itemRef.count > 1 then itemName = itemName .. \" (\" .. itemRef.count .. \")\" end\n    local ownerName = types.NPC.record(owner).name\n    purchase.npc, purchase.item, purchase.price = owner, itemRef, price\n    player:sendEvent(\"apMessageMenu\", {\n        message = string.format(l10n(\"PurchaseMessage\"), itemName, price, ownerName),\n        buttons = { core.getGMST(\"sYes\"), core.getGMST(\"sNo\") }\n    })\n    player:sendEvent(\"ambientPlaySound\", {id=\"Menu Click\"})\nend\n\n---Check if the player is looking at an item and is in a state where they can purchase it\n---@param target tes3reference\n---@return boolean\nlocal function canPurchase(target)\n    local id = target.recordId\n    if id:find(\"^gold_\") then\n--        print(\"Cannot purchase\", id, \"- Target is gold\")\n        return false\n    end\n    local ownerId = target.owner.recordId\n    if not ownerId or not types.NPC.record(ownerId) then\n--        print(\"Cannot purchase\", id, \"- No NPC owner\")\n        return false\n    end\n    if not tradesItemType(ownerId, target) then\n        print(\"Cannot purchase\", id, \"- Owner does not trade this item type\")\n        return false\n    end\n    print(\"Can purchase\", id)\n    return true\nend\n\nlocal function getPlayerGold()\n\tlocal gold = types.Actor.inventory(player):find(\"gold_001\")\n\tif not gold then return 0 end\n\treturn gold.count\nend\n\n---Purchase an item by activating it\n---@param e activateEventData\nfunction M.onActivate(target, actor)\n    player = actor\n    if not canPurchase(target) then\n--        print(\"Cannot purchase\", target.recordId)\n        return true\n    end\n    local owner = getOwner(target)\n    if not owner then\n        player:sendEvent(\"apShowMessage\", string.format(l10n(\"msg_sellermissing\"),\n            types.NPC.record(target.owner.recordId).name))\n        player:sendEvent(\"ambientPlaySound\", {id=\"Menu Click\"})\n        return false\n    end\n    if owner and types.Actor.isDead(owner) then\n        player:sendEvent(\"apShowMessage\", string.format(l10n(\"msg_sellerdead\"),\n            types.NPC.record(owner).name))\n        player:sendEvent(\"ambientPlaySound\", {id=\"Menu Click\"})\n        return false\n    end\n    local price = getBarterOffer(owner, target, true)\n    --player has enough gold\n    if getPlayerGold() < price then\n        player:sendEvent(\"apShowMessage\", \"NotEnoughGold\")\n        player:sendEvent(\"ambientPlaySound\", {id=\"Menu Click\"})\n        return false\n    end\n    openPurchaseMenu(target, owner, price)\n    return false\nend\n\nreturn M\n",
    "OpenMW Animated Pickup and Shop Around-54585-1-21a-1725831953\\scripts\\AnimatedPickup\\global.lua": "local types = require(\"openmw.types\")\nlocal async = require(\"openmw.async\")\nlocal core = require(\"openmw.core\")\nlocal util = require(\"openmw.util\")\nlocal I = require(\"openmw.interfaces\")\nlocal world = require(\"openmw.world\")\nlocal storage = require(\"openmw.storage\")\n\nlocal direct = require(\"scripts.AnimatedPickup.directPurchase\")\n\nlocal Actor, ST = types.Actor, types.Actor.STANCE\n\nlocal handlers = { types.Activator, types.Apparatus, types.Armor, types.Clothing,\n\ttypes.Ingredient, types.Light, types.Lockpick, types.Miscellaneous,\n\ttypes.Potion, types.Probe, types.Repair, types.Weapon }\n\nlocal players = {}\n\nlocal animating = {}\nlocal quickloot = {}\nlocal cleared = true\n\n\nlocal function verifyPlayer(arg)\n\tif players[arg.id] then return end\n\tplayers[arg.id] = {obj=arg, sneak=false, nosteal=false, direct=true, anim=true, speed=750, speedtk=100}\nend\n\nlocal function isThieving(obj, actor)\n\tlocal block = false\n\tif obj.owner.recordId then block = true end\n\tlocal faction = obj.owner.factionId\n\tif faction then\n\t\tblock = true\n\t\tlocal rank, need = types.NPC.getFactionRank(actor, faction), obj.owner.factionRank\n--\t\tprint(faction, need, rank)\n\t\tif (rank > 0 and need == nil) or rank >= need then block = false end\n\tend\n\tif block then\n\t\tactor:sendEvent(\"apShowMessage\", \"msg_usesneak\")\n\t\tactor:sendEvent(\"ambientPlaySound\", {id=\"Menu Click\"})\n\tend\n\treturn block\nend\n\nlocal function noQuickloot(o, loot)\n\tif not loot then return false end\n--\tprint(\"cancel quickloot \"..o.recordId)\n\to:moveInto(loot.container)\n\tquickloot[o.id] = nil\n\treturn false\nend\n\nlocal function onPickup(o, actor)\n\tif actor.type ~= types.Player then return end\n\tverifyPlayer(actor)\n\tlocal player = players[actor.id]\n\tlocal loot = quickloot[o.id]\n\tlocal directPurchase = true\n\tif loot and loot.blocked then directPurchase = false end\n\tif not player.sneak then\n\t\tif player.direct and not types.Activator.objectIsInstance(o) and directPurchase\n\t\t\tand not direct.onActivate(o, actor) then return noQuickloot(o, loot) end\n\t\tif player.nosteal and isThieving(o, actor) then return noQuickloot(o, loot) end\n\tend\n\t-- skip for ashfall gear\n\tif o.recordId:find(\"^ashfall_\") then return end\n\tif o.type == types.Activator or not players[actor.id].anim or not o.cell\n\t\tor world.mwscript.getLocalScript(o, actor) then\n\t\t\treturn\n\tend\n\t-- skip for takeAll action by quickloot\n\tif loot and loot.blocked then quickloot[o.id] = nil return end\n\tlocal pickup, inTable, slot = false, false, #animating + 1\n\tfor i=1, #animating do\n\t\tif animating[i].obj == o then\n\t\t\tinTable = true\n\t\t\tif not animating[i].valid then slot = i\n\t\t\telseif animating[i].k  == 4 then\n\t\t\t\tpickup = true\n\t\t\t\tanimating[i].valid = false\n\t\t\telse return false\n\t\t\tend\n\t\tend\n\tend\n\t-- check object hasn't been deleted and is still in the world\n\tif not o:isValid() then return false end\n\tif pickup then\n\t\tif loot then quickloot[o.id] = nil end\n\t\treturn\n\tend\n\tif inTable and not animating[slot] then return false end\n--\tprint(slot, inTable, cleared)\n\tif cleared and #animating > 10 then animating = {} slot = 1 end\n\tlocal npc, gender = types.NPC.record(actor), \"female\"\n\tif npc.isMale then gender = \"male\" end\n\tlocal height = 128 * types.NPC.races.record(npc.race).height[gender] * actor.scale\n\tlocal speed, maxK = players[actor.id].speed, 0.7\n\tlocal distance = (actor.position - o.position):length()\n\tif Actor.activeEffects(actor):getEffect(\"telekinesis\").magnitude > 0 and distance > 220 then\n\t\tspeed = players[actor.id].speedtk\n\t\tmaxK = 1 - (60 / distance)\n\tend\n\tlocal start = o.position\n\tif loot then start = loot.container.position end\n\tanimating[slot] = {obj=o, actor=actor, startPos=start, height=height,\n\t\tspeed=speed, k=0, maxK=maxK, valid=true}\n\tcleared = false\n\treturn false\nend\n\nfor i = 1, #handlers do\n  I.Activation.addHandlerForType(handlers[i], function(o, actor) return onPickup(o, actor) end)\nend\n\nlocal function playerUpdate(e)\n\tlocal actor = e.player\n\tif not actor or actor.type ~= types.Player then return end\n\tverifyPlayer(actor)\n\tif e.sneak ~=nil then players[actor.id].sneak = e.sneak end\n\tif e.nosteal ~=nil then players[actor.id].nosteal = e.nosteal end\n\tif e.direct ~=nil then players[actor.id].direct = e.direct end\n\tif e.anim ~= nil then players[actor.id].anim = e.anim end\n\tif e.spd then players[actor.id].speed = e.spd end\n\tif e.spdtk then players[actor.id].speedtk = e.spdtk end\n--\tprint(\"sneaking\", players[actor.id].sneak, \"nosteal\", players[actor.id].nosteal, \"anim\", players[actor.id].anim)\nend\n\nlocal function onUpdate(dt)\n\tif cleared then return end\n\tcleared = true\n\tfor i=1, #animating do\n\t\tlocal data = animating[i]\n\t\tlocal o = data.obj\n\t\t-- check object hasn't been deleted and is still in the world\n\t\tif not o:isValid() or not o.cell then data.valid = false end\n\t\tif data.k < 1 and data.valid then\n\t\t\tcleared = false\n\t\t\tlocal playerPos = data.actor.position\n\t\t\tplayerPos = playerPos + util.vector3(0, 0, data.height * 0.6)\n\t\t\tlocal k = data.k + data.speed * 0.01 * dt\n\t\t\tif o.cell == data.actor.cell then\n\t\t\t\tlocal destVec = (playerPos - data.startPos) * k\n\t\t\t\to:teleport(o.cell, data.startPos + destVec)\n\t\t\telse data.valid = false\n\t\t\tend\n\t\t\tif k >= data.maxK then\n\t\t\t\tk = 1\n\t\t\tend\n\t\t\tdata.k = k\n\t\telseif data.k < 4 and data.valid then\n\t\t\t-- leave 3 frame gap between end of animate and activateBy command\n\t\t\tdata.k = data.k + 1\n\t\t\tcleared = false\n\t\t\tif data.k > 3 then o:activateBy(data.actor) end\n\t\tend\n\tend\nend\n\nlocal function logQuickloot(e)\n\tlocal player, container, o = unpack(e)\n\tif not player or not container then return end\n\tlocal type = types.Actor\n\tif types.Container.objectIsInstance(container) then type = types.Container end\n\tif not o then\n\t\tfor k, v in pairs(type.inventory(container):getAll()) do\n\t\t\tquickloot[v.id] = { object=v, player=player, container=container, blocked=true }\n--\t\t\tprint(\"LOGGED \"..k..\" \"..v.recordId)\n\t\tend\n\telse\n\t\tloot = { object=object, player=player, container=container }\n\t\tquickloot[o.id] = { object=object, player=player, container=container }\n--\t\tprint(\"LOGGED \"..o.recordId)\n\tend\nend\n\nreturn {\n\tengineHandlers = { onUpdate = onUpdate, onPlayerAdded = verifyPlayer },\n\teventHandlers = { anpPlayerUpdate = playerUpdate,\n\t\tapMessageMenu = direct.uiMessageMenu,\n\t\tOwnlysQuickLoot_take = logQuickloot,\n\t\tOwnlysQuickLoot_takeAll = logQuickloot\n }\n}\n",
    "OpenMW Animated Pickup and Shop Around-54585-1-21a-1725831953\\scripts\\AnimatedPickup\\player.lua": "local self = require(\"openmw.self\")\nlocal types = require(\"openmw.types\")\nlocal input = require(\"openmw.input\")\nlocal async = require(\"openmw.async\")\nlocal core = require(\"openmw.core\")\nlocal camera = require(\"openmw.camera\")\nlocal nearby = require(\"openmw.nearby\")\nlocal ambient = require(\"openmw.ambient\")\nlocal ui = require(\"openmw.ui\")\nlocal I = require(\"openmw.interfaces\")\nlocal util = require(\"openmw.util\")\nlocal storage = require(\"openmw.storage\")\nlocal l10n = core.l10n(\"AnimatedPickup\")\n\nlocal MD = camera.MODE\nlocal sneaking = false\nlocal animPickup, camMode = false, nil\nlocal buyDirect, sneakSteal = true, false\nlocal v2 = util.vector2\n\n\nI.Settings.registerPage {\n   key = \"animPickup\",\n   l10n = \"AnimatedPickup\",\n   name = \"settings_modName\",\n   description = \"settings_modDesc\"\n}\n\nI.Settings.registerGroup({\n   key = \"Settings_animPickup_player\",\n   page = \"animPickup\",\n   l10n = \"AnimatedPickup\",\n   name = \"settings_modCategory1_name\",\n   permanentStorage = true,\n   settings = {\n\t{key = \"animatespd\",\n\tdefault = 750,\n\trenderer = \"number\",\n\tname = \"settings_modCategory1_setting01_name\",\n\targument = { min = 1, max = 2000 },\n\t},\n\t{key = \"animatespdtk\",\n\tdefault = 100,\n\trenderer = \"number\",\n\tname = \"settings_modCategory1_setting02_name\",\n\targument = { min = 1, max = 2000 },\n\t},\n\t{key = \"animate1st\",\n\tdefault = true,\n\trenderer = \"checkbox\",\n\tname = \"settings_modCategory1_setting03_name\",\n\t},\n\t{key = \"animate3rd\",\n\tdefault = true,\n\trenderer = \"checkbox\",\n\tname = \"settings_modCategory1_setting04_name\",\n\t},\n\t{key = \"nosteal\",\n\tdefault = false,\n\trenderer = \"checkbox\",\n\tname = \"settings_modCategory1_setting05_name\",\n\t},\n\t{key = \"buydirect\",\n\tdefault = true,\n\trenderer = \"checkbox\",\n\tname = \"settings_modCategory1_setting06_name\",\n\t},\n   },\n})\n\nlocal settings = storage.playerSection(\"Settings_animPickup_player\")\n\nlocal function updateSettings()\n\tcamMode = camera.getMode()\n\tlocal anim = false\n\tif settings:get(\"animate1st\") and camMode == MD.FirstPerson then anim = true end\n\tif settings:get(\"animate3rd\") and ( camMode == MD.ThirdPerson or camMode == MD.Preview )\n\t\tthen anim = true end\n\tbuyDirect = settings:get(\"buydirect\")\n\tsneakSteal = settings:get(\"nosteal\")\n\tcore.sendGlobalEvent(\"anpPlayerUpdate\", {player=self, nosteal=settings:get(\"nosteal\"),\n\t\tanim=anim, spd=settings:get(\"animatespd\"), spdtk=settings:get(\"animatespdtk\"),\n\t\tdirect=buyDirect})\nend\n\nsettings:subscribe(async:callback(updateSettings))\nupdateSettings()\n\nlocal function gmstToRgb(id)\n\tlocal gmst = core.getGMST(id)\n\tif not gmst then return util.color.rgb(0.6, 0.6, 0.6) end\n\tlocal col = {}\n\tfor v in string.gmatch(gmst, \"(%d+)\") do col[#col + 1] = tonumber(v) end\n\tif #col ~= 3 then print(\"Invalid RGB from \"..gmst..\" \"..id) return util.color.rgb(0.6, 0.6, 0.6) end\n\treturn util.color.rgb(col[1] / 255, col[2] / 255, col[3] / 255)\nend\n\nlocal uiTheme = {\n\tnormal = gmstToRgb(\"FontColor_color_normal\"),\n\tsteal = util.color.rgb(1, 0.15, 0.15),\n\tsize = 16,\n\t}\n\n\nlocal merchants = {}\n\nlocal function getOwner(reference)\n    local id = reference.owner.recordId\n    local owner = merchants[id]\n    if owner then\n        local o = owner.object\n        if o and o:isValid() then\n            if o.cell ~= reference.cell then o = nil end\n            return o\n        end\n    end\n    if owner and owner.scanned == reference.cell then return end\n    print(\"SCAN for merchant \"..id)\n    local actor\n    for _, v in ipairs(nearby.actors) do\n        if v.recordId == id then actor = v end\n    end\n    merchants[id] = {scanned=reference.cell}\n    if actor then merchants[id].object = actor end\n    return actor\nend\n\nlocal typeToService = {\n\t[types.Apparatus] = \"Apparatus\",\n\t[types.Armor] = \"Armor\",\n--\t[types.Book] = \"Books\",\n\t[types.Clothing] = \"Clothing\",\n\t[types.Ingredient] = \"Ingredients\",\n\t[types.Light] = \"Lights\",\n\t[types.Lockpick] = \"Picks\",\n\t[types.Miscellaneous] = \"Misc\",\n\t[types.Potion] = \"Potions\",\n\t[types.Probe] = \"Probes\",\n\t[types.Repair] = \"RepairItems\",\n\t[types.Weapon] = \"Weapon\"\n\t}\n\nlocal function tradesItemType(id, item)\n    local services = types.NPC.record(id).servicesOffered\n    if not services.Barter then return false end\n    if types.Item.itemData(item).enchantmentCharge then\n        if services.MagicItems then return true end\n        return false\n    end\n    local serviceType = typeToService[item.type]\n    return services[serviceType]\nend\n\n    \nlocal timer = 0\nlocal tooltip, target, toolIcon\n\nlocal function onUpdate()\n\tif camera.getMode() ~= camMode then updateSettings() end\n\tif self.controls.sneak == sneaking then return end\n\tsneaking = self.controls.sneak\n\tif tooltip or (sneaking and sneakSteal) then target = nil end\n\tcore.sendGlobalEvent(\"anpPlayerUpdate\", {player=self, sneak=sneaking,\n\t\tnosteal=settings:get(\"nosteal\"), direct=settings:get(\"buydirect\")})\nend\n\nlocal function onFrame(dt)\n\ttimer = timer + dt\n\tif timer < 0.1 then return end\n\ttimer = 0\n\tif not buyDirect and not sneakSteal then return end\n\tlocal pos = camera.getPosition()\n\tlocal posTarget = pos + camera.viewportToWorldVector(v2(0.5,0.5))\n\t\t* (220 + camera.getThirdPersonDistance())\n\tlocal res = nearby.castRenderingRay(pos, posTarget, { ignore = self })\n\tlocal o = res.hitObject\n\tif target and o == target then return end\n\tif tooltip then tooltip:destroy() tooltip = nil end\n\ttarget = o\n--\tif o then print(o.recordId) end\n\tif not o or not types.Item.objectIsInstance(o) or types.Book.objectIsInstance(o) then return end\n    local ownerId = o.owner.recordId\n    local factionId = o.owner.factionId\n    if not ownerId and not factionId then return end\n\n    if factionId then\n        local rank = o.owner.factionRank or 1\n        if sneakSteal and not sneaking then return end\n        if types.NPC.getFactionRank(self, factionId) >= rank then return end\n        toolIcon = \"take.dds\"\n    elseif ownerId then\n        if not buyDirect and sneakSteal and not sneaking then return end\n        local trade\n        if types.NPC.record(ownerId) then trade = tradesItemType(ownerId, o) end\n        toolIcon = \"take.dds\"\n        if o.recordId:find(\"^gold_\") then trade = false end\n        if sneakSteal and not sneaking and not trade then return end\n        if buyDirect and trade and not sneaking then toolIcon = \"directPurchase.dds\" end\n    end\n\n    local col = uiTheme.normal\n    if toolIcon == \"take.dds\" then col = uiTheme.steal end\n--    local owner = getOwner(o)\n--    if not owner then return end\n--    if not tradesItemType(ownerId, o) then return end\n    tooltip = ui.create { layer = 'HUD', type = ui.TYPE.Image,\n            props = {\n                visible = true,\n                relativePosition = v2(0.505, 0.505),\n                size = v2(32, 32),\n                resource = ui.texture { path = \"textures/AnimatedPickup/\" .. toolIcon },\n                color = col,\n            },\n        }\nend\n\nlocal messageBox\nI.UI.setPauseOnMode(I.UI.MODE.QuickKeysMenu, false)\n\nlocal function uiClick(_, e)\n--\tfor k, v in pairs(e) do print(k, v) end\n--\tprint(e.userData)\n\tmessageBox:destroy()\n\tmessageBox = nil\n\tI.UI.removeMode(I.UI.MODE.QuickKeysMenu)\n        core.sendGlobalEvent(\"apMessageMenu\", e.userData)\nend\n\nlocal function Container(options)\n    options = options or {}\n\n    local color = options.color and options.color or util.color.hex(\"000000\")\n    local alpha = options.alpha or 0\n    local padding = options.padding and options.padding or 0\n\n    if type(padding) == \"number\" then\n        padding = { left = padding, right = padding, top = padding, bottom = padding }\n    else\n        padding = {\n            left = padding.left and padding.left or 0,\n            right = padding.right and padding.right or 0,\n            top = padding.top and padding.top or 0,\n            bottom = padding.bottom and padding.bottom or 0\n        }\n    end\n\n    local template = {\n        type = ui.TYPE.Container,\n        content = ui.content {\n            {\n                type = ui.TYPE.Image,\n                props = {\n                    relativeSize = util.vector2(1, 1),\n                    resource = ui.texture { path = \"white\" },\n                    color = color,\n                    alpha = alpha,\n                    size = util.vector2(padding.left + padding.right, padding.top + padding.bottom),\n                },\n            },\n            {\n                external = { slot = true },\n                props = {\n                    position = util.vector2(padding.left, padding.top),\n                    relativeSize = util.vector2(1, 1),\n                }\n            },\n        },\n    }\n    return template\nend\n\nlocal function uiButton(k, text, callback)\n    return { type = ui.TYPE.Container, content = ui.content {\n\t{ template = I.MWUI.templates.box, props = { anchor = v2(0, -0.5) },\n\t\tcontent = ui.content { {\n                template = I.MWUI.templates.padding,\n                alignment = ui.ALIGNMENT.Center,\n        \t        content = ui.content { {\n\n\t\t\t\ttype = ui.TYPE.Text,\n\t\t\t\tuserData = k,\n\t\t\t\tevents = { mouseClick = callback },\n\t\t\t\tname = name,\n\t\t\t\tprops = { text = text, align = ui.ALIGNMENT.Center,\n\t\t\t\t\ttextColor = uiTheme.normal, textSize = uiTheme.size }\n\t\t\t} }\n\t\t} }\n\t}\n    } }\nend\n\nlocal function uiMessageMenu(e)\n\tif messageBox then messageBox:destroy() end\n\tI.UI.setMode(I.UI.MODE.QuickKeysMenu, {windows={}})\n\n\tlocal buttons\n\tif e.message then buttons = { {\n                template = I.MWUI.templates.padding,\n                alignment = ui.ALIGNMENT.Center,\n        \t        content = ui.content { {\n\n\t\t\ttype = ui.TYPE.Text,\n\t\t\tprops = {\n\t\t\ttext = e.message, multiline = true,\n\t\t\ttextAlignH = ui.ALIGNMENT.Center,\n\t\t\ttextColor = uiTheme.normal,\n\t\t\ttextSize = uiTheme.size\n\t        \t}\n\n\t\t} }\n\t} }\n\telse buttons = {}\n\tend\n\n\tfor k, item in ipairs(e.buttons) do\n\t\tlocal button = uiButton(k, item, async:callback(uiClick))\n\t\ttable.insert(buttons, button)\n\tend\n    messageBox = ui.create {\n        layer = \"Windows\",\n        template = I.MWUI.templates.boxTransparentThick,\n        props = {\n            relativePosition = v2(0.5, 0.7),\n            anchor = v2(0.5, 0.5),\n            align = ui.ALIGNMENT.Center,\n            arrange = ui.ALIGNMENT.Center\n        },\n        content = ui.content {\n\n            { template = Container({ alpha = 0.0, padding = 8, color = util.color.hex(\"00ff00\") }),\n            content = ui.content {\n\n                { type = ui.TYPE.Flex,\n                content = ui.content(buttons),\n                props = {\n                    horizontal = false,\n                    align = ui.ALIGNMENT.Center,\n                    arrange = ui.ALIGNMENT.Center,\n--                    relativeSize = v2(1, 1),\n--                    size = v2(40, 40),\n                } },\n\n            } },\n         }\n    }\nend\n\nlocal cancelModes = {\n\t[I.UI.MODE.QuickKeysMenu] = true,\n\t[I.UI.MODE.Dialogue] = true,\n\t[I.UI.MODE.Book] = true,\n\t[I.UI.MODE.Scroll] = true,\n\t[I.UI.MODE.Journal] = true,\n\t[I.UI.MODE.Barter] = true,\n\t[I.UI.MODE.Alchemy] = true,\n\t[I.UI.MODE.Companion] = true\n}\n\nreturn {\n\tengineHandlers = { onUpdate = onUpdate, onFrame = onFrame,\n\t\tonMouseButtonPress = function(e)\n\t\t\tif e ~= 3 then return end\n\t\t\tif messageBox then messageBox:destroy() messageBox=nil end\n\t\t\tlocal mode = I.UI.getMode()\n\t\t\tif cancelModes[mode] then I.UI.setMode() end\n\t\tend,\n\t},\n\teventHandlers = { apShowMessage = function(data) ui.showMessage(l10n(data)) end,\n\t\tambientPlaySound = function(data) ambient.playSound(data.id, data.options) end,\n\t\tUiModeChanged = function(e) if messageBox and e.oldMode == I.UI.MODE.QuickKeysMenu then\n\t\t\tmessageBox:destroy() messageBox=nil end end,\n\t\tapMessageMenu = uiMessageMenu,\n\t\tanpResetTooltip = function() target = nil if tooltip then tooltip:destroy() end end\n\t}\n}\n"
  }
}