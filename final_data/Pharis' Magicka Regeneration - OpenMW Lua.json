{
  "folder_name": "Pharis' Magicka Regeneration - OpenMW Lua",
  "lua_files": {
    "Pharis' Magicka Regeneration-52779-1-2-1-1705209567\\Scripts\\Pharis\\PharisMagickaRegeneration\\actor.lua": "--[[\n\nMod: Pharis' Magicka Regeneration\nAuthor: Pharis\n\n--]]\n\nlocal async = require(\"openmw.async\")\nlocal core = require(\"openmw.core\")\nlocal self = require(\"openmw.self\")\nlocal storage = require(\"openmw.storage\")\nlocal time = require(\"openmw_aux.time\")\nlocal types = require(\"openmw.types\")\nlocal util = require('openmw.util')\n\nif core.API_REVISION < 39 then\n\terror(\"This mod requires a newer version of OpenMW, please update.\")\nend\n\nlocal modInfo = require(\"Scripts.Pharis.PharisMagickaRegeneration.modinfo\")\n\nlocal generalSettings = storage.globalSection(\"SettingsGlobal\" .. modInfo.name)\nlocal gameplaySettings = storage.globalSection(\"SettingsGlobal\" .. modInfo.name .. \"Gameplay\")\n\nlocal max = math.max\nlocal min = math.min\n\nlocal TICK_INTERVAL = time.second / 10\n\nlocal STUNTED_MAGICKA = core.magic.EFFECT_TYPE.StuntedMagicka\n\nlocal runOnSelf\nlocal stopTickTimerFn\n\nlocal magickaHandlers = {}\n\n-- Data saved and compared against each tick\nlocal prevGameTime = -1\nlocal prevGameTimeScale = -1\n\nlocal regenSuppressed = false\nlocal suppressRegenSecondsPassed = 0\nlocal suppressRegenTotalSeconds = -1\n\nlocal fatigueStat = types.Actor.stats.dynamic.fatigue(self)\nlocal healthStat = types.Actor.stats.dynamic.health(self)\nlocal magickaStat = types.Actor.stats.dynamic.magicka(self)\nlocal willpowerStat = types.Actor.stats.attributes.willpower(self)\nlocal activeEffects = types.Actor.activeEffects(self)\n\n---Temporarily halt all magicka regeneration for the duration of the timer. If 'force' is false or nil 'seconds' values less\n---than or equal to remaining timer duration will be ignored and higher values will overwrite and reset current timer. Pass a\n---'force' value of true to always overide regardless of current timer remaining time.\n---@param seconds number Timer duration in seconds.\n---@param force any boolean or nil Force override any current timer regardless of time remaining.\n---@return boolean Whether suppression was successfully applied.\nlocal function suppressRegen(seconds, force)\n\tif (not force) and (seconds <= suppressRegenTotalSeconds - suppressRegenSecondsPassed) then return false end\n\tsuppressRegenSecondsPassed = 0\n\tsuppressRegenTotalSeconds = seconds\n\tregenSuppressed = true\n\treturn true\nend\n\n---Remove active regeneration suppression. This will have no effect on\n---regeneration stopped by the Stunted Magicka effect. Be wary of\n---possible incompatibilities with other mods using the interface.\nlocal function removeSuppression()\n\tsuppressRegenSecondsPassed = 0\n\tsuppressRegenTotalSeconds = -1\n\tregenSuppressed = false\nend\n\nlocal function magickaRegenTick()\n\tlocal currentMagickaCurrent = magickaStat.current\n\tlocal currentMagickaBase = magickaStat.base\n\tlocal currentGameTimeScale = core.getGameTimeScale()\n\tlocal currentGameTime = core.getGameTime()\n\n\t-- Early out if current >= base, checking anything else is just a waste\n\t-- Still need to save data on skipped ticks so it doesn't get out of date\n\t-- which would trigger excessive regen on next successful tick\n\tif (currentMagickaCurrent >= currentMagickaBase)\n\t\tor (healthStat.current <= 0)\n\t\tor (regenSuppressed)\n\t\tor (activeEffects:getEffect(STUNTED_MAGICKA).magnitude ~= 0)\n\t\tor (prevGameTime == -1)\n\t\tor (prevGameTimeScale == -1) then\n\t\tprevGameTimeScale = currentGameTimeScale\n\t\tprevGameTime = currentGameTime\n\t\treturn\n\tend\n\n\t-- Fatigue\n\t-- Neutral fatigue ratio range [0.5, 0.75]\n\tlocal fatigueMultiplier = 1.0\n\tlocal fatigueRatio = util.clamp(fatigueStat.current / fatigueStat.base, 0, 1)\n\tif (fatigueRatio < 0.5) then\n\t\tif (fatigueRatio <= 0.25) then\n\t\t\tfatigueMultiplier = 0.5 + 1.4 * fatigueRatio\n\t\telse\n\t\t\tfatigueMultiplier = 0.7 + 0.6 * fatigueRatio\n\t\tend\n\telseif (fatigueRatio > 0.75) then\n\t\tif (fatigueRatio <= 0.9) then\n\t\t\tfatigueMultiplier = 0.5 + (fatigueRatio * 2 / 3)\n\t\telse\n\t\t\tfatigueMultiplier = -0.25 + (1.5 * fatigueRatio)\n\t\tend\n\tend\n\n\t-- Willpower\n\tlocal currentWillpowerModified = willpowerStat.modified\n\tlocal willpowerMultiplier\n\tif (currentWillpowerModified <= 40) then\n\t\twillpowerMultiplier = 1 + currentWillpowerModified / 40\n\telseif (currentWillpowerModified <= 60) then\n\t\twillpowerMultiplier = -2 + currentWillpowerModified / 10\n\telseif (currentWillpowerModified <= 85) then\n\t\twillpowerMultiplier = -6.8 + 0.18 * currentWillpowerModified\n\telseif (currentWillpowerModified <= 100) then\n\t\twillpowerMultiplier = currentWillpowerModified / 10\n\telseif (currentWillpowerModified <= 200) then\n\t\twillpowerMultiplier = 5 + currentWillpowerModified / 20\n\telseif (currentWillpowerModified <= 300) then\n\t\twillpowerMultiplier = 11 + currentWillpowerModified / 50\n\telseif (currentWillpowerModified <= 500) then\n\t\twillpowerMultiplier = 14 + currentWillpowerModified / 100\n\telse\n\t\twillpowerMultiplier = 16.5 + currentWillpowerModified / 200\n\tend\n\n\twillpowerMultiplier = max(willpowerMultiplier, 1)\n\n\t-- Regeneration Decay\n\tlocal lowMagickaRegenerationBoostMultiplier = gameplaySettings:get(\"enableLowMagickaRegenerationBoost\") and\n\t\t1 + ((1 - currentMagickaCurrent / currentMagickaBase) / 2) or 1\n\n\t-- Apply multipliers\n\tlocal regenerationRate = 0.5 * gameplaySettings:get(\"baseMultiplier\") * fatigueMultiplier * willpowerMultiplier *\n\t\tlowMagickaRegenerationBoostMultiplier\n\n\t-- Magicka per game second * game seconds passed since last tick\n\tlocal calculatedMagicka = { delta = (regenerationRate / max(currentGameTimeScale, prevGameTimeScale, 1)) *\n\t\t\t(currentGameTime - prevGameTime) }\n\n\t-- Run all registered handlers before clamping\n\tfor _, handler in ipairs(magickaHandlers) do\n\t\thandler(calculatedMagicka)\n\tend\n\n\t-- Prevent overflow\n\tlocal magickaDelta = min(calculatedMagicka.delta, currentMagickaBase - currentMagickaCurrent)\n\n\tif (magickaDelta > 0) then\n\t\tmagickaStat.current = magickaStat.current + magickaDelta\n\tend\n\n\tprevGameTime = currentGameTime\n\tprevGameTimeScale = currentGameTimeScale\nend\n\n-- Logic for determining whether the actor the script is on should recieve magicka ticks.\n-- This check runs when an actor becomes active or whenever any settings are changed\n-- and will automatically start or stop the magicka tick timer\nlocal function updateSelfRunState()\n\trunOnSelf = generalSettings:get(\"modEnable\") and\n\t\t((types.Player.objectIsInstance(self) and gameplaySettings:get(\"enablePlayerRegeneration\"))\n\t\t\tor (types.NPC.objectIsInstance(self) and gameplaySettings:get(\"enableNPCRegeneration\"))\n\t\t\tor (types.Creature.objectIsInstance(self) and gameplaySettings:get(\"enableCreatureRegeneration\")))\n\n\tif (runOnSelf) then\n\t\tif (stopTickTimerFn) then return end\n\t\tstopTickTimerFn = time.runRepeatedly(\n\t\t\tmagickaRegenTick,\n\t\t\tTICK_INTERVAL\n\t\t)\n\t\treturn\n\tend\n\n\t-- Causes first tick after mod is re-enabled to be skipped to prevent huge amount of\n\t-- regen because of how much time has passed since mod was disabled\n\tprevGameTime = -1\n\tprevGameTimeScale = -1\n\n\tif (stopTickTimerFn) then stopTickTimerFn() end\nend\n\ngeneralSettings:subscribe(async:callback(updateSelfRunState))\ngameplaySettings:subscribe(async:callback(updateSelfRunState))\n\nlocal function onUpdate(dt)\n\t-- Ignore runOnSelf and timer state here as suppression timer should run out regardless\n\tif (regenSuppressed) then\n\t\tsuppressRegenSecondsPassed = suppressRegenSecondsPassed + dt\n\t\tif (suppressRegenSecondsPassed >= suppressRegenTotalSeconds) then removeSuppression() end\n\tend\nend\n\n---Get remaining time on regeneration suppression timer in seconds.\n---@return number seconds\nlocal function getSuppressionSecondsRemaining()\n\treturn suppressRegenTotalSeconds ~= -1 and suppressRegenTotalSeconds - suppressRegenSecondsPassed or 0\nend\n\n---Add new handler that will be called every regeneration tick\n---to edit the magicka delta for that tick after stat-based\n---calculations are done. Magicka delta will be clamped to\n---prevent overflow after all handlers are called.\n---@param handler function The handler\nlocal function addMagickaHandler(handler)\n\tmagickaHandlers[#magickaHandlers + 1] = handler\nend\n\nlocal interface = {\n\tversion = 1,\n\tsuppressRegen = suppressRegen,\n\tremoveSuppression = removeSuppression,\n\tgetSuppressionSecondsRemaining = getSuppressionSecondsRemaining,\n\taddMagickaHandler = addMagickaHandler\n}\n\nreturn {\n\tengineHandlers = {\n\t\tonActive = updateSelfRunState,\n\t\tonUpdate = onUpdate\n\t},\n\tinterfaceName = \"PharisMagickaRegeneration\",\n\tinterface = interface\n}\n",
    "Pharis' Magicka Regeneration-52779-1-2-1-1705209567\\Scripts\\Pharis\\PharisMagickaRegeneration\\modinfo.lua": "--[[\n\nMod: Pharis' Magicka Regeneration\nAuthor: Pharis\n\n--]]\n\nreturn {\n\tname = \"PharisMagickaRegeneration\",\n\tversion = \"1.2.0\"\n}\n",
    "Pharis' Magicka Regeneration-52779-1-2-1-1705209567\\Scripts\\Pharis\\PharisMagickaRegeneration\\settings.lua": "--[[\n\nMod: Pharis' Magicka Regeneration\nAuthor: Pharis\n\n--]]\n\nlocal I = require(\"openmw.interfaces\")\n\nlocal modInfo = require(\"Scripts.Pharis.PharisMagickaRegeneration.modinfo\")\n\n-- Page description(s)\nlocal pageDescription = \"By Pharis\\nv\" .. modInfo.version .. \"\\n\\nMagicka regeneration for players, NPCs, and creatures.\"\n\nI.Settings.registerPage {\n\tkey = modInfo.name,\n\tl10n = modInfo.name,\n\tname = \"Pharis' Magicka Regeneration\",\n\tdescription = pageDescription\n}\n",
    "Pharis' Magicka Regeneration-52779-1-2-1-1705209567\\Scripts\\Pharis\\PharisMagickaRegeneration\\settingsglobal.lua": "--[[\n\nMod: Pharis' Magicka Regeneration\nAuthor: Pharis\n\n--]]\n\nlocal I = require(\"openmw.interfaces\")\n\nlocal modInfo = require(\"Scripts.Pharis.PharisMagickaRegeneration.modinfo\")\n\n-- Magicka regeneration settings description(s)\nlocal modEnableDescription = \"To mod or not to mod.\"\nlocal enableLowMagickaRegenerationBoostDescription = \"Increases magicka regeneration at lower magicka ratios. Note that disabling this will effectively lower regeneration so you may want to raise the multiplier as well.\"\nlocal baseMultiplierDescription = \"Base regeneration multiplier. Gets real unbalanced real fast.\\n[0.01,100.0]\"\n\nlocal function setting(key, renderer, argument, name, description, default)\n\treturn {\n\t\tkey = key,\n\t\trenderer = renderer,\n\t\targument = argument,\n\t\tname = name,\n\t\tdescription = description,\n\t\tdefault = default,\n\t}\nend\n\nI.Settings.registerGroup {\n\tkey = \"SettingsGlobal\" .. modInfo.name,\n\tpage = modInfo.name,\n\torder = 0,\n\tl10n = modInfo.name,\n\tname = \"General\",\n\tpermanentStorage = false,\n\tsettings = {\n\t\tsetting(\"modEnable\", \"checkbox\", {}, \"Enable Mod\", modEnableDescription, true),\n\t}\n}\n\nI.Settings.registerGroup {\n\tkey = \"SettingsGlobal\" .. modInfo.name .. \"Gameplay\",\n\tpage = modInfo.name,\n\torder = 1,\n\tl10n = modInfo.name,\n\tname = \"Gameplay\",\n\tdescription = \"\",\n\tpermanentStorage = false,\n\tsettings = {\n\t\tsetting(\"enablePlayerRegeneration\", \"checkbox\", {}, \"Enable Player Regeneration\", \"\", true),\n\t\tsetting(\"enableNPCRegeneration\", \"checkbox\", {}, \"Enable NPC Regeneration\", \"\", true),\n\t\tsetting(\"enableCreatureRegeneration\", \"checkbox\", {}, \"Enable Creature Regeneration\", \"\", true),\n\t\tsetting(\"enableLowMagickaRegenerationBoost\", \"checkbox\", {}, \"Enable Low Magicka Regeneration Boost\", enableLowMagickaRegenerationBoostDescription, true),\n\t\tsetting(\"baseMultiplier\", \"number\", {min = 0.01, max = 100.0}, \"Base Multiplier\", baseMultiplierDescription, 1.0),\n\t},\n}\n\nprint(\"[\" .. modInfo.name .. \"] Initialized v\" .. modInfo.version)\n"
  }
}