{
  "folder_name": "(OpenMW 0.49) Fortify Nerf",
  "lua_files": {
    "Fortify Nerf-54865-1-2-1718992576\\FortifyNerf\\scripts\\FortifyNerf\\FortNerf_p.lua": "local ui = require('openmw.ui')\nlocal I = require(\"openmw.interfaces\")\nlocal core = require(\"openmw.core\")\nlocal types = require('openmw.types')\nlocal self = require('openmw.self')\nlocal ambient = require('openmw.ambient')\nlocal resources = types.Actor.stats.dynamic\nlocal MODE = I.UI.MODE\nlocal windows = require('scripts.uimodes.windows')\nlocal MOD_NAME = \"FortifyNerf\"\nlocal storage = require('openmw.storage')\nlocal playerSection = storage.playerSection(\"SettingsPlayer\" .. MOD_NAME)\nlocal async = require('openmw.async')\nlocal I = require(\"openmw.interfaces\")\nlocal UI = require('openmw.interfaces').UI\nlocal skills = require('openmw.types').NPC.stats.skills\nlocal attributes = require('openmw.types').Actor.stats.attributes\n--stored on save\n--local nerfedSkills = {}\n--local nerfedAttributes = {}\n--local nerfActive = false\n\n\nnerfUIs = {\n\t[\"Dialogue\"] = true,\n\t[\"Container\"] =true,\n\t[\"SpellBuying\"] = true,\n\t[\"SpellCreation\"] = true,\n\t[\"Barter\"] = true,\n\t[\"Alchemy\"] = true,\n\t[\"Recharge\"] = true,\n\t[\"Enchanting\"] = true,\n\t[\"Training\"] = true,\n\t[\"MerchantRepair\"] = true,\n\t[\"Repair\"] = true,\n\t[\"Travel\"] = true,\n}\n\n\nI.Settings.registerPage {\n\tkey = MOD_NAME,\n\tl10n = MOD_NAME,\n\tname = \"FortifyNerf\",\n\tdescription = \"\"\n}\n\nI.Settings.registerGroup {\n\tkey = \"SettingsPlayer\" .. MOD_NAME,\n\tl10n = MOD_NAME,\n\tname = \"\",\n\tpage = MOD_NAME,\n\tdescription = \"\",\n\tpermanentStorage = true,\n\tsettings = {\n\t\t{\n\t\t\tkey = \"maxDuration\",\n\t\t\tname = \"Fortify Spell Duration For Max Effect\",\n\t\t\tdescription = \"The duration needed by your fortify spells to reach their max magnitude in tradeskill menus.\\nDefault: fEnchantmentConstantDurationMult/2 GMST (100/2 in vanilla)\",\n\t\t\tdefault =core.getGMST(\"fEnchantmentConstantDurationMult\")/2, \n\t\t\trenderer = 'number',\n\t\t\targument = {\n\t\t\t\tmin = 1,\n\t\t\t\tmax = 10000,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tkey = \"buffCap\",\n\t\t\tname = \"Max Temporary Fortify Magnitude\",\n\t\t\tdescription = \"Caps the cumulated magnitude of each fortify type at this value.\\nOnly counts temporary fortify effects\\nAlchemy and magic have their seperate limits\",\n\t\t\tdefault =100, \n\t\t\trenderer = 'number',\n\t\t\targument = {\n\t\t\t\tmin = 1,\n\t\t\t\tmax = 10000,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tkey = \"onlyBestBuff\",\n\t\t\tname = \"onlyBestBuff\",\n\t\t\tdescription = \"Use only the best buff for each attribute/skill (one from alchemy and one from magic)\",\n\t\t\tdefault = true,\n\t\t\trenderer = \"checkbox\",\n\t\t},\n\t\t{\n\t\t\tkey = \"alwaysActive\",\n\t\t\tname = \"alwaysActive\",\n\t\t\tdescription = \"runs every frame and not just when crafting\",\n\t\t\tdefault = true,\n\t\t\trenderer = \"checkbox\",\n\t\t},\n\t\t{\n\t\t\tkey = \"useDurationLeft\",\n\t\t\tname = \"useDurationLeft\",\n\t\t\tdescription = \"instead of the max duration of the buff\",\n\t\t\tdefault = false,\n\t\t\trenderer = \"checkbox\",\n\t\t},\n\t\t\n\t}\n}\nlocal function applyNerf()\n\tlocal skillBuffs = {}\n\tlocal alchemySkillBuffs = {}\n\tlocal attributeBuffs = {}\n\tlocal alchemyAttributeBuffs = {}\n\tfor a,b in pairs(types.Actor.activeSpells(self)) do\n\t\tlocal spell = core.magic.spells.records[b.id]\n\t\tlocal thisSpellSkills = {}\n\t\tlocal thisSpellSkillsTotal = {}\n\t\tlocal thisSpellAttributes = {}\n\t\tlocal thisSpellAttributesTotal = {}\n\t\tfor c,d in pairs(b.effects) do\n\t\t\tif d.id == \"fortifyattribute\" and d.duration then\n\t\t\t\tlocal duration = playerSection:get(\"useDurationLeft\") and d.durationLeft or d.duration\n\t\t\t\tlocal adjustedBuff = math.floor(d.magnitudeThisFrame*(math.max(0,math.min(1, duration / playerSection:get(\"maxDuration\")))))\n\t\t\t\tthisSpellAttributes[d.affectedAttribute] = (thisSpellAttributes[d.affectedAttribute] or 0) + adjustedBuff\n\t\t\t\tthisSpellAttributesTotal[d.affectedAttribute] = (thisSpellAttributesTotal[d.affectedAttribute] or 0) + d.magnitudeThisFrame\n\t\t\telseif d.id == \"fortifyskill\" and d.duration then\n\t\t\t\tlocal duration = playerSection:get(\"useDurationLeft\") and d.durationLeft or d.duration\n\t\t\t\tlocal adjustedBuff = math.floor(d.magnitudeThisFrame*(math.max(0,math.min(1, duration / playerSection:get(\"maxDuration\")))))\n\t\t\t\tthisSpellSkills[d.affectedSkill] = (thisSpellSkills[d.affectedSkill] or 0) + adjustedBuff\n\t\t\t\tthisSpellSkillsTotal[d.affectedSkill] = (thisSpellSkillsTotal[d.affectedSkill] or 0) + d.magnitudeThisFrame\n\t\t\tend\n\t\tend\n\t\tfor attribute,magnitude in pairs(thisSpellAttributes) do\n\t\t\tif spell then\n\t\t\t\tif not attributeBuffs[attribute] then\n\t\t\t\t\tattributeBuffs[attribute]={}\n\t\t\t\tend\n\t\t\t\ttable.insert(attributeBuffs[attribute],{adjusted = thisSpellAttributes[attribute], base = thisSpellAttributesTotal[attribute]})\n\t\t\telse\n\t\t\t\tif not alchemyAttributeBuffs[attribute] then\n\t\t\t\t\talchemyAttributeBuffs[attribute]={}\n\t\t\t\tend\n\t\t\t\ttable.insert(alchemyAttributeBuffs[attribute],{adjusted = thisSpellAttributes[attribute], base = thisSpellAttributesTotal[attribute]})\n\t\t\tend\n\t\tend\n\t\tfor skill,magnitude in pairs(thisSpellSkills) do\n\t\t\tif spell then\n\t\t\t\tif not skillBuffs[skill] then\n\t\t\t\t\tskillBuffs[skill]={}\n\t\t\t\tend\n\t\t\t\ttable.insert(skillBuffs[skill],{adjusted = thisSpellSkills[skill], base = thisSpellSkillsTotal[skill]})\n\t\t\telse\n\t\t\t\tif not alchemySkillBuffs[skill] then\n\t\t\t\t\talchemySkillBuffs[skill]={}\n\t\t\t\tend\n\t\t\t\ttable.insert(alchemySkillBuffs[skill],{adjusted = thisSpellSkills[skill], base = thisSpellSkillsTotal[skill]})\n\t\t\tend\n\t\tend\n\tend\n\tlocal function subcompute(a, s)\n\t\tlocal totalSkillBuffs = {}\n\t\tlocal totalSkillBuffsBase = {}\n\t\tlocal totalAttributeBuffs = {}\n\t\tlocal totalAttributeBuffsBase = {}\n\t\tlocal bestAttributeBuff = {}\n\t\tlocal bestSkillBuff = {}\n\t\tfor attribute,spells in pairs(a) do\n\t\t\tfor i, t in pairs(spells) do\n\t\t\t\ttotalAttributeBuffs[attribute] = (totalAttributeBuffs[attribute] or 0) + t.adjusted\n\t\t\t\ttotalAttributeBuffsBase[attribute] = (totalAttributeBuffsBase[attribute] or 0) + t.base\n\t\t\t\tbestAttributeBuff[attribute] = math.max(bestAttributeBuff[attribute] or 0, t.adjusted)\n\t\t\tend\n\t\tend\n\t\tfor skill,spells in pairs(s) do\n\t\t\tfor i, t in pairs(spells) do\n\t\t\t\ttotalSkillBuffs[skill] = (totalSkillBuffs[skill] or 0) + t.adjusted\n\t\t\t\ttotalSkillBuffsBase[skill] = (totalSkillBuffsBase[skill] or 0) + t.base\n\t\t\t\tbestSkillBuff[skill] = math.max(bestSkillBuff[skill] or 0, t.adjusted)\n\t\t\tend\n\t\tend\n\t\tfor attribute, magnitude in pairs(totalAttributeBuffs) do\n\t\t\tif playerSection:get(\"onlyBestBuff\") then\n\t\t\t\tlocal nerfAmount = totalAttributeBuffsBase[attribute] - math.min(playerSection:get(\"buffCap\"),bestAttributeBuff[attribute])\n\t\t\t\t--print(\"nerfAmount\",nerfAmount)\n\t\t\t\t--print(\"modifier before\",attributes[attribute](self).modifier)\n\t\t\t\tnerfedAttributes[attribute] = (nerfedAttributes[attribute] or 0) + nerfAmount\n\t\t\t\tattributes[attribute](self).modifier = attributes[attribute](self).modifier - nerfAmount\n\t\t\t\t--print(nerfedAttributes[attribute] ,attributes[attribute](self).modifier, nerfAmount,bestAttributeBuff[attribute])\n\t\t\telse\n\t\t\t\tlocal nerfAmount = totalAttributeBuffsBase[attribute] - math.min(playerSection:get(\"buffCap\"),totalAttributeBuffs[attribute])\n\t\t\t\tnerfedAttributes[attribute] = (nerfedAttributes[attribute] or 0) + nerfAmount\n\t\t\t\tattributes[attribute](self).modifier = attributes[attribute](self).modifier - nerfAmount\n\t\t\tend\n\t\tend\n\t\tfor skill, magnitude in pairs(totalSkillBuffs) do\n\t\t\tif playerSection:get(\"onlyBestBuff\") then\n\t\t\t\tlocal nerfAmount = totalSkillBuffsBase[skill] - math.min(playerSection:get(\"buffCap\"),bestSkillBuff[skill])\n\t\t\t\tnerfedSkills[skill] = (nerfedSkills[skill] or 0) + nerfAmount\n\t\t\t\tskills[skill](self).modifier = skills[skill](self).modifier - nerfAmount\n\t\t\telse\n\t\t\t\tlocal nerfAmount = totalSkillBuffsBase[skill] - math.min(playerSection:get(\"buffCap\"),totalSkillBuffs[skill])\n\t\t\t\tnerfedSkills[skill] = (nerfedSkills[skill] or 0) + nerfAmount\n\t\t\t\tskills[skill](self).modifier = skills[skill](self).modifier - nerfAmount\n\t\t\tend\n\t\tend\n\tend\n\tsubcompute(attributeBuffs,skillBuffs)\n\tsubcompute(alchemyAttributeBuffs,alchemySkillBuffs)\n\tnerfActive = true\nend\n\nlocal function undoNerf()\n\tif nerfActive then\n\t\tfor a,b in pairs(nerfedAttributes) do\n\t\t\tattributes[a](self).modifier = attributes[a](self).modifier + b\n\t\tend\n\t\tnerfedAttributes = {}\n\t\tfor a,b in pairs(nerfedSkills) do\n\t\t\tskills[a](self).modifier = skills[a](self).modifier + b\n\t\tend\n\t\tnerfedSkills = {}\n\t\tnerfActive = false\n\tend\nend\n\nfunction uiModeChanged(data)\n\tif playerSection:get(\"alwaysActive\") or data.newMode and nerfUIs[data.newMode] then\n\t\tundoNerf()\n\t\tapplyNerf()\n\telse\n\t\tundoNerf()\n\tend\n\t--if data.newMode and nerfUIs[data.newMode] then\n\t--\tif not nerfActive then\n\t--\t\tapplyNerf()\n\t--\tend\n\t--elseif nerfActive then\n\t--\tundoNerf()\n\t--end\n\t--print(attributes[\"willpower\"](self).modifier)\nend\nlocal function userDataLength (userData)\n\tlocal i = 0\n\tfor _ in pairs(userData) do\n\t\ti=i+1\n\tend\n\treturn i\nend\nlocal activeSpells = userDataLength(types.Actor.activeSpells(self))\nlocal function onFrame(dt)\n\tif dt == 0 and activeSpells == userDataLength(types.Actor.activeSpells(self)) then\n\t\treturn\n\tend\n\tactiveSpells = userDataLength(types.Actor.activeSpells(self))\n\tif playerSection:get(\"alwaysActive\") then\n\t\tundoNerf()\n\t\tapplyNerf()\n\tend\nend\n\n\nlocal function onInit()\n\tnerfedSkills = {}\n\tnerfedAttributes = {}\n\tnerfActive = false\n\tloadCounter = 1\n\t--print(\"FortNerf\")\n\treturn {nerfedSkills = nerfedSkills, nerfedAttributes = nerfedAttributes, nerfActive = nerfActive, loadCounter = 1}\nend\n\nlocal function onLoad(data)\n\tif not data or not data.nerfedSkills then\n\t\tnerfedSkills = {}\n\t\tnerfedAttributes = {}\n\t\tnerfActive = false\n\t\tloadCounter = 1\n\telse\n\t\tnerfedSkills = data.nerfedSkills\n\t\tnerfedAttributes = data.nerfedAttributes\n\t\tnerfActive = data.nerfActive\n\t\tloadCounter = data.loadCounter+1\n\tend\n\t--print(\"FortNerf \"..loadCounter)\nend\n\nlocal function onSave()\n\treturn {nerfedSkills = nerfedSkills, nerfedAttributes = nerfedAttributes, nerfActive = nerfActive, loadCounter = loadCounter}\nend\n\n\n\nreturn {\n\teventHandlers = {\n\t\tUiModeChanged = uiModeChanged,\n\t},\n\tengineHandlers ={ \n\t\tonFrame = onFrame,\n\t\tonUpdate = onUpdate,\n\t\tonLoad = onLoad,\n\t\tonSave = onSave,\n\t\tonInit = onInit,\n\t}\n}"
  }
}