{
  "folder_name": "Flight Animated for OpenMW",
  "lua_files": {
    "Flight Animated for OpenMW-54500-0-66a-1724005816\\scripts\\Flight\\player.lua": "local self = require(\"openmw.self\")\nlocal types = require(\"openmw.types\")\nlocal async = require(\"openmw.async\")\nlocal core = require(\"openmw.core\")\nlocal util = require(\"openmw.util\")\nlocal I = require(\"openmw.interfaces\")\nlocal animation = require(\"openmw.animation\")\nlocal camera = require(\"openmw.camera\")\nlocal ui = require(\"openmw.ui\")\n\nlocal Actor, ctrls = types.Actor, self.controls\nlocal stance, ST = types.Actor.getStance(self), types.Actor.STANCE\n\nlocal flight, moved = false, true\nlocal savedOptions = {}\n\nif core.API_REVISION < 66 then\n\tprint(\"Flight Animated requires a version of OpenMW built after 13 August 2024\")\n\tui.showMessage(\"ERROR: Flight Animated needs a newer version of OpenMW\")\n\treturn\nend\n\nlocal switch1 = {\n\t[\"turnright\"] = { id=\"swimturnright\", opt={speed=1} },\n\t[\"turnright1h\"] = { id=\"swimturnright\", opt={speed=1} },\n\t[\"turnright2c\"] = { id=\"swimturnright\", opt={speed=1} },\n\t[\"turnright2w\"] = { id=\"swimturnright\", opt={speed=1} },\n\t[\"turnrighthh\"] = { id=\"swimturnright\", opt={speed=1} },\n\t[\"spellturnright\"] = { id=\"swimturnright\", opt={speed=1} },\n\t[\"turnleft\"] = { id=\"swimturnleft\", opt={speed=1} },\n\t[\"turnleft1h\"] = { id=\"swimturnleft\", opt={speed=1} },\n\t[\"turnleft2c\"] = { id=\"swimturnleft\", opt={speed=1} },\n\t[\"turnleft2w\"] = { id=\"swimturnleft\", opt={speed=1} },\n\t[\"turnlefthh\"] = { id=\"swimturnleft\", opt={speed=1} },\n\t[\"spellturnleft\"] = { id=\"swimturnleft\", opt={speed=1} },\n\t[\"hit1\"] = { id=\"hit1\", opt={blendMask=14} },\n\t[\"hit2\"] = { id=\"hit2\", opt={blendMask=14} },\n\t[\"hit3\"] = { id=\"hit3\", opt={blendMask=14} },\n\t[\"hit4\"] = { id=\"hit4\", opt={blendMask=14} },\n\t[\"hit5\"] = { id=\"hit5\", opt={blendMask=14} },\n\t[\"death1\"] = \"swimdeath\",\n\t[\"death2\"] = \"swimdeath\",\n\t[\"death3\"] = \"swimdeath\",\n\t[\"death4\"] = \"swimdeath\",\n\t[\"death5\"] = \"swimdeath\",\n\t[\"deathknockdown\"] = \"swimdeathknockdown\",\n\t[\"deathknockout\"] = \"swimdeathknockout\",\n\t[\"knockdown\"] = \"swimknockdown\",\n\t[\"knockout\"] = \"swimknockout\",\n\n\t[\"walkforward\"] = { id=\"flywalkforward\", opt={speed=0.6} },\n\t[\"walkforward1h\"] = { id=\"flywalkforward\", opt={speed=0.6} },\n\t[\"walkforward2c\"] = { id=\"flywalkforward\", opt={speed=0.6} },\n\t[\"walkforward2w\"] = { id=\"flywalkforward\", opt={speed=0.6} },\n\t[\"walkforwardhh\"] = { id=\"flywalkforward\", opt={speed=0.6} },\n\t[\"runforward\"] = { id=\"flyrunforward\", opt={speed=0.6} },\n\t[\"runforward1h\"] = { id=\"flyrunforward\", opt={speed=0.6} },\n\t[\"runforward2c\"] = { id=\"flyrunforward\", opt={speed=0.6} },\n\t[\"runforward2w\"] = { id=\"flyrunforward\", opt={speed=0.6} },\n\t[\"runforwardhh\"] = { id=\"flyrunforward\", opt={speed=0.6} },\n\n\t}\n\nlocal switch2 = {\n\t[\"walkback\"] = \"swimwalkback\",\n\t[\"walkleft\"] = \"swimwalkleft\",\n\t[\"walkright\"] = \"swimwalkright\",\n\t[\"walkback1h\"] = \"swimwalkback\",\n\t[\"walkback2c\"] = \"swimwalkback\",\n\t[\"walkback2w\"] = \"swimwalkback\",\n\t[\"walkbackhh\"] = \"swimwalkback\",\n\t[\"walkleft1h\"] = \"swimwalkleft\",\n\t[\"walkleft2c\"] = \"swimwalkleft\",\n\t[\"walkleft2w\"] = \"swimwalkleft\",\n\t[\"walklefthh\"] = \"swimwalkleft\",\n\t[\"walkright1h\"] = \"swimwalkright\",\n\t[\"walkright2c\"] = \"swimwalkright\",\n\t[\"walkright2w\"] = \"swimwalkright\",\n\t[\"walkrighthh\"] = \"swimwalkright\",\n\t[\"runback\"] = \"flyrunback\",\n\t[\"runleft\"] = \"swimrunleft\",\n\t[\"runright\"] = \"swimrunright\",\n\t[\"runback1h\"] = \"flyrunback\",\n\t[\"runback2c\"] = \"flyrunback\",\n\t[\"runback2w\"] = \"flyrunback\",\n\t[\"runbackhh\"] = \"flyrunback\",\n\t[\"runleft1h\"] = \"swimrunleft\",\n\t[\"runleft2c\"] = \"swimrunleft\",\n\t[\"runleft2w\"] = \"swimrunleft\",\n\t[\"runlefthh\"] = \"swimrunleft\",\n\t[\"runright1h\"] = \"swimrunright\",\n\t[\"runright2c\"] = \"swimrunright\",\n\t[\"runright2w\"] = \"swimrunright\",\n\t[\"runrighthh\"] = \"swimrunright\",\n\n\t[\"idleswim\"] = \"idleswim\",\n\t[\"swimturnleft\"] = \"swimturnleft\",\n\t[\"swimturnright\"] = \"swimturnright\",\n\t[\"swimwalkforward\"] = \"swimrunforward\",\n\t[\"swimwalkback\"] = \"flyrunback\",\n\t[\"swimwalkleft\"] = \"swimrunleft\",\n\t[\"swimwalkright\"] = \"swimrunright\",\n\t[\"swimrunforward\"] = \"swimrunforward\",\n\t[\"swimrunback\"] = \"flyrunback\",\n\t[\"swimrunleft\"] = \"swimrunleft\",\n\t[\"swimrunright\"] = \"swimrunright\",\n\n\t}\n\n\nlocal flyCancel = { \"swimturnleft\", \"swimturnright\", \"idleflight\", \"swimwalkforward\", \"swimwalkback\",\n\t\"swimwalkleft\", \"swimwalkright\", \"flyrunforward\", \"flyrunforwardup\", \"flyrunforwarddown\",\n\t\"flyrunback\", \"swimrunleft\", \"swimrunright\" }\n\nlocal flypitch = { \"flyrunforward\", \"flyrunforwardup\", \"flyrunforwarddown\", \"flywalkforward\" } \n\n\nlocal function switchVFX()\n\tif Actor.activeEffects(self):getEffect(\"levitate\").magnitude == 0 or\n\t\tcamera.getMode() == camera.MODE.FirstPerson then flight=false end\n\tif not flight then return end\n\tanimation.removeAllVfx(self)\n\tanimation.addVfx(self, \"meshes/e/magic_hit_levitate.nif\",\n\t\t{boneName=\"Bip01 LevitateVfx\", loop=true, vfxId=core.magic.EFFECT_TYPE.Levitate})\n\tself:sendEvent(\"vfxRemoveAll\")\nend\n\nlocal function switchAnimation(g, o)\n\tif Actor.activeEffects(self):getEffect(\"levitate\").magnitude == 0 then return end\n\tif camera.getMode() == camera.MODE.FirstPerson then flight=false return end\n\tif not flight then\n\t\tasync:newUnsavableSimulationTimer(2, function() switchVFX() end)\n\tend\n\tflight = true\n\tif Actor.activeEffects(self):getEffect(\"levitate\").magnitude > 99 then\n\t\tg = string.gsub(g, \"walk\", \"run\")\n\tend\n-- Compensate for omw Camera script doing 3rd person auto-rotate\n\tif string.find(g, \"turnleft\") or string.find(g, \"turnright\") then moved = true end\n\tlocal switch = switch1[g]\n\tif switch then\n\t\tif type(switch) == \"table\" then\n\t\t\tg = switch.id\n\t\t\tfor k,v in pairs(switch.opt) do o[k] = v end\n\t\telse\n\t\t\tg = switch\n\t\tend\n\t\tif g == \"flyrunforward\" then\n\t\t\tfor k,v in pairs(o) do savedOptions[k] = v end\n\t\t\tsavedOptions.startKey, savedOptions.stopKey = \"loop start\", \"stop\"\n\t\t\tlocal pitch = math.deg(self.rotation:getPitch())\n\t\t\tif pitch < -35 then g = g..\"up\" end\n\t\t\tif pitch > 30 then g = g..\"down\" end\n\t\tend\n\t\tif g == \"flywalkforward\" then\n\t\t\tfor k,v in pairs(o) do savedOptions[k] = v end\n\t\t\tsavedOptions.startKey, savedOptions.stopKey = \"loop start\", \"stop\"\n\t\tend\n\telse\n\t\tswitch = switch2[g]\n\t\tif switch then\n\t\t\tg = switch\n\t\t\to.speed = 0.2\n\t\tend\n\tend\n\treturn g\nend\n\n\nI.AnimationController.addPlayBlendedAnimationHandler(function (groupname, options)\n  local groupname = switchAnimation(groupname, options)\n  return true, groupname\nend)\n\nlocal WPN = types.Weapon.TYPE\nlocal wpnTypes = { [WPN.AxeOneHand] = \"idle1h\", [WPN.BluntOneHand] = \"idle1h\", [WPN.LongBladeOneHand] = \"idle1h\",\n\t[WPN.ShortBladeOneHand] = \"idle1h\", [WPN.AxeTwoHand] = \"idle2c\", [WPN.BluntTwoClose] = \"idle2c\",\n\t[WPN.BluntTwoWide] = \"idle2w\", [WPN.LongBladeTwoHand] = \"idle2c\", [WPN.SpearTwoWide] = \"idle2w\",\n\t[WPN.MarksmanBow] = \"idle1h\", [WPN.MarksmanCrossbow] = \"idlecrossbow\", [WPN.MarksmanThrown] = \"idle1h\"\n\t\t}\n\nlocal function getIdleStance()\n\tif Actor.getStance(self) == ST.Nothing then return \"idleflight\" end\n\tif Actor.getStance(self) == ST.Spell then return \"idlespell\" end\n\tlocal item = Actor.getEquipment(self, Actor.EQUIPMENT_SLOT.CarriedRight)\n\tif item == nil then return \"idlehh\" end\n\tif item.type ~= types.Weapon then return \"idleflight\" end\n\tlocal idle = wpnTypes[types.Weapon.record(item).type]\n\tif not idle then idle = \"idleflight\" end\n\treturn idle\nend\n\nlocal function onUpdate(dt)\n\tif camera.getMode() == camera.MODE.FirstPerson then return end\n\tif Actor.activeEffects(self):getEffect(\"levitate\").magnitude == 0 then\n\t\tif not flight then return end\n\t\tfor i=1, #flyCancel do\n\t\t\tanimation.cancel(self, flyCancel[i])\n\t\tend\n\t\tflight = false\n\t\treturn\n\tend\n\tlocal isPlay = nil\n\tfor i=1, #flypitch do\n\t\tif animation.isPlaying(self, flypitch[i]) then isPlay = flypitch[i] end\n\tend\n\tif isPlay and string.find(isPlay, \"runforward\") then\n\t\tlocal pitch = math.deg(self.rotation:getPitch())\n\t\tif pitch < -35 and isPlay ~= \"flyrunforwardup\" then\n\t\t\tanimation.cancel(self, isPlay)\n\t\t\tanimation.playBlended(self, \"flyrunforwardup\", savedOptions)\n\t\telseif pitch > 30 and isPlay ~= \"flyrunforwarddown\" then\n\t\t\tanimation.cancel(self, isPlay)\n\t\t\tanimation.playBlended(self, \"flyrunforwarddown\", savedOptions)\n\t\telseif pitch >= -35 and pitch <= 30 and isPlay ~= \"flyrunforward\" then\n\t\t\tanimation.cancel(self, isPlay)\n\t\t\tanimation.playBlended(self, \"flyrunforward\", savedOptions)\n\t\tend\n\tend\n\tif ctrls.movement ~= 0 or ctrls.sideMovement ~= 0 or ctrls.yawChange ~= 0 then\n\t\tmoved = true\n\t\treturn\n\tend\n\tif stance ~= Actor.getStance(self) then\n\t\tmoved = true\n\t\tstance = Actor.getStance(self)\n\tend\n\tif isPlay == nil then\n\t\tif moved then\n\t\t\tanimation.cancel(self, \"idleflight\")\n\t\t\tmoved = false\n\t\t\tlocal idleStance = getIdleStance()\n\t\t\tif idleStance == \"idleflight\" then\n\tanimation.playBlended(self, \"idleflight\", {loops=50, priority=5, speed=0.2, forceLoop=true})\n\t\t\telse\n\tanimation.playBlended(self, idleStance, {loops=50, blendMask=14, priority=5})\n\tanimation.playBlended(self, \"idleflight\", {loops=50, blendMask=1, priority=5, speed=0.2, forceLoop=true})\n\t\t\tend\n\t\tend\n\t\treturn\n\tend\n\tif string.find(isPlay, \"runforward\") then\n\t\tanimation.cancel(self, isPlay)\n\t\tanimation.playBlended(self, \"swimrunforward\", {startKey=\"loop stop\", priority=6, speed=0.6})\n\telseif string.find(isPlay, \"walkforward\") then\n\t\tanimation.cancel(self, isPlay)\n\t\tanimation.playBlended(self, \"swimwalkforward\", {startKey=\"loop stop\", priority=6, speed=0.6})\n\tend\nend\n\nreturn {\n\tengineHandlers = { onUpdate = onUpdate },\n}\n",
    "Flight Animated for OpenMW-54500-0-66a-1724005816\\scripts\\omw\\mechanics\\animationcontroller.lua": "local anim = require('openmw.animation')\nlocal self = require('openmw.self')\n\nlocal playBlendedHandlers = {}\nlocal function onPlayBlendedAnimation(groupname, options)\n    for i = #playBlendedHandlers, 1, -1 do\n\tlocal h, g = playBlendedHandlers[i](groupname, options)\n\tif type(g) == \"string\" then groupname = g end\n        if h == false then\n            return groupname\n        end\n    end\n    return groupname\nend\n\nlocal function playBlendedAnimation(groupname, options)\n    local swap = onPlayBlendedAnimation(groupname, options)\n    if options.skip then\n        return\n    end\n    if swap then groupname = swap end\n    anim.playBlended(self, groupname, options)\nend\n\nlocal textKeyHandlers = {}\nlocal function onAnimationTextKey(groupname, key)\n    local handlers = textKeyHandlers[groupname]\n    if handlers then\n        for i = #handlers, 1, -1 do\n            if handlers[i](groupname, key) == false then\n                return\n            end\n        end\n    end\n    handlers = textKeyHandlers['']\n    if handlers then\n        for i = #handlers, 1, -1 do\n            if handlers[i](groupname, key) == false then\n                return\n            end\n        end\n    end\nend\n\nlocal initialized = false\n\nlocal function onUpdate(dt)\n    -- The script is loaded before the actor's CharacterController object is initialized, therefore\n    -- we have to delay this initialization step or the call won't have any effect.\n    if not initialized then\n        self:_enableLuaAnimations(true)\n        initialized = true\n    end\nend\n\nreturn {\n    engineHandlers = { \n        _onPlayAnimation = playBlendedAnimation,\n        _onAnimationTextKey = onAnimationTextKey,\n        onUpdate = onUpdate,\n    },\n    \n    interfaceName = 'AnimationController',\n    --- \n    -- Animation controller interface\n    -- @module AnimationController\n    -- @usage local anim = require('openmw.animation')\n    -- local I = require('openmw.interfaces')\n    --\n    -- -- play spellcast animation \n    -- I.AnimationController.playBlendedAnimation('spellcast', { startkey = 'self start', stopkey = 'self stop', priority = {\n    --      [anim.BONE_GROUP.RightArm] = anim.PRIORITY.Weapon,\n    --      [anim.BONE_GROUP.LeftArm] = anim.PRIORITY.Weapon,\n    --      [anim.BONE_GROUP.Torso] = anim.PRIORITY.Weapon,\n    --      [anim.BONE_GROUP.LowerBody] = anim.PRIORITY.WeaponLowerBody\n    --      } })\n    -- \n    -- @usage -- react to the spellcast release textkey\n    -- I.AnimationController.addTextKeyHandler('spellcast', function(groupname, key)\n    --     -- Note, Lua is 1-indexed so have to subtract 1 less than the length of 'release'\n    --     if key.sub(key, #key - 6) == 'release' then\n    --         print('Abra kadabra!')\n    --     end\n    -- end)\n    --\n    -- @usage -- Add a text key handler that will react to all keys\n    -- I.AnimationController.addTextKeyHandler('', function(groupname, key)\n    --     if key.sub(key, #key - 2) == 'hit' and not key.sub(key, #key - 7) == ' min hit' then\n    --         print('Hit!')\n    --     end\n    -- end)\n    -- \n    -- @usage -- Make a handler that changes player attack speed based on current fatigue\n    -- I.AnimationController.addPlayBlendedAnimationHandler(function (groupname, options)\n    --     local stop = options.stopkey\n    --     if #stop > 10 and stop.sub(stop, #stop - 10) == ' max attack' then\n    --         -- This is an attack wind up animation, scale its speed by attack \n    --         local fatigue = Actor.stats.dynamic.fatigue(self)\n    --         local factor = 1 - fatigue.current / fatigue.base\n    --         speed = 1 - factor * 0.8\n    --         options.speed = speed\n    --     end\n    -- end)\n    -- \n    \n    interface = {\n        --- Interface version\n        -- @field [parent=#AnimationController] #number version\n        version = 0,\n        \n        --- AnimationController Package\n        -- @type Package\n        \n        --- Make this actor play an animation. Makes a call to @{openmw.animation#playBlended}, after invoking handlers added through addPlayBlendedAnimationHandler\n        -- @function [parent=#AnimationController] playBlendedAnimation\n        -- @param #string groupname The animation group to be played\n        -- @param #table options The table of play options that will be passed to @{openmw.animation#playBlended}\n        playBlendedAnimation = playBlendedAnimation,\n\n        --- Add new playBlendedAnimation handler for this actor\n        -- If `handler(groupname, options)` returns false, other handlers for\n        -- the call will be skipped.\n        -- @function [parent=#AnimationController] addPlayBlendedAnimationHandler\n        -- @param #function handler The handler.\n        addPlayBlendedAnimationHandler = function(handler)\n            playBlendedHandlers[#playBlendedHandlers + 1] = handler\n        end,\n\n        --- Add new text key handler for this actor\n        -- While playing, some animations emit text key events. Register a handle to listen for all\n        -- text key events associated with this actor's animations.\n        -- If `handler(groupname, key)` returns false, other handlers for\n        -- the call will be skipped.\n        -- @function [parent=#AnimationController] addTextKeyHandler\n        -- @param #string groupname Name of the animation group to listen to keys for. If the empty string or nil, all keys will be received\n        -- @param #function handler The handler.\n        addTextKeyHandler = function(groupname, handler)\n            if not groupname then\n                groupname = \"\"\n            end\n            local handlers = textKeyHandlers[groupname]\n            if handlers == nil then\n                handlers = {}\n                textKeyHandlers[groupname] = handlers\n            end\n            handlers[#handlers + 1] = handler\n        end\n    },\n\n    eventHandlers = {\n         AddVfx = function(data)\n             anim.addVfx(self, data.model, data.options)\n         end,\n    }\n}",
    "ODAR debug tool-54500-0-21-1714260306\\scripts\\Flight\\debug.lua": "local time = require(\"openmw_aux.time\")\nlocal I = require(\"openmw.interfaces\")\n\nlocal idlespam = false\n\n\nI.AnimationController.addPlayBlendedAnimationHandler(function (g, o)\n  -- Block spamming of messages about playing idle animations every frame\n\tif g ~= \"idle1h\" and g ~= \"idle2c\" and g ~= \"idlehh\" then\n\t\tidlespam = false\n\telse\n\t\tif not idlespam then idlespam = true\n\t\telse return end\n\tend\n\tprint(g)\nend)\n\n\ntime.runRepeatedly(function() idlespam = false end, 5 * time.second)\n\n\nreturn\n"
  }
}