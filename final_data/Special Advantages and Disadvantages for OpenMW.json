{
  "folder_name": "Special Advantages and Disadvantages for OpenMW",
  "lua_files": {
    "Special for OpenMW-55026-0-1-6-1726438225\\scripts\\special\\change_disposition.lua": "local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local assert = _tl_compat and _tl_compat.assert or assert; local core = require('openmw.core')\nlocal self = require('openmw.self')\nlocal NPC = require('openmw.types').NPC\n\nlocal dispositionModifier = 0\n\nlocal function modifyDisposition(data)\n   assert(data and data.modifier and data.toward)\n   if data.modifier == dispositionModifier then return end\n   local diffModifier = data.modifier - dispositionModifier\n   NPC.modifyBaseDisposition(self, data.toward, diffModifier)\n   dispositionModifier = data.modifier\nend\n\nlocal function onSave()\n   return { dispositionModifier = dispositionModifier }\nend\n\nlocal function onLoad(data, _)\n   dispositionModifier = data and data.dispositionModifier or 0\nend\n\nreturn {\n   engineHandlers = {\n      onLoad = onLoad,\n      onSave = onSave,\n   },\n   eventHandlers = {\n      SpecialModifyDisposition = modifyDisposition,\n   },\n}\n",
    "Special for OpenMW-55026-0-1-6-1726438225\\scripts\\special\\conf.lua": "local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local assert = _tl_compat and _tl_compat.assert or assert; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local pairs = _tl_compat and _tl_compat.pairs or pairs; local string = _tl_compat and _tl_compat.string or string; local table = _tl_compat and _tl_compat.table or table; maxDifficultyPoints = 50\nmaxPaddingPoints = 20\nmaxValidDifficultyPoints = maxDifficultyPoints - maxPaddingPoints\nreputationCost = 2\n\nSpecial = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Special:new(special)\n   assert(special)\n   local self = setmetatable(special, { __index = Special })\n   return self\nend\n\nfunction Special:copy()\n   local copy = Special:new()\n   copy.id = self.id\n   copy.name = self.name\n   copy.group = self.group\n   copy.abilityId = self.abilityId\n   copy.abilityIdAtNight = self.abilityIdAtNight\n   copy.abilityIdWhenOutside = self.abilityIdWhenOutside\n   copy.abilityIdWhenInside = self.abilityIdWhenInside\n   local phobiaOf = self.phobiaOf\n   if type(phobiaOf) == \"table\" then\n      for _, phobia in ipairs(phobiaOf) do\n         table.insert(copy.phobiaOf, phobia)\n      end\n   end\n   copy.cost = self.cost\nend\n\nadvantages = {}\nadvantagesById = {}\nadvantagesByAbilityId = {}\ndisadvantages = {}\ndisadvantagesById = {}\ndisadvantagesByAbilityId = {}\n\n\nfunction addSpecial(special)\n   if special.cost >= 0 then\n      table.insert(advantages, special)\n      advantagesById[special.id] = special\n      if special.abilityId then\n         advantagesByAbilityId[special.abilityId] = special\n      end\n   else\n      table.insert(disadvantages, special)\n      disadvantagesById[special.id] = special\n      if special.abilityId then\n         disadvantagesByAbilityId[special.abilityId] = special\n      end\n   end\nend\n\nlocal function percentageToNounAndGroup(percentage)\n   if percentage == 100 then return { 'immunity', 'Resistance' }\n   elseif percentage == 75 then return { 'high resistance', 'Resistance' }\n   elseif percentage == 50 then return { 'resistance', 'Resistance' }\n   elseif percentage == 25 then return { 'low resistance', 'Resistance' }\n   elseif percentage == -25 then return { 'small weakness', 'Weakness' }\n   elseif percentage == -50 then return { 'weakness', 'Weakness' }\n   elseif percentage == -75 then return { 'great weakness', 'Weakness' }\n   elseif percentage == -100 then return { 'critical weakness', 'Weakness' }\n   else error('Unknown percentage ' .. tostring(percentage))\n   end\nend\n\nlocal function firstToUpper(str)\n   return (str:gsub(\"^%l\", string.upper))\nend\n\nlocal function spacesToUnderscores(str)\n   return (str:gsub(\" +\", \"_\"))\nend\n\nfor _, element in ipairs({ 'fire', 'frost', 'shock', 'poison' }) do\n   for absoluteCost, absolutePercentage in pairs({ [40] = 100,\n[30] = 75,\n[20] = 50,\n[10] = 25, }) do\n      for cost, percentage in pairs({ [absoluteCost] = absolutePercentage,\n[-absoluteCost] = -absolutePercentage, }) do\n         local nounAndGroup = percentageToNounAndGroup(percentage)\n         local noun = nounAndGroup[1]\n         local id = spacesToUnderscores(noun) .. '_to_' .. element\n         local abilityId = 'special_' .. id\n         local name = firstToUpper(noun) .. ' to ' .. firstToUpper(element)\n         local description = tostring(percentage) .. '% ' .. nounAndGroup[2] .. ' to ' .. firstToUpper(element) .. '.'\n         local group = { nounAndGroup[2], firstToUpper(element) }\n         addSpecial({\n            id = id,\n            name = name,\n            description = description,\n            group = group,\n            abilityId = abilityId,\n            cost = cost,\n         })\n      end\n   end\nend\n\nfor absoluteCost, absolutePercentage in pairs({ [40] = 75,\n[30] = 50,\n[20] = 25, }) do\n   for cost, percentage in pairs({ [absoluteCost] = absolutePercentage,\n[-absoluteCost] = -absolutePercentage, }) do\n      local nounAndGroup = percentageToNounAndGroup(percentage)\n      local noun = nounAndGroup[1]\n      local id = spacesToUnderscores(noun) .. '_to_magicka'\n      local abilityId = 'special_' .. id\n      local name = firstToUpper(noun) .. ' to magicka'\n      local description = tostring(percentage) .. '% ' .. nounAndGroup[2] .. ' to Magicka.'\n      local group = { nounAndGroup[2], 'Magicka' }\n      addSpecial({\n         id = id,\n         name = name,\n         description = description,\n         group = group,\n         abilityId = abilityId,\n         cost = cost,\n      })\n   end\nend\n\naddSpecial({\n   id = 'robust',\n   name = 'Robust',\n   description = '+10 Endurance.',\n   group = { 'Attribute' },\n   abilityId = 'special_robust',\n   cost = 20,\n})\n\naddSpecial({\n   id = 'fragile',\n   name = 'Fragile',\n   description = '-10 Endurance.',\n   group = { 'Attribute' },\n   abilityId = 'special_fragile',\n   cost = -20,\n})\n\naddSpecial({\n   id = 'strong',\n   name = 'Strong',\n   description = '+10 Strength.',\n   group = { 'Attribute' },\n   abilityId = 'special_strong',\n   cost = 20,\n})\n\naddSpecial({\n   id = 'weak',\n   name = 'Weak',\n   description = '-10 Strength.',\n   group = { 'Attribute' },\n   abilityId = 'special_weak',\n   cost = -20,\n})\n\naddSpecial({\n   id = 'agile',\n   name = 'Agile',\n   description = '+10 Agility.',\n   group = { 'Attribute' },\n   abilityId = 'special_agile',\n   cost = 20,\n})\n\naddSpecial({\n   id = 'Clumsy',\n   name = 'Clumsy',\n   description = '-10 Agility.',\n   group = { 'Attribute' },\n   abilityId = 'special_clumsy',\n   cost = -20,\n})\n\naddSpecial({\n   id = 'fast',\n   name = 'Fast',\n   description = '+10 Speed.',\n   group = { 'Attribute' },\n   abilityId = 'special_fast',\n   cost = 20,\n})\n\naddSpecial({\n   id = 'slow',\n   name = 'Slow',\n   description = '-10 Speed.',\n   group = { 'Attribute' },\n   abilityId = 'special_slow',\n   cost = -20,\n})\n\naddSpecial({\n   id = 'charismatic',\n   name = 'Charismatic',\n   description = '+10 Personality.',\n   group = { 'Attribute' },\n   abilityId = 'special_charismatic',\n   cost = 20,\n})\n\naddSpecial({\n   id = 'uncharismatic',\n   name = 'Uncharismatic',\n   description = '-10 Personality.',\n   group = { 'Attribute' },\n   abilityId = 'special_uncharismatic',\n   cost = -20,\n})\n\naddSpecial({\n   id = 'intelligent',\n   name = 'Intelligent',\n   description = '+10 Intelligence.',\n   group = { 'Attribute' },\n   abilityId = 'special_intelligent',\n   cost = 20,\n})\n\naddSpecial({\n   id = 'stupid',\n   name = 'Stupid',\n   description = '-10 Intelligence.',\n   group = { 'Attribute' },\n   abilityId = 'special_stupid',\n   cost = -20,\n})\n\naddSpecial({\n   id = 'resolute',\n   name = 'Resolute',\n   description = '+10 Willpower.',\n   group = { 'Attribute' },\n   abilityId = 'special_resolute',\n   cost = 20,\n})\n\naddSpecial({\n   id = 'irresolute',\n   name = 'Irresolute',\n   description = '-10 Willpower.',\n   group = { 'Attribute' },\n   abilityId = 'special_irresolute',\n   cost = -20,\n})\n\naddSpecial({\n   id = 'lucky',\n   name = 'Lucky',\n   description = '+10 Luck.',\n   group = { 'Attribute' },\n   abilityId = 'special_lucky',\n   cost = 20,\n})\n\naddSpecial({\n   id = 'unlucky',\n   name = 'Unlucky',\n   description = '-10 Luck.',\n   group = { 'Attribute' },\n   abilityId = 'special_unlucky',\n   cost = -20,\n})\n\naddSpecial({\n   id = 'regenerative',\n   name = 'Regenerative',\n   description = 'Regenerates 1 health per second.',\n   group = { 'Trait' },\n   abilityId = 'special_regenerative',\n   cost = 20,\n})\n\naddSpecial({\n   id = 'relentless',\n   name = 'Relentless',\n   description = 'Regenerates 4 fatigue per second.',\n   group = { 'Trait' },\n   abilityId = 'special_relentless',\n   cost = 20,\n})\n\naddSpecial({\n   id = 'recharging',\n   name = 'Recharging',\n   description = 'Regenerates 1 magicka per second.',\n   group = { 'Trait' },\n   abilityId = 'special_recharging',\n   cost = 20,\n})\n\nfor _, skill in ipairs({ 'Heavy Armor',\n'Medium Armor',\n'Spear',\n'Acrobatics',\n'Armorer',\n'Axe',\n'Blunt Weapon',\n'Long Blade',\n'Block',\n'Light Armor',\n'Marksman',\n'Sneak',\n'Athletic',\n'HandToHand',\n'Short Blade',\n'Unarmored',\n'Illusion',\n'Mercantile',\n'Speechcraft',\n'Alchemy',\n'Conjuration',\n'Enchant',\n'Security',\n'Alteration',\n'Destruction',\n'Mysticism',\n'Restoration', }) do\n   local idPostfix = spacesToUnderscores(skill:lower())\n\n   local id = 'proficient_in_' .. idPostfix\n   addSpecial({\n      id = id,\n      name = 'Proficient in ' .. skill,\n      description = skill .. ' +20.',\n      group = { 'Proficiency' },\n      abilityId = 'special_' .. id,\n      cost = 20,\n   })\n\n   id = 'inept_at_' .. idPostfix\n   addSpecial({\n      id = id,\n      name = 'Inept at ' .. skill,\n      description = skill .. ' -100.',\n      group = { 'Ineptness' },\n      abilityId = 'special_' .. id,\n      cost = -5,\n   })\nend\n\naddSpecial({\n   id = 'shadowborn',\n   name = 'Shadowborn',\n   description = 'Chameleon 20.',\n   group = { 'Trait' },\n   abilityId = 'special_shadowborn',\n   cost = 20,\n})\n\naddSpecial({\n   id = 'dodger',\n   name = 'Dodger',\n   description = 'Sanctuary 20.',\n   group = { 'Trait' },\n   abilityId = 'special_dodger',\n   cost = 20,\n})\n\n\n\n\naddSpecial({\n   id = 'phobia_of_ash_creatures',\n   name = 'Phobia of Ash Creatures',\n   description = 'Applies a -20 to all skills whenever close to and looking at an Ash enemy.',\n   group = { 'Phobia' },\n   phobiaOf = { 'ascended_sleeper', 'dagoth', 'ash', 'corprus' },\n   cost = -30,\n})\n\n\nfor _, beastAndMatch in ipairs({\n      { 'alit', { 'alit' } },\n      { 'cliff racer', { 'cliff.*racer' } },\n      { 'dreugh', { 'dreugh' } },\n      { 'guar', { 'guar' } },\n      { 'kagouti', { 'kagouti' } },\n      { 'mudcrab', { 'mudcrab' } },\n      { 'netch', { 'netch' } },\n      { 'nix-hound', { 'nix.*hound' } },\n      { 'rat', { 'rat' } },\n      { 'shalk', { 'shalk' } },\n      { 'slaughterfish', { 'slaughterfish' } },\n      { 'kwama', { 'kwama', 'scrib' } },\n   }) do\n   addSpecial({\n      id = 'phobia_of_' .. spacesToUnderscores(beastAndMatch[1]),\n      name = 'Phobia of ' .. firstToUpper(beastAndMatch[1]),\n      description = 'Applies a -20 to all skills whenever close to and looking at a ' .. beastAndMatch[1] .. '.',\n      group = { 'Phobia', 'Beast' },\n      phobiaOf = beastAndMatch[2],\n      cost = -2,\n   })\nend\n\n\naddSpecial({\n   id = 'phobia_of_daedra',\n   name = 'Phobia of all Daedra',\n   description = 'Applies a -20 to all skills whenever close to and looking at a daedra.',\n   group = { 'Phobia' },\n   phobiaOf = { 'atronach', 'clannfear', 'daedroth', 'dremora', 'golden.*saint', 'hunger', 'ogrim', 'scamp', 'winged.*twilight' },\n   cost = -40,\n})\n\nfor _, daedraAndMatch in ipairs({\n      { 'atronach', { 'atronach' } },\n      { 'clannfear', { 'clannfear' } },\n      { 'daedroth', { 'daedroth' } },\n      { 'dremora', { 'dremora' } },\n      { 'golden saint', { 'golden.*saint' } },\n      { 'hunger', { 'hunger' } },\n      { 'ogrim', { 'ogrim' } },\n      { 'scamp', { 'scamp' } },\n      { 'winged twilight', { 'winged.*twilight' } },\n   }) do\n   addSpecial({\n      id = 'phobia_of_' .. spacesToUnderscores(daedraAndMatch[1]),\n      name = 'Phobia of ' .. firstToUpper(daedraAndMatch[1]),\n      description = 'Applies a -20 to all skills whenever close to and looking at a ' .. daedraAndMatch[1] .. '.',\n      group = { 'Phobia', 'Daedra' },\n      phobiaOf = daedraAndMatch[2],\n      cost = -5,\n   })\nend\n\n\naddSpecial({\n   id = 'phobia_of_dwemer_constructs',\n   name = 'Phobia of Dwemer Constructs',\n   description = 'Applies a -20 to all skills whenever close to and looking at a dwemer construct.',\n   group = { 'Phobia' },\n   phobiaOf = { 'centurion' },\n   cost = -20,\n})\n\n\naddSpecial({\n   id = 'phobia_of_ghosts',\n   name = 'Phobia of Ghosts',\n   description = 'Applies a -20 to all skills whenever close to and looking at a ghost.',\n   group = { 'Phobia', 'Undead' },\n   phobiaOf = { 'ghost', 'wraith', 'gateway.*haunt', 'ancestor.*guardian', 'ancestor.*wisewoman', 'dahrik.*mezalf' },\n   cost = -10,\n})\n\naddSpecial({\n   id = 'phobia_of_boneundead',\n   name = 'Phobia of Bone Undead',\n   description = 'Applies a -20 to all skills whenever close to and looking at a bonelord, a bonewalker or any other bone undead.',\n   group = { 'Phobia', 'Undead' },\n   phobiaOf = { 'bonelord', 'bonewalker', 'wolf.*bone' },\n   cost = -10,\n})\n\naddSpecial({\n   id = 'phobia_of_skeletons',\n   name = 'Phobia of Skeletons',\n   description = 'Applies a -20 to all skills whenever close to and looking at a skeleton.',\n   group = { 'Phobia', 'Undead' },\n   phobiaOf = { 'skeleton', 'worm.*lord' },\n   cost = -10,\n})\n\naddSpecial({\n   id = 'phobia_of_liches',\n   name = 'Phobia of Liches',\n   description = 'Applies a -20 to all skills whenever close to and looking at a lich.',\n   group = { 'Phobia', 'Undead' },\n   phobiaOf = { 'lich' },\n   cost = -10,\n})\n\naddSpecial({\n   id = 'phobia_of_draugr',\n   name = 'Phobia of Draugr',\n   description = 'Applies a -20 to all skills whenever close to and looking at a draugr.',\n   group = { 'Phobia', 'Undead' },\n   phobiaOf = { 'draugr' },\n   cost = -10,\n})\n\n\n\naddSpecial({\n   id = 'night_person',\n   name = 'Night Person',\n   description = '+10 to Agility, Intelligence, Willpower and Personality at night between 6pm and 6am.',\n   group = { 'Trait' },\n   abilityIdAtNight = 'special_night_person',\n   cost = 10,\n})\n\naddSpecial({\n   id = 'good_natured',\n   name = 'Good Natured',\n   description = '-10 to all combat skills and +5 to every other skill. Combat skills are: Spear Axe, BluntWeapon, LongBlade, Marksman, HandToHand, ShortBlade, Mysticism and Destruction.',\n   group = { 'Trait' },\n   abilityId = 'special_good_natured',\n   cost = 0,\n})\n\naddSpecial({\n   id = 'small_frame',\n   name = 'Small Frame',\n   description = '+10 to Agility and -10 to Endurance.',\n   group = { 'Trait' },\n   abilityId = 'special_small_frame',\n   cost = 0,\n})\n\naddSpecial({\n   id = 'claustrophobia',\n   name = 'Claustrophobia',\n   description = '+10 to all skills when outside and -10 to all skills when not outside.',\n   group = { 'Trait' },\n   abilityIdWhenInside = 'special_claustrophobia_inside',\n   abilityIdWhenOutside = 'special_claustrophobia_outside',\n   cost = 0,\n})\n\nAdvantagesDisadvantages = {}\n\n\n\n\n\n\n\nfunction AdvantagesDisadvantages:new()\n   local self = setmetatable({}, { __index = AdvantagesDisadvantages })\n   self.maxHp = 0\n   self.advantages = {}\n   self.disadvantages = {}\n   self.reputation = {}\n   return self\nend\n\nfunction AdvantagesDisadvantages:copy()\n   local copy = AdvantagesDisadvantages:new()\n   copy.maxHp = self.maxHp\n   for _, special in ipairs(self.advantages) do\n      table.insert(copy.advantages, special:copy())\n   end\n   for _, special in ipairs(self.disadvantages) do\n      table.insert(copy.disadvantages, special:copy())\n   end\n   for factionId, reputationModifier in pairs(self.reputation) do\n      copy.reputation[factionId] = reputationModifier\n   end\nend\n\nfunction AdvantagesDisadvantages:isNotEmpty()\n   return self.maxHp ~= 0 or #self.advantages ~= 0 or #self.disadvantages ~= 0\nend\n\nfunction AdvantagesDisadvantages:cost()\n   local cost = self.maxHp\n   for _, advantage in ipairs(self.advantages) do\n      cost = cost + advantage.cost\n   end\n   for _, disadvantage in ipairs(self.disadvantages) do\n      cost = cost + disadvantage.cost\n   end\n   for _, reputation in pairs(self.reputation) do\n      if reputation < 0 then\n         cost = cost - reputationCost\n      elseif reputation > 0 then\n         cost = cost + reputationCost\n      end\n   end\n   return cost\nend\n\nfunction AdvantagesDisadvantages:availableAdvantages()\n   local notAvailableAdvantages = {}\n   for _, advantage in ipairs(self.advantages) do\n      notAvailableAdvantages[advantage.id] = true\n   end\n   local availableAdvantages = {}\n   for _, advantage in ipairs(advantages) do\n      if not notAvailableAdvantages[advantage.id] then\n         table.insert(availableAdvantages, advantage)\n      end\n   end\n   return availableAdvantages\nend\n\nfunction AdvantagesDisadvantages:availableDisadvantages()\n   local notAvailableDisadvantages = {}\n   for _, disadvantage in ipairs(self.disadvantages) do\n      notAvailableDisadvantages[disadvantage.id] = true\n   end\n   local availableDisadvantages = {}\n   for _, advantage in ipairs(disadvantages) do\n      if not notAvailableDisadvantages[advantage.id] then\n         table.insert(availableDisadvantages, advantage)\n      end\n   end\n   return availableDisadvantages\nend\n",
    "Special for OpenMW-55026-0-1-6-1726438225\\scripts\\special\\print_out.lua": "local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local string = _tl_compat and _tl_compat.string or string; local table = _tl_compat and _tl_compat.table or table; local _ = require('scripts/special/conf')\n\nGrouppedSpecial = {}\n\n\n\n\n\n\nlocal specials = {}\nfor _, advantage in ipairs(advantages) do\n   table.insert(specials, advantage)\nend\nfor _, disadvantage in ipairs(disadvantages) do\n   table.insert(specials, disadvantage)\nend\n\nlocal grouppedSpecials = {}\nlocal grouppedSpecialsByGroup = {}\nfor _, special in ipairs(specials) do\n   local pgroup = ''\n   local numParents = 0\n   local last = nil\n\n   for i, part in ipairs(special.group) do\n      if pgroup ~= '' then\n         numParents = numParents + 1\n      end\n      pgroup = pgroup .. '.' .. part\n      if not grouppedSpecialsByGroup[pgroup] then\n         local grouppedSpecial = {\n            name = part,\n            items = {},\n            numParents = numParents,\n         }\n         if last then\n            table.insert(last.items, grouppedSpecial)\n         end\n         grouppedSpecialsByGroup[pgroup] = grouppedSpecial\n         if i == 1 then\n            table.insert(grouppedSpecials, grouppedSpecial)\n         end\n      end\n      last = grouppedSpecialsByGroup[pgroup]\n   end\n\n   if last then\n      numParents = numParents + 1\n      last.items = last.items or {}\n      table.insert(last.items, {\n         name = special.name,\n         special = special,\n         items = {},\n         numParents = numParents,\n      })\n   else\n      table.insert(grouppedSpecials, {\n         name = special.name,\n         special = special,\n         items = {},\n         numParents = numParents,\n      })\n   end\nend\n\nlocal toPrint = {}\nlocal function push(specials_)\n   table.sort(specials_, function(s1, s2)\n      return s1.name < s2.name\n   end)\n   for i = 0, #specials_ - 1 do\n      table.insert(toPrint, specials_[#specials_ - i])\n   end\nend\npush(grouppedSpecials)\nwhile #toPrint > 0 do\n   local curr = table.remove(toPrint)\n   local str = string.rep(' ', curr.numParents) .. curr.name\n   if #curr.items > 0 then\n      print(str)\n      push(curr.items)\n   else\n      print(str .. ' [cost:' .. tostring(curr.special.cost) .. ']: ' .. curr.special.description)\n   end\nend\n",
    "Special for OpenMW-55026-0-1-6-1726438225\\scripts\\special\\settings.lua": "local I = require('openmw.interfaces')\n\nI.Settings.registerPage({\n   key = 'special',\n   l10n = 'special',\n   name = 'setting_special_page',\n})\n\nI.Settings.registerGroup({\n   key = 'Settings_special',\n   l10n = 'special',\n   name = 'setting_special_group',\n   page = 'special',\n   permanentStorage = false,\n   settings = {\n      {\n         key = 'open_special_main_element_key',\n         name = 'setting_open_special_main_element_key',\n         description = 'setting_open_special_main_element_key_description',\n         renderer = 'textLine',\n         default = 'u',\n      },\n      {\n         key = 'enable_special_skill_progression_modifier',\n         name = 'setting_disable_special_skill_progression_modifier',\n         description = 'setting_disable_special_skill_progression_modifier_description',\n         renderer = 'checkbox',\n         default = true,\n      },\n   },\n})\n",
    "Special for OpenMW-55026-0-1-6-1726438225\\scripts\\special\\special.lua": "local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local math = _tl_compat and _tl_compat.math or math; local string = _tl_compat and _tl_compat.string or string; local table = _tl_compat and _tl_compat.table or table; local camera = require('openmw.camera')\nlocal core = require('openmw.core')\nlocal input = require('openmw.input')\nlocal I = require('openmw.interfaces')\nlocal nearby = require('openmw.nearby')\nlocal self = require('openmw.self')\nlocal storage = require('openmw.storage')\nlocal time = require('openmw_aux.time')\nlocal types = require('openmw.types')\nlocal ui = require('openmw.ui')\nlocal util = require('openmw.util')\nlocal _conf = require('scripts.special.conf')\nlocal _widgets = require('scripts.special.widgets')\nlocal _ = require('scripts.special.settings')\n\nlocal rgb = util.color.rgb\nlocal v2 = util.vector2\nlocal V2 = util.Vector2\n\nlocal specials = AdvantagesDisadvantages:new()\nlocal specialsSkillMultiplier = 1\nlocal phobias = {}\nlocal phobiaCheckEvery = 2\nlocal phobiaTimeSinceCheck = 0\nlocal phobiaTimeSinceLastTriggerred = 0\nlocal nightlys = {}\nlocal nightlysCheckEvery = 5\nlocal nightlysTimeSinceCheck = 10000000\nlocal insidesOutsides = {}\nlocal insidesCheckEvery = 5\nlocal insidesTimeSinceCheck = 100000\nlocal mainElement = nil\nlocal createMainElement = nil\nlocal editElement = nil\nlocal editElementChangeSelection = nil\nlocal applyElement = nil\nlocal reputationElement = nil\n\nlocal settings = storage.playerSection('Settings_special')\n\n\nlocal function checkSpellExists(abilityId)\n   if (core.magic.spells.records)[abilityId] == nil then\n      error('Ability ' .. abilityId .. ' not found in game! Please load the plugin special.omwaddon.')\n   end\nend\n\nlocal function checkSpecialAbilitiesExist(special)\n   if special.abilityId then\n      checkSpellExists(special.abilityId)\n   end\n   if special.abilityIdAtNight then\n      checkSpellExists(special.abilityIdAtNight)\n   end\n   if special.abilityIdWhenInside then\n      checkSpellExists(special.abilityIdWhenInside)\n   end\n   if special.abilityIdWhenOutside then\n      checkSpellExists(special.abilityIdWhenOutside)\n   end\nend\n\ncheckSpellExists('special_phobia')\n\nfor _, advantage in ipairs(advantages) do\n   checkSpecialAbilitiesExist(advantage)\nend\nfor _, disadvantage in ipairs(disadvantages) do\n   checkSpecialAbilitiesExist(disadvantage)\nend\n\n\nlocal function destroyMainElement()\n   if not mainElement then return end\n   mainElement:destroy()\n   mainElement = nil\n   I.UI.setMode()\nend\n\nlocal function destroyEditElement()\n   if not editElement then return end\n   editElement:destroy()\n   editElement = nil\n   editElementChangeSelection = nil\n   I.UI.setMode()\nend\n\nlocal function destroyApplyElement()\n   if not applyElement then return end\n   applyElement:destroy()\n   applyElement = nil\n   I.UI.setMode()\nend\n\nlocal function destroyReputationElement()\n   if not reputationElement then return end\n   reputationElement:destroy()\n   reputationElement = nil\n   I.UI.setMode()\nend\n\n\n\nlocal function skillAdvancementDifficultyFraction()\n   local difficulty = math.max(-maxDifficultyPoints, math.min(maxDifficultyPoints, specials:cost()))\n   return (difficulty + maxDifficultyPoints) / (maxDifficultyPoints * 2)\nend\n\nlocal function updateDifficultyLine()\n   local lineRelativePosition = 0.2 + 0.75 * (1 - skillAdvancementDifficultyFraction())\n   local line = lookupLayout(mainElement.layout, { 'second_column', 'difficulty_line' })\n   local linePosition = line.props.relativePosition\n   line.props.relativePosition = v2(linePosition.x, lineRelativePosition)\nend\n\nlocal function firstColumn()\n   local content = ui.content({})\n   content:add(background({}))\n   content:add(borders(true))\n   content:add(textLines({\n      lines = { 'ADVANTAGES/DISADVANTAGES' },\n      relativeSize = v2(1, 0.08),\n   }))\n   content:add({\n      template = I.MWUI.templates.horizontalLineThick,\n      props = {\n         anchor = v2(0, 0.5),\n         relativePosition = v2(0, 0.08),\n      },\n   })\n   local lines = {}\n   for _, advantage in ipairs(specials.advantages) do\n      table.insert(lines, advantage.name .. ' [' .. tostring(advantage.cost) .. ' points]')\n   end\n   for _, disadvantage in ipairs(specials.disadvantages) do\n      table.insert(lines, disadvantage.name .. ' [' .. tostring(disadvantage.cost) .. ' points]')\n   end\n   local scrollableTextLine\n   scrollableTextLine = ScrollableTextLines:new({\n      lines = lines,\n      events = {\n         mouseDoubleClick = function(i)\n            if i <= #specials.advantages then\n               table.remove(specials.advantages, i)\n            else\n               table.remove(specials.disadvantages, i - #specials.advantages)\n            end\n            scrollableTextLine:remove(i)\n            updateDifficultyLine()\n            mainElement:update()\n         end,\n         onChange = function(_) mainElement:update() end,\n      },\n      props = {\n         relativePosition = v2(0.05, 0.1),\n         relativeSize = v2(0.9, 0.85),\n         scrollbarRelativeSizeWidth = 0.05,\n      },\n   })\n   content:add(scrollableTextLine:layout())\n   return {\n      content = content,\n      props = {\n         relativeSize = v2(0.48, 1),\n      },\n   }\nend\n\nlocal function secondColumn()\n   local content = ui.content({})\n   content:add(background({}))\n   content:add(borders(true))\n   content:add(textLines({\n      lines = { 'SKILL', 'ADVANCEMENT', 'FOR CLASS' },\n      relativeSize = v2(1, 0.15),\n   }))\n   content:add({\n      template = I.MWUI.templates.horizontalLineThick,\n      props = { relativePosition = v2(0, 0.15) },\n   })\n   content:add({\n      template = templates.textNormal,\n      props = {\n         anchor = v2(1, 0),\n         relativePosition = v2(0.65, 0.2),\n         text = 'DIFFICULT',\n      },\n   })\n   content:add({\n      template = templates.textNormal,\n      props = {\n         anchor = v2(1, 0.5),\n         relativePosition = v2(0.65, 0.575),\n         text = 'AVERAGE',\n      },\n   })\n   content:add({\n      template = templates.textNormal,\n      props = {\n         anchor = v2(1, 1),\n         relativePosition = v2(0.65, 0.95),\n         text = 'EASY',\n      },\n   })\n   content:add({\n      type = ui.TYPE.Image,\n      props = {\n         alpha = 0.5,\n         color = util.color.hex('910601'),\n         relativePosition = v2(0.7, 0.2),\n         relativeSize = v2(0.2, 0.15),\n         resource = ui.texture({ path = 'white' }),\n      },\n   })\n   content:add({\n      type = ui.TYPE.Image,\n      props = {\n         alpha = 0.5,\n         color = util.color.hex('910601'),\n         relativePosition = v2(0.7, 0.8),\n         relativeSize = v2(0.2, 0.15),\n         resource = ui.texture({ path = 'white' }),\n      },\n   })\n   content:add({\n      template = templates.textNormal,\n      props = {\n         anchor = v2(1, 0.5),\n         relativePosition = v2(0.65, 0.35),\n         text = 'x3.0',\n      },\n   })\n   content:add({\n      template = templates.textNormal,\n      props = {\n         anchor = v2(1, 0.5),\n         relativePosition = v2(0.65, 0.8),\n         text = 'x0.3',\n      },\n   })\n   content:add({\n      content = ui.content({ borders(true) }),\n      props = {\n         relativePosition = v2(0.7, 0.2),\n         relativeSize = v2(0.2, 0.75),\n      },\n   })\n   local lineRelativePosition = 0.2 + 0.75 * (1 - skillAdvancementDifficultyFraction())\n   content:add({\n      name = 'difficulty_line',\n      type = ui.TYPE.Image,\n      props = {\n         color = rgb(0.5, 0.5, 0.5),\n         anchor = v2(0, 0.5),\n         relativePosition = v2(0.68, lineRelativePosition),\n         relativeSize = v2(0.24, 0.01),\n         resource = ui.texture({ path = 'white' }),\n      },\n   })\n   return {\n      name = 'second_column',\n      content = content,\n      props = {\n         relativePosition = v2(0.49, 0),\n         relativeSize = v2(0.25, 1),\n      },\n   }\nend\n\n\n\n\n\n\nlocal function changeHitPoints(_)\n   ui.showMessage('Changing hit points is not supported yet')\n\n\n\n\n\n\nend\n\nlocal function hitPoint()\n   local content = ui.content({})\n\n   content:add(background({}))\n   content:add(borders(true))\n   content:add(textLines({\n      lines = { 'MAX', 'HIT POINTS', 'PER LEVEL' },\n      relativePosition = v2(0.1, 0.01),\n      relativeSize = v2(0.8, 0.49),\n   }))\n   content:add(TextButton:new({\n      lines = { '+' },\n      events = {\n         focusChange = function() mainElement:update() end,\n         mouseClick = function() changeHitPoints(1) end,\n      },\n      props = {\n         relativePosition = v2(0.1, 0.5),\n         relativeSize = v2(0.1, 0.2),\n      },\n   }):layout())\n   content:add(TextButton:new({\n      lines = { '-' },\n      events = {\n         focusChange = function() mainElement:update() end,\n         mouseClick = function() changeHitPoints(-1) end,\n      },\n      props = {\n         relativePosition = v2(0.1, 0.7),\n         relativeSize = v2(0.1, 0.2),\n      },\n   }):layout())\n   content:add({\n      name = 'boxedHitPoints',\n      content = ui.content({\n         borders(false),\n         textLines({ lines = { tostring(specials.maxHp) } }),\n      }),\n      props = {\n         relativePosition = v2(0.3, 0.5),\n         relativeSize = v2(0.6, 0.4),\n      },\n   })\n   return {\n      name = 'hitPoints',\n      content = content,\n      props = {\n         relativePosition = v2(0.75, 0),\n         relativeSize = v2(0.25, 0.32),\n      },\n   }\nend\n\nlocal function createEditElement(availableSpecials, add)\n   destroyMainElement()\n   local toGroup = {}\n   for _, special in ipairs(availableSpecials) do\n      table.insert(toGroup, {\n         layout = {\n            type = ui.TYPE.Flex,\n            props = {\n               autoSize = false,\n               horizontal = true,\n               relativeSize = v2(1, 0),\n               size = v2(0, templates.textNormal.props.textSize),\n            },\n            content = ui.content({\n               {\n                  template = templates.textNormal,\n                  name = 'text',\n                  props = {\n                     autoSize = false,\n                     relativeSize = v2(0.7, 0),\n                     size = v2(0, templates.textNormal.props.textSize),\n                     text = special.name,\n                  },\n               },\n               {\n                  template = templates.textNormal,\n                  name = 'cost',\n                  props = {\n                     autoSize = false,\n                     relativeSize = v2(0.3, 0),\n                     size = v2(0, templates.textNormal.props.textSize),\n                     text = tostring(special.cost),\n                     textAlignH = ui.ALIGNMENT.End,\n                  },\n               },\n            }),\n         },\n         group = special.group,\n         data = special,\n      })\n   end\n   local items = group(toGroup)\n   local selected = nil\n   local scrollable\n   scrollable = ScrollableGroups:new({\n      items = items,\n      events = {\n         focusGainNonGroup = function(_, item)\n            if not item.data then return end\n            local special = item.data\n            if not special.description then return end\n            local tooltip = lookupLayout(editElement.layout, { 'tooltip' })\n            tooltip.content = ui.content({\n               background({}),\n               borders(true),\n               {\n                  template = templates.textNormal,\n                  props = {\n                     autoSize = false,\n                     multiline = true,\n                     relativePosition = v2(0.05, 0.1),\n                     relativeSize = v2(0.9, 0.8),\n                     wordWrap = true,\n                     text = special.description,\n                  },\n               },\n            })\n            editElement:update()\n         end,\n         focusLossNonGroup = function(_, _)\n            local tooltip = lookupLayout(editElement.layout, { 'tooltip' })\n            if not tooltip.content then return end\n            tooltip.content = nil\n            editElement:update()\n         end,\n         mouseClickNonGroup = function(_, item)\n            if type(selected) == \"table\" then\n               lookupLayout(selected.layout, { 'text' }).props.textColor = templates.textNormal.props.textColor\n               lookupLayout(selected.layout, { 'cost' }).props.textColor = templates.textNormal.props.textColor\n            end\n            selected = item\n            lookupLayout(selected.layout, { 'text' }).props.textColor = templates.textHeader.props.textColor\n            lookupLayout(selected.layout, { 'cost' }).props.textColor = templates.textHeader.props.textColor\n         end,\n         mouseDoubleClickNonGroup = function(_, item)\n            add(item.data)\n            destroyEditElement()\n            createMainElement()\n         end,\n         onChange = function(_) editElement:update() end,\n      },\n      props = {\n         lineSizeY = templates.textNormal.props.textSize,\n         relativePosition = v2(0.05, 0.05),\n         relativeSize = v2(0.9, 0.7),\n      },\n   })\n   editElementChangeSelection = function(offset)\n\n      local newCurrent = scrollable.scrollable.scrollbar.current + offset\n      scrollable.scrollable:setCurrent(newCurrent)\n      scrollable:update()\n      scrollable.options.events.onChange(newCurrent)\n   end\n   local content = ui.content({})\n   content:add(background({}))\n   content:add(borders(true))\n   content:add(scrollable:layout())\n   content:add(TextButton:new({\n      lines = { 'EXIT' },\n      backgroundOptions = {\n         color = rgb(0.1, 0, 0),\n      },\n      events = {\n         focusChange = function() editElement:update() end,\n         mouseClick = function()\n            destroyEditElement()\n            createMainElement()\n         end,\n      },\n      props = {\n         relativePosition = v2(0.8, 0.8),\n         relativeSize = v2(0.15, 0.15),\n      },\n   }):layout())\n   editElement = ui.create({\n      layer = 'Windows',\n      content = ui.content({\n         {\n            content = content,\n            props = {\n               anchor = v2(0.5, 0.5),\n               relativePosition = v2(0.5, 0.5),\n               relativeSize = v2(0.5, 0.5),\n            },\n         },\n         {\n            name = 'tooltip',\n            props = {\n               anchor = v2(0.5, 0),\n               relativePosition = v2(0.5, 0.77),\n               relativeSize = v2(0.5, 0.15),\n            },\n         },\n      }),\n      props = { relativeSize = v2(1, 1) },\n   })\n   I.UI.setMode('Interface', { windows = {} })\nend\n\nlocal function openAddAdvantagesWindow()\n   createEditElement(specials:availableAdvantages(), function(a) table.insert(specials.advantages, a) end)\nend\n\nlocal function openAddDisadvantagesWindow()\n   createEditElement(specials:availableDisadvantages(), function(a) table.insert(specials.disadvantages, a) end)\nend\n\nlocal function editSpecialAdvantagesButton()\n   return TextButton:new({\n      lines = { 'ADD', 'SPECIAL', 'ADVANTAGES' },\n      backgroundOptions = {},\n      events = {\n         focusChange = function() mainElement:update() end,\n         mouseClick = openAddAdvantagesWindow,\n      },\n      props = {\n         relativePosition = v2(0.75, 0.33),\n         relativeSize = v2(0.25, 0.16),\n      },\n   }):layout()\nend\n\nlocal function editSpecialDisadvantagesButton()\n   return TextButton:new({\n      lines = { 'ADD', 'SPECIAL', 'DISADVANTAGES' },\n      backgroundOptions = {},\n      events = {\n         focusChange = function() mainElement:update() end,\n         mouseClick = openAddDisadvantagesWindow,\n      },\n      props = {\n         relativePosition = v2(0.75, 0.50),\n         relativeSize = v2(0.25, 0.16),\n      },\n   }):layout()\nend\n\nlocal function createReputationElement()\n   ui.showMessage('Changing reputation is not yet implemented!')\n   return\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nend\n\nlocal function editReputationButton()\n   return TextButton:new({\n      lines = { 'EDIT', 'REPUTATION' },\n      backgroundOptions = {},\n      events = {\n         focusChange = function() mainElement:update() end,\n         mouseClick = createReputationElement,\n      },\n      props = {\n         relativePosition = v2(0.75, 0.67),\n         relativeSize = v2(0.25, 0.16),\n      },\n   }):layout()\nend\n\nlocal function calculateSpecialsSkillMultiplier(cost)\n   if cost >= 0 then\n      return 1 + (0.3 - 1) / 30 * cost\n   else\n      return 3 + (1 - 3) / 30 * (cost + 30)\n   end\nend\n\nlocal function isSkillGainMultiplierEnabled()\n   return settings:get('enable_special_skill_progression_modifier')\nend\n\nI.SkillProgression.addSkillUsedHandler(function(_, params)\n   local multiplier = isSkillGainMultiplierEnabled() and 1 or specialsSkillMultiplier\n   params.skillGain = params.skillGain * multiplier\n   return true\nend)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlocal function removeExistingSpecials()\n   for _, spell in ipairs(types.Actor.spells(self)) do\n      if advantagesByAbilityId[spell.id] or disadvantagesByAbilityId[spell.id] then\n         print('Removing spell ' .. spell.id)\n         types.Actor.spells(self):remove(spell)\n      end\n   end\nend\n\nlocal function applySpecials()\n   removeExistingSpecials()\n\n   print('Applying specials abilities')\n   nightlys = {}\n   for _, advantage in ipairs(specials.advantages) do\n      if advantage.abilityId then\n         types.Actor.spells(self):add(advantage.abilityId)\n      end\n      if advantage.abilityIdAtNight then\n         table.insert(nightlys, advantage)\n      end\n      if advantage.abilityIdWhenInside or advantage.abilityIdWhenOutside then\n         table.insert(insidesOutsides, advantage)\n      end\n   end\n   phobias = {}\n   for _, disadvantage in ipairs(specials.disadvantages) do\n      if disadvantage.abilityId then\n         types.Actor.spells(self):add(disadvantage.abilityId)\n      end\n      if disadvantage.abilityIdAtNight then\n         table.insert(nightlys, disadvantage)\n      end\n      if disadvantage.abilityIdWhenInside or disadvantage.abilityIdWhenOutside then\n         table.insert(insidesOutsides, disadvantage)\n      end\n\n      local phobiaOf = disadvantage.phobiaOf\n      if type(phobiaOf) == \"table\" then\n         table.insert(phobias, disadvantage)\n      end\n   end\n\n   specialsSkillMultiplier = calculateSpecialsSkillMultiplier(specials:cost())\n   print('Applying specials skill multiplier ' .. tostring(specialsSkillMultiplier))\n\n\nend\n\nlocal function createApplyElement()\n   local content = ui.content({})\n   content:add(background({}))\n   content:add(borders(true))\n   content:add({\n      content = ui.content({ borders(false) }),\n      props = {\n         relativePosition = v2(0.05, 0.05),\n         relativeSize = v2(0.9, 0.5),\n      },\n   })\n   local specialsCost = specials:cost()\n   local text\n   local enableApplyButton\n   if specialsCost > maxValidDifficultyPoints or specialsCost < -maxValidDifficultyPoints then\n      text = 'The total cost of the special advantages and disadvantages is ' .. tostring(specialsCost) ..\n      ' which is outside the valid range [-' .. tostring(maxValidDifficultyPoints) .. ',' ..\n      tostring(maxValidDifficultyPoints) .. ']. Do you want to exit or go back to editing?'\n      enableApplyButton = false\n   else\n      text = 'Do you want to apply the special advantages and disadvantages, exit without applying them or go back to editing?'\n      enableApplyButton = true\n   end\n   content:add({\n      template = templates.textNormal,\n      props = {\n         autoSize = false,\n         text = text,\n         multiline = true,\n         wordWrap = true,\n         relativePosition = v2(0.1, 0.1),\n         relativeSize = v2(0.8, 0.4),\n      },\n   })\n   if enableApplyButton then\n      content:add(TextButton:new({\n         lines = { 'APPLY' },\n         backgroundOptions = {\n            color = rgb(0.1, 0, 0),\n         },\n         events = {\n            focusChange = function() applyElement:update() end,\n            mouseClick = function()\n               applySpecials()\n               destroyApplyElement()\n            end,\n         },\n         props = {\n            relativePosition = v2(0.1, 0.6),\n            relativeSize = v2(0.2, 0.3),\n         },\n      }):layout())\n   end\n   content:add(TextButton:new({\n      lines = { 'EXIT' },\n      backgroundOptions = {\n         color = rgb(0.1, 0, 0),\n      },\n      events = {\n         focusChange = function() applyElement:update() end,\n         mouseClick = destroyApplyElement,\n      },\n      props = {\n         relativePosition = v2(0.4, 0.6),\n         relativeSize = v2(0.2, 0.3),\n      },\n   }):layout())\n   content:add(TextButton:new({\n      lines = { 'GO BACK' },\n      events = {\n         focusChange = function() applyElement:update() end,\n         mouseClick = function()\n            destroyApplyElement()\n            createMainElement()\n         end,\n      },\n      props = {\n         relativePosition = v2(0.7, 0.6),\n         relativeSize = v2(0.2, 0.3),\n      },\n   }):layout())\n   applyElement = ui.create({\n      layer = 'Windows',\n      content = content,\n      props = {\n         anchor = v2(0.5, 0.5),\n         relativePosition = v2(0.5, 0.5),\n         relativeSize = v2(0.4, 0.3),\n      },\n   })\n   I.UI.setMode('Interface', { windows = {} })\nend\n\nlocal function exitButton()\n   return TextButton:new({\n      lines = { 'EXIT' },\n      backgroundOptions = {\n         color = rgb(0.1, 0, 0),\n      },\n      events = {\n         focusChange = function() mainElement:update() end,\n         mouseClick = function()\n            destroyMainElement()\n            createApplyElement()\n         end,\n      },\n      props = {\n         relativePosition = v2(0.825, 0.86),\n         relativeSize = v2(0.10, 0.12),\n      },\n   }):layout()\nend\n\ncreateMainElement = function()\n   mainElement = ui.create({\n      layer = 'Windows',\n      name = 'outer',\n      type = ui.TYPE.Widget,\n      props = {\n         anchor = v2(0.5, 0.5),\n         relativePosition = v2(0.5, 0.5),\n         relativeSize = v2(0.7, 0.8),\n      },\n      content = ui.content({\n         firstColumn(),\n         secondColumn(),\n         hitPoint(),\n         editSpecialAdvantagesButton(),\n         editSpecialDisadvantagesButton(),\n         editReputationButton(),\n         exitButton(),\n      }),\n   })\n   I.UI.setMode('Interface', { windows = {} })\nend\n\nlocal function getOpenSpecialMainElementKey()\n   return settings:get('open_special_main_element_key')\nend\n\nlocal function loadPlayerSpecials()\n   specials = AdvantagesDisadvantages:new()\n   for _, spell in ipairs(types.Actor.spells(self)) do\n      local advantage = advantagesByAbilityId[spell.id]\n      if advantage then\n         table.insert(specials.advantages, advantage)\n      else\n         local disadvantage = disadvantagesByAbilityId[spell.id]\n         if disadvantage then\n            table.insert(specials.disadvantages, disadvantage)\n         end\n      end\n   end\n   for _, phobia in ipairs(phobias) do\n      table.insert(specials.disadvantages, phobia)\n   end\nend\n\nlocal testElement = nil\n\nlocal function onKeyPress(key)\n   if not mainElement and input.getKeyName(key.code):lower() == getOpenSpecialMainElementKey():lower() then\n      loadPlayerSpecials()\n      createMainElement()\n   elseif key.code == input.KEY.Escape then\n      destroyMainElement()\n      destroyEditElement()\n      destroyApplyElement()\n      destroyReputationElement()\n   elseif editElement and key.code == input.KEY.UpArrow then\n      editElementChangeSelection(-1)\n   elseif editElement and key.code == input.KEY.DownArrow then\n      editElementChangeSelection(1)\n   elseif editElement and key.code == input.KEY.Enter then\n\n   end\nend\n\nlocal function onMouseWheel(vertical, _)\n   if not editElement or not onMouseWheel then return end\n   editElementChangeSelection(-vertical)\nend\n\nlocal applyReputationChangesLastRun = 100000000\nlocal applyReputationChangesEvery = 5\nlocal function applyReputationChanges(dt)\n   applyReputationChangesLastRun = applyReputationChangesLastRun + dt\n   if applyReputationChangesLastRun < applyReputationChangesEvery then return end\n   applyReputationChangesLastRun = 0\n   for _, actor in ipairs(nearby.actors) do\n      if not types.NPC.objectIsInstance(actor) then return end\n      for _, factionId in ipairs(types.NPC.getFactions(actor)) do\n         if specials.reputation[factionId] then\n            actor:sendEvent('SpecialModifyDisposition', { toward = self.id, modifier = specials.reputation[factionId] })\n            break\n         end\n      end\n   end\nend\n\nlocal function applyNightlys(dt)\n   nightlysTimeSinceCheck = nightlysTimeSinceCheck + dt\n   if nightlysTimeSinceCheck < nightlysCheckEvery then return end\n   nightlysTimeSinceCheck = 0\n   local hour = core.getGameTime() % time.day\n   local isNight = hour < 21600 or hour >= 64800\n   for _, special in ipairs(nightlys) do\n      if isNight and not (types.Actor.spells(self))[special.abilityIdAtNight] then\n         types.Actor.spells(self):add(special.abilityIdAtNight)\n      elseif not isNight and (types.Actor.spells(self))[special.abilityIdAtNight] then\n         types.Actor.spells(self):remove(special.abilityIdAtNight)\n      end\n   end\nend\n\nlocal function applyInsidesOutsides(dt)\n   insidesTimeSinceCheck = insidesTimeSinceCheck + dt\n   if insidesTimeSinceCheck < insidesCheckEvery then return end\n   insidesTimeSinceCheck = 0\n   for _, special in ipairs(insidesOutsides) do\n      if self.cell.isExterior then\n         if special.abilityIdWhenInside and (types.Actor.spells(self))[special.abilityIdWhenInside] then\n            types.Actor.spells(self):remove(special.abilityIdWhenInside)\n         end\n         if special.abilityIdWhenOutside and not (types.Actor.spells(self))[special.abilityIdWhenOutside] then\n            types.Actor.spells(self):add(special.abilityIdWhenOutside)\n         end\n      else\n         if special.abilityIdWhenInside and not (types.Actor.spells(self))[special.abilityIdWhenInside] then\n            types.Actor.spells(self):add(special.abilityIdWhenInside)\n         end\n         if special.abilityIdWhenOutside and (types.Actor.spells(self))[special.abilityIdWhenOutside] then\n            types.Actor.spells(self):remove(special.abilityIdWhenOutside)\n         end\n      end\n   end\nend\n\nlocal function onUpdate(dt)\n   applyReputationChanges(dt)\n   applyNightlys(dt)\n   applyInsidesOutsides(dt)\n\n   if not phobias then return end\n\n   if types.Actor.activeSpells(self):isSpellActive('special_phobia') then\n      phobiaTimeSinceLastTriggerred = phobiaTimeSinceLastTriggerred + dt\n\n      local willpower = types.Actor.stats.attributes.willpower(self).modified\n      local duration = math.max(10, 60 - 0.5 * willpower)\n\n      if phobiaTimeSinceLastTriggerred >= duration then\n\n         types.Actor.activeSpells(self):remove('special_phobia')\n      end\n   else\n\n      phobiaTimeSinceCheck = phobiaTimeSinceCheck + dt\n      if phobiaTimeSinceCheck < phobiaCheckEvery then return end\n      phobiaTimeSinceCheck = 0\n\n      local res = nearby.castRay(camera.getPosition(), camera.getPosition() + camera.viewportToWorldVector(v2(0.5, 0.5)) * 2048, { ignore = self })\n      if res and res.hitObject and (types.Creature.objectIsInstance(res.hitObject) or types.NPC.objectIsInstance(res.hitObject)) then\n         local id = ''\n         if types.Creature.objectIsInstance(res.hitObject) then\n            id = types.Creature.record(res.hitObject).id\n         elseif types.NPC.objectIsInstance(res.hitObject) then\n            id = types.NPC.record(res.hitObject).id\n         end\n         for _, special in ipairs(phobias) do\n            for _, phobia in ipairs(special.phobiaOf or {}) do\n               if string.find(id:lower(), phobia) then\n                  phobiaTimeSinceLastTriggerred = 0\n                  print('is spell active:' .. tostring(types.Actor.activeSpells(self):isSpellActive('special_phobia')))\n                  if not types.Actor.activeSpells(self):isSpellActive('special_phobia') then\n                     local name = nil\n                     if types.Creature.objectIsInstance(res.hitObject) then\n                        name = types.Creature.record(res.hitObject).name\n                     elseif types.NPC.objectIsInstance(res.hitObject) then\n                        name = types.NPC.record(res.hitObject).name\n                     end\n                     ui.showMessage(special.name .. ' triggered by ' .. name)\n                     types.Actor.activeSpells(self):add({\n                        id = 'special_phobia',\n                        name = 'Phobia',\n                        effects = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26 },\n                        ignoreResistances = true,\n                        ignoreSpellAbsorption = true,\n                        ignoreReflect = true,\n                        stackable = false,\n                        temporary = true,\n                     })\n                  end\n               end\n            end\n         end\n      end\n   end\nend\n\nlocal function onSave()\n   return {\n      insidesOutsides = insidesOutsides,\n      nightlys = nightlys,\n      phobias = phobias,\n      reputation = specials.reputation,\n      specialsSkillMultiplier = specialsSkillMultiplier,\n   }\nend\n\nlocal function onLoad(data)\n   if data.insidesOutsides then\n      insidesOutsides = insidesOutsides\n   end\n   if data.nightlys then\n      nightlys = data.nightlys\n   end\n   if data.specialsSkillMultiplier and data.specialsSkillMultiplier ~= 1 then\n      specialsSkillMultiplier = data.specialsSkillMultiplier\n      print('Applying specials skill multiplier ' .. tostring(specialsSkillMultiplier))\n   end\n   if data.phobias then\n      phobias = data.phobias\n   end\n   if data.reputation then\n      specials.reputation = data.reputation\n   end\n\nend\n\nlocal function checkAndAddSpecial(special)\n   checkSpecialAbilitiesExist(special)\n   addSpecial(special)\nend\n\nreturn {\n   engineHandlers = {\n      onKeyPress = onKeyPress,\n      onUpdate = onUpdate,\n      onMouseWheel = onMouseWheel,\n      onSave = onSave,\n      onLoad = onLoad,\n   },\n   eventHandlers = {\n      AddSpecial = checkAndAddSpecial,\n   },\n}\n",
    "Special for OpenMW-55026-0-1-6-1726438225\\scripts\\special\\utils.lua": "local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local table = _tl_compat and _tl_compat.table or table; local ui = require('openmw.ui')\n\nfunction lookupLayout(layout, names)\n   local current = layout\n   for _, name in ipairs(names) do\n      current = current.content[name]\n      if current == nil then\n         error('Unable to find layour with name ' .. name .. '(names: ' .. table.concat(names, \".\") .. ')')\n      end\n   end\n   return current\nend\n",
    "Special for OpenMW-55026-0-1-6-1726438225\\scripts\\special\\widgets.lua": "local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local assert = _tl_compat and _tl_compat.assert or assert; local ipairs = _tl_compat and _tl_compat.ipairs or ipairs; local math = _tl_compat and _tl_compat.math or math; local table = _tl_compat and _tl_compat.table or table; local async = require('openmw.async')\nlocal auxUi = require('openmw_aux.ui')\nlocal I = require('openmw.interfaces')\nlocal ui = require('openmw.ui')\nlocal util = require('openmw.util')\nlocal _utils = require('scripts.special.utils')\n\nlocal v2 = util.vector2\nlocal V2 = util.Vector2\n\nsandColor = I.MWUI.templates.textNormal.props.textColor\nlightSandColor = I.MWUI.templates.textHeader.props.textColor\n\nlocal function calculateTextSize()\n   local screenSize = ui.layers[ui.layers.indexOf('Windows')].size\n   return screenSize.y / 35\nend\n\nlocal function calculateTextNormalTemplate()\n   local textTemplate = auxUi.deepLayoutCopy(I.MWUI.templates.textNormal)\n   textTemplate.props.textSize = calculateTextSize()\n   textTemplate.props.textColor = sandColor\n   return textTemplate\nend\n\nlocal function calculateTextHeaderTemplate()\n   local textTemplate = auxUi.deepLayoutCopy(calculateTextNormalTemplate())\n   textTemplate.props.textColor = lightSandColor\n   return textTemplate\nend\n\ntemplates = {\n   sandImage = {\n      type = ui.TYPE.Image,\n      props = {\n         alpha = 0.8,\n         color = sandColor,\n         resource = ui.texture({ path = 'white' }),\n      },\n   },\n\n   textHeader = calculateTextHeaderTemplate(),\n   textNormal = calculateTextNormalTemplate(),\n}\n\nBackgroundOptions = {}\n\n\n\n\nfunction background(options)\n   return {\n      type = ui.TYPE.Image,\n      props = {\n         alpha = options.alpha or 0.9,\n         color = options.color or util.color.rgb(0, 0, 0),\n         relativeSize = v2(1, 1),\n         resource = ui.texture({ path = 'white' }),\n      },\n   }\nend\n\nfunction borders(thick)\n   return {\n      template = thick and I.MWUI.templates.bordersThick or I.MWUI.templates.borders,\n      props = { relativeSize = v2(1, 1) },\n   }\nend\n\n\n\n\n\n\n\n\n\n\nfunction textLines(options)\n   local content = ui.content({})\n   for i, line in ipairs(options.lines) do\n      content:add({\n         name = tostring(i),\n         template = templates.textNormal,\n         props = {\n            text = line,\n            textColor = options.color,\n         },\n      })\n   end\n   return {\n      type = ui.TYPE.Flex,\n      name = options.flexName or 'flex',\n      props = {\n         autoSize = false,\n         arrange = ui.ALIGNMENT.Center,\n         align = ui.ALIGNMENT.Center,\n         relativePosition = options.relativePosition or v2(0, 0),\n         relativeSize = options.relativeSize or v2(1, 1),\n         size = options.size or v2(0, 0),\n      },\n      content = content,\n   }\nend\n\nTextButtonEvents = {}\n\n\n\n\n\n\nTextButtonProperties = {}\n\n\n\n\n\nTextButtonOptions = {}\n\n\n\n\n\n\n\nTextButton = {}\n\n\n\n\n\nfunction TextButton:new(options)\n   local self = setmetatable({}, { __index = TextButton })\n   self.options = options\n   local unfocusedColor = options.normalTextColor or sandColor\n   self.textLines = textLines({\n      color = unfocusedColor,\n      lines = options.lines,\n   })\n   return self\nend\n\nfunction TextButton:changeTextColor(color)\n   for i, _ in ipairs(self.options.lines) do\n      lookupLayout(self.textLines, { tostring(i) }).props.textColor = color\n   end\n   if self.options.events.focusChange then self.options.events.focusChange() end\nend\n\nfunction TextButton:layout()\n   local content = ui.content({})\n   if self.options.backgroundOptions ~= nil then\n      content:add(background(self.options.backgroundOptions))\n   end\n   content:add(borders(true))\n   content:add(self.textLines)\n   local events = {}\n   local unfocusedColor = self.options.normalTextColor or sandColor\n   events.focusGain = async:callback(self.options.events.focusGain or function() self:changeTextColor(lightSandColor) end)\n   events.focusLoss = async:callback(self.options.events.focusLoss or function() self:changeTextColor(unfocusedColor) end)\n   if self.options.events and self.options.events.mouseClick then\n      events.mouseClick = async:callback(self.options.events.mouseClick)\n   end\n   return {\n      content = content,\n      events = events,\n      props = self.options.props,\n   }\nend\n\nScrollbarProperties = {}\n\n\n\n\nScrollbarEvents = {}\n\n\n\nScrollbarOptions = {}\n\n\n\n\n\nScrollbar = {}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Scrollbar:new(options)\n   local self = setmetatable({}, { __index = Scrollbar })\n   options.size = options.size or 1\n   options.events = options.events or {}\n   options.events.onChange = options.events.onChange or function(_) end\n   options.props = options.props or {}\n   self.options = options\n   self.buttonRelativeSizeY = 0.1\n   self.scrollerAreaRelativeSizeY = 1 - 2 * self.buttonRelativeSizeY\n   self.scrollerRelativeSizeY = self.scrollerAreaRelativeSizeY / self.options.size\n   self.current = 1\n   return self\nend\n\nfunction Scrollbar:updateScrollerRelativePosition()\n   if not self.scroller then return end\n   local scrollerRelativePositionY = self.buttonRelativeSizeY +\n   (self.current - 1) * self.scrollerRelativeSizeY\n   self.scroller.props = self.scroller.props or {}\n   self.scroller.props.relativePosition = v2(0, scrollerRelativePositionY)\nend\n\nfunction Scrollbar:updateScroller()\n   self.scroller.props = self.scroller.props or {}\n   self.scroller.props.relativeSize = v2(1, self.scrollerRelativeSizeY)\n   self:updateScrollerRelativePosition()\nend\n\nfunction Scrollbar:update()\n   self.scrollerRelativeSizeY = self.scrollerAreaRelativeSizeY / self.options.size\n\n   if self.options.size <= 1 then return end\n\n   if self._layout and self._layout.content and #self._layout.content > 1 then\n      self:updateScroller()\n      return\n   end\n\n   self._layout.content = ui.content({})\n\n\n   self._layout.content:add({\n      template = I.MWUI.templates.borders,\n      props = { relativeSize = v2(1, 1) },\n   })\n\n\n   self.upButton = {\n      template = templates.sandImage,\n      events = {\n         mouseClick = async:callback(function()\n            self:decrease()\n            self.options.events.onChange(self.current)\n         end),\n      },\n      props = {\n         relativeSize = v2(1, self.buttonRelativeSizeY),\n      },\n   }\n   self._layout.content:add(self.upButton)\n\n\n   self.scroller = { template = templates.sandImage }\n   self._layout.content:add(self.scroller)\n   self:updateScroller()\n\n\n   local downButtonRelativePositionY = self.buttonRelativeSizeY + self.scrollerAreaRelativeSizeY\n   self.downButton = {\n      template = templates.sandImage,\n      events = {\n         mouseClick = async:callback(function()\n            self:increase()\n            self.options.events.onChange(self.current)\n         end),\n      },\n      props = {\n         relativePosition = v2(0, downButtonRelativePositionY),\n         relativeSize = v2(1, self.buttonRelativeSizeY),\n      },\n   }\n   self._layout.content:add(self.downButton)\nend\n\nfunction Scrollbar:changeSize(newSize)\n   self.options.size = math.max(1, newSize)\n   self.current = math.min(self.options.size, self.current)\n   self:update()\nend\n\nfunction Scrollbar:decreaseSize()\n   self:changeSize(self.options.size - 1)\nend\n\nfunction Scrollbar:setCurrent(newCurrent)\n   self.current = math.max(1, math.min(self.options.size, newCurrent))\n   self:updateScrollerRelativePosition()\nend\n\nfunction Scrollbar:increase() self:setCurrent(self.current + 1) end\nfunction Scrollbar:decrease() self:setCurrent(self.current - 1) end\n\nfunction Scrollbar:layout()\n   self._layout = {\n      props = self.options.props,\n   }\n   self:update()\n   return self._layout\nend\n\nScrollableTextLinesProperties = {}\n\n\n\n\n\nScrollableTextLinesEvents = {}\n\n\n\n\nScrollableTextLinesOptions = {}\n\n\n\n\n\nScrollableTextLines = {}\n\n\n\n\n\nfunction ScrollableTextLines:new(options)\n   local self = setmetatable({}, { __index = ScrollableTextLines })\n   options.lines = options.lines or {}\n   options.events = options.events or {}\n   options.events.mouseDoubleClick = options.events.mouseDoubleClick or function(_) end\n   options.events.onChange = options.events.onChange or function(_) end\n   options.props = options.props or {}\n   options.props.scrollbarRelativeSizeWidth = options.props.scrollbarRelativeSizeWidth or 0.01\n   self.options = options\n   return self\nend\n\nfunction ScrollableTextLines:update()\n   if not self.linesFlex then return end\n   local linesFlexContent = ui.content({})\n   for i, line in ipairs(self.options.lines) do\n      if i >= self.scrollbar.current then\n         local isFirst = i == self.scrollbar.current\n         linesFlexContent:add({\n            template = isFirst and templates.textHeader or templates.textNormal,\n            events = {\n               mouseClick = async:callback(function()\n                  self.scrollbar:setCurrent(i)\n                  self:update()\n                  self.options.events.onChange(i)\n               end),\n               mouseDoubleClick = async:callback(function()\n                  self.options.events.mouseDoubleClick(i)\n               end),\n            },\n            props = { text = line },\n         })\n      end\n   end\n   self.linesFlex.content = linesFlexContent\nend\n\nfunction ScrollableTextLines:remove(i)\n   table.remove(self.options.lines, i)\n   self.scrollbar:decreaseSize()\n   self:update()\n   self.options.events.onChange(self.scrollbar.current)\nend\n\nfunction ScrollableTextLines:layout()\n   local content = ui.content({})\n\n   self.linesFlex = {\n      type = ui.TYPE.Flex,\n      props = {\n         relativePosition = v2(0.01, 0.01),\n         relativeSize = v2(1 - 2 * 0.01 - self.options.props.scrollbarRelativeSizeWidth, 0.98),\n      },\n   }\n   content:add(self.linesFlex)\n   self.scrollbar = Scrollbar:new({\n      size = #self.options.lines,\n      events = {\n         onChange = function(newCurrent)\n            self:update()\n            self.options.events.onChange(newCurrent)\n         end,\n      },\n      props = {\n         relativePosition = v2(0.98, 0.01),\n         relativeSize = v2(self.options.props.scrollbarRelativeSizeWidth, 0.98),\n      },\n   })\n   content:add(self.scrollbar:layout())\n\n   self:update()\n\n   return {\n      content = content,\n      props = self.options.props,\n   }\nend\n\n\nScrollableProperties = {}\n\n\n\n\n\n\nScrollableEvents = {}\n\n\n\n\n\nScrollableOptions = {}\n\n\n\n\n\nScrollable = {}\n\n\n\n\n\n\n\nlocal noOp = function() end\n\nfunction Scrollable:new(options)\n   local self = setmetatable({}, { __index = Scrollable })\n   assert(options.props.lineSizeY)\n   options.lines = options.lines or {}\n   options.events = options.events or {}\n   options.events.mouseClick = options.events.mouseClick or noOp\n   options.events.mouseDoubleClick = options.events.mouseDoubleClick or noOp\n   options.events.onChange = options.events.onChange or noOp\n   options.props = options.props or {}\n   options.props.scrollbarRelativeSizeWidth = options.props.scrollbarRelativeSizeWidth or 0.01\n   self.options = options\n   return self\nend\n\nfunction Scrollable:update()\n   if not self.linesFlex then return end\n   local linesFlexContent = ui.content({})\n   for i, line in ipairs(self.options.lines) do\n      if i >= self.scrollbar.current then\n         linesFlexContent:add({\n            content = ui.content({ line }),\n            events = {\n               mouseClick = async:callback(function()\n                  self.options.events.mouseClick(i)\n               end),\n               mouseDoubleClick = async:callback(function()\n                  self.options.events.mouseDoubleClick(i)\n               end),\n            },\n            props = {\n               relativeSize = v2(1, 0),\n               size = v2(0, self.options.props.lineSizeY),\n            },\n         })\n      end\n   end\n   self.linesFlex.content = linesFlexContent\nend\n\nfunction Scrollable:updateAndOnChange()\n   self:update()\n   self.options.events.onChange(self.scrollbar.current)\nend\n\nfunction Scrollable:setCurrent(current)\n   self.scrollbar:setCurrent(current)\n   self:updateAndOnChange()\nend\n\nfunction Scrollable:increase()\n   self.scrollbar:increase()\n   self:updateAndOnChange()\nend\n\nfunction Scrollable:decrease()\n   self.scrollbar:decrease()\n   self:updateAndOnChange()\nend\n\nfunction Scrollable:setLines(lines)\n   self.options.lines = lines or {}\n   self.scrollbar:changeSize(#self.options.lines)\n   self:update()\nend\n\nfunction Scrollable:remove(i)\n   table.remove(self.options.lines, i)\n   self.scrollbar:decreaseSize()\n   self:updateAndOnChange()\nend\n\nfunction Scrollable:layout()\n   local content = ui.content({})\n\n   local scrollbarPositionX = 1 - 2 * 0.01 - self.options.props.scrollbarRelativeSizeWidth\n   self.linesFlex = {\n      type = ui.TYPE.Flex,\n      props = {\n         autoSize = false,\n         relativePosition = v2(0.01, 0.01),\n         relativeSize = v2(scrollbarPositionX - 0.05, 0.98),\n      },\n   }\n   content:add(self.linesFlex)\n   self.scrollbar = Scrollbar:new({\n      size = #self.options.lines,\n      events = {\n         onChange = function(_) self:updateAndOnChange() end,\n      },\n      props = {\n         relativePosition = v2(scrollbarPositionX, 0.01),\n         relativeSize = v2(self.options.props.scrollbarRelativeSizeWidth, 0.98),\n      },\n   })\n   local scrollbarLayout = self.scrollbar:layout()\n   scrollbarLayout.name = 'scrollbar'\n   content:add(self.scrollbar:layout())\n\n   self:update()\n\n   self._layout = {\n      content = content,\n      props = self.options.props,\n   }\n   return self._layout\nend\n\nExpandable = {}\n\n\n\n\n\n\n\nfunction Expandable:new(expandable)\n   local self = setmetatable(expandable, { __index = Expandable })\n   expandable.isExpanded = expandable.isExpanded == nil and false or expandable.isExpanded\n   expandable.items = expandable.items == nil and {} or expandable.items\n   expandable.numParents = expandable.numParents == nil and 0 or expandable.numParents\n   return self\nend\n\nfunction flattenExpandables(expandables)\n   local layouts = {}\n   local toVisit = {}\n   for i = 0, #expandables - 1 do\n      expandables[#expandables - i].numParents = 0\n      table.insert(toVisit, expandables[#expandables - i])\n   end\n   while #toVisit > 0 do\n      local current = table.remove(toVisit)\n      table.insert(layouts, current)\n      if current.isExpanded then\n         for i = 0, #current.items - 1 do\n            current.items[#current.items - i].numParents = current.numParents + 1\n            table.insert(toVisit, current.items[#current.items - i])\n         end\n      end\n   end\n   return layouts\nend\n\nExpandableScrollableEvents = {}\n\n\n\n\n\n\n\n\n\nExpandableScrollableOption = {}\n\n\n\n\n\nScrollableGroups = {}\n\n\n\n\n\n\n\n\nfunction ScrollableGroups:new(options)\n   local self = setmetatable({}, { __index = ScrollableGroups })\n   self.options = options\n   self.options.events = self.options.events or {}\n   self.options.events.focusGainNonGroup = self.options.events.focusGainNonGroup or noOp\n   self.options.events.focusLossNonGroup = self.options.events.focusLossNonGroup or noOp\n   self.options.events.mouseClickGroup = self.options.events.mouseClickGroup or noOp\n   self.options.events.mouseClickNonGroup = self.options.events.mouseClickNonGroup or noOp\n   self.options.events.mouseDoubleClickGroup = self.options.events.mouseDoubleClickGroup or noOp\n   self.options.events.mouseDoubleClickNonGroup = self.options.events.mouseDoubleClickNonGroup or noOp\n   self.options.events.onChange = self.options.events.onChange or noOp\n   self.options.items = self.options.items or {}\n   self.options.props = self.options.props or {}\n   return self\nend\n\nfunction ScrollableGroups:update()\n   self._flattenedItems = flattenExpandables(self.options.items)\n   local itemsLayouts = {}\n   for i, item in ipairs(self._flattenedItems) do\n      item.items = item.items or {}\n      local content = ui.content({})\n      local paddingSizeX = item.numParents * 0.025\n      local expandingSignSizeX = 0.05\n      content:add({\n         props = {\n            relativeSize = v2(paddingSizeX, 1),\n         },\n      })\n      if #item.items > 0 then\n         content:add({\n            template = templates.textNormal,\n            props = {\n               autoSize = false,\n               relativeSize = v2(expandingSignSizeX, 1),\n               text = item.isExpanded and '-' or '+',\n            },\n         })\n      else\n         content:add({\n            props = {\n               relativeSize = v2(expandingSignSizeX, 1),\n            },\n         })\n      end\n      content:add({\n         content = ui.content({ item.layout }),\n         props = {\n            relativeSize = v2(1 - paddingSizeX - expandingSignSizeX, 1),\n         },\n      })\n      table.insert(itemsLayouts, {\n         type = ui.TYPE.Flex,\n         content = content,\n         events = {\n            focusGain = async:callback(function()\n               if #item.items <= 0 then\n                  self.options.events.focusGainNonGroup(i, item)\n               end\n            end),\n            focusLoss = async:callback(function()\n               if #item.items <= 0 then\n                  self.options.events.focusLossNonGroup(i, item)\n               end\n            end),\n            mouseClick = async:callback(function()\n               if #item.items > 0 then\n                  self.options.events.mouseClickGroup(i, item)\n               else\n                  self.options.events.mouseClickNonGroup(i, item)\n               end\n               return true\n            end),\n            mouseDoubleClick = async:callback(function()\n               if #item.items > 0 then\n                  self.options.events.mouseDoubleClickGroup(i, item)\n               else\n                  self.options.events.mouseDoubleClickNonGroup(i, item)\n               end\n               return true\n            end),\n         },\n         props = {\n            autoSize = false,\n            horizontal = true,\n            relativeSize = v2(1, 0),\n            size = v2(0, templates.textNormal.props.textSize),\n         },\n      })\n   end\n   self.scrollable:setLines(itemsLayouts)\nend\n\nfunction ScrollableGroups:updateAndOnChange()\n   self:update()\n   self.options.events.onChange()\nend\n\nfunction ScrollableGroups:layout()\n   self.scrollable = Scrollable:new({\n      events = {\n         mouseClick = function(i)\n            self._flattenedItems[i].isExpanded = not self._flattenedItems[i].isExpanded\n            self:updateAndOnChange()\n         end,\n         onChange = self.options.events.onChange,\n      },\n      props = {\n         relativeSize = v2(1, 1),\n         lineSizeY = self.options.props.lineSizeY,\n      },\n   })\n   self._layout = {\n      content = ui.content({ self.scrollable:layout() }),\n      props = self.options.props,\n   }\n   self:update()\n   return self._layout\nend\n\nGrouppable = {}\n\n\n\n\n\nfunction group(grouppables)\n   local expandables = {}\n   local expandablesByGroup = {}\n   for _, grouppable in ipairs(grouppables) do\n      local pgroup = ''\n      local lastExpandable = nil\n\n      for i, part in ipairs(grouppable.group) do\n         pgroup = pgroup .. '.' .. part\n         if not expandablesByGroup[pgroup] then\n            local expandable = Expandable:new({\n               layout = {\n                  template = templates.textNormal,\n                  props = { text = part },\n               },\n            })\n            if lastExpandable then\n               table.insert(lastExpandable.items, expandable)\n            end\n            expandablesByGroup[pgroup] = expandable\n            if i == 1 then\n               table.insert(expandables, expandable)\n            end\n         end\n         lastExpandable = expandablesByGroup[pgroup]\n      end\n\n      if lastExpandable then\n         lastExpandable.items = lastExpandable.items or {}\n         table.insert(lastExpandable.items, {\n            layout = grouppable.layout,\n            data = grouppable.data,\n         })\n      else\n         table.insert(expandables, {\n            layout = grouppable.layout,\n            data = grouppable.data,\n         })\n      end\n   end\n   return expandables\nend\n"
  }
}