{
  "folder_name": "NCGDMW Lua Edition",
  "lua_files": {
    "NCGDMW Lua Edition-53136-3-5-1725880983\\00 Core\\scripts\\NCGDMW\\common.lua": "local core = require('openmw.core')\nlocal self = require('openmw.self')\nlocal ui = require('openmw.ui')\nlocal types = require('openmw.types')\nlocal Player = require('openmw.types').Player\nlocal dynamic = types.Actor.stats.dynamic\n\nlocal def = require('scripts.NCGDMW.definition')\nlocal cfg = require('scripts.NCGDMW.configuration')\nlocal S = require('scripts.NCGDMW.settings')\nlocal H = require('scripts.NCGDMW.helpers')\n\nlocal L = core.l10n(def.MOD_NAME)\n\nlocal function debugPrint(str)\n    if S.globalStorage:get(\"debugMode\") then\n        print(\"DEBUG: \" .. str)\n    end\nend\n\nlocal ambient\n\nif def.isLuaApiRecentEnough then\n    ambient = require('openmw.ambient')\nend\n\nlocal hasStats = false\nlocal baseSkills = {}\nlocal baseAttributes = {}\nlocal startAttributes = {}\nlocal fortifiedHealthV48 = 0\nlocal maxSkills = H.initNewTable(0, Player.stats.skills)\nlocal skillProgress = H.initNewTable(0, Player.stats.skills)\nlocal decaySkills = H.initNewTable(0, Player.stats.skills)\nlocal attributeDiffs = H.initNewTable(0, Player.stats.attributes)\nlocal messagesLog = {}\n\n\n-- Map lowercased, concatenated skill names to human-readable form\nlocal skillsMapV48 = {\n    [\"mediumarmor\"] = \"Medium Armor\",\n    [\"heavyarmor\"] = \"Heavy Armor\",\n    [\"bluntweapon\"] = \"Blunt Weapon\",\n    [\"longblade\"] = \"Long Blade\",\n    [\"lightarmor\"] = \"Light Armor\",\n    [\"shortblade\"] = \"Short Blade\",\n    [\"handtohand\"] = \"Hand To Hand\",\n}\n\nlocal starwindSkills = {\n    alchemy = true,\n    alteration = true,\n    armorer = true,\n    conjuration = true,\n    destruction = true,\n    enchant = true,\n    illusion = true,\n    mysticism = true,\n    restoration = true,\n    spear = true,\n}\n\nlocal skillsBySchool = {\n    combat = { \"block\", \"armorer\", \"mediumarmor\", \"heavyarmor\", \"bluntweapon\", \"longblade\", \"axe\", \"spear\", \"athletics\" },\n    magic = { \"enchant\", \"destruction\", \"alteration\", \"illusion\", \"conjuration\", \"mysticism\", \"restoration\", \"alchemy\", \"unarmored\" },\n    stealth = { \"security\", \"sneak\", \"acrobatics\", \"lightarmor\", \"shortblade\", \"marksman\", \"mercantile\", \"speechcraft\", \"handtohand\" },\n}\n\nlocal skillIdToSchool = {}\nfor type, skills in pairs(skillsBySchool) do\n    for _, skillId in ipairs(skills) do\n        skillIdToSchool[skillId] = type\n    end\nend\n\n-- Common functions\n\nlocal function init()\n    baseSkills = {}\n    maxSkills = H.initNewTable(0, Player.stats.skills)\n    decaySkills = H.initNewTable(0, Player.stats.skills)\n    baseAttributes = {}\n    startAttributes = {}\n    attributeDiffs = attributeDiffs or {}\nend\n\nlocal function showMessage(message)\n    ui.showMessage(message)\n    table.insert(messagesLog, 1, { message = message, time = os.date(\"%H:%M:%S\") })\n    if #messagesLog > 11 then\n        table.remove(messagesLog)\n    end\nend\n\nlocal function maybePlaySound(sound, options)\n    if def.isLuaApiRecentEnough then\n        ambient.playSound(sound, options)\n    end\nend\n\nlocal function totalGameTimeInHours()\n    return core.getGameTime() / 60 / 60\nend\n\nlocal currentSerializedBaseStatsMods\n\nlocal function getBaseStatsModifiers()\n    local baseStatsMods = { attributes = {}, skills = {} }\n    if not def.isLuaApiRecentEnough then return baseStatsMods end\n    for _, spell in pairs(Player.activeSpells(self)) do\n        if spell.affectsBaseValues then\n            for _, effect in pairs(spell.effects) do\n                local kind, statId\n                if effect.affectedAttribute ~= nil and effect.id == \"fortifyattribute\" then\n                    kind = \"attributes\"\n                    statId = effect.affectedAttribute\n                elseif effect.affectedSkill ~= nil and effect.id == \"fortifyskill\" then\n                    kind = \"skills\"\n                    statId = effect.affectedSkill\n                end\n                if kind ~= nil then\n                    baseStatsMods[kind][statId] = (baseStatsMods[kind][statId] or 0) + effect.magnitudeThisFrame\n                end\n            end\n        end\n    end\n    if next(baseStatsMods.attributes) or next(baseStatsMods.skills) then\n        local serializedBaseStatsMods = H.tableOfTablesToString(baseStatsMods)\n        if serializedBaseStatsMods ~= currentSerializedBaseStatsMods then\n            currentSerializedBaseStatsMods = serializedBaseStatsMods\n            debugPrint(string.format(\"Detected base statistics modifiers: %s\", serializedBaseStatsMods))\n        end\n    end\n    return baseStatsMods\nend\n\nlocal function getSkillGainFactorIfDecay(skillId)\n    local skillLostLevels = maxSkills[skillId] - baseSkills[skillId]\n    return skillLostLevels > 0 and cfg.decayLostLevelsSkillGainFact(skillLostLevels) or 1\nend\n\n-- Slow down decay based on skill gain\n-- Will benefit from MBSP skill gain boost\n-- Won't be affected by skill gain reduction settings\nlocal function slowDownSkillDecayOnSkillUsed(skillId, skillGain)\n    decaySkills[skillId] = math.max(0, decaySkills[skillId] - (skillGain * cfg.decayRecoveredHoursPerSkillUsed))\n    if cfg.decayRecoveredHoursPerSkillUsedSynergyFactor ~= 0 then\n        for _, otherSkillId in ipairs(skillsBySchool[skillIdToSchool[skillId]]) do\n            if otherSkillId ~= skillId then\n                decaySkills[otherSkillId] = math.max(0, decaySkills[otherSkillId]\n                        - (skillGain * cfg.decayRecoveredHoursPerSkillUsed * cfg.decayRecoveredHoursPerSkillUsedSynergyFactor))\n            end\n        end\n    end\nend\n\nlocal function slowDownSkillDecayOnSkillLevelUp(skillId)\n    decaySkills[skillId] = decaySkills[skillId] * cfg.slowDownSkillDecayOnSkillLevelUpFactor\nend\n\nlocal function getMaxHealthModifier()\n    if not def.isLuaApiRecentEnough then\n        return fortifiedHealthV48\n    end\n    local healthMod = 0\n    for _, spell in pairs(Player.activeSpells(self)) do\n        if spell.affectsBaseValues then\n            for _, effect in pairs(spell.effects) do\n                if effect.id == \"fortifyhealth\" then\n                    healthMod = healthMod + effect.magnitudeThisFrame\n                end\n            end\n        end\n    end\n    if healthMod ~= 0 then\n        debugPrint(string.format(\"Detected max health modifier: %d\", healthMod))\n    end\n    return healthMod\nend\n\nlocal function getStat(kind, statId)\n    return Player.stats[kind][statId](self).base\nend\n\nlocal function getStatName(kind, statId)\n    if kind == \"skills\" and S.globalStorage:get(\"starwindNames\") and starwindSkills[statId] then\n        return L(\"starwind_\" .. statId)\n    end\n    if def.isLuaApiRecentEnough then\n        if kind == \"attributes\" then\n            return core.stats.Attribute.record(statId).name\n        else\n            return core.stats.Skill.record(statId).name\n        end\n    end\n    local statName = H.capitalize(statId)\n    if kind == \"skills\" then\n        if skillsMapV48[statId] ~= nil then\n            statName = skillsMapV48[statId]\n        end\n    end\n    return statName\nend\n\nlocal function setStat(kind, statId, value)\n    local current = Player.stats[kind][statId](self).base\n    local baseStatsMods = getBaseStatsModifiers()\n    local realBase = value - (baseStatsMods[kind][statId] or 0)\n    local toShow\n    if kind == \"attributes\" then\n        if value > current then\n            toShow = \"attrUp\"\n        elseif value < current then\n            toShow = \"attrDown\"\n        end\n        baseAttributes[statId] = realBase\n    elseif kind == \"skills\" then\n        if value > current then\n            toShow = \"skillUp\"\n        elseif value < current then\n            toShow = \"skillDown\"\n        end\n    end\n    if current == value then return false end\n\n    Player.stats[kind][statId](self).base = value\n    showMessage(L(toShow, { stat = getStatName(kind, statId), value = realBase }))\n    return true\nend\n\nlocal function modStat(kind, stat, value)\n    return setStat(kind, stat, Player.stats[kind][stat](self).base + value)\nend\n\nlocal function increaseSkill(skillId)\n    modStat(\"skills\", skillId, 1)\n    maybePlaySound(\"skillraise\")\nend\n\nlocal function modMagicka(amount)\n    dynamic.magicka(self).current = dynamic.magicka(self).current + amount\nend\n\nlocal function onLoad(data)\n    hasStats = data.hasStats or false\n    baseSkills = data.baseSkills\n    baseAttributes = data.baseAttributes\n    startAttributes = data.startAttributes\n    fortifiedHealthV48 = data.fortifiedHealthV48 or 0\n    maxSkills = data.maxSkills or maxSkills\n    skillProgress = data.skillProgress or {}\n    decaySkills = data.decaySkills or decaySkills\n    attributeDiffs = data.attributeDiffs or attributeDiffs\n    messagesLog = data.messagesLog or {}\n\n    --Handle Loading Save Without Mod--\n    for skillId, _ in pairs(Player.stats.skills) do\n        --If below vanilla skill cap, update skill progress for use in calculations\n        if Player.stats.skills[skillId](self).base < 100 then\n            if Player.stats.skills[skillId](self).progress > 0 or skillProgress[skillId] == nil then\n                skillProgress[skillId] = Player.stats.skills[skillId](self).progress\n            else\n                Player.stats.skills[skillId](self).progress = skillProgress[skillId]\n            end\n            --If at or above vanilla skill cap, get current progress, then override\n        elseif Player.stats.skills[skillId](self).progress > 0 then\n            skillProgress[skillId] = Player.stats.skills[skillId](self).progress\n            Player.stats.skills[skillId](self).progress = 0\n        end\n    end\nend\n\nlocal function onSave(data)\n    data.hasStats = hasStats\n    data.baseSkills = baseSkills\n    data.baseAttributes = baseAttributes\n    data.startAttributes = startAttributes\n    data.fortifiedHealthV48 = fortifiedHealthV48\n    data.maxSkills = maxSkills\n    data.skillProgress = skillProgress\n    data.decaySkills = decaySkills\n    data.attributeDiffs = attributeDiffs\n    data.messagesLog = messagesLog\nend\n\nreturn {\n    debugPrint = debugPrint,\n    hasStats = function() return hasStats end,\n    setHasStats = function(value) hasStats = value end,\n    baseSkills = function() return baseSkills end,\n    baseAttributes = function() return baseAttributes end,\n    startAttributes = function() return startAttributes end,\n    setFortifiedHealthV48 = function(value) fortifiedHealthV48 = value end,\n    maxSkills = function() return maxSkills end,\n    skillProgress = function() return skillProgress end,\n    decaySkills = function() return decaySkills end,\n    attributeDiffs = function() return attributeDiffs end,\n    messagesLog = function() return messagesLog end,\n    skillsBySchool = function() return skillsBySchool end,\n    skillIdToSchool = function() return skillIdToSchool end,\n    init = init,\n    showMessage = showMessage,\n    maybePlaySound = maybePlaySound,\n    totalGameTimeInHours = totalGameTimeInHours,\n    getBaseStatsModifiers = getBaseStatsModifiers,\n    getSkillGainFactorIfDecay = getSkillGainFactorIfDecay,\n    slowDownSkillDecayOnSkillUsed = slowDownSkillDecayOnSkillUsed,\n    slowDownSkillDecayOnSkillLevelUp = slowDownSkillDecayOnSkillLevelUp,\n    getMaxHealthModifier = getMaxHealthModifier,\n    getStat = getStat,\n    getStatName = getStatName,\n    setStat = setStat,\n    modStat = modStat,\n    increaseSkill = increaseSkill,\n    modMagicka = modMagicka,\n    onLoad = onLoad,\n    onSave = onSave,\n}",
    "NCGDMW Lua Edition-53136-3-5-1725880983\\00 Core\\scripts\\NCGDMW\\configuration.lua": "-- This file contains main configuration values and functions that are not configurable from the in-game settings page.\n-- You can alter its content to change the mod balance\n\nlocal H = require('scripts.NCGDMW.helpers')\n\nlocal config = {\n    -- How skills contribute to attributes growth\n    skillsImpactOnAttributes = {\n        block = { strength = 2, agility = 1, endurance = 4 },\n        armorer = { strength = 1, endurance = 4, personality = 2 },\n        mediumarmor = { endurance = 4, speed = 2, willpower = 1 },\n        heavyarmor = { strength = 1, endurance = 4, speed = 2 },\n        bluntweapon = { strength = 4, endurance = 1, willpower = 2 },\n        longblade = { strength = 2, agility = 4, speed = 1 },\n        axe = { strength = 4, agility = 2, willpower = 1 },\n        spear = { strength = 4, endurance = 2, speed = 1 },\n        athletics = { endurance = 2, speed = 4, willpower = 1 },\n\n        enchant = { intelligence = 4, willpower = 2, personality = 1 },\n        destruction = { intelligence = 2, willpower = 4, personality = 1 },\n        alteration = { speed = 1, intelligence = 2, willpower = 4 },\n        illusion = { agility = 1, intelligence = 2, personality = 4 },\n        conjuration = { intelligence = 4, willpower = 1, personality = 2 },\n        mysticism = { intelligence = 4, willpower = 2, personality = 1 },\n        restoration = { endurance = 1, willpower = 4, personality = 2 },\n        alchemy = { endurance = 1, intelligence = 4, personality = 2 },\n        unarmored = { endurance = 1, speed = 4, willpower = 2 },\n\n        security = { agility = 4, intelligence = 2, personality = 1 },\n        sneak = { agility = 4, speed = 1, personality = 2 },\n        acrobatics = { strength = 1, agility = 2, speed = 4 },\n        lightarmor = { agility = 1, endurance = 2, speed = 4 },\n        shortblade = { agility = 4, speed = 2, personality = 1 },\n        marksman = { strength = 4, agility = 2, speed = 1 },\n        mercantile = { intelligence = 2, willpower = 1, personality = 4 },\n        speechcraft = { intelligence = 1, willpower = 2, personality = 4 },\n        handtohand = { strength = 4, agility = 2, endurance = 1 }\n    },\n\n    -- How attributes contribute to total health\n    healthAttributeFactors = {\n        endurance = 4 / 7,\n        strength = 2 / 7,\n        willpower = 1 / 7,\n    },\n\n    -- Skills won't decay below that value\n    -- skillMaxLevel is the highest level the skill reached before decay\n    decayMinSkill = function(skillMaxLevel)\n        return math.max(15, math.ceil(skillMaxLevel / 2))\n    end,\n\n    -- How many hours it takes for a skill level 100 to decay with slow decay, if that skill is never used\n    -- Decay of a skill level 33 increases 3 times slower than a skill level 100\n    -- With standard decay, the decay passed time increases twice faster than with slow decay\n    -- With fast decay, the decay passed time increases twice faster than with standard decay\n    decayTimeBaseInHours = 336, -- 2 week\n\n    -- Recovering skill lost levels is at least 4 time faster than normal skill gains\n    -- Set the return to 1 for no boost\n    decayLostLevelsSkillGainFact = function(skillLostLevels)\n        return 4 * skillLostLevels ^ 0.5\n    end,\n\n    -- Each time a skill is used, its decay progress is slowed down by subtracting hours to decay time passed\n    decayRecoveredHoursPerSkillUsed = 1,\n\n    -- Other skills from same specialization will also get their decay slowed down by a fraction of current skill reduction\n    -- For instance, using lock pick will, skill gain 2.0, and decayRecoveredHoursPerSkillUsed = 1\n    --   will remove 2 * 1 = 2 hours to lock pick decay passed time,\n    --   and will remove 2 / 20 = 0.1 hours (6 minutes) to all other stealth skills\n    -- Set it to 0 to disable the synergy\n    decayRecoveredHoursPerSkillUsedSynergyFactor = 1 / 20,\n\n    -- When a skill is trained, the passed 2 hours won't after its decay progress\n    -- Other skills from same specialization can benefit from a progress reduction\n    -- Set to 1 for no reduction, 0 for no decay progress\n    decayReducedHoursPerSkillTrainedSynergyFactor = 1 / 2,\n\n    -- When a skill levels up, the decay progress is reduced by a factor to prevent having a decay just after a level up\n    -- Set it to 0 to reset the decay progress on levels up\n    slowDownSkillDecayOnSkillLevelUpFactor = 0.5,\n\n    -- When resting in a bed, change the decay time passed by a factor\n    decayRestWithBedTimePassedFactor = 0,\n\n    -- When resting without a bed, change the decay time passed by a factor (only openmw 0.49)\n    decayRestWithoutBedTimePassedFactor = 1 / 2,\n\n    -- When traveling with a transport, change the decay time passed by a factor\n    decayTransportTimePassedFactor = 1 / 2,\n\n    -- With openmw48, when resting, waiting or training a skill, change the decay time passed by a factor\n    decayRestOrWaitOrTrainTimePassedFactorV48 = 1 / 2,\n}\n\nconfig.updateConfig = function(configuration)\n    H.overrideTableValues(config, configuration)\nend\n\n-- Get configuration data, excluding functions\nconfig.getData = function()\n    local data = {}\n    for k, v in pairs(config) do\n        if type(v) ~= \"function\" then\n            data[k] = v\n        end\n    end\n    return data\nend\n\nconfig.setSkillsImpactOnAttributes = function(skillId, primaryAttrId, secondaryAttrId, tertiaryAttrId)\n    local changed = config.skillsImpactOnAttributes[skillId][primaryAttrId] ~= 4\n            or config.skillsImpactOnAttributes[skillId][secondaryAttrId] ~= 2\n            or config.skillsImpactOnAttributes[skillId][tertiaryAttrId] ~= 1\n    config.skillsImpactOnAttributes[skillId] = { [primaryAttrId] = 4, [secondaryAttrId] = 2, [tertiaryAttrId] = 1 }\n    return changed\nend\n\nreturn config",
    "NCGDMW Lua Edition-53136-3-5-1725880983\\00 Core\\scripts\\NCGDMW\\decay.lua": "local self = require('openmw.self')\nlocal util = require('openmw.util')\n\nlocal def = require('scripts.NCGDMW.definition')\nlocal cfg = require('scripts.NCGDMW.configuration')\nlocal S = require('scripts.NCGDMW.settings')\nlocal C = require('scripts.NCGDMW.common')\nlocal H = require('scripts.NCGDMW.helpers')\n\n-- Time passed since last decay update\nlocal lastDecayTime = 0\n-- Time of last decay update\nlocal lastDecayUpdateTime = 0\nlocal lastUiRestData = { withActivator = false, time = 0, hasSleptOrWaited = false }\nlocal lastTrainedSkillId\nlocal noDecayTime = 0\nlocal noDecayTimeStart = 0\nlocal lastPlayerPos = 0\nlocal lastOnFrameRefreshTime = 0\nlocal jailTime = 0\n\nlocal function init()\n    lastDecayTime = 0\n    lastDecayUpdateTime = C.totalGameTimeInHours()\n    noDecayTime = C.totalGameTimeInHours()\n    noDecayTimeStart = C.totalGameTimeInHours()\n    lastPlayerPos = self.position\n    C.debugPrint(string.format(\"Decay: Init no decay time to %s\", noDecayTime))\nend\n\n-- This is used to calculate \"decay memory\" so we subtract \"no decay time\" to\n-- ensure an accurate value which properly factors if the player disabled\n-- decay for any period of time.\nlocal function getDecayTime()\n    return C.totalGameTimeInHours() - noDecayTime\nend\n\n-- Log how long the player's played without decay so an accurate number can be\n-- used in the decay maths below.\nlocal function logDecayTime()\n    if S.skillsStorage:get(\"decayRate\") == \"none\" then\n        noDecayTimeStart = C.totalGameTimeInHours()\n        C.debugPrint(string.format(\"Decay: Set no decay time start to %.3f\", noDecayTimeStart))\n    elseif noDecayTimeStart ~= 0 then\n        noDecayTime = noDecayTime + (C.totalGameTimeInHours() - noDecayTimeStart)\n        C.debugPrint(string.format(\"Decay: Updated no decay time to %.3f\", noDecayTime))\n        noDecayTimeStart = 0\n        lastDecayTime = getDecayTime()\n    end\nend\n\nlocal function updateDecay()\n    lastOnFrameRefreshTime = 0\n    if not C.hasStats() then return end\n    local decayRate = S.skillsStorage:get(\"decayRate\")\n    if decayRate == \"none\" then return end\n\n    local decayRateNum = S.getSkillDecayRates(decayRate)\n    local decayTime = getDecayTime()\n    local passedTime = decayTime - lastDecayTime\n    --C.debugPrint(string.format(\"Decay: Refreshing decay, %.3f hours have passed, decay time is %.3f\", passedTime, decayTime));\n\n    local longTimePassed = passedTime > 0.5\n    if longTimePassed then\n        -- More than half an hour passed, the player slept, waited, trained or took a transport\n        C.debugPrint(string.format(\"A long time passed: %.2f hours\", passedTime))\n        if lastTrainedSkillId ~= nil then\n            C.debugPrint(\"The player trained a skill\")\n        else\n            local playerPos = self.position\n            local traveledDistance = util.vector3(playerPos.x - lastPlayerPos.x, playerPos.y - lastPlayerPos.y, playerPos.z - lastPlayerPos.z)\n            if traveledDistance:length() > 10000 then\n                -- The player used a transport\n                C.debugPrint(\"The player used a transport\")\n                passedTime = passedTime * cfg.decayTransportTimePassedFactor\n            elseif not def.isLuaApiRecentEnough then\n                -- On openmw 0.48, we cannot detect if the player slept (with or without a bed), waited, or trained a skill\n                C.debugPrint(\"The player slept, waited or trained a skill\")\n                passedTime = passedTime * cfg.decayRestOrWaitOrTrainTimePassedFactorV48\n            elseif lastUiRestData.hasSleptOrWaited and lastUiRestData.time > lastDecayUpdateTime then\n                -- The player slept\n                if lastUiRestData.withActivator then\n                    -- The player used a bed\n                    C.debugPrint(\"The player slept in a bed\")\n                    passedTime = passedTime * cfg.decayRestWithBedTimePassedFactor\n                elseif not self.cell:hasTag(\"NoSleep\") then\n                    -- The player slept without a bed\n                    C.debugPrint(\"The player slept without a bed\")\n                    passedTime = passedTime * cfg.decayRestWithoutBedTimePassedFactor\n                else\n                    -- The player just waited: No decay reduction\n                    C.debugPrint(\"The player waited\")\n                end\n            end\n        end\n    end\n\n    local decayHappened = false;\n    for skillId, _ in pairs(C.decaySkills()) do\n        if C.baseSkills()[skillId] > cfg.decayMinSkill(C.maxSkills()[skillId]) then\n            local skillPassedTime = passedTime\n            if longTimePassed and lastTrainedSkillId ~= nil then\n                if lastTrainedSkillId == skillId then\n                    C.decaySkills()[skillId] = 0\n                    skillPassedTime = 0\n                else\n                    if H.isInArray(skillId, C.skillsBySchool()[C.skillIdToSchool()[lastTrainedSkillId]]) then\n                        skillPassedTime = passedTime * cfg.decayReducedHoursPerSkillTrainedSynergyFactor\n                    end\n                end\n            end\n            -- Increase decay by (time spent since last update) * (1, 2 or 4 depending on decay setting) * (skill base level / 100)\n            C.decaySkills()[skillId] = C.decaySkills()[skillId] + skillPassedTime * (2 ^ (decayRateNum - 1)) * C.baseSkills()[skillId] / 100\n            if C.decaySkills()[skillId] > cfg.decayTimeBaseInHours then\n                C.debugPrint(string.format(\"Decay: Decay happening for \\\"%s\\\", reducing by half decay progress for this skill\", skillId))\n                C.decaySkills()[skillId] = C.decaySkills()[skillId] - cfg.decayTimeBaseInHours\n                decayHappened = true\n                C.modStat(\"skills\", skillId, -1)\n\n                C.maybePlaySound(\"skillraise\", { pitch = 0.79 })\n                C.maybePlaySound(\"skillraise\", { pitch = 0.76 })\n\n                -- Force a recheck of this skill's value\n                C.baseSkills()[skillId] = nil\n            end\n        end\n    end\n    if longTimePassed then\n        lastTrainedSkillId = nil\n    end\n    lastDecayTime = decayTime\n    lastDecayUpdateTime = C.totalGameTimeInHours()\n    lastPlayerPos = self.position\n    return decayHappened\nend\n\nlocal function onFrame(deltaTime)\n    lastOnFrameRefreshTime = lastOnFrameRefreshTime + deltaTime\n    if lastOnFrameRefreshTime < 2 then return end\n\n    local decayHappened = updateDecay()\n    if decayHappened and def.isLuaApiRecentEnough then\n        self:sendEvent(\"updateProfile\")\n    end\nend\n\nlocal function checkJailTime(data)\n    if S.skillsStorage:get(\"decayRate\") == \"none\" then return end\n\n    if data.newMode == \"Jail\" and not jailTime then\n        jailTime = C.totalGameTimeInHours()\n    elseif not data.newMode and jailTime then\n        noDecayTime = noDecayTime + (C.totalGameTimeInHours() - jailTime)\n        jailTime = nil\n        lastDecayTime = getDecayTime()\n    end\nend\n\nlocal function getSkillUsedHandler()\n    return function(skillId, params)\n        if S.skillsStorage:get(\"decayRate\") ~= \"none\" then\n            params.skillGain = params.skillGain * C.getSkillGainFactorIfDecay(skillId)\n            C.slowDownSkillDecayOnSkillUsed(skillId, params.skillGain)\n        end\n    end\nend\n\nlocal function onLoad(data)\n    noDecayTime = data.noDecayTime or 0\n    lastDecayTime = data.lastDecayTime or getDecayTime()\n    noDecayTimeStart = data.noDecayTimeStart or getDecayTime()\n    lastPlayerPos = self.position\nend\n\nlocal function onSave(data)\n    data.lastDecayTime = lastDecayTime\n    data.noDecayTime = noDecayTime\n    data.noDecayTimeStart = noDecayTimeStart\nend\n\nreturn {\n    noDecayTime = function() return noDecayTime end,\n    lastUiRestData = function() return lastUiRestData end,\n    setLastTrainedSkillId = function(skillId) lastTrainedSkillId = skillId end,\n    init = init,\n    logDecayTime = logDecayTime,\n    updateDecay = updateDecay,\n    onFrame = onFrame,\n    checkJailTime = checkJailTime,\n    getSkillUsedHandler = getSkillUsedHandler,\n    onLoad = onLoad,\n    onSave = onSave,\n}",
    "NCGDMW Lua Edition-53136-3-5-1725880983\\00 Core\\scripts\\NCGDMW\\definition.lua": "local core = require('openmw.core')\n\nreturn {\n    MOD_NAME = \"NCGDMW\",\n    isLuaApiRecentEnough = core.API_REVISION >= 68,\n    isOpenMW049 = core.API_REVISION > 29,\n}\n",
    "NCGDMW Lua Edition-53136-3-5-1725880983\\00 Core\\scripts\\NCGDMW\\helpers.lua": "local util = require('openmw.util')\n\nmath.randomseed(os.time())\n\n-- UI\n\nlocal function mixColors(color1, color2, ratio)\n    return util.color.rgb(\n            color1.r * ratio + color2.r * (1 - ratio),\n            color1.g * ratio + color2.g * (1 - ratio),\n            color1.b * ratio + color2.b * (1 - ratio)\n    )\nend\n\n-- Strings\n\nlocal function capitalize(s)\n    -- THANKS: https://stackoverflow.com/a/2421843\n    return s:sub(1, 1):upper() .. s:sub(2)\nend\n\n-- Numbers\n\nlocal function randInt(rangeStart, rangeEnd)\n    return math.random(rangeStart, rangeEnd)\nend\n\nlocal function round(num, numDecimal)\n    if numDecimal and numDecimal > 0 then\n        local mult = 10 ^ numDecimal\n        return math.floor(num * mult + 0.5) / mult\n    end\n    return math.floor(num + 0.5)\nend\n\n-- Arrays\n\nlocal function indexOf(value, array)\n    for i = 1, #array do\n        if array[i] == value then\n            return i\n        end\n    end\nend\n\nlocal function isInArray(value, array)\n    for _, otherValue in ipairs(array) do\n        if otherValue == value then\n            return true\n        end\n    end\n    return false\nend\n\nlocal function insertMultipleInArray(sourceArray, array)\n    for _, value in ipairs(array) do\n        table.insert(sourceArray, value)\n    end\nend\n\nlocal function insertAtMultipleInArray(sourceArray, pos, array)\n    for i, value in ipairs(array) do\n        table.insert(sourceArray, pos + i - 1, value)\n    end\nend\n\n-- Tables\n\nlocal function initNewTable(value, sourceTable)\n    local table = {}\n    for k, _ in pairs(sourceTable) do\n        table[k] = value\n    end\n    return table\nend\n\nlocal function overrideTableValues(target, source)\n    for k, v in pairs(source) do\n        target[k] = v\n    end\nend\n\nlocal function replaceAllTableValues(target, source)\n    for k, _ in pairs(target) do\n        target[k] = nil\n    end\n    for k, v in pairs(source) do\n        target[k] = v\n    end\nend\n\nlocal function tableOfTablesToString(_table)\n    local strs = {}\n    for key, subTable in pairs(_table) do\n        strs[#strs + 1] = key .. \" = { \"\n        for subKey, subValue in pairs(subTable) do\n            strs[#strs + 1] = subKey .. \" = \" .. subValue .. \", \"\n        end\n        strs[#strs + 1] = \"}, \"\n    end\n    return table.concat(strs)\nend\n\nreturn {\n    mixColors = mixColors,\n    capitalize = capitalize,\n    randInt = randInt,\n    round = round,\n    indexOf = indexOf,\n    isInArray = isInArray,\n    insertMultipleInArray = insertMultipleInArray,\n    insertAtMultipleInArray = insertAtMultipleInArray,\n    initNewTable = initNewTable,\n    replaceAllTableValues = replaceAllTableValues,\n    overrideTableValues = overrideTableValues,\n    tableOfTablesToString = tableOfTablesToString,\n}\n",
    "NCGDMW Lua Edition-53136-3-5-1725880983\\00 Core\\scripts\\NCGDMW\\mbsp.lua": "local async = require('openmw.async')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal Player = require('openmw.types').Player\nlocal dynamic = types.Actor.stats.dynamic\n\nlocal S = require('scripts.NCGDMW.settings')\nlocal C = require('scripts.NCGDMW.common')\n\nlocal storedMagicka = 0\n\nlocal magickaSkills = {\n    destruction = true,\n    restoration = true,\n    conjuration = true,\n    mysticism = true,\n    illusion = true,\n    alteration = true,\n}\n\nlocal deltaMTable = {}\n\nlocal function getRefund(skill, cost)\n    local refund\n    refund = cost * (S.mbspStorage:get(\"refundMult\") / 5) * (1 - 0.5 ^ (math.max(skill - S.mbspStorage:get(\"refundStart\"), 0) / 100))\n    if refund > cost then\n        refund = cost\n    end\n    return refund\nend\n\nlocal function addDeltaMagicka(val)\n    table.insert(deltaMTable, val)\nend\n\nlocal function removeOldestDeltaMagicka()\n    table.remove(deltaMTable, 1)\nend\n\nlocal function getDeltaMagicka()\n    if #deltaMTable > 0 then\n        return math.max(table.unpack(deltaMTable), 0)\n    else\n        return 0\n    end\nend\n\n----------------Engine Handlers--------------------\n\nlocal function getSkillUsedHandler()\n    return function(skillId, params)\n        if not magickaSkills[skillId] or not S.mbspStorage:get(\"mbspEnabled\") then return end\n\n        local magickaXPRate = S.mbspStorage:get(\"magickaXPRate\")\n        local cost = Player.getSelectedSpell(self).cost\n        C.debugPrint(string.format(\"MBSP: Magic skill \\\"%s\\\" increase, base gain = %.5f, cost = %d, XP rate = %d, final gain = %.5f\",\n                skillId, params.skillGain, cost, magickaXPRate, params.skillGain * cost / magickaXPRate))\n        params.skillGain = params.skillGain * cost / magickaXPRate\n        if S.mbspStorage:get(\"refundEnabled\") then\n            local refund = getRefund(Player.stats.skills[skillId](self).base, cost)\n            if refund > 0 then\n                C.debugPrint(string.format(\"MBSP: Magic skill \\\"%s\\\" refund: %.2f\", skillId, refund))\n                C.modMagicka(refund)\n            end\n        end\n    end\nend\n\nlocal lastOnFrame = 1\n\n-- MBSP + Uncapper, only for openmw 0.48\nlocal function onFrame(deltaTime)\n    if not C.hasStats() then return end\n\n    lastOnFrame = lastOnFrame + deltaTime\n    if lastOnFrame < 0.5 then return end\n    lastOnFrame = 0\n\n    local deltaMagicka = 0\n    if S.mbspStorage:get(\"mbspEnabled\") then\n        --Stores all changes in magicka in the last 2 seconds\n        if storedMagicka - dynamic.magicka(self).current > 1 then\n            addDeltaMagicka(storedMagicka - dynamic.magicka(self).current)\n            async:newSimulationTimer(\n                    2,\n                    async:registerTimerCallback(\n                            \"removeOldestDeltaMagicka\",\n                            function()\n                                removeOldestDeltaMagicka()\n                            end\n                    )\n            )\n        end\n        deltaMagicka = getDeltaMagicka()\n    end\n\n    local decayRate = S.skillsStorage:get(\"decayRate\")\n    local mbspEnabled = S.mbspStorage:get(\"mbspEnabled\")\n    local magickaXPRate = S.mbspStorage:get(\"magickaXPRate\")\n    local skillsMaxValue = S.skillsStorage:get(\"uncapperMaxValue\")\n    local perSkillMaxValues = S.getPerSkillMaxValues()\n    local refundEnabled = S.mbspStorage:get(\"refundEnabled\")\n\n    for skillId, _ in pairs(Player.stats.skills) do\n        local progress = Player.stats.skills[skillId](self).progress\n        local skillGain = 0\n        if Player.stats.skills[skillId](self).base < 100 then\n            local progressDiff = progress - C.skillProgress()[skillId]\n            --If the skill has leveled up normally\n            if progressDiff < -0.5 then\n                C.skillProgress()[skillId] = 0\n                --If increase in skill progress is detected\n            elseif progressDiff > 0.001 then\n                skillGain = progressDiff\n                if magickaSkills[skillId] and mbspEnabled then\n                    skillGain = skillGain * deltaMagicka / magickaXPRate\n                    Player.stats.skills[skillId](self).progress = Player.stats.skills[skillId](self).progress + skillGain - progressDiff\n                    if Player.stats.skills[skillId](self).progress >= 1 then\n                        C.increaseSkill(skillId)\n                        Player.stats.skills[skillId](self).progress = 0\n                    end\n                end\n                if decayRate ~= \"none\" then\n                    skillGain = skillGain * C.getSkillGainFactorIfDecay(skillId)\n                    C.slowDownSkillDecayOnSkillUsed(skillId, skillGain)\n                end\n                C.skillProgress()[skillId] = Player.stats.skills[skillId](self).progress\n            end\n        else\n            if Player.stats.skills[skillId](self).base < (perSkillMaxValues[skillId] or skillsMaxValue) then\n                skillGain = progress\n                if skillGain > 0.001 then\n                    if magickaSkills[skillId] and mbspEnabled then\n                        skillGain = skillGain * deltaMagicka / magickaXPRate\n                    end\n                    if decayRate ~= \"none\" then\n                        skillGain = skillGain * C.getSkillGainFactorIfDecay(skillId)\n                        C.slowDownSkillDecayOnSkillUsed(skillId, skillGain)\n                    end\n                    C.skillProgress()[skillId] = C.skillProgress()[skillId] + skillGain\n                    if C.skillProgress()[skillId] >= 1 then\n                        C.increaseSkill(skillId)\n                        C.skillProgress()[skillId] = 0\n                    end\n                end\n            else\n                C.skillProgress()[skillId] = 0\n            end\n            Player.stats.skills[skillId](self).progress = 0\n        end\n        if skillGain > 0.001 then\n            C.debugPrint(string.format(\"MBSP: Used skill \\\"%s\\\", progress is %.5f, skill gain is %.5f, new progress is %.5f\",\n                    skillId, progress, skillGain, C.skillProgress()[skillId]))\n            if deltaMagicka > 0 and magickaSkills[skillId] and mbspEnabled then\n                local refund = 0\n                if refundEnabled then\n                    refund = getRefund(Player.stats.skills[skillId](self).base, deltaMagicka)\n                    C.modMagicka(refund)\n                end\n                C.debugPrint(string.format(\"MBSP: Used skill \\\"%s\\\", cost is %d, refund is %.2f\", skillId, deltaMagicka, refund))\n            end\n        end\n    end\n\n    storedMagicka = dynamic.magicka(self).current\nend\n\nreturn {\n    onFrame = onFrame,\n    getSkillUsedHandler = getSkillUsedHandler,\n}\n",
    "NCGDMW Lua Edition-53136-3-5-1725880983\\00 Core\\scripts\\NCGDMW\\player.lua": "local core = require('openmw.core')\nlocal async = require('openmw.async')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal ui = require('openmw.ui')\nlocal I = require('openmw.interfaces')\nlocal types = require('openmw.types')\nlocal Player = require('openmw.types').Player\nlocal aux_util = require('openmw_aux.util')\nlocal debug = require('openmw.debug')\n\nlocal S = require('scripts.NCGDMW.settings')\n-- Init settings first to init storage which is used everywhere\nS.initSettings()\n\nlocal def = require('scripts.NCGDMW.definition')\nlocal cfg = require('scripts.NCGDMW.configuration')\nlocal C = require('scripts.NCGDMW.common')\nlocal H = require('scripts.NCGDMW.helpers')\nlocal ncgdUI = require(\"scripts.NCGDMW.ui\")\nlocal decay = require('scripts.NCGDMW.decay')\nlocal mbsp = require('scripts.NCGDMW.mbsp')\nlocal spellHelper = require('scripts.NCGDMW.spells')\n\nlocal L = core.l10n(def.MOD_NAME)\n\nlocal isDisabled = false\nlocal potionId = \"ncgd_start_potion\"\nlocal interfaceVersion = 4\nlocal savedGameVersion = 3.4\nlocal lastUiMode\nlocal baseTotalStats\nlocal lvlProg = 0\nlocal healthAttributes = H.initNewTable(0, cfg.healthAttributeFactors)\nlocal forceUpdateHealth = false\nlocal lastUpdateHealthTime = 0\nlocal resetStatsAsked = false\nlocal updateProfileAsked = false\nlocal updateStarterSpellsAsked = false\nlocal updateProfileOnUpdateAsked = false\nlocal healthDamagingEffectIds = {\n    drainhealth = true,\n    damagehealth = true,\n    absorbhealth = true,\n    firedamage = true,\n    frostdamage = true,\n    shockdamage = true,\n    poison = true,\n    sundamage = true,\n}\nlocal effectDamage = { time = 0, sum = 0, drain = 0 }\n\nlocal countPlugins\nif def.isLuaApiRecentEnough then\n    countPlugins = (core.contentFiles.has(\"ncgdmw.omwaddon\") and 1 or 0)\n            + (core.contentFiles.has(\"ncgdmw_alt_start.omwaddon\") and 1 or 0)\n            + (core.contentFiles.has(\"ncgdmw_starwind.omwaddon\") and 1 or 0)\nelse\n    countPlugins = (core.getGMST(\"iLevelupMajorMult\") == 0 and core.getGMST(\"iLevelupMinorMult\") == 0) and 1 or 0\nend\nif countPlugins ~= 1 then\n    local plugins = { \"ncgdmw.omwaddon\", \"ncgdmw_alt_start.omwaddon\", \"ncgdmw_starwind.omwaddon\" }\n    ui.create(ncgdUI.missingPluginWarning(countPlugins == 0 and L(\"pluginErrorMissingOneOf\") or L(\"pluginErrorTooMany\"), plugins))\n    return\nend\nif def.isLuaApiRecentEnough then\n    if core.contentFiles.has(\"ncgdmw-vanilla-birthsigns-patch.omwaddon\") then\n        ui.create(ncgdUI.missingPluginWarning(L(\"pluginErrorNotCompatible49\"), { \"ncgdmw-vanilla-birthsigns-patch.omwaddon\" }))\n        return\n    end\n    if not core.contentFiles.has(\"ncgdmw-dev.omwscripts\") then\n        ui.create(ncgdUI.missingPluginWarning(L(\"pluginErrorMissing\"), { \"ncgdmw-dev.omwscripts\" }))\n        return\n    end\n    if core.contentFiles.has(\"MBSP_Uncapper.omwscripts\") then\n        ui.create(ncgdUI.missingPluginWarning(L(\"pluginErrorNotCompatible\"), { \"MBSP_Uncapper.omwscripts\" }))\n        return\n    end\n    if core.contentFiles.has(\"MBSP.omwscripts\") then\n        ui.create(ncgdUI.missingPluginWarning(L(\"pluginErrorNotCompatible\"), { \"MBSP.omwscripts\" }))\n        return\n    end\nend\n\nif def.isLuaApiRecentEnough then\n    if core.contentFiles.has(\"ncgdmw-vanilla-birthsigns-patch.omwaddon\") then\n        C.showMessage(L(\"dontUseBirthsignsPlugin\"))\n        print(L(\"dontUseBirthsignsPlugin\"))\n    end\n    if core.contentFiles.has(\"ncgdmw_starwind.omwaddon\") then\n        print(L(\"autoStarwind\"))\n        S.globalStorage:set(\"starwindNames\", true)\n    end\nend\n\nif def.isOpenMW049 then\n    if def.isLuaApiRecentEnough then\n        C.debugPrint(\"OpenMW 0.49.0 detected. Lua API recent enough for all features.\")\n    else\n        C.debugPrint(\"OpenMW 0.49.0 detected. Lua API too old for recent features.\")\n    end\nelse\n    C.debugPrint(\"OpenMW 0.48.0 detected. Some features will be disabled.\")\nend\n\n---- Core Logic ----\n\nlocal function getAttributesToRecalculate(baseStatsMods, forceAll)\n    local recalculate = {}\n    local decayEnabled = S.skillsStorage:get(\"decayRate\") ~= \"none\"\n    local skillsMaxValue = S.skillsStorage:get(\"uncapperMaxValue\")\n    local perSkillMaxValues = S.getPerSkillMaxValues()\n\n    for skillId, getter in pairs(Player.stats.skills) do\n        local maxValue = perSkillMaxValues[skillId] or skillsMaxValue\n\n        -- Update base and max values in case of manual or uncapper settings changes\n        if getter(self).base > maxValue then\n            C.setStat(\"skills\", skillId, maxValue)\n        end\n        C.maxSkills()[skillId] = math.min(C.maxSkills()[skillId], maxValue)\n\n        local actualBase = getter(self).base - (baseStatsMods.skills[skillId] or 0)\n        if not decayEnabled or actualBase > C.maxSkills()[skillId] then\n            C.maxSkills()[skillId] = actualBase\n        end\n\n        local storedBase = C.baseSkills()[skillId]\n\n        if forceAll or storedBase ~= actualBase then\n            if storedBase ~= actualBase then\n                if storedBase ~= nil then\n                    C.debugPrint(string.format(\"Skill \\\"%s\\\" has changed from %s to %.2f\", skillId, storedBase, actualBase))\n                end\n                if (storedBase == nil or actualBase > storedBase) and decayEnabled then\n                    C.slowDownSkillDecayOnSkillLevelUp(skillId)\n                end\n            end\n            C.baseSkills()[skillId] = actualBase\n            local affected = cfg.skillsImpactOnAttributes[skillId]\n            if affected then\n                for attributeId, _ in pairs(affected) do\n                    --C.debugPrint(string.format(\"\\\"%s\\\" should be recalculated!\", attributeId))\n                    recalculate[attributeId] = true\n                end\n            end\n        end\n    end\n    return recalculate\nend\n\nlocal function attributeDiff(attributeId, baseStatsMods)\n    -- Try to see if something else has modified an attribute and preserve that difference.\n    local diff = C.attributeDiffs()[attributeId]\n            + Player.stats.attributes[attributeId](self).base\n            - (baseStatsMods.attributes[attributeId] or 0)\n            - C.baseAttributes()[attributeId]\n    if diff ~= C.attributeDiffs()[attributeId] then\n        C.debugPrint(string.format(\"Detected external change %d for \\\"%s\\\", base is %d, stored base is %d\",\n                diff, attributeId, Player.stats.attributes[attributeId](self).base, C.baseAttributes()[attributeId]))\n    end\n    C.attributeDiffs()[attributeId] = diff\n    return diff\nend\n\nlocal function updateStarterSpells()\n    if not def.isLuaApiRecentEnough then return end\n\n    local baseSpellIds = spellHelper.getPlayerInnateSpellIds(self)\n    for _, spell in pairs(Player.spells(self)) do\n        if spell.starterSpellFlag and not baseSpellIds[spell.id] then\n            Player.spells(self):remove(spell.id)\n            C.debugPrint(string.format(\"Removed existing starter spell: %s\", spell.id))\n        end\n    end\n\n    local starterSpells = spellHelper.autoCalcPlayerSpells(self)\n    for _, spellId in ipairs(starterSpells) do\n        Player.spells(self):add(spellId)\n        C.debugPrint(string.format(\"Added starter spell: %s\", spellId))\n    end\nend\n\nlocal function updatePlayerStats(forceUpdateAttributes)\n    local growthRateNum = S.getAttributeGrowthRates(S.attributesStorage:get(\"growthRate\"))\n    local baseStatsMods = C.getBaseStatsModifiers()\n    local toRecalculate = getAttributesToRecalculate(baseStatsMods, forceUpdateAttributes)\n    local attributesChanged = false\n    local attributesMaxValue = S.attributesStorage:get(\"uncapperMaxValue\")\n    local perAttributeMaxValues = S.getPerAttributeMaxValues()\n\n    -- Look at each attribute, determine if it should be recalculated based on its related skills\n    for attributeId, _ in pairs(toRecalculate) do\n        local getter = Player.stats.attributes[attributeId]\n        local maxValue = perAttributeMaxValues[attributeId] or attributesMaxValue\n\n        -- Update base value in case of manual or uncapper settings changes\n        if getter(self).base > maxValue then\n            C.setStat(\"attributes\", attributeId, maxValue)\n        end\n\n        -- First check for an external change to the attribute. If found, save it to be reapplied later\n        local diff = attributeDiff(attributeId, baseStatsMods)\n\n        -- Calculate XP based on each attribute's related skills\n        local total = 0\n        for skillId, attributes in pairs(cfg.skillsImpactOnAttributes) do\n            local impactFactor = attributes[attributeId]\n            if impactFactor then\n                total = total + (C.baseSkills()[skillId] ^ 2) * impactFactor\n            end\n        end\n\n        total = math.floor(math.sqrt(total * growthRateNum / 27)\n                + C.startAttributes()[attributeId])\n                + diff\n                + (baseStatsMods.attributes[attributeId] or 0)\n        total = math.min(total, maxValue)\n\n        -- If the attribute has changed, signal to recalculate LUCK\n        local changed = C.setStat(\"attributes\", attributeId, total)\n        if changed then\n            attributesChanged = true\n        end\n    end\n\n    if next(toRecalculate) ~= nil then\n        -- Recalculate level progress\n        local totalStats = 0\n        for _, value in pairs(C.baseSkills()) do\n            totalStats = totalStats + value ^ 2\n        end\n        local totalLevel = math.sqrt(totalStats * 2 / 27)\n\n        local currentLevel = Player.stats.level(self).current\n        if baseTotalStats == nil then\n            -- First stats update, we preserve player level and level progression\n            baseTotalStats = totalLevel - currentLevel - Player.stats.level(self).progress / core.getGMST(\"iLevelupTotal\")\n        end\n        totalLevel = totalLevel - baseTotalStats\n\n        lvlProg = math.floor(totalLevel % 1 * 100)\n        local newLevel = math.floor(totalLevel)\n\n        if newLevel ~= currentLevel then\n            forceUpdateHealth = true\n        end\n\n        -- Something changed, show a message to the player\n        if newLevel > 0 then\n            if newLevel > currentLevel then\n                C.showMessage(L(\"lvlUp\", { level = newLevel }))\n            elseif newLevel < currentLevel then\n                C.showMessage(L(\"lvlDown\", { level = newLevel }))\n            end\n            Player.stats.level(self).current = newLevel\n        end\n\n        if attributesChanged then\n            local diff = attributeDiff(\"luck\", baseStatsMods)\n            if diff > 0 then\n                C.debugPrint(string.format(\"Adding external change for Luck: %d\", diff))\n            end\n            local newLuck = math.floor(math.sqrt(totalStats * growthRateNum / 27) + C.startAttributes().luck) + diff\n            C.setStat(\"attributes\", \"luck\", newLuck)\n        end\n    end\n\n    if updateStarterSpellsAsked then\n        updateStarterSpellsAsked = false\n        updateStarterSpells()\n    end\nend\n\nlocal function getHealthFactor(attributes)\n    local baseHPRatio = S.attributesStorage:get(\"baseHPRatio\")\n    local factor = baseHPRatio ~= \"full\" and S.getBaseHPRatioFactor(baseHPRatio) or 1\n    local attributeFactor = 0\n    for attributeId, value in pairs(cfg.healthAttributeFactors) do\n        attributeFactor = attributeFactor + attributes[attributeId] * value\n    end\n    return factor * attributeFactor\nend\n\nlocal function doHealth(deltaTime)\n    lastUpdateHealthTime = lastUpdateHealthTime + (deltaTime or 0.5)\n    if lastUpdateHealthTime < 0.5 then return end\n    lastUpdateHealthTime = 0\n\n    local recalculate = false\n    local stateBasedHP = S.attributesStorage:get(\"stateBasedHP\")\n    for attribute, value in pairs(healthAttributes) do\n        local current\n        if stateBasedHP then\n            current = Player.stats.attributes[attribute](self).modified\n        else\n            current = Player.stats.attributes[attribute](self).base\n        end\n        if current ~= value then\n            healthAttributes[attribute] = current\n            recalculate = true\n        end\n    end\n    if recalculate or forceUpdateHealth then\n        local hpGainRatio = 10\n        if S.attributesStorage:get(\"perLevelHPGain\") == \"low\" then\n            hpGainRatio = 20\n        end\n        forceUpdateHealth = false\n        local currentLevel = Player.stats.level(self).current\n        local maxHealth = math.floor(getHealthFactor(healthAttributes)\n                + (currentLevel - 1) * getHealthFactor(healthAttributes) / hpGainRatio\n                + C.getMaxHealthModifier())\n        local health = Player.stats.dynamic.health(self)\n        local ratio = health.current / health.base\n        health.base = maxHealth\n        health.current = ratio * maxHealth\n    end\nend\n\nlocal function updateHealth()\n    forceUpdateHealth = true\nend\n\nlocal function addSkillGain(skillId, skillGain)\n    local skillRequirement = I.SkillProgression.getSkillProgressRequirement(skillId)\n    local progress = Player.stats.skills[skillId](self).progress + skillGain / skillRequirement\n    local excessSkillGain = (progress - 1) * skillRequirement\n    C.debugPrint(string.format(\"Add skill \\\"%s\\\" gain %.5f (requirement %.5f, excess %.5f), progress %.5f to %.5f\",\n            skillId, skillGain, skillRequirement, excessSkillGain > 0 and excessSkillGain or 0, Player.stats.skills[skillId](self).progress, progress))\n    if excessSkillGain >= 0 then\n        C.increaseSkill(skillId)\n        if not S.skillsStorage:get(\"carryOverExcessSkillGain\") or\n                Player.stats.skills[skillId](self).base >= S.getSkillMaxValue(skillId) then\n            progress = 0\n        else\n            Player.stats.skills[skillId](self).progress = 0\n            -- Recursive function to allow gaining multiple levels with one skill action (unlikely but possible)\n            addSkillGain(skillId, excessSkillGain)\n            return\n        end\n    end\n    C.skillProgress()[skillId] = progress\n    Player.stats.skills[skillId](self).progress = progress\nend\n\nlocal function addSkillUsedHandlers()\n    if not def.isLuaApiRecentEnough then return end\n\n    I.SkillProgression.addSkillUsedHandler(function(skillId, params)\n        local skillLevel = Player.stats.skills[skillId](self).base\n        addSkillGain(skillId, params.skillGain)\n        if skillLevel ~= Player.stats.skills[skillId](self).base then\n            updatePlayerStats(false)\n        end\n        -- We handle skill level up\n        return false\n    end)\n\n    I.SkillProgression.addSkillUsedHandler(function(skillId, params)\n        C.debugPrint(string.format(\"Skill \\\"%s\\\" used, base gain = %.5f\", skillId, params.skillGain))\n        local skillIncreaseConstantFactor = S.skillsStorage:get(\"skillIncreaseConstantFactor\")\n        if skillIncreaseConstantFactor ~= \"vanilla\" then\n            params.skillGain = params.skillGain / S.getSkillIncreaseConstantFactor(skillIncreaseConstantFactor)\n            C.debugPrint(string.format(\"Skill gain of \\\"%s\\\" reduced by constant, new gain = %.5f\", skillId, params.skillGain))\n        end\n        local skillIncreaseSquaredLevelFactor = S.skillsStorage:get(\"skillIncreaseSquaredLevelFactor\")\n        if skillIncreaseSquaredLevelFactor ~= \"disabled\" then\n            params.skillGain = params.skillGain / (\n                    (S.getSkillIncreaseSquaredLevelFactor(skillIncreaseSquaredLevelFactor) - 1)\n                            * (Player.stats.skills[skillId](self).base / 100) ^ 2\n                            + 1)\n            C.debugPrint(string.format(\"Skill gain of \\\"%s\\\" reduced by square, new gain = %.5f\", skillId, params.skillGain))\n        end\n    end)\n\n    I.SkillProgression.addSkillUsedHandler(decay.getSkillUsedHandler())\n\n    I.SkillProgression.addSkillUsedHandler(mbsp.getSkillUsedHandler())\n\n    I.SkillProgression.addSkillUsedHandler(function(skillId, _)\n        if Player.stats.skills[skillId](self).base >= S.getSkillMaxValue(skillId) then\n            Player.stats.skills[skillId](self).progress = 0\n            -- Stop skill used handlers\n            return false\n        end\n    end)\n\n    I.SkillProgression.addSkillLevelUpHandler(function(skillId, source)\n        if source == I.SkillProgression.SKILL_INCREASE_SOURCES.Book and not S.skillsStorage:get(\"skillIncreaseFromBooks\") then\n            C.debugPrint(string.format(\"Preventing skill \\\"%s\\\" level up from book\", skillId))\n            -- Stop skill level up handlers\n            return false\n        end\n        if lastUiMode == \"Training\" then\n            decay.setLastTrainedSkillId(skillId)\n        end\n        -- Send an event to give time to the skill to level up before updating player stats\n        self:sendEvent(\"updateProfile\")\n    end)\nend\n\nlocal function init(clearAll)\n    C.debugPrint(\"NCGDMW Lua Edition INIT begins!\")\n\n    C.init()\n\n    local attributes = {}\n    if def.isLuaApiRecentEnough then\n        -- Get race attributes and class specialized attributes to improve initialization on existing games\n        local playerRecord = Player.record(self)\n        local specAttributes = {}\n        for _, attributeId in ipairs(Player.classes.record(playerRecord.class).attributes) do\n            specAttributes[attributeId] = true\n        end\n        for attributeId, value in pairs(Player.races.record(playerRecord.race).attributes) do\n            attributes[attributeId] = (playerRecord.isMale and value.male or value.female) + (specAttributes[attributeId] and 10 or 0)\n        end\n        baseTotalStats = nil\n    else\n        for attributeId, getter in pairs(Player.stats.attributes) do\n            attributes[attributeId] = getter(self).base\n        end\n    end\n\n    if not def.isLuaApiRecentEnough and Player.stats.level(self).current == 1 then\n        local fortifiedHealth = Player.stats.dynamic.health(self).base - (Player.stats.attributes.strength(self).base + Player.stats.attributes.endurance(self).base) / 2\n        if fortifiedHealth > 0 then\n            C.setFortifiedHealthV48(fortifiedHealth)\n            C.debugPrint(string.format(\"Detected fortified health: %d\", fortifiedHealth))\n        end\n    end\n\n    local baseStatsMods = C.getBaseStatsModifiers()\n\n    for attributeId, value in pairs(attributes) do\n        C.baseAttributes()[attributeId] = value - (baseStatsMods.attributes[attributeId] or 0)\n        C.startAttributes()[attributeId] = C.baseAttributes()[attributeId] / 2\n        if clearAll or C.attributeDiffs()[attributeId] == nil then\n            C.attributeDiffs()[attributeId] = 0\n        elseif C.attributeDiffs()[attributeId] ~= 0 then\n            C.debugPrint(string.format(\"Preserving previous \\\"%s\\\" external change of %d\", attributeId, C.attributeDiffs()[attributeId]))\n        end\n        healthAttributes = H.initNewTable(0, cfg.healthAttributeFactors)\n    end\n\n    for skillId, getter in pairs(Player.stats.skills) do\n        -- Base skills will be set in getAttributesToRecalculate. Set to nil to detect the new value and update attributes accordingly\n        C.baseSkills()[skillId] = nil\n        -- Max skills shall not include base skill modifiers\n        C.maxSkills()[skillId] = getter(self).base - (baseStatsMods.skills[skillId] or 0)\n    end\n\n    decay.init()\n\n    C.setHasStats(true)\n\n    updateProfileAsked = true\n    updateStarterSpellsAsked = true\n    addSkillUsedHandlers()\n\n    if S.globalStorage:get(\"showIntro\") then\n        -- Wait a few seconds, then flash a message to prompt the user to configure the mod\n        async:newSimulationTimer(\n                2,\n                async:registerTimerCallback(\n                        \"newGameGreeting\",\n                        function()\n                            C.showMessage(L(\"doSettings\"))\n                            C.debugPrint(\"NCGDMW Lua Edition INIT has ended!\")\n                        end\n                )\n        )\n    end\nend\n\nlocal function onConsume(item)\n    -- No need to do any record checking if the player already has stats.\n    if C.hasStats() then return end\n\n    -- But if we don't have stats, check to see if this\n    -- is the right potion and do init() as needed.\n    if item.recordId == potionId then\n        init(true)\n    end\nend\n\nlocal function resetStats(clearAll)\n    C.debugPrint(\"Resetting abilities...\")\n    for _, activeSpell in pairs(Player.activeSpells(self)) do\n        if not activeSpell.fromEquipment then\n            C.debugPrint(string.format(\"Clearing active spell \\\"%s\\\"\", activeSpell.name))\n            Player.activeSpells(self):remove(activeSpell.id)\n        end\n    end\n    for _, spell in pairs(Player.spells(self)) do\n        if spell.type == core.magic.SPELL_TYPE.Ability or spell.type == core.magic.SPELL_TYPE.Curse then\n            C.debugPrint(string.format(\"Removing ability spell \\\"%s\\\"\", spell.name))\n            Player.spells(self):remove(spell.id)\n        end\n    end\n    local spellIds = {}\n    local birthSign = Player.birthSigns.record(Player.getBirthSign(self))\n    if birthSign ~= nil then\n        for _, spellId in pairs(birthSign.spells) do\n            table.insert(spellIds, spellId)\n        end\n    end\n    local race = Player.races.record(Player.record(self).race)\n    for _, spellId in pairs(race.spells) do\n        table.insert(spellIds, spellId)\n    end\n    for _, spellId in ipairs(spellIds) do\n        local spell = core.magic.spells.records[spellId]\n        if spell.type == core.magic.SPELL_TYPE.Ability then\n            C.debugPrint(string.format(\"Adding ability \\\"%s\\\"\", spell.name))\n            Player.spells(self):add(spell.id)\n        end\n    end\n\n    -- Wait a short time in order to abilities reset to take effect\n    -- Using 2 different callbacks as we cannot pass a variable to them\n    if clearAll then\n        async:newSimulationTimer(\n                1,\n                async:registerTimerCallback(\n                        \"initHardNCGD\",\n                        function()\n                            init(true)\n                        end\n                )\n        )\n    else\n        async:newSimulationTimer(\n                1,\n                async:registerTimerCallback(\n                        \"initSoftNCGD\",\n                        function()\n                            init(false)\n                        end\n                )\n        )\n    end\nend\n\nlocal function hasOrHadPotion()\n    -- Even if the player isn't using the alt start version, if they have stats\n    -- then for all intents and purposes they may as well have had the potion.\n    if C.hasStats() then return true end\n\n    -- Being in possession of the potion will prevent init()\n    -- from running on its own (see \"onConsume\" below).\n    if def.isLuaApiRecentEnough then\n        return #Player.inventory(self):findAll(potionId) > 0\n    else\n        return Player.inventory(self):countOf(potionId) > 0\n    end\nend\n\nlocal function increaseMagicDamageTaken(deltaTime)\n    if def.isLuaApiRecentEnough and debug.isGodMode() then return end\n    local magicDamageMultiplier = S.attributesStorage:get(\"magicDamageMultiplier\")\n    if magicDamageMultiplier == \"disabled\" then return end\n\n    effectDamage.time = effectDamage.time + deltaTime\n    if effectDamage.time < 0.1 then return end\n\n    local drainDamage = 0\n    local numEffects = 0\n    for _, effect in pairs(types.Actor.activeEffects(self)) do\n        if healthDamagingEffectIds[effect.id] then\n            numEffects = numEffects + 1\n            if effect.id == \"drainhealth\" then\n                drainDamage = effect.magnitude\n            elseif effect.id ~= \"sundamage\" or self.cell.isExterior or self.cell:hasTag(\"QuasiExterior\") then\n                effectDamage.sum = effectDamage.sum + effect.magnitude\n            end\n        end\n    end\n\n    -- Drain health value changed: Update player health (increase, reduce, cancel drain)\n    if drainDamage ~= effectDamage.drain then\n        Player.stats.dynamic.health(self).current = Player.stats.dynamic.health(self).current\n                - S.getMagicDamageMultiplierFactor(magicDamageMultiplier) * (drainDamage - effectDamage.drain)\n        effectDamage.drain = drainDamage\n    end\n\n    if effectDamage.sum ~= 0 then\n        local damage = S.getMagicDamageMultiplierFactor(magicDamageMultiplier) * effectDamage.time * effectDamage.sum\n        C.debugPrint(string.format(\"Inflicting %.2f extra magic damage from %d effect(s) over %.2f seconds\",\n                damage, numEffects, effectDamage.time))\n        effectDamage.sum = 0\n\n        Player.stats.dynamic.health(self).current = math.min(\n                math.max(0, Player.stats.dynamic.health(self).current - damage),\n                Player.stats.dynamic.health(self).base\n        )\n    end\n    effectDamage.time = 0\nend\n\nlocal function onFrame(deltaTime)\n    if isDisabled then return end\n    -- This is a hack to see if we're far enough along in CharGen to have stats\n    if not C.hasStats() and not hasOrHadPotion() and input.getControlSwitch(input.CONTROL_SWITCH.ViewMode) then\n        init(true)\n    elseif C.hasStats() then\n        -- Main loop\n        if updateProfileAsked then\n            updateProfileAsked = false\n            updatePlayerStats(true)\n        elseif not def.isLuaApiRecentEnough then\n            updatePlayerStats(false)\n        end\n        if not def.isLuaApiRecentEnough then\n            mbsp.onFrame(deltaTime)\n        end\n        increaseMagicDamageTaken(deltaTime)\n        decay.onFrame(deltaTime)\n        doHealth(deltaTime)\n    end\nend\n\nlocal function onUpdate()\n    if updateProfileOnUpdateAsked then\n        updateProfileOnUpdateAsked = false\n        if C.hasStats() then\n            updatePlayerStats(true)\n            updateHealth()\n        end\n    end\nend\n\nlocal function uiModeChanged(data)\n    lastUiMode = data.newMode\n    decay.checkJailTime(data)\n\n    if data.oldMode == nil and data.newMode == \"Rest\" then\n        decay.lastUiRestData().withActivator = data.arg and data.arg.type == types.Activator\n        decay.lastUiRestData().time = C.totalGameTimeInHours()\n        decay.lastUiRestData().hasSleptOrWaited = false\n    elseif data.oldMode == \"Rest\" and data.newMode == \"Loading\" then\n        decay.lastUiRestData().hasSleptOrWaited = true\n    end\nend\n\nlocal function onActive()\n    if resetStatsAsked then\n        resetStatsAsked = false\n        resetStats(false)\n    end\nend\n\nlocal function onLoad(data)\n    C.debugPrint(string.format(\"Loaded saved game data:\\n%s\", aux_util.deepToString(data, 5)))\n    if data then\n        cfg.updateConfig(data.configuration or {})\n        baseTotalStats = data.baseTotalStats\n        lvlProg = data.lvlProg\n        healthAttributes = data.healthAttributes or healthAttributes\n        effectDamage = data.effectDamage or effectDamage,\n        C.onLoad(data)\n        decay.onLoad(data)\n        local isDataMissing = not C.hasStats() or C.baseSkills() == nil or C.baseAttributes() == nil or C.startAttributes() == nil\n        if data.savedGameVersion == nil or data.savedGameVersion < 3.4 then\n            if S.attributesStorage:get(\"uncapperMaxValue\") then\n                S.attributesStorage:set(\"uncapperMaxValue\", 1000)\n            else\n                S.attributesStorage:set(\"uncapperMaxValue\", 100)\n            end\n            if S.skillsStorage:get(\"uncapperMaxValue\") then\n                S.skillsStorage:set(\"uncapperMaxValue\", 1000)\n            else\n                S.skillsStorage:set(\"uncapperMaxValue\", 100)\n            end\n            return\n        end\n        if def.isLuaApiRecentEnough then\n            -- Saved games before 3.2 (no version) need a reset as storage values have changed\n            -- Saved games from 3.2 need a reset because of a bug on baseTotalStats not properly reset\n            if data.savedGameVersion == nil or data.savedGameVersion < 3.3 or isDataMissing then\n                resetStatsAsked = true\n                return\n            end\n        elseif isDataMissing then\n            isDisabled = true\n            C.setHasStats(false)\n            C.showMessage(L(\"requiresNewGameWithOpenmw48\"))\n            return\n        end\n        updateProfileAsked = true\n        if C.hasStats() then\n            addSkillUsedHandlers()\n        end\n    end\nend\n\nlocal function onSave()\n    local data = {\n        savedGameVersion = savedGameVersion,\n        configuration = cfg.getData(),\n        baseTotalStats = baseTotalStats,\n        lvlProg = lvlProg,\n        healthAttributes = healthAttributes,\n        effectDamage = effectDamage,\n    }\n    C.onSave(data)\n    decay.onSave(data)\n    return data\nend\n\n-- Public interface\n\nlocal interface = {\n    version = interfaceVersion,\n    -- Get an attribute value, also set it if value is not nil\n    Attribute = function(attributeId, value)\n        if attributeId == nil or Player.stats.attributes[attributeId] == nil then\n            error(string.format(\"Invalid attribute id \\\"%s\\\"\"), attributeId)\n        end\n        local changed = false\n        if value ~= nil then\n            local numValue = tonumber(value)\n            if numValue == nil or numValue < 0 then\n                error(string.format(\"Invalid attribute value \\\"%s\\\"\"), value)\n            end\n            changed = C.setStat(\"attributes\", attributeId, numValue)\n        end\n        return changed, C.getStat(\"attributes\", attributeId)\n    end,\n    -- Get a skill value, also set it if value is not nil\n    Skill = function(skillId, value)\n        if skillId == nil or Player.stats.skills[skillId] == nil then\n            error(string.format(\"Invalid skill id \\\"%s\\\"\"), skillId)\n        end\n        local changed = false\n        if value ~= nil then\n            local numValue = tonumber(value)\n            if numValue == nil or numValue < 0 then\n                error(string.format(\"Invalid skill value \\\"%s\\\"\"), value)\n            end\n            changed = C.setStat(\"skills\", skillId, numValue)\n            C.maxSkills()[skillId] = numValue\n            C.decaySkills()[skillId] = 0\n        end\n        return changed, C.getStat(\"skills\", skillId)\n    end,\n    -- Get a skill progress value, also set it if value is not nil\n    SkillProgress = function(skillId, value)\n        if skillId == nil or Player.stats.skills[skillId] == nil then\n            error(string.format(\"Invalid skill id \\\"%s\\\"\"), skillId)\n        end\n        local changed = false\n        if value ~= nil then\n            local numValue = tonumber(value)\n            if numValue == nil or numValue < 0 or numValue >= 1 then\n                error(string.format(\"Invalid skill progress value \\\"%s\\\", it must be between 0 and 1\"), value)\n            end\n            changed = C.skillProgress()[skillId] ~= value\n            C.skillProgress()[skillId] = value\n            Player.stats.skills[skillId](self).progress = value\n        end\n        return changed, C.skillProgress()[skillId]\n    end,\n    -- Get skill affected attributes, also set them if primaryAttrId, secondaryAttrId and tertiaryAttrId are not nil\n    SkillAffectedAttributes = function(skillId, primaryAttrId, secondaryAttrId, tertiaryAttrId)\n        if skillId == nil or Player.stats.skills[skillId] == nil then\n            error(string.format(\"Invalid skill id \\\"%s\\\"\", skillId));\n        end\n        if primaryAttrId == nil and secondaryAttrId == nil and tertiaryAttrId == nil then\n            return false, cfg.skillsImpactOnAttributes[skillId]\n        end\n        if primaryAttrId == nil or Player.stats.attributes[primaryAttrId] == nil then\n            error(string.format(\"Invalid primary attribute id \\\"%s\\\"\", primaryAttrId));\n        end\n        if secondaryAttrId == nil or Player.stats.attributes[secondaryAttrId] == nil then\n            error(string.format(\"Invalid secondary attribute id \\\"%s\\\"\", secondaryAttrId));\n        end\n        if tertiaryAttrId == nil or Player.stats.attributes[tertiaryAttrId] == nil then\n            error(string.format(\"Invalid tertiary attribute id \\\"%s\\\"\", tertiaryAttrId));\n        end\n        if primaryAttrId == secondaryAttrId or primaryAttrId == tertiaryAttrId or secondaryAttrId == tertiaryAttrId then\n            error(\"Affected attributes must be different.\");\n        end\n        if primaryAttrId == \"luck\" or secondaryAttrId == \"luck\" or tertiaryAttrId == \"luck\" then\n            error(\"Luck cannot be set as an affected attribute.\");\n        end\n        local changed = cfg.setSkillsImpactOnAttributes(skillId, primaryAttrId, secondaryAttrId, tertiaryAttrId)\n        return changed, cfg.skillsImpactOnAttributes[skillId]\n    end,\n    -- Get player level process value\n    LevelProgress = function(raw)\n        if raw then\n            return lvlProg\n        else\n            return tostring(lvlProg) .. \"%\"\n        end\n    end,\n    -- Get player no decay time value (total time in hours without decay)\n    NoDecayTime = function()\n        print(decay.noDecayTime())\n    end,\n    -- Reset player's profile stats, useful with game saved before NCGDMW 3.2 or when some stats are broken\n    ResetStats = function()\n        if not def.isLuaApiRecentEnough then\n            error(\"Resetting stats can only be done with a recent enough OpenMW 0.49 version.\")\n        end\n        resetStats(true)\n    end,\n}\n\nlocal function showStatsMenu(data)\n    decay.updateDecay()\n    updatePlayerStats(true)\n    doHealth()\n    ncgdUI.showStatsMenu(data)\nend\n\nreturn {\n    engineHandlers = {\n        onConsume = onConsume,\n        onFrame = onFrame,\n        onUpdate = onUpdate,\n        onKeyPress = ncgdUI.onKeyPress,\n        onKeyRelease = ncgdUI.onKeyRelease,\n        onLoad = onLoad,\n        onSave = onSave,\n        onActive = onActive,\n    },\n    eventHandlers = {\n        UiModeChanged = uiModeChanged,\n        updateProfile = function()\n            updateProfileAsked = true\n        end,\n        updateProfileOnUpdate = function()\n            updateProfileOnUpdateAsked = true\n        end,\n        showStatsMenu = showStatsMenu,\n        updateHealth = updateHealth,\n        refreshDecay = function()\n            if C.hasStats() then\n                decay.logDecayTime()\n            end\n        end,\n    },\n    interfaceName = def.MOD_NAME,\n    interface = interface\n}\n",
    "NCGDMW Lua Edition-53136-3-5-1725880983\\00 Core\\scripts\\NCGDMW\\renderers.lua": "local core = require('openmw.core')\nlocal async = require('openmw.async')\nlocal input = require('openmw.input')\nlocal ui = require('openmw.ui')\nlocal util = require('openmw.util')\nlocal I = require(\"openmw.interfaces\")\n\nlocal def = require('scripts.NCGDMW.definition')\n\n-- THANKS:\n-- https://gitlab.com/urm-openmw-mods/camerahim/-/blob/1a12e3f8c902291d5629f2d8cc8649eac315533a/Data%20Files/scripts/CameraHIM/settings.lua#L23-35\nI.Settings.registerRenderer(\n        \"NCGDMW_hotkey\", function(value, set)\n            return {\n                template = I.MWUI.templates.textEditLine,\n                props = {\n                    text = value and input.getKeyName(value) or '',\n                    textAlignH = ui.ALIGNMENT.End,\n                },\n                events = {\n                    keyPress = async:callback(function(e)\n                        set(e.code)\n                    end)\n                }\n            }\n        end)\n\nlocal growingInterval = {\n    external = { grow = 1 }\n}\n\nlocal stretchingLine = {\n    template = I.MWUI.templates.horizontalLine,\n    external = { stretch = 1 },\n}\n\nlocal leftArrow = ui.texture {\n    path = 'textures/omw_menu_scroll_left.dds',\n}\n\nlocal rightArrow = ui.texture {\n    path = 'textures/omw_menu_scroll_right.dds',\n}\n\nlocal function validateNumber(text, argument)\n    local number = tonumber(text)\n    if not number then return end\n    if argument.min and number < argument.min then return argument.min end\n    if argument.max and number > argument.max then return argument.max end\n    if argument.integer and math.floor(number) ~= number then return math.floor(number) end\n    return number\nend\n\nlocal registerMultiSelectNumberRenderer = function(settingKey, allItems)\n    I.Settings.registerRenderer(\n            settingKey, function(data, set, argument)\n                data = data or {}\n                local items = {}\n                local lines = {}\n\n                local getAvailableItems = function()\n                    local available = {}\n                    local taken = {}\n                    for _, item in ipairs(items) do\n                        taken[item.key] = true\n                    end\n                    for _, item in ipairs(allItems) do\n                        if not taken[item.key] then\n                            table.insert(available, item)\n                        end\n                    end\n                    return available\n                end\n\n                local getNextItem = function(key, forward)\n                    local available = {}\n                    local taken = {}\n                    for _, item in ipairs(items) do\n                        if item.key ~= key then\n                            taken[item.key] = true\n                        end\n                    end\n                    local index\n                    for _, item in ipairs(allItems) do\n                        if not taken[item.key] then\n                            if item.key == key then\n                                index = #available + 1\n                            end\n                            table.insert(available, item)\n                        end\n                    end\n                    return available[(index + (forward and 0 or -2)) % #available + 1]\n                end\n\n                local lastInput\n\n                for index, item in pairs(data) do\n                    table.insert(items, { key = item.key, name = item.name, value = item.value })\n\n                    table.insert(lines, {\n                        type = ui.TYPE.Flex,\n                        props = {\n                            horizontal = true,\n                            size = util.vector2(150, 0),\n                        },\n                        external = { stretch = 1 },\n                        content = ui.content {\n                            { props = { size = util.vector2(10, 0) } },\n                            {\n                                type = ui.TYPE.Image,\n                                props = {\n                                    resource = leftArrow,\n                                    size = util.vector2(1, 1) * 12,\n                                },\n                                events = {\n                                    mouseClick = async:callback(function()\n                                        items[index] = getNextItem(item.key, false)\n                                        set(items)\n                                    end),\n                                },\n                            },\n                            { template = I.MWUI.templates.interval },\n                            {\n                                template = I.MWUI.templates.textNormal,\n                                props = { text = item.name },\n                                growingInterval,\n                            },\n                            { template = I.MWUI.templates.interval },\n                            {\n                                type = ui.TYPE.Image,\n                                props = {\n                                    resource = rightArrow,\n                                    size = util.vector2(1, 1) * 12,\n                                },\n                                events = {\n                                    mouseClick = async:callback(function()\n                                        items[index] = getNextItem(item.key, true)\n                                        set(items)\n                                    end),\n                                },\n                            },\n                            growingInterval,\n                            {\n                                template = I.MWUI.templates.textEditLine,\n                                props = {\n                                    text = tostring(item.value),\n                                    size = util.vector2(50, 0),\n                                    textAlignH = ui.ALIGNMENT.End,\n                                },\n                                events = {\n                                    textChanged = async:callback(function(value)\n                                        lastInput = value\n                                    end),\n                                    focusLoss = async:callback(function()\n                                        if not lastInput then return end\n                                        local number = validateNumber(lastInput, argument)\n                                        if number and number ~= data then\n                                            items[index].value = number\n                                        end\n                                        set(items)\n                                        lastInput = nil\n                                    end),\n                                }\n                            },\n                            { props = { size = util.vector2(10, 0) } },\n                            {\n                                type = ui.TYPE.Text,\n                                template = I.MWUI.templates.textNormal,\n                                props = {\n                                    text = \"x\",\n                                    textSize = 14,\n                                    textColor = util.color.rgb(.8, .3, .4),\n                                },\n                                events = {\n                                    mouseClick = async:callback(function()\n                                        table.remove(items, index)\n                                        set(items)\n                                    end),\n                                }\n                            },\n                        },\n                    })\n                end\n\n                return {\n                    type = ui.TYPE.Flex,\n                    content = ui.content {\n                        {\n                            type = ui.TYPE.Flex,\n                            props = { horizontal = true },\n                            external = { stretch = 1 },\n                            content = ui.content {\n                                growingInterval,\n                                {\n                                    type = ui.TYPE.Text,\n                                    template = I.MWUI.templates.textNormal,\n                                    props = { text = \"+\", textSize = 24 },\n                                },\n                            },\n                            events = {\n                                mouseClick = async:callback(function()\n                                    local available = getAvailableItems()\n                                    if #available > 0 then\n                                        items[#items + 1] = available[1]\n                                        set(items)\n                                    end\n                                end),\n                            }\n                        },\n                        stretchingLine,\n                        table.unpack(lines),\n                    },\n                }\n            end)\n\nend\n\nlocal skillItems = {}\nlocal attributeItems = {}\nif def.isLuaApiRecentEnough then\n    for _, stat in pairs(core.stats.Skill.records) do\n        table.insert(skillItems, { key = stat.id, name = stat.name, value = 1000 })\n    end\n    for _, stat in pairs(core.stats.Attribute.records) do\n        table.insert(attributeItems, { key = stat.id, name = stat.name, value = 1000 })\n    end\nelse\n    attributeItems = {\n        { key = \"strength\", name = \"Strength\", value = 1000 },\n        { key = \"intelligence\", name = \"Intelligence\", value = 1000 },\n        { key = \"willpower\", name = \"Willpower\", value = 1000 },\n        { key = \"agility\", name = \"Agility\", value = 1000 },\n        { key = \"speed\", name = \"Speed\", value = 1000 },\n        { key = \"endurance\", name = \"Endurance\", value = 1000 },\n        { key = \"personality\", name = \"Personality\", value = 1000 },\n        { key = \"luck\", name = \"Luck\", value = 1000 },\n    }\n    skillItems = {\n        { key = \"block\", name = \"Block\", value = 1000 },\n        { key = \"armorer\", name = \"Armorer\", value = 1000 },\n        { key = \"mediumarmor\", name = \"Medium Armor\", value = 1000 },\n        { key = \"heavyarmor\", name = \"Heavy Armor\", value = 1000 },\n        { key = \"bluntweapon\", name = \"Blunt Weapon\", value = 1000 },\n        { key = \"longblade\", name = \"Long Blade\", value = 1000 },\n        { key = \"axe\", name = \"Axe\", value = 1000 },\n        { key = \"spear\", name = \"Spear\", value = 1000 },\n        { key = \"athletics\", name = \"Athletics\", value = 1000 },\n        { key = \"enchant\", name = \"Enchant\", value = 1000 },\n        { key = \"destruction\", name = \"Destruction\", value = 1000 },\n        { key = \"alteration\", name = \"Alteration\", value = 1000 },\n        { key = \"illusion\", name = \"Illusion\", value = 1000 },\n        { key = \"conjuration\", name = \"Conjuration\", value = 1000 },\n        { key = \"mysticism\", name = \"Mysticism\", value = 1000 },\n        { key = \"restoration\", name = \"Restoration\", value = 1000 },\n        { key = \"alchemy\", name = \"Alchemy\", value = 1000 },\n        { key = \"unarmored\", name = \"Unarmored\", value = 1000 },\n        { key = \"security\", name = \"Security\", value = 1000 },\n        { key = \"sneak\", name = \"Sneak\", value = 1000 },\n        { key = \"acrobatics\", name = \"Acrobatics\", value = 1000 },\n        { key = \"lightarmor\", name = \"Light Armor\", value = 1000 },\n        { key = \"shortblade\", name = \"Short Blade\", value = 1000 },\n        { key = \"marksman\", name = \"Marksman\", value = 1000 },\n        { key = \"mercantile\", name = \"Mercantile\", value = 1000 },\n        { key = \"speechcraft\", name = \"Speechcraft\", value = 1000 },\n        { key = \"handtohand\", name = \"Hand-to-hand\", value = 1000 },\n    }\nend\n\nregisterMultiSelectNumberRenderer(\"NCGDMW_per_skill_uncapper\", skillItems)\nregisterMultiSelectNumberRenderer(\"NCGDMW_per_attribute_uncapper\", attributeItems)",
    "NCGDMW Lua Edition-53136-3-5-1725880983\\00 Core\\scripts\\NCGDMW\\settings.lua": "local async = require('openmw.async')\nlocal I = require(\"openmw.interfaces\")\nlocal storage = require('openmw.storage')\nlocal self = require('openmw.self')\n\nlocal def = require('scripts.NCGDMW.definition')\n\nlocal globalSettingsKey = \"SettingsPlayer\" .. def.MOD_NAME\nlocal skillsSettingsKey = \"SettingsPlayerSkills\" .. def.MOD_NAME\nlocal attributesSettingsKey = \"SettingsPlayerAttributes\" .. def.MOD_NAME\nlocal mbspSettingsKey = \"SettingsPlayerMBSP\" .. def.MOD_NAME\n\nlocal function getDescriptionIfOpenMWTooOld(key)\n    if not def.isLuaApiRecentEnough then\n        if def.isOpenMW049 then\n            return \"requiresNewerOpenmw49\"\n        else\n            return \"requiresOpenmw49\"\n        end\n    end\n    return key\nend\n\nlocal settingGroups = {\n    [globalSettingsKey] = {\n        key = globalSettingsKey,\n        l10n = def.MOD_NAME,\n        name = \"settingsTitle\",\n        page = def.MOD_NAME,\n        order = 0,\n        description = \"settingsDesc\",\n        permanentStorage = false,\n        settings = {\n            {\n                key = \"statsMenuKey\",\n                name = \"statsMenuKey_name\",\n                default = nil,\n                renderer = \"NCGDMW_hotkey\",\n            },\n            {\n                key = \"showMessagesLog\",\n                name = \"showMessagesLog_name\",\n                description = \"showMessagesLog_description\",\n                default = true,\n                renderer = \"checkbox\"\n            },\n            {\n                key = \"showIntro\",\n                name = \"showIntro_name\",\n                default = true,\n                renderer = \"checkbox\"\n            },\n            {\n                key = \"starwindNames\",\n                name = \"starwindNames_name\",\n                default = false,\n                renderer = \"checkbox\"\n            },\n            {\n                key = \"debugMode\",\n                name = \"debugMode_name\",\n                default = false,\n                renderer = \"checkbox\"\n            },\n        }\n    },\n    [skillsSettingsKey] = {\n        key = skillsSettingsKey,\n        l10n = def.MOD_NAME,\n        name = \"settingsTitle_skills\",\n        page = def.MOD_NAME,\n        order = 1,\n        description = \"settingsDesc_skills\",\n        permanentStorage = false,\n        settings = {\n            {\n                key = \"uncapperMaxValue\",\n                name = \"uncapperMaxValue_name\",\n                description = \"skillUncapperMaxValue_description\",\n                renderer = \"number\",\n                default = 1000,\n                argument = {\n                    integer = true,\n                    min = 5,\n                    max = 1000,\n                },\n            },\n            {\n                key = \"perSkillUncapper\",\n                name = \"perSkillUncapper_name\",\n                description = \"perSkillUncapper_description\",\n                default = nil,\n                renderer = \"NCGDMW_per_skill_uncapper\",\n                argument = {\n                    integer = true,\n                    min = 5,\n                    max = 1000,\n                },\n            },\n            {\n                key = \"decayRate\",\n                name = \"decayRate_name\",\n                description = \"decayRate_description\",\n                default = \"none\",\n                argument = {\n                    l10n = def.MOD_NAME,\n                    items = { \"fast\", \"standard\", \"slow\", \"none\" },\n                    values = { 3, 2, 1, 0 },\n                },\n                renderer = \"select\"\n            },\n            {\n                key = \"skillIncreaseFromBooks\",\n                name = \"skillIncreaseFromBooks_name\",\n                default = true,\n                argument = {\n                    disabled = not def.isLuaApiRecentEnough,\n                },\n                renderer = \"checkbox\",\n                description = getDescriptionIfOpenMWTooOld(\"\"),\n            },\n            {\n                key = \"skillIncreaseConstantFactor\",\n                name = \"skillIncreaseConstantFactor_name\",\n                description = getDescriptionIfOpenMWTooOld(\"skillIncreaseConstantFactor_description\"),\n                default = \"vanilla\",\n                argument = {\n                    l10n = def.MOD_NAME,\n                    items = { \"vanilla\", \"half\", \"quarter\" },\n                    values = { 1, 2, 4 },\n                    disabled = not def.isLuaApiRecentEnough,\n                },\n                renderer = \"select\",\n            },\n            {\n                key = \"skillIncreaseSquaredLevelFactor\",\n                name = \"skillIncreaseSquaredLevelFactor_name\",\n                description = getDescriptionIfOpenMWTooOld(\"skillIncreaseSquaredLevelFactor_description\"),\n                default = \"disabled\",\n                argument = {\n                    l10n = def.MOD_NAME,\n                    items = { \"disabled\", \"downToHalf\", \"downToAQuarter\", \"downToAEighth\" },\n                    values = { 1, 2, 4, 8 },\n                    disabled = not def.isLuaApiRecentEnough,\n                },\n                renderer = \"select\",\n            },\n            {\n                key = \"carryOverExcessSkillGain\",\n                name = \"carryOverExcessSkillGain_name\",\n                default = true,\n                renderer = \"checkbox\",\n                description = getDescriptionIfOpenMWTooOld(\"carryOverExcessSkillGain_description\"),\n                argument = {\n                    disabled = not def.isLuaApiRecentEnough,\n                }\n            },\n        }\n    },\n    [attributesSettingsKey] = {\n        key = attributesSettingsKey,\n        l10n = def.MOD_NAME,\n        name = \"settingsTitle_attributes\",\n        page = def.MOD_NAME,\n        order = 2,\n        description = \"settingsDesc_attributes\",\n        permanentStorage = false,\n        settings = {\n            {\n                key = \"growthRate\",\n                name = \"growthRate_name\",\n                default = \"slow\",\n                argument = {\n                    l10n = def.MOD_NAME,\n                    items = { \"fast\", \"standard\", \"slow\" },\n                    values = { 3, 2, 1 },\n                },\n                renderer = \"select\"\n            },\n            {\n                key = \"uncapperMaxValue\",\n                name = \"uncapperMaxValue_name\",\n                description = \"attributeUncapperMaxValue_description\",\n                renderer = \"number\",\n                default = 1000,\n                argument = {\n                    integer = true,\n                    min = 5,\n                    max = 1000,\n                },\n            },\n            {\n                key = \"perAttributeUncapper\",\n                name = \"perAttributeUncapper_name\",\n                description = \"perAttributeUncapper_description\",\n                default = nil,\n                renderer = \"NCGDMW_per_attribute_uncapper\",\n                argument = {\n                    integer = true,\n                    min = 5,\n                    max = 1000,\n                },\n            },\n            {\n                key = \"stateBasedHP\",\n                name = \"stateBasedHP_name\",\n                description = \"stateBasedHP_description\",\n                default = false,\n                renderer = \"checkbox\"\n            },\n            {\n                key = \"baseHPRatio\",\n                name = \"baseHPRatio_name\",\n                description = \"baseHPRatio_description\",\n                default = \"full\",\n                argument = {\n                    l10n = def.MOD_NAME,\n                    items = { \"full\", \"3/4\", \"1/2\", \"1/4\" },\n                    values = { 1, 3 / 4, 1 / 2, 1 / 4 },\n                },\n                renderer = \"select\"\n            },\n            {\n                key = \"perLevelHPGain\",\n                name = \"perLevelHPGain_name\",\n                description = \"perLevelHPGain_description\",\n                default = \"high\",\n                argument = {\n                    l10n = def.MOD_NAME,\n                    items = { \"high\", \"low\" }\n                },\n                renderer = \"select\"\n            },\n            {\n                key = \"magicDamageMultiplier\",\n                name = \"magicDamageMultiplier_name\",\n                description = getDescriptionIfOpenMWTooOld(\"magicDamageMultiplier_description\"),\n                default = \"disabled\",\n                argument = {\n                    l10n = def.MOD_NAME,\n                    items = { \"disabled\", \"150%\", \"200%\", \"300%\", \"400%\" },\n                    values = { 0, 1 / 2, 1, 2, 3 },\n                    disabled = not def.isLuaApiRecentEnough,\n                },\n                renderer = \"select\"\n            },\n        }\n    },\n    [mbspSettingsKey] = {\n        key = mbspSettingsKey,\n        l10n = def.MOD_NAME,\n        name = \"settingsTitle_MBSP\",\n        page = def.MOD_NAME,\n        order = 3,\n        description = \"settingsDesc_MBSP\",\n        permanentStorage = false,\n        settings = {\n            {\n                key = \"mbspEnabled\",\n                name = \"mbspEnabled\",\n                default = true,\n                renderer = \"checkbox\",\n            },\n            {\n                key = \"magickaXPRate\",\n                name = \"magickaXPRate\",\n                default = \"10\",\n                argument = {\n                    l10n = def.MOD_NAME,\n                    items = { \"5\", \"10\", \"15\", \"20\", \"25\" },\n                },\n                renderer = \"select\",\n                description = \"magickaXPRate_desc\",\n            },\n            {\n                key = \"refundEnabled\",\n                name = \"refundEnabled\",\n                default = false,\n                renderer = \"checkbox\",\n                description = \"refundEnabled_desc\",\n            },\n            {\n                key = \"refundMult\",\n                name = \"refundMult\",\n                default = \"4\",\n                argument = {\n                    l10n = def.MOD_NAME,\n                    items = { \"1\", \"2\", \"3\", \"4\", \"5\" },\n                },\n                renderer = \"select\",\n                description = \"refundMult_desc\"\n            },\n            {\n                key = \"refundStart\",\n                default = 35,\n                renderer = \"number\",\n                name = \"Refund Skill Start\",\n                description = \"refundStart_desc\",\n                argument = {\n                    integer = true,\n                    min = 1,\n                    max = 1000,\n                },\n            },\n        }\n    }\n}\n\nlocal function getStorage(key)\n    return storage.playerSection(key)\nend\n\nlocal function getSetting(groupKey, settingKey)\n    local group = settingGroups[groupKey]\n    if group ~= nil then\n        for _, setting in ipairs(group.settings) do\n            if setting.key == settingKey then\n                return setting\n            end\n        end\n    end\n    print(string.format(\"Cannot find setting %s in group %s\", settingKey, groupKey))\n    return nil\nend\n\nlocal function setSettingToDefaultValue(groupKey, settingKey)\n    local setting = getSetting(groupKey, settingKey)\n    if setting ~= nil then\n        getStorage(groupKey):set(settingKey, setting.default)\n    end\n    return nil\nend\n\nlocal function getSettingSelectValue(groupKey, settingKey, item)\n    local setting = getSetting(groupKey, settingKey)\n    if setting ~= nil then\n        for i, value in ipairs(setting.argument.items) do\n            if value == item then\n                return setting.argument.values[i]\n            end\n        end\n    end\n    return nil\nend\n\nlocal function initSettings()\n    I.Settings.registerPage {\n        key = def.MOD_NAME,\n        l10n = def.MOD_NAME,\n        name = \"name\",\n        description = \"description\"\n    }\n\n    if not def.isLuaApiRecentEnough then\n        require('scripts.NCGDMW.renderers')\n    end\n\n    I.Settings.registerGroup(settingGroups[globalSettingsKey])\n    I.Settings.registerGroup(settingGroups[skillsSettingsKey])\n    I.Settings.registerGroup(settingGroups[attributesSettingsKey])\n    I.Settings.registerGroup(settingGroups[mbspSettingsKey])\n\n    if not def.isLuaApiRecentEnough then\n        -- clear settings in case the player downgrade from 0.49 to 0.48\n        setSettingToDefaultValue(skillsSettingsKey, \"carryOverExcessSkillGain\")\n        setSettingToDefaultValue(skillsSettingsKey, \"skillIncreaseConstantFactor\")\n        setSettingToDefaultValue(skillsSettingsKey, \"skillIncreaseSquaredLevelFactor\")\n        setSettingToDefaultValue(skillsSettingsKey, \"skillIncreaseFromBooks\")\n        setSettingToDefaultValue(attributesSettingsKey, \"magicDamageMultiplier\")\n    end\n\n    getStorage(skillsSettingsKey):subscribe(async:callback(function(_, key)\n        if key == \"decayRate\" then\n            self:sendEvent(\"refreshDecay\")\n        elseif key == \"uncapperMaxValue\" or key == \"perSkillUncapper\" then\n            self:sendEvent(\"updateProfileOnUpdate\")\n        end\n    end))\n\n    getStorage(attributesSettingsKey):subscribe(async:callback(function(_, _)\n        self:sendEvent(\"updateProfileOnUpdate\")\n    end))\nend\n\nlocal getStatMaxValue = function(statId, groupKey, settingKey)\n    for _, item in ipairs(getStorage(groupKey):get(settingKey) or {}) do\n        if item.key == statId then\n            return tonumber(item.value)\n        end\n    end\n    return getStorage(groupKey):get(\"uncapperMaxValue\")\nend\n\nlocal getPerStatMaxValues = function(groupKey, settingKey)\n    local map = {}\n    for _, item in ipairs(getStorage(groupKey):get(settingKey) or {}) do\n        map[item.key] = tonumber(item.value)\n    end\n    return map\nend\n\nreturn {\n    initSettings = initSettings,\n    -- Storages\n    globalStorage = getStorage(globalSettingsKey),\n    skillsStorage = getStorage(skillsSettingsKey),\n    attributesStorage = getStorage(attributesSettingsKey),\n    mbspStorage = getStorage(mbspSettingsKey),\n    -- Select key to values converters\n    getSkillDecayRates = function(key)\n        return getSettingSelectValue(skillsSettingsKey, \"decayRate\", key)\n    end,\n    getSkillIncreaseConstantFactor = function(key)\n        return getSettingSelectValue(skillsSettingsKey, \"skillIncreaseConstantFactor\", key)\n    end,\n    getSkillIncreaseSquaredLevelFactor = function(key)\n        return getSettingSelectValue(skillsSettingsKey, \"skillIncreaseSquaredLevelFactor\", key)\n    end,\n    getAttributeGrowthRates = function(key)\n        return getSettingSelectValue(attributesSettingsKey, \"growthRate\", key)\n    end,\n    getBaseHPRatioFactor = function(key)\n        return getSettingSelectValue(attributesSettingsKey, \"baseHPRatio\", key)\n    end,\n    getMagicDamageMultiplierFactor = function(key)\n        return getSettingSelectValue(attributesSettingsKey, \"magicDamageMultiplier\", key)\n    end,\n    getSkillMaxValue = function(skillId)\n        return getStatMaxValue(skillId, skillsSettingsKey, \"perSkillUncapper\")\n    end,\n    getPerSkillMaxValues = function()\n        return getPerStatMaxValues(skillsSettingsKey, \"perSkillUncapper\")\n    end,\n    getAttributeMaxValue = function(attributeId)\n        return getStatMaxValue(attributeId, attributesSettingsKey, \"perAttributeUncapper\")\n    end,\n    getPerAttributeMaxValues = function()\n        return getPerStatMaxValues(attributesSettingsKey, \"perAttributeUncapper\")\n    end,\n}",
    "NCGDMW Lua Edition-53136-3-5-1725880983\\00 Core\\scripts\\NCGDMW\\spells.lua": "local core = require('openmw.core')\nlocal Player = require('openmw.types').Player\n\nlocal function getPlayerInnateSpellIds(player)\n    local baseSpellIds = {}\n    local birthSign = Player.birthSigns.record(Player.getBirthSign(player))\n    if birthSign ~= nil then\n        for _, spellId in pairs(birthSign.spells) do\n            baseSpellIds[spellId] = true\n        end\n    end\n    local race = Player.races.record(Player.record(player).race)\n    for _, spellId in pairs(race.spells) do\n        baseSpellIds[spellId] = true\n    end\n    return baseSpellIds\nend\n\n-- Dehardcoding of autoCalcPlayerSpells C++ implementation from openmw source code: apps/openmw/mwmechanics/autocalcspell.cpp\n\nlocal function calcWeakestSchool(spell, context)\n    local minChance = math.huge\n    local effectiveSchool\n    local skillTerm = 0\n    for _, effect in ipairs(spell.effects) do\n        local minMagnitude = 1\n        local maxMagnitude = 1\n        if effect.effect.hasMagnitude then\n            minMagnitude = effect.magnitudeMin\n            maxMagnitude = effect.magnitudeMax\n        end\n        local duration = 0\n        if effect.effect.hasDuration then\n            duration = effect.duration\n        end\n        if effect.effect.isAppliedOnce then\n            duration = math.max(1, effect.duration)\n        end\n\n        local x = (0.5 * (math.max(1, minMagnitude) + math.max(1, maxMagnitude))\n                * 0.1 * effect.effect.baseCost\n                * (1 + duration)\n                + 0.05 * math.max(1, effect.area) * effect.effect.baseCost\n        ) * context.fEffectCostMult\n\n        if effect.range == core.magic.RANGE.Target then\n            x = x * 1.5\n        end\n\n        local s = 0\n        local skill = Player.stats.skills[effect.effect.school]\n        if skill then\n            s = 2 * skill(context.player).base;\n        end\n        if s - x < minChance then\n            minChance = s - x\n            effectiveSchool = effect.effect.school\n            skillTerm = s\n        end\n    end\n    return effectiveSchool, skillTerm\nend\n\nlocal function calcAutoCastChance(spell, context)\n    if spell.type ~= core.magic.SPELL_TYPE.Spell then return 100 end\n    if spell.alwaysSucceedFlag then return 100 end\n\n    local _, skillTerm = calcWeakestSchool(spell, context)\n\n    return skillTerm - spell.cost\n            + 0.2 * Player.stats.attributes.willpower(context.player).base\n            + 0.1 * Player.stats.attributes.luck(context.player).base\nend\n\nlocal function attrSkillCheck(spell, context)\n    for _, effect in ipairs(spell.effects) do\n        if effect.affectedSkill then\n            local skill = Player.stats.skills[effect.affectedSkill]\n            if not skill or skill(context.player).base < context.iAutoSpellAttSkillMin then\n                return false\n            end\n        end\n        if effect.affectedAttribute then\n            local attribute = Player.stats.attributes[effect.affectedAttribute]\n            if not attribute or attribute(context.player).base < context.iAutoSpellAttSkillMin then\n                return false\n            end\n        end\n        return true\n    end\nend\n\nlocal function selectStarterSpell(spell, context)\n    if spell.type ~= core.magic.SPELL_TYPE.Spell then return end\n    if context.reachedLimit and spell.cost <= context.minCost then return end\n    if context.baseSpellIds[spell.id] then return end\n    if context.baseMagicka < spell.cost then return end\n    if calcAutoCastChance(spell, context) < context.fAutoPCSpellChance then return end\n    if not attrSkillCheck(spell, context) then return end\n\n    table.insert(context.selectedSpells, spell.id)\n\n    if context.reachedLimit then\n        for i, spellId in ipairs(context.selectedSpells) do\n            if spellId == context.weakestSpell.id then\n                table.remove(context.selectedSpells, i)\n            end\n        end\n\n        context.minCost = math.huge\n        for _, spellId in ipairs(context.selectedSpells) do\n            local testSpell = core.magic.spells.records[spellId]\n            if testSpell.cost < context.minCost then\n                context.minCost = testSpell.cost\n                context.weakestSpell = testSpell\n            end\n        end\n    else\n        if (spell.cost < context.minCost) then\n            context.weakestSpell = spell\n            context.minCost = spell.cost\n        end\n        if #context.selectedSpells == context.iAutoPCSpellMax then\n            context.reachedLimit = true\n        end\n    end\nend\n\nlocal function autoCalcPlayerSpells(player)\n    local context = {\n        player = player,\n        fAutoPCSpellChance = core.getGMST(\"fAutoPCSpellChance\"),\n        fEffectCostMult = core.getGMST(\"fEffectCostMult\"),\n        iAutoSpellAttSkillMin = core.getGMST(\"iAutoSpellAttSkillMin\"),\n        iAutoPCSpellMax = core.getGMST(\"iAutoPCSpellMax\"),\n        baseMagicka = core.getGMST(\"fPCbaseMagickaMult\") * Player.stats.attributes.intelligence(player).base,\n        reachedLimit = false,\n        weakestSpell = nil,\n        minCost = math.huge,\n        baseSpellIds = getPlayerInnateSpellIds(player),\n        selectedSpells = {},\n    }\n    for _, spell in ipairs(core.magic.spells.records) do\n        if spell.starterSpellFlag then\n            selectStarterSpell(spell, context)\n        end\n    end\n    return context.selectedSpells\nend\n\nreturn {\n    getPlayerInnateSpellIds = getPlayerInnateSpellIds,\n    autoCalcPlayerSpells = autoCalcPlayerSpells,\n}",
    "NCGDMW Lua Edition-53136-3-5-1725880983\\00 Core\\scripts\\NCGDMW\\ui.lua": "local core = require('openmw.core')\nlocal async = require('openmw.async')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal ui = require('openmw.ui')\nlocal v2 = require('openmw.util').vector2\nlocal I = require(\"openmw.interfaces\")\nlocal Player = require('openmw.types').Player\nlocal util = require('openmw.util')\nlocal calendar = require('openmw_aux.calendar')\n\nlocal def = require('scripts.NCGDMW.definition')\nlocal cfg = require('scripts.NCGDMW.configuration')\nlocal S = require('scripts.NCGDMW.settings')\nlocal C = require('scripts.NCGDMW.common')\nlocal H = require('scripts.NCGDMW.helpers')\n\nlocal L = core.l10n(def.MOD_NAME)\n\nlocal ncgdStatsMenu\nlocal ncgdTooltip\nlocal lastTooltipMessage\n\nlocal orderedAttributeIds = { \"strength\", \"intelligence\", \"willpower\", \"agility\", \"speed\", \"endurance\", \"personality\", \"luck\" }\n\nlocal function padding(horizontal, vertical)\n    return { props = { size = v2(horizontal, vertical) } }\nend\n\nlocal function head(text)\n    return {\n        type = ui.TYPE.Text,\n        template = I.MWUI.templates.textHeader,\n        props = { text = text }\n    }\nend\n\nlocal growingInterval = {\n    external = { grow = 1 }\n}\n\nlocal vGap10 = padding(0, 10)\nlocal vGap20 = padding(0, 20)\nlocal vMargin = padding(0, 30)\nlocal hMargin = padding(30, 0)\n\nlocal stretchingLine = {\n    template = I.MWUI.templates.horizontalLineThick,\n    external = {\n        stretch = 1,\n    },\n}\n\nlocal textDecayColor = util.color.rgb(96 / 255, 134 / 255, 202 / 255)\nlocal textNormalColor = I.MWUI.templates.textNormal.props.textColor\n\nlocal function text(str, extraProps)\n    local props = { text = str }\n    if extraProps then\n        for k, v in pairs(extraProps) do\n            props[k] = v\n        end\n    end\n    return {\n        type = ui.TYPE.Text,\n        template = I.MWUI.templates.textNormal,\n        props = props,\n    }\nend\n\nlocal function textCells(...)\n    local texts = { ... }\n    local cells = {}\n    for _, cell in ipairs(texts) do\n        table.insert(cells, {\n            type = ui.TYPE.Flex,\n            props = { size = util.vector2(cell.width, 0), arrange = ui.ALIGNMENT.End },\n            content = ui.content { text(cell.text, cell.props) },\n            events = cell.events,\n        })\n    end\n    return {\n        type = ui.TYPE.Flex,\n        props = { horizontal = true },\n        content = ui.content {\n            table.unpack(cells)\n        }\n    }\nend\n\nlocal function textCell(width, str, props, events)\n    return { width = width, text = str, props = props, events = events }\nend\n\nlocal function row(key, content, isHead)\n    local left, right\n    if type(key) == \"string\" then\n        left = isHead and head(key) or text(key)\n    else\n        left = key\n    end\n    if type(content) == \"string\" then\n        right = isHead and head(content) or text(content)\n    else\n        right = content\n    end\n    return {\n        type = ui.TYPE.Flex,\n        props = { horizontal = true },\n        external = { stretch = 1 },\n        content = ui.content {\n            left,\n            growingInterval,\n            right,\n        }\n    }\nend\n\nlocal function headRow(key, value)\n    return row(key, value, true)\nend\n\nlocal boxTemplate = I.MWUI.templates.boxTransparent\nif def.isLuaApiRecentEnough then\n    boxTemplate = I.MWUI.templates.boxTransparentThick\nend\n\nlocal function centerWindow(content)\n    return {\n        layer = \"Windows\",\n        template = boxTemplate,\n        props = {\n            relativePosition = v2(.5, .5),\n            anchor = v2(.5, .5)\n        },\n        content = ui.content { content }\n    }\nend\n\nlocal function toolTip(content, position)\n    return {\n        layer = \"Notification\",\n        template = I.MWUI.templates.boxTransparent,\n        props = { position = position },\n        content = ui.content {\n            padding(0, 5),\n            {\n                type = ui.TYPE.Flex,\n                props = { horizontal = true },\n                content = ui.content {\n                    padding(5, 0),\n                    content,\n                    padding(5, 0),\n                }\n            },\n            padding(0, 5),\n        }\n    }\nend\n\nlocal function menu(content)\n    return centerWindow({\n        type = ui.TYPE.Flex,\n        content = ui.content {\n            vMargin,\n            {\n                type = ui.TYPE.Flex,\n                props = { horizontal = true },\n                external = { stretch = 1 },\n                content = ui.content {\n                    hMargin,\n                    content,\n                    hMargin,\n                }\n            },\n            vMargin,\n        }\n    })\nend\n\nlocal function getSkillsRows(getSkillValues)\n    local combatBlock = {\n        head(L(\"skillsCombatHead\")),\n    }\n    for _, skillId in ipairs(C.skillsBySchool().combat) do\n        table.insert(combatBlock, getSkillValues(skillId))\n    end\n\n    local magicBlock = {\n        head(L(\"skillsMagicHead\")),\n    }\n    for _, skillId in ipairs(C.skillsBySchool().magic) do\n        table.insert(magicBlock, getSkillValues(skillId))\n    end\n\n    local thiefBlock = {\n        head(L(\"skillsThiefHead\")),\n    }\n    for _, skillId in ipairs(C.skillsBySchool().stealth) do\n        table.insert(thiefBlock, getSkillValues(skillId))\n    end\n\n    return { combatBlock = combatBlock, magicBlock = magicBlock, thiefBlock = thiefBlock }\nend\n\nlocal function formatPercent(skillVal)\n    return string.format(\"%s%%\", math.floor(skillVal * 100 + 0.5))\nend\n\nlocal function createTooltip(message, position)\n    return ui.create(toolTip(text(message, { multiline = true }), position))\nend\n\nlocal function tooltipPosition(mousePosition)\n    return util.vector2(mousePosition.x - 20, mousePosition.y + 30)\nend\n\nlocal function closeTooltip()\n    if (ncgdTooltip ~= nil) then\n        ncgdTooltip:destroy()\n        ncgdTooltip = nil\n    end\nend\n\nlocal function closeMenu()\n    if ncgdStatsMenu ~= nil then\n        ncgdStatsMenu:destroy()\n        ncgdStatsMenu = nil\n        closeTooltip()\n    end\nend\n\nlocal function tooltipEvent(message)\n    return {\n        mouseMove = async:callback(function(mouseEvent, _)\n            if (ncgdTooltip == nil) then\n                ncgdTooltip = createTooltip(message, tooltipPosition(mouseEvent.position))\n            else\n                if lastTooltipMessage ~= message then\n                    closeTooltip()\n                    ncgdTooltip = createTooltip(message, mouseEvent.position)\n                else\n                    ncgdTooltip.layout.props.position = tooltipPosition(mouseEvent.position)\n                    ncgdTooltip:update()\n                end\n            end\n            lastTooltipMessage = message\n        end)\n    }\nend\n\nlocal menuWidth = 900\nlocal menuHMargin = 40\nlocal menuBlockHGap = 50\nlocal menuHeadHBlockSize = v2((menuWidth - menuBlockHGap * 2 - menuHMargin * 2) / 3, 0)\nlocal menuHBlockSize = v2((menuWidth - menuBlockHGap - menuHMargin * 2) / 2, 0)\nlocal menuHGapSize = v2(menuBlockHGap, 0)\nlocal menuCellWidth = 35\nlocal menuPercentCellWidth = 40\n\nlocal function getStatsMenu()\n    local growthRate = S.attributesStorage:get(\"growthRate\")\n    local decayRate = S.skillsStorage:get(\"decayRate\")\n    local baseStatsMods = C.getBaseStatsModifiers()\n    local baseAttrMods = {}\n    local hasAttrBaseStatsMods = false\n    local hasSkillBaseStatsMods = false\n    local maxHealthMod = C.getMaxHealthModifier()\n\n    for attributeId, _ in pairs(Player.stats.attributes) do\n        local baseMod = baseStatsMods.attributes[attributeId] or 0\n        baseAttrMods[attributeId] = baseMod + C.attributeDiffs()[attributeId]\n        if baseAttrMods[attributeId] ~= 0 then\n            hasAttrBaseStatsMods = true\n        end\n    end\n    for _, value in pairs(baseStatsMods.skills) do\n        if value ~= nil and value ~= 0 then\n            hasSkillBaseStatsMods = true\n            break\n        end\n    end\n\n    local leftHeadBlock = {}\n    local centerHeadBlock = {}\n    local rightHeadBlock = {}\n\n    H.insertMultipleInArray(leftHeadBlock, {\n        head(L(\"levelHead\")),\n        text(tostring(Player.stats.level(self).current)),\n        vGap10,\n        head(L(\"levelProgressHead\")),\n        text(tostring(I.NCGDMW.LevelProgress())),\n    })\n\n    H.insertMultipleInArray(centerHeadBlock, {\n        head(L(\"Settings\")),\n        row(L(\"growthRate_name\"), L(growthRate)),\n        row(L(\"decayRate_name\"), L(decayRate)),\n    })\n\n    if I.MarksmansEye then\n        H.insertMultipleInArray(centerHeadBlock, {\n            vGap10,\n            head(L(\"marksmansEyeHead\")),\n            text(I.MarksmansEye.Level()),\n        })\n    end\n\n    H.insertMultipleInArray(rightHeadBlock, {\n        head(L(\"gameTimeHead\")),\n        text(calendar.formatGameTime()),\n        vGap10,\n        head(L(\"daysPassedHead\")),\n        text(tostring(math.floor(C.totalGameTimeInHours() / 24))),\n    })\n\n    local leftBlock = {}\n    local rightBlock = {}\n\n    if maxHealthMod ~= 0 then\n        H.insertMultipleInArray(leftBlock, {\n            head(L(\"fortifyHealthHead\")),\n            text(tostring(maxHealthMod)),\n            vGap10,\n        })\n    end\n\n    H.insertMultipleInArray(leftBlock, {\n        headRow(L(\"attributesHead\"),\n                (hasAttrBaseStatsMods and (L(\"statsModifierHead\") .. \" - \") or \"\")\n                        .. L(\"attributesGrowthHead\") .. \" - \"\n                        .. L(\"attributesStartHead\") .. \" - \"\n                        .. L(\"statsBaseHead\")),\n        vGap10\n    })\n\n    for _, attributeId in ipairs(orderedAttributeIds) do\n        table.insert(leftBlock, row(\n                C.getStatName(\"attributes\", attributeId),\n                textCells(\n                        textCell(\n                                menuCellWidth,\n                                baseAttrMods[attributeId] ~= 0 and (tostring(baseAttrMods[attributeId])) or \"\",\n                                nil,\n                                tooltipEvent(L(\"modifierAttributeValue\"))),\n                        textCell(\n                                menuCellWidth,\n                                tostring(H.round(\n                                        Player.stats.attributes[attributeId](self).base - baseAttrMods[attributeId] - C.startAttributes()[attributeId],\n                                        1)),\n                                nil,\n                                tooltipEvent(L(\"growthAttributeValue\"))),\n                        textCell(\n                                menuCellWidth,\n                                tostring(H.round(C.startAttributes()[attributeId], 1)),\n                                nil,\n                                tooltipEvent(L(\"startAttributeValue\"))\n                        ),\n                        textCell(\n                                menuCellWidth,\n                                tostring(Player.stats.attributes[attributeId](self).base),\n                                nil,\n                                tooltipEvent(L(\"currentAttributeValue\")))\n                )\n        ))\n    end\n    table.insert(leftBlock, vGap10)\n\n    local hasDecay = decayRate ~= \"none\"\n    -- percentage won't update until decay mem is updated and decay memory doesn't adjust after you change the decay rate\n    local skillsMaxValue = S.skillsStorage:get(\"uncapperMaxValue\")\n    local perSkillMaxValues = S.getPerSkillMaxValues()\n\n    H.insertMultipleInArray(leftBlock, {\n        headRow(L(\"skillsHead\"),\n                L(\"skillsProgressHead\")\n                        .. (hasDecay and \" - \" .. L(\"skillsDecayHead\") or \"\")\n                        .. (hasSkillBaseStatsMods and (\" - \" .. L(\"statsModifierHead\")) or \"\")\n                        .. \" - \" .. L(\"statsBaseHead\")),\n        vGap10,\n    })\n\n    local skillRows = getSkillsRows(function(skillId)\n        local base = Player.stats.skills[skillId](self).base\n        local decayPercent = C.decaySkills()[skillId] / cfg.decayTimeBaseInHours\n        return row(\n                C.getStatName(\"skills\", skillId),\n                textCells(\n                        textCell(\n                                menuPercentCellWidth,\n                                (base < (perSkillMaxValues[skillId] or skillsMaxValue)) and formatPercent(C.skillProgress()[skillId]) or \"--%\",\n                                nil,\n                                tooltipEvent(L(\"progressSkillValue\"))\n                        ),\n                        textCell(\n                                hasDecay and menuPercentCellWidth or 0,\n                                hasDecay and formatPercent(decayPercent) or \"\",\n                                { textColor = H.mixColors(textDecayColor, textNormalColor, decayPercent) },\n                                tooltipEvent(L(\"decaySkillValue\"))\n                        ),\n                        textCell(\n                                hasSkillBaseStatsMods and menuCellWidth or 0,\n                                baseStatsMods.skills[skillId] and tostring(baseStatsMods.skills[skillId]) or \"\",\n                                tooltipEvent(L(\"modifierSkillValue\"))\n                        ),\n                        textCell(\n                                menuCellWidth,\n                                tostring(base),\n                                C.baseSkills()[skillId] < C.maxSkills()[skillId] and { textColor = textDecayColor } or nil,\n                                tooltipEvent(L(\"currentSkillValue\"))\n                        )\n                )\n        )\n    end)\n\n    H.insertMultipleInArray(leftBlock, skillRows.combatBlock)\n\n    H.insertMultipleInArray(rightBlock, skillRows.magicBlock)\n    table.insert(rightBlock, vGap10)\n    H.insertMultipleInArray(rightBlock, skillRows.thiefBlock)\n\n    local menuContent = {\n        {\n            type = ui.TYPE.Flex,\n            props = { horizontal = true },\n            content = ui.content {\n                {\n                    type = ui.TYPE.Flex,\n                    props = { size = menuHeadHBlockSize },\n                    content = ui.content(leftHeadBlock)\n                },\n                {\n                    type = ui.TYPE.Flex,\n                    props = { size = menuHGapSize },\n                },\n                {\n                    type = ui.TYPE.Flex,\n                    props = { size = menuHeadHBlockSize },\n                    content = ui.content(centerHeadBlock)\n                },\n                {\n                    type = ui.TYPE.Flex,\n                    props = { size = menuHGapSize },\n                },\n                {\n                    type = ui.TYPE.Flex,\n                    props = { size = menuHeadHBlockSize, arrange = ui.ALIGNMENT.End },\n                    content = ui.content(rightHeadBlock)\n                },\n            }\n        },\n        vGap10,\n        stretchingLine,\n        vGap10,\n        {\n            type = ui.TYPE.Flex,\n            props = { horizontal = true },\n            content = ui.content {\n                {\n                    type = ui.TYPE.Flex,\n                    props = { size = menuHBlockSize },\n                    content = ui.content(leftBlock)\n                },\n                {\n                    type = ui.TYPE.Flex,\n                    props = { size = menuHGapSize },\n                },\n                {\n                    type = ui.TYPE.Flex,\n                    props = { size = menuHBlockSize },\n                    content = ui.content(rightBlock)\n                },\n            }\n        }\n    }\n\n    if S.globalStorage:get(\"showMessagesLog\") then\n        local messagesBlock = {\n            headRow(L(\"messagesLogTitleHead\"), L(\"messagesLogTimestampHead\")),\n            vGap10\n        }\n        for _, log in ipairs(C.messagesLog()) do\n            table.insert(messagesBlock, row(log.message, log.time))\n        end\n        H.insertMultipleInArray(menuContent, {\n            vGap10,\n            stretchingLine,\n            vGap10,\n            {\n                type = ui.TYPE.Flex,\n                external = { stretch = 1 },\n                content = ui.content(messagesBlock)\n            }\n        })\n    end\n\n    return menu({\n        type = ui.TYPE.Flex,\n        content = ui.content(menuContent),\n        events = { mouseMove = async:callback(closeTooltip) },\n    })\nend\n\nlocal function missingPluginWarning(message, plugins)\n    local lines = {\n        head(L(\"pluginError0\")),\n        vGap20,\n        text(L(\"pluginError1\")),\n        vGap20,\n        text(message),\n        vGap20\n    }\n    for _, plugin in ipairs(plugins) do\n        table.insert(lines, text(plugin))\n    end\n    H.insertMultipleInArray(lines, {\n        vGap20,\n        text(L(\"pluginError2\")),\n        text(L(\"pluginError3\")),\n        vGap20,\n        text(L(\"pluginError4\")),\n    })\n    return menu({\n        type = ui.TYPE.Flex,\n        content = ui.content(lines)\n    })\nend\n\nlocal function onKeyPress(key)\n    -- Chargen isn't done enough\n    if not C.hasStats() then return end\n\n    -- Prevent the stats menu from rendering over the escape menu\n    if key.code == input.KEY.Escape then\n        closeMenu()\n        return\n    end\n\n    if key.code == S.globalStorage:get(\"statsMenuKey\") then\n        -- Update player stats and then show menu\n        self:sendEvent(\"showStatsMenu\", { create = true })\n    end\nend\n\nlocal function showStatsMenu(data)\n    local statsMenu = getStatsMenu()\n\n    if ncgdStatsMenu == nil then\n        if not data.create then return end\n        ncgdStatsMenu = ui.create(statsMenu)\n    else\n        if data.create then return end\n        ncgdStatsMenu.layout = statsMenu\n        ncgdStatsMenu:update()\n    end\n    async:newUnsavableSimulationTimer(\n            1,\n            function()\n                if ncgdStatsMenu ~= nil then\n                    self:sendEvent(\"showStatsMenu\", { create = false })\n                end\n            end)\nend\n\nlocal function onKeyRelease(key)\n    if key.code == S.globalStorage:get(\"statsMenuKey\") then\n        closeMenu()\n    end\nend\n\nreturn {\n    missingPluginWarning = missingPluginWarning,\n    onKeyPress = onKeyPress,\n    onKeyRelease = onKeyRelease,\n    showStatsMenu = showStatsMenu,\n}\n",
    "NCGDMW Lua Edition-53136-3-5-1725880983\\02 OpenMW DevBuild\\scripts\\NCGDMW\\menu.lua": "require('scripts.NCGDMW.renderers')"
  }
}