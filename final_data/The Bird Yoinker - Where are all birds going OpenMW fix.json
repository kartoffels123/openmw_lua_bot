{
  "folder_name": "The Bird Yoinker - Where are all birds going OpenMW fix",
  "lua_files": {
    "BirdsYoink-54983-0-0-1-1721078339\\scripts\\MaxYari\\BirdsYoink\\BirdsYoink.lua": "local gutils = require(\"scripts/MaxYari/BirdsYoink/gutils\")\n\nlocal core = require(\"openmw.core\")\nlocal omwself = require(\"openmw.self\")\nlocal nearby = require(\"openmw.nearby\")\nlocal util = require(\"openmw.util\")\n\n\nlocal function isABird(actor)\n    return string.find(actor.recordId, \"ab01bird\")\nend\n\nif not isABird(omwself) then return end\n\n\n--print(\"Bird yoinker found a bird! \", omwself.recordId)\n\nlocal beenYoinkedAtStart = false\nlocal desiredElevation = 3000\nlocal dangerZone = math.random(300, 600)\n\nlocal function onUpdate(dt)\n    local now = core.getRealTime()\n    local raycast = nearby.castRay(omwself.position,\n        omwself.position - util.vector3(0, 0, desiredElevation), { ignore = omwself })\n\n    if raycast.hitPos and (not raycast.hitObject or not isABird(raycast.hitObject)) then\n        local elevation = (omwself.position - raycast.hitPos).z\n        local elevationGain = desiredElevation - elevation\n\n        if elevation < desiredElevation and not beenYoinkedAtStart then\n            --print(\"START: Birb\" .. omwself.recordId .. \" was too low, yoinking to \", desiredElevation)\n            core.sendGlobalEvent(\"instaYoink\", { actorObject = omwself, elevationGain = elevationGain })\n        elseif elevation < dangerZone then\n            --print(\"DANGER ZONE: Birb\" .. omwself.recordId .. \" was too low, yoinking to \", desiredElevation)\n            core.sendGlobalEvent(\"slowYoink\", { actorObject = omwself, elevationGain = elevationGain })\n        end\n    end\n\n    beenYoinkedAtStart = true\nend\n\nreturn {\n    engineHandlers = {\n        onUpdate = onUpdate,\n    }\n}\n",
    "BirdsYoink-54983-0-0-1-1721078339\\scripts\\MaxYari\\BirdsYoink\\BirdsYoinkGlobal.lua": "local gutils = require(\"scripts/MaxYari/BirdsYoink/gutils\")\n\n\nlocal core = require(\"openmw.core\")\nlocal util = require(\"openmw.util\")\nlocal world = require('openmw.world')\n\nlocal function isABird(actor)\n    return string.find(actor.recordId, \"ab01bird\")\nend\n\nprint(\"°°°Bird yoinker is ready to yoink some birds!°°°\")\n\nlocal slowYoinkers = {}\n\nlocal function isValid(birb)\n    return birb and birb:isValid() and birb.count > 0\nend\n\nlocal function onUpdate(dt)\n    for birb, data in pairs(slowYoinkers) do\n        if not isValid(birb) or math.abs(birb.position.z - data.elevation) <= 100 then\n            slowYoinkers[birb] = nil\n            goto continue\n        end\n\n        local newZ = gutils.lerp(birb.position.z, data.elevation, dt / 5)\n        local newPos = util.vector3(birb.position.x, birb.position.y, newZ)\n        birb:teleport(birb.cell, newPos)\n\n        ::continue::\n    end\nend\n\nreturn {\n    engineHandlers = {\n        onUpdate = onUpdate,\n    },\n    eventHandlers = {\n        instaYoink = function(data)\n            -- print(\"Yoinking the\" .. data.actorObject.recordId .. \" bird\")\n            data.actorObject:teleport(data.actorObject.cell,\n                data.actorObject.position + util.vector3(0, 0, data.elevationGain))\n        end,\n        slowYoink = function(data)\n            if slowYoinkers[data.actorObject] then return end\n\n            slowYoinkers[data.actorObject] = {\n                elevation = data.actorObject.position.z + data.elevationGain\n            }\n        end\n    },\n}\n",
    "BirdsYoink-54983-0-0-1-1721078339\\scripts\\MaxYari\\BirdsYoink\\gutils.lua": "local core = require('openmw.core')\nlocal types = require('openmw.types')\nlocal util = require('openmw.util')\nlocal status, omwself = pcall(require, \"openmw.self\")\nlocal status, nearby = pcall(require, \"openmw.nearby\")\n\nlocal fFightDispMult = core.getGMST(\"fFightDispMult\")\n\n-- Generic utility functions --\nDebugLevel = 0\n\nlocal module = {}\n\n-- Helper print function\n-- Author: mostly ChatGPT\nlocal function uprint(...)\n    local args = { ... }\n    local lvl = args[#args]\n    if type(lvl) ~= \"number\" then\n        lvl = 1\n    else\n        table.remove(args)\n    end\n    if lvl <= DebugLevel then\n        for i, v in ipairs(args) do\n            args[i] = tostring(v)\n        end\n        local messageHeader = \"[Mercy]\"\n        if omwself then messageHeader = messageHeader .. \"[\" .. omwself.recordId .. \"]\" end\n        print(messageHeader .. \":\", table.concat(args, \" \"))\n    end\nend\nmodule.print = uprint\n\nlocal function foundInList(list, item)\n    -- Author: ChatGPT 2024\n    for _, value in ipairs(list) do\n        if value == item then\n            return true\n        end\n    end\n    return false\nend\nmodule.foundInList = foundInList\n\nlocal function stringToHash(str)\n    -- Author: ChatGPT 2024\n    local hash = 5381\n\n    for i = 1, #str do\n        local char = str:byte(i)\n        hash = ((hash * 33) + char) % 2 ^ 32 -- Multiply by 33 and add ASCII value\n    end\n\n    return hash\nend\nmodule.stringToHash = stringToHash\n\nlocal function tableToString(tbl, indent)\n    indent = indent or \"  \"\n    local result = { \"\\n===> \" .. tostring(tbl) .. \" <===\" }\n\n    for key, value in pairs(tbl) do\n        local keyStr = tostring(key)\n        local valueStr = tostring(value)\n        table.insert(result, indent .. keyStr .. \": \" .. valueStr)\n    end\n\n    return table.concat(result, \"\\n\")\nend\nmodule.tableToString = tableToString\n\nlocal function dialogRecordInfoToString(info)\n    return \"==== Dialog record info ===\\n\" ..\n        \"filterActorClass: \" .. tostring(info.filterActorClass) .. \"\\n\" ..\n        \"filterActorDisposition: \" .. tostring(info.filterActorDisposition) .. \"\\n\" ..\n        \"filterActorFaction: \" .. tostring(info.filterActorFaction) .. \"\\n\" ..\n        \"filterActorFactionRank: \" .. tostring(info.filterActorFactionRank) .. \"\\n\" ..\n        \"filterActorGender: \" .. tostring(info.filterActorGender) .. \"\\n\" ..\n        \"filterActorId: \" .. tostring(info.filterActorId) .. \"\\n\" ..\n        \"filterActorRace: \" .. tostring(info.filterActorRace) .. \"\\n\" ..\n        \"filterPlayerCell: \" .. tostring(info.filterPlayerCell) .. \"\\n\" ..\n        \"filterPlayerFaction: \" .. tostring(info.filterPlayerFaction) .. \"\\n\" ..\n        \"filterPlayerFactionRank: \" .. tostring(info.filterPlayerFactionRank) .. \"\\n\" ..\n        \"id: \" .. tostring(info.id) .. \"\\n\" ..\n        \"isQuestFinished: \" .. tostring(info.isQuestFinished) .. \"\\n\" ..\n        \"isQuestName: \" .. tostring(info.isQuestName) .. \"\\n\" ..\n        \"isQuestRestart: \" .. tostring(info.isQuestRestart) .. \"\\n\" ..\n        \"questStage: \" .. tostring(info.questStage) .. \"\\n\" ..\n        \"resultScript: \" .. tostring(info.resultScript) .. \"\\n\" ..\n        \"sound: \" .. tostring(info.sound) .. \"\\n\" ..\n        \"text: \" .. tostring(info.text)\nend\nmodule.dialogRecordInfoToString = dialogRecordInfoToString\n\n-- A sampler that retains samples within specified time window and calculates their mean value\n-- Author: mostly ChatGPT\nlocal MeanSampler = {}\nfunction MeanSampler:new(time_window)\n    -- Create a new object with initial properties\n    local obj = {\n        time_window = time_window,\n        values = {},\n        mean = 0,\n        warmedUp = false\n    }\n\n    -- Define the sample function for the sampler instance\n    function obj:sample(value)\n        -- Get the current time\n        local current_time = core.getRealTime()\n\n\n        -- Add the new value and its timestamp to the values array\n        table.insert(self.values, { time = current_time, value = value })\n\n        -- Remove values that are older than the specified time window\n        local i = 1\n        while i <= #self.values do\n            if current_time - self.values[i].time > self.time_window then\n                table.remove(self.values, i)\n            else\n                i = i + 1\n            end\n        end\n\n        self.warmedUp = self.values[#self.values].time - self.values[1].time > self.time_window * 0.75\n\n        -- Calculate the mean of the remaining values\n        local sum = nil\n        for _, v in ipairs(self.values) do\n            if sum then\n                sum = sum + v.value\n            else\n                sum = v.value\n            end\n        end\n        if #self.values > 0 then\n            self.mean = sum / #self.values\n        else\n            self.mean = 0\n        end\n    end\n\n    -- Set the metatable for the new object to use the class methods\n    setmetatable(obj, self)\n    self.__index = self\n\n    return obj\nend\n\nmodule.MeanSampler = MeanSampler\n\nlocal function shallowTableCopy(orig)\n    local orig_type = type(orig)\n    local copy\n    if orig_type == 'table' then\n        copy = {}\n        for orig_key, orig_value in pairs(orig) do\n            copy[orig_key] = orig_value\n        end\n    else -- number, string, boolean, etc\n        copy = orig\n    end\n    return copy\nend\nmodule.shallowTableCopy = shallowTableCopy\n\nlocal PosToVelSampler = {\n    new = function(self, time_window)\n        self.positionSampler = MeanSampler:new(time_window)\n        self.velocitySampler = MeanSampler:new(time_window)\n        self.time_window = time_window\n        return self\n    end,\n    sample = function(self, pos)\n        self.positionSampler:sample(pos)\n        if #self.positionSampler.values - 1 > 0 then\n            local lastPosSample = self.positionSampler.values[#self.positionSampler.values]\n            local preLastPosSample = self.positionSampler.values[#self.positionSampler.values - 1]\n            local velocity = (lastPosSample.value - preLastPosSample.value) /\n                (lastPosSample.time - preLastPosSample.time)\n            self.velocitySampler:sample(velocity)\n        end\n        self.warmedUp = self.velocitySampler.warmedUp\n    end,\n    mean = function(self)\n        return self.velocitySampler.mean\n    end\n}\nmodule.PosToVelSampler = PosToVelSampler\n\n-- Function that mimics a ternary operator\n-- Author: ChatGPT 2024\nlocal function ternary(condition, if_true, if_false)\n    if condition then\n        return if_true\n    else\n        return if_false\n    end\nend\nmodule.ternary = ternary\n\nlocal function findField(dictionary, value)\n    for field, val in pairs(dictionary) do\n        if val == value then\n            return field\n        end\n    end\n    return nil\nend\nmodule.findField = findField\n\nlocal function cache(fn, delay)\n    delay = delay or 0.25 -- default delay is 0.25 seconds\n    local lastExecution = 0\n    local c1, c2 = nil, nil\n\n    return function(...)\n        local currentTime = core.getRealTime()\n        if currentTime - lastExecution < delay then\n            return c1, c2, \"cached\"\n        end\n\n        lastExecution = currentTime\n        c1, c2 = fn(...)\n        return c1, c2, \"new\"\n    end\nend\nmodule.cache = cache\n\n\nlocal function randomDirection()\n    -- Author: ChatGPT 2024\n    local angle = math.random() * 2 * math.pi\n    return util.vector3(math.cos(angle), math.sin(angle), 0)\nend\nmodule.randomDirection = randomDirection\n\nlocal function minHorizontalHalfSize(bounds)\n    return math.abs(math.min(bounds.halfExtents.x, bounds.halfExtents.y))\nend\nmodule.minHorizontalHalfSize = minHorizontalHalfSize\n\nlocal function diagonalFlatHalfSize(bounds)\n    return util.vector2(bounds.halfExtents.x, bounds.halfExtents.y):length()\nend\nmodule.diagonalFlatHalfSize = diagonalFlatHalfSize\n\nlocal function getActorLookRayPos(actor)\n    local bounds = types.Actor.getPathfindingAgentBounds(actor)\n    return actor.position + util.vector3(0, 0, bounds.halfExtents.z * 0.75)\nend\nmodule.getActorLookRayPos = getActorLookRayPos\n\nlocal function getDistanceToBounds(actor, target)\n    local dist = (target.position - actor.position):length() -\n        types.Actor.getPathfindingAgentBounds(target).halfExtents.y -\n        types.Actor.getPathfindingAgentBounds(actor).halfExtents.y;\n    return dist;\nend\nmodule.getDistanceToBounds = getDistanceToBounds\n\nlocal function lerp(a, b, t)\n    return a + (b - a) * t\nend\nmodule.lerp = lerp\n\nlocal function lerpClamped(a, b, t)\n    t = math.max(0, math.min(t, 1))\n    return lerp(a, b, t)\nend\nmodule.lerpClamped = lerpClamped\n\n\n\nlocal Actor = {}\nActor.__index = Actor\n\nfunction Actor:new(go, omwClass)\n    if not omwClass then omwClass = types.Actor end\n    local instance = {\n        gameObject = go,\n        omwClass = omwClass\n    }\n    setmetatable(instance, self)\n    return instance\nend\n\nfunction Actor:__index(key)\n    local value = rawget(Actor, key)\n    if value ~= nil then\n        return value\n    end\n\n    value = self.omwClass[key]\n    if type(value) == \"function\" then\n        return function(_, ...)\n            return value(self.gameObject, ...)\n        end\n    elseif type(value) == \"table\" or type(value) == \"userdata\" then\n        return Actor:new(self.gameObject, value)\n    else\n        return value\n    end\nend\n\nfunction Actor:getDumpableInventoryItems()\n    -- data.actor, data.position\n    local items = {}\n    local inventory = self:inventory()\n    --print(\"Inventory resolved:\", inventory:isResolved())\n    local invItems = inventory:getAll()\n\n    for i, item in pairs(invItems) do\n        if (types.Armor.objectIsInstance(item) or types.Clothing.objectIsInstance(item)) and self:hasEquipped(item) then goto continue end\n        table.insert(items, item)\n        ::continue::\n    end\n\n    return items\nend\n\nfunction Actor:isRanged()\n    -- Check if enemy actor is ranged\n    local weaponObj = self:getEquipment(types.Actor.EQUIPMENT_SLOT.CarriedRight)\n    local weaponRecord\n    if weaponObj then\n        weaponRecord = types.Weapon.record(weaponObj.recordId)\n    end\n    local stance = self:getStance()\n\n    if weaponRecord and (weaponRecord.type == types.Weapon.TYPE.MarksmanBow or\n            weaponRecord.type == types.Weapon.TYPE.MarksmanCrossbow or\n            weaponRecord.type == types.Weapon.TYPE.MarksmanThrown) then\n        return true\n    elseif stance == types.Actor.STANCE.Spell then\n        return true\n    end\n\n    return false\nend\n\nfunction Actor:isMelee()\n    return not self:isRanged()\nend\n\nfunction Actor:isVampire()\n    -- Based on Urm's function\n    local vampirism = self:activeEffects():getEffect('vampirism')\n    local isVampire = not vampirism or vampirism.magnitude > 0\n    return isVampire\nend\n\nfunction Actor:canOpenDoor(door)\n    local canOpen = true\n    if types.Lockable.isLocked(door) then\n        canOpen = false\n        local keyRecord = types.Lockable.getKeyRecord(door)\n        local inventory = self:inventory()\n        if keyRecord and inventory:find(keyRecord.id) then\n            -- The door is locked, but actor has a key!\n            canOpen = true\n        end\n    end\n    return canOpen\nend\n\nmodule.Actor = Actor\n\n\n\n\n\nlocal function forEachNearbyActor(distLimit, cb)\n    for _, actor in ipairs(nearby.actors) do\n        local dist = (omwself.position - actor.position):length()\n        if dist < distLimit then\n            cb(actor)\n        end\n    end\nend\nmodule.forEachNearbyActor = forEachNearbyActor\n\nlocal function getSortedAttackTypes(weaponRecord)\n    if weaponRecord then\n        local attacks = {\n            { type = \"Chop\",   averageDamage = (weaponRecord.chopMinDamage + weaponRecord.chopMaxDamage) / 2 },\n            { type = \"Slash\",  averageDamage = (weaponRecord.slashMinDamage + weaponRecord.slashMaxDamage) / 2 },\n            { type = \"Thrust\", averageDamage = (weaponRecord.thrustMinDamage + weaponRecord.thrustMaxDamage) / 2 }\n        }\n\n        table.sort(attacks, function(a, b) return a.averageDamage > b.averageDamage end)\n\n        return attacks\n    else\n        -- Assume this is hand-to-hand\n        local attacks = {\n            { type = \"Chop\",   averageDamage = 1 },\n            { type = \"Slash\",  averageDamage = 1 },\n            { type = \"Thrust\", averageDamage = 1 }\n        }\n        return attacks\n    end\nend\n\nmodule.getSortedAttackTypes = getSortedAttackTypes\n\nlocal function getGoodAttacks(attacks)\n    local bestAttack = attacks[1]\n    local goodAttacks = { bestAttack } -- Start with the best attack\n\n    local threshold = 0.33             -- Threshold for damage difference\n\n    for i = 2, #attacks do\n        local currentAttack = attacks[i]\n        local percentageDifference = math.abs(currentAttack.averageDamage - bestAttack.averageDamage) /\n            bestAttack.averageDamage\n\n        if percentageDifference <= threshold then\n            table.insert(goodAttacks, currentAttack)\n        else\n            break -- No need to check further since attacks are sorted by averageDamage\n        end\n    end\n\n    return goodAttacks\nend\n\nmodule.getGoodAttacks = getGoodAttacks\n\nlocal function pickWeightedRandomAttackType(attacks)\n    -- Author: ChatGPT 2024\n    local totalAverageDamage = 0\n    for _, attack in ipairs(attacks) do\n        totalAverageDamage = totalAverageDamage + attack.averageDamage\n    end\n\n    local rand = math.random() * totalAverageDamage\n    local cumulativeProbability = 0\n\n    for _, attack in ipairs(attacks) do\n        cumulativeProbability = cumulativeProbability + attack.averageDamage\n        if rand <= cumulativeProbability then\n            return attack\n        end\n    end\n\n    return attacks[1]\nend\nmodule.pickWeightedRandomAttackType = pickWeightedRandomAttackType\n\n\n\nlocal function getFightDispositionBias(omwself, enemyActor)\n    local disposition = 50\n    if types.NPC.objectIsInstance(omwself) and types.Player.objectIsInstance(enemyActor) then\n        disposition = types.NPC.getDisposition(omwself, enemyActor)\n    end\n    return ((50 - disposition) * fFightDispMult);\nend\nmodule.getFightDispositionBias = getFightDispositionBias\n\n\nlocal function imAGuard()\n    local record = types.NPC.record(omwself)\n    return record and record.class == \"guard\"\nend\nmodule.imAGuard = imAGuard\n\nlocal castingSkills = { \"conjuration\", \"alteration\", \"destruction\", \"mysticism\", \"restoration\" }\nlocal function imASpellCaster()\n    if not types.NPC.objectIsInstance(omwself) then return false end\n    local className = types.NPC.record(omwself.recordId).class\n    local majorSkills = types.NPC.classes.record(className).majorSkills\n    for _, skillName in ipairs(majorSkills) do\n        if foundInList(castingSkills, skillName) then return true end\n    end\n    return false\nend\nmodule.imASpellCaster = imASpellCaster\n\nlocal targetsHistory = {}\nlocal function addTargetsToHistory(targets)\n    -- Author: mostly ChatGPT 2024\n    local timeLimit = 5\n    local now = core.getRealTime()\n    for _, target in ipairs(targets) do\n        targetsHistory[target] = now\n    end\n    for target, timestamp in pairs(targetsHistory) do\n        if now - timestamp > timeLimit then\n            targetsHistory[target] = nil\n        end\n    end\nend\nmodule.addTargetsToHistory = addTargetsToHistory\n\nlocal function wasMyTarget(actor)\n    return targetsHistory[actor]\nend\nmodule.wasMyTarget = wasMyTarget\n\nlocal function isMyFriend(actor)\n    local sameType = true\n    if types.NPC.objectIsInstance(omwself) and not types.NPC.objectIsInstance(actor) then\n        sameType = false\n    end\n    local fightVal = types.Actor.stats.ai.fight(actor)\n    return actor.id ~= omwself.id and not types.Player.objectIsInstance(actor) and sameType and\n        not wasMyTarget(actor) and fightVal.modified >= BaseFriendFightVal\nend\nmodule.isMyFriend = isMyFriend\n\nlocal function stringStartsWith(String, Start)\n    -- Source: https://stackoverflow.com/questions/22831701/lua-read-beginning-of-a-string\n    -- Author: https://stackoverflow.com/users/542190/filmor\n    return string.sub(String, 1, string.len(Start)) == Start\nend\n\nmodule.stringStartsWith = stringStartsWith\n\nreturn module\n"
  }
}