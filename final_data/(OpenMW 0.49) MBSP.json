{
  "folder_name": "(OpenMW 0.49) MBSP",
  "lua_files": {
    "MBSP-54953-1-0-1720627029\\MBSP\\Scripts\\MBSP_p.lua": "local core = require('openmw.core')\nlocal self = require('openmw.self')\nlocal storage = require('openmw.storage')\nlocal types = require('openmw.types')\nlocal I = require(\"openmw.interfaces\")\nlocal input = require('openmw.input')\nlocal async = require('openmw.async')\nlocal animation = require('openmw.animation')\nlocal MOD_NAME = \"MBSP_STANDALONE\"\nlocal UI = require('openmw.interfaces').UI\nlocal Player = require('openmw.types').Player\nlocal Actor = require('openmw.types').Actor\nlocal ui = require('openmw.ui')\n--local L = core.l10n(MOD_NAME)\nlocal playerSection = storage.playerSection(\"SettingsPlayer\" .. MOD_NAME)\nlocal dynamic = types.Actor.stats.dynamic\nlocal debug = require('openmw.debug')\nlocal useFlipFlop = false\nlocal useRapidfire = false\nlocal casting = false\nlocal castedSpell = nil\nlocal backtrackFrame = 19999999999\nlocal castingSounds = {\n[\"restoration cast\"] = true,\n[\"alteration cast\"] = true,\n[\"destruction cast\"] = true,\n[\"mysticism cast\"] = true,\n[\"illusion cast\"] = true,\n[\"conjuration cast\"] = true,\n}\nlocal addSkillNextFrame = {}\n\nlocal catchupSpeed = 1 -- 1=default = no catchup boost. only gradually activates if the skill is below character level * 2\nlocal skillMultipliers= { -- suggested multipliers (frequently used skills = 0.9, rare skills up to 1.5)\n[\"acrobatics\"  ] = 1, --0.8\n[\"alchemy\"     ] = 1, --1\n[\"alteration\"  ] = 1, --1.4\n[\"armorer\"     ] = 1, --1\n[\"athletics\"   ] = 1, --0.9\n[\"axe\"         ] = 1, --0.9\n[\"block\"       ] = 1, --1\n[\"bluntweapon\" ] = 1, --0.9\n[\"conjuration\" ] = 1, --1.5\n[\"destruction\" ] = 1, --0.9 --\n[\"enchant\"     ] = 1, --1.1\n[\"handtohand\"  ] = 1, --0.9\n[\"heavyarmor\"  ] = 1, --1.2\n[\"illusion\"    ] = 1, --1.5\n[\"lightarmor\"  ] = 1, --1.1\n[\"longblade\"   ] = 1, --0.9\n[\"marksman\"    ] = 1, --0.9\n[\"mediumarmor\" ] = 1, --1.1\n[\"mercantile\"  ] = 1, --1\n[\"mysticism\"   ] = 1, --1.5\n[\"restoration\" ] = 1, --1\n[\"security\"    ] = 1, --1.1\n[\"shortblade\"  ] = 1, --0.9\n[\"sneak\"       ] = 1, --1.6\n[\"spear\"       ] = 1, --0.9\n[\"speechcraft\" ] = 1, --1.1\n[\"unarmored\"   ] = 1, --1.3\n}\n\nlocal function dbg(...)\n\tif playerSection:get(\"PrintDebug\") then\n\t\tprint(...)\n\tend\nend\n\n\n\n\nlocal casting = false\nlocal frame = 0\nlocal startedCasting = 0\nlocal stoppedCasting = 0\n\nlocal spellDB = {}\nlocal function checkSpell(spell)\n\tlocal spellId = spell.id\n\tif not spellDB[spellId] then\n\t\tspellDB[spellId] = {}\n\t\tlocal s = spellDB[spellId]\n\t\ts.schools = {}\n\t\ts.calculatedCost = 0\n\t\ts.autoCalculated = spell.autocalcFlag\n\t\ts.isSpell = spell.type == core.magic.SPELL_TYPE.Spell\n\t\tlocal playerSpell = spellId:sub(1,9) == \"Generated\"\n\t\tfor _,effect in pairs(spell.effects) do\n\t\t\tlocal school = effect.effect.school\n\t\t\tlocal hasMagnitude = effect.effect.hasMagnitude\n\t\t\tlocal hasDuration = effect.effect.hasDuration\n\t\t\tlocal appliedOnce = effect.effect.isAppliedOnce\n\t\t\tlocal minMagn = hasMagnitude and effect.magnitudeMin or 1;\n\t\t\tlocal maxMagn = hasMagnitude and effect.magnitudeMax or 1;\n\t\t\t--if (method == EffectCostMethod::PlayerSpell || method == EffectCostMethod::GameSpell)\n\t\t\t\tminMagn = math.max(1, minMagn);\n\t\t\t\tmaxMagn = math.max(1, maxMagn);\n\t\t\t-- }\n\t\t\tlocal duration = hasDuration and effect.duration or 1;\n\t\t\tif (not appliedOnce) then\n\t\t\t\tduration = math.max(1, duration);\n\t\t\tend\n\t\t\tlocal fEffectCostMult =  core.getGMST(\"fEffectCostMult\")\n\t\t\t--local iAlchemyMod = core.getGMST(\"iAlchemyMod\") \n\t\n\t\t\tlocal durationOffset = 0;\n\t\t\tlocal minArea = 0;\n\t\t\tlocal costMult = fEffectCostMult;\n\t\t\tif playerSpell then\n\t\t\t\tdurationOffset = 1;\n\t\t\t\tminArea = 1;\n\t\t\tend -- elseif GamePotion\n\t\t\t--    minArea = 1;\n\t\t\t--    costMult = iAlchemyMod;\n\t\t\t-- end\n\t\n\t\t\tlocal x = 0.5 * (minMagn + maxMagn);\n\t\t\tx = x * (0.1 * effect.effect.baseCost);\n\t\t\tx = x * (durationOffset + duration);\n\t\t\tx = x + (0.05 * math.max(minArea, effect.area) * effect.effect.baseCost);\n\t\n\t\t\tx = x * costMult;\n\t\t\tif effect.range == core.magic.RANGE.Target then--  if (effect.mData.mRange == ESM::RT_Target)\n\t\t\t\tx = x * 1.5\n\t\t\tend\n\t\t\tx= math.max(0,x)\n\t\t\ts.schools[school] = (s.schools[school] or 0) + x\n\t\t\ts.calculatedCost = s.calculatedCost + x\n\t\tend\n\t\tif spell.autocalcFlag then\n\t\t\ts.cost = math.floor(s.calculatedCost+0.5)\n\t\telse\n\t\t\ts.cost = math.floor(spell.cost+0.5)\n\t\tend\n\tend\n\treturn spellDB[spellId]\nend\nI.AnimationController.addTextKeyHandler('', function(groupname, key) --self start/stop, touch start/stop, target start/stop\n\tif groupname == \"spellcast\" then\n\t\tif key == \"self start\" or key == \"touch start\" or key == \"target start\" then\n\t\t\tcastedSpell = Player.getSelectedSpell(self)\n\t\t\tcasting = true\n\t\telseif key == \"self stop\" or key == \"touch stop\" or key == \"target stop\" then\n\t\t\tcastedSpell = nil\n\t\t\tcasting = false\n\t\t\tstoppedCasting = frame\n\t\tend\n\tend\n\t--print(groupname,key)\nend)\n\nlocal function hasSilenceParalysis(actor)\n\tfor a,b in pairs(Actor.activeSpells(actor)) do\n\t\tfor c,d in pairs(b.effects) do\n\t\t\tif d.id == \"silence\" then\n\t\t\t\treturn true\n\t\t\telseif d.id == \"paralyze\" then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend\n\nlocal function isCastingSoundPlaying(actor)\n\tfor a,b in pairs(castingSounds) do\n\t\tif core.sound.isSoundPlaying(a, actor) then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend\nlocal function getAverageSkill(spell)\n\tlocal s = checkSpell(spell)\n\tlocal skill = Player.stats.attributes[\"willpower\"](self).modified/5 + Player.stats.attributes[\"luck\"](self).modified/10\n\tfor school, cost in pairs(s.schools) do\n\t\tskill = skill + Player.stats.skills[school](self).modified*(cost/math.max(1,s.calculatedCost))\n\tend\n\treturn skill\nend\n\ninput.bindAction('Use', async:callback(function(dt, use, sneak, run)\n\tframe = frame + 1\n\t--if not casting and frame > stoppedCasting + 1 then use = true end\n\tuseRapidfire = not useRapidfire\n\tif playerSection:get(\"rapidfire\") and useRapidfire and Actor.getStance(self) == Actor.STANCE.Spell then\n\t\tuse = false\n\tend\n\tif playerSection:get(\"refundMode\") == \"EXPERIMENTAL\" then\n\t\tlocal castingSoundPlaying = isCastingSoundPlaying(self)\n\t\tif negativeRefundFail then\n\t\t\tdynamic.magicka(self).current = dynamic.magicka(self).current - negativeRefundFail\n\t\t\tnegativeRefundFail = nil\n\t\telseif backtrack and castingSoundPlaying then\n\t\t\tbacktrack = nil\n\t\t\tbacktrackFrame = 1999999999\n\t\t\t--dbg(\"success\")\n\t\telseif backtrack and not castingSoundPlaying and backtrackFrame < frame-2 then\n\t\t\tdynamic.magicka(self).current = dynamic.magicka(self).current - backtrack\n\t\t\tdbg(\"backtracking \"..backtrack..\" magicka costs because no sound next frame\")\n\t\t\tbacktrack = nil\n\t\t\tbacktrackFrame = 1999999999\n\t\tend\n\t\tif use\n\t\tand Actor.getStance(self)==Actor.STANCE.Spell\n\t\tand not castingSoundPlaying\n\t\tand not animation.isPlaying(self, \"knockdown\")\n\t\tand not animation.isPlaying(self, \"knockout\") \n\t\tand not animation.isPlaying(self, \"hit1\") \n\t\tand not animation.isPlaying(self, \"hit2\") \n\t\tand not animation.isPlaying(self, \"hit3\") \n\t\tand not animation.isPlaying(self, \"hit4\") \n\t\tand not animation.isPlaying(self, \"hit5\")\n\t\tand not hasSilenceParalysis(self)\n\t\tand not UI.getMode()\n\t\tand not useFlipFlop\n\t\tand not casting\n\t\tand not backtrack\n\t\tand not debug.isGodMode()\n\t\tthen\n\t\t\tlocal spell = Player.getSelectedSpell(self)\n\t\t\tlocal s = checkSpell(spell)\n\t\t\tif s.isSpell then\t\n\t\t\t\tlocal cost = s.cost\n\t\t\t\tlocal skill = getAverageSkill(spell)-playerSection:get(\"refundStart\")\n\t\t\t\tlocal effectiveSpellCost = playerSection:get(\"refundMult\")^(skill/playerSection:get(\"levelScaling\"))\n\t\t\t\tif playerSection:get(\"negativeRefunds\") then\n\t\t\t\t\teffectiveSpellCost = effectiveSpellCost*playerSection:get(\"spellCostMultiplier\")\n\t\t\t\t\teffectiveSpellCost = effectiveSpellCost + playerSection:get(\"spellCostOffset\")\n\t\t\t\t\t--effectiveSpellCost = effectiveSpellCost*(1+(math.random()-0.5)*playerSection:get(\"randomSpellCostVariance\"))\n\t\t\t\tend\n\t\t\t\t--print(effectiveSpellCost)\n\t\t\t\teffectiveSpellCost = effectiveSpellCost * cost\n\t\t\t\tlocal refund = cost-effectiveSpellCost\n\t\t\t\tif refund > 0 or playerSection:get(\"negativeRefunds\") then\n\t\t\t\t\tif playerSection:get(\"negativeRefunds\") and dynamic.magicka(self).current+refund < cost then\n\t\t\t\t\t\tnegativeRefundFail = refund\n\t\t\t\t\t\tdynamic.magicka(self).current = dynamic.magicka(self).current + refund\n\t\t\t\t\t\tdbg(string.format(\"MBSP: Magic Level %i, refund: %.2f / %i\",skill, refund, cost))\n\t\t\t\t\telseif dynamic.magicka(self).current+refund >= cost then\n\t\t\t\t\t\tdynamic.magicka(self).current = dynamic.magicka(self).current + refund\n\t\t\t\t\t\tdbg(string.format(\"MBSP: Magic Level %i, refund: %.2f / %i\",skill, refund, cost))\n\t\t\t\t\t\tbacktrack = refund\n\t\t\t\t\t\tbacktrackFrame = frame\n\t\t\t\t\t\tfor a,b in pairs( Player.getSelectedSpell(self).effects) do\n\t\t\t\t\t\t\t--print(core.magic.effects.records[b.id])\n\t\t\t\t\t\t\t--print(core.magic.effects.records[b.id].castSound)\n\t\t\t\t\t\t\tlocal castSound = core.magic.effects.records[b.id].castSound\n\t\t\t\t\t\t\tif castSound and castSound ~= \"\" then\n\t\t\t\t\t\t\t\tcastingSounds[castSound] = true\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t--castingSounds[core.magic.effects.records[b.id].castSound] = true\n\t\t\t\t\t\tend\t--castingSounds[] = true\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tuseFlipFlop = useFlipFlop or use\n\tif not use then\n\t\tuseFlipFlop = false\n\tend\n\treturn use\nend), {  })\n  \nI.Settings.registerPage {\n\tkey = MOD_NAME,\n\tl10n = MOD_NAME,\n\tname = \"MBSP\",\n\tdescription = \"Your effective skill level for magicka refunding is:\\nSkill Level + Willpower/5 + Luck/10 - RefundStart\\n\\nThe formula for the effective mana costs after refund is Scaling^(Skill/LevelScaling) (for example 0.5^(50/100) = 0.7071)\\n\\nThe experience per successful spell cast is halfed but you get experience equal to 1 spellcast every X magicka spent (->'Magicka XP Rate' setting)\"\n}\n\nI.Settings.registerGroup {\n\tkey = \"SettingsPlayer\" .. MOD_NAME,\n\tl10n = MOD_NAME,\n\tname = \"\",\n\tpage = MOD_NAME,\n\tdescription = \"\",\n\tpermanentStorage = true,\n\tsettings = {\n\t\t{\n\t\t\tkey = \"magickaXPRate\",\n\t\t\tname = \"Magicka XP Rate\",\n\t\t\tdescription = \"spent magicka per experience point\\nIgnores Refunds\\n0 = disabled for compatibility with ncgd or other leveling/uncapper mods\",\n\t\t\tdefault = 15,\n\t\t\targument = {\n\t\t\t\tmin = 0,\n\t\t\t\tmax = 1000,\n\t\t\t},\n\t\t\trenderer = \"number\",\n\t\t},\n\t\t{\n\t\t\tkey = \"enableUncapper\",\n\t\t\tname = \"Enable Uncapper\",\n\t\t\tdescription = \"Allows any skill to reach a higher level than 100.\\nIf you want, there's also multipliers for every skill's xp in the lua file that i don't wanna list here.\",\n\t\t\tdefault = false,\n\t\t\trenderer = 'checkbox',\n\t\t},\n\t\t{\n\t\t\tkey = \"refundMode\",\n\t\t\tname = \"Enable Refund\",\n\t\t\tdescription = \"Refund magicka on successful casts or before spending the magicka (EXPERIMENTAL)\",\n\t\t\tdefault = \"Refund\", \n\t\t\trenderer = \"select\",\n\t\t\targument = {\n\t\t\t\tdisabled = false,\n\t\t\t\tl10n = \"LocalizationContext\", \n\t\t\t\titems = {\"Disabled\", \"Refund\", \"EXPERIMENTAL\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tkey = \"refundStart\",\n\t\t\tname = \"Refund: Skill Start\",\n\t\t\tdescription = \"Before this skill level, you won't get any Magicka Refunds.\\nThis Value is also subtracted from your effective Level for the refund formula\",\n\t\t\tdefault = 35,\n\t\t\trenderer = 'number',\n\t\t\targument = {\n\t\t\t\tinteger = true,\n\t\t\t\tmin = 1,\n\t\t\t\tmax = 1000,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tkey = \"refundMult\",\n\t\t\tname = \"Refund: Magicka Cost Scaling\",\n\t\t\tdescription = \"The effective magicka costs get multiplied by this value every 100 levels (by default, setting below)\",\n\t\t\tdefault = 0.5,\n\t\t\targument = {\n\t\t\t\tmin = 0.01,\n\t\t\t\tmax = 10,\n\t\t\t},\n\t\t\trenderer = \"number\",\n\t\t},\n\t\t{\n\t\t\tkey = \"levelScaling\",\n\t\t\tname = \"Refund: Level Scaling\",\n\t\t\tdescription = \"Every 100 levels (by default, or whatever this setting's value is) your effective spell costs get multiplied by 0.5 (by default, setting above), so your effective spell costs would be 25% at level 200 with default settings for example.\",\n\t\t\tdefault = 100,\n\t\t\trenderer = 'number',\n\t\t\targument = {\n\t\t\t\tinteger = true,\n\t\t\t\tmin = 1,\n\t\t\t\tmax = 10000,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tkey = \"negativeRefunds\",\n\t\t\tname = \"Refunds Can Be Negative\",\n\t\t\tdescription = \"For example when your skill is lower than the 'Refund Skill Start'\\nRequires the 'EXPERIMENTAL' refund mode\",\n\t\t\tdefault = false,\n\t\t\trenderer = \"checkbox\",\n\t\t},\n\t\t{\n\t\t\tkey = \"spellCostMultiplier\",\n\t\t\tname = \"Spell Cost Multiplier\",\n\t\t\tdescription = \"Requires the 'Negative Refunds' setting and the 'EXPERIMENTAL' refund mode!\\nThis is a final multiplier on the spell costs after the refund formula was applied\\nSince the settings can be buggy when entering a dot/period symbol on some keyboard layouts, just copy paste one from somewhere else\",\n\t\t\tdefault = 1,\n\t\t\trenderer = 'number',\n\t\t\targument = {\n\t\t\t\tmin = 0,\n\t\t\t\tmax = 10000,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tkey = \"spellCostOffset\",\n\t\t\tname = \"Spell Cost Offset\",\n\t\t\tdescription = \"Requires the 'Negative Refunds' setting and the 'EXPERIMENTAL' refund mode!\\nThis setting adds or subtracts a portion of the spell's base(vanilla) cost to the final result after the multiplier above has been applied\",\n\t\t\tdefault = 0,\n\t\t\trenderer = 'number',\n\t\t\targument = {\n\t\t\t\tmin = -1,\n\t\t\t\tmax = 1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tkey = \"PrintDebug\",\n\t\t\tname = \"Print Debug Messages\",\n\t\t\tdescription = \"into the console\",\n\t\t\tdefault = false,\n\t\t\trenderer = \"checkbox\",\n\t\t},\n\t\t{\n\t\t\tkey = \"rapidfire\",\n\t\t\tname = \"Experimental: Rapidfire Casting\",\n\t\t\tdescription = \"Allows you to spam spells by holding the button\",\n\t\t\tdefault = false,\n\t\t\trenderer = \"checkbox\",\n\t\t},\n\t}\n}\n\nlocal magickaSkills = {\n    destruction = true,\n    restoration = true,\n    conjuration = true,\n    mysticism = true,\n    illusion = true,\n    alteration = true,\n}\n\n\n\nI.SkillProgression.addSkillUsedHandler(function(skillId, params)\n\tif magickaSkills[skillId] and castedSpell then\n\t\tlocal magickaXPRate = playerSection:get(\"magickaXPRate\")\n\t\tlocal cost = checkSpell(castedSpell).cost\n\t\tif magickaXPRate > 0 then\n\t\t\tlocal newGain = params.skillGain/2 + params.skillGain * cost / magickaXPRate\n\t\t\tdbg(string.format(\"MBSP: %s XP + %.4f (= %.2f /2 + %.2f /%i *%i)\",skillId, newGain, params.skillGain, params.skillGain, magickaXPRate, cost ))\n\t\t\tparams.skillGain = newGain\n\t\tend\n\t\tif playerSection:get(\"refundMode\") == \"Refund\" then\n\t\t\t--local attribute = core.stats.Skill.record(skillId).attribute\n\t\t\tlocal skill = getAverageSkill(castedSpell)-playerSection:get(\"refundStart\") --Player.stats.skills[skillId](self).base + Player.stats.attributes[\"willpower\"](self).base/5 + Player.stats.attributes[\"luck\"](self).base/10 \n\t\t\tlocal refund = (1-(playerSection:get(\"refundMult\")^(skill/playerSection:get(\"levelScaling\"))))*cost\n\t\t\tif refund > 0 then\n\t\t\t\tif not debug.isGodMode() then\n\t\t\t\t\tdbg(string.format(\"MBSP: %s# Level %i, refund: %.2f / %i\", skillId, skill, refund, cost))\n\t\t\t\t\tdynamic.magicka(self).current = dynamic.magicka(self).current + refund\n\t\t\t\telse\n\t\t\t\t\tdbg(string.format(\"MBSP: %s# Level %i, refund: %.2f / %i (skipped because of god mode)\", skillId, skill, refund, cost))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tparams.skillGain = params.skillGain * (skillMultipliers[skillId] or 1)\n\tif catchupSpeed > 1 then\n\t\tlocal speedMult = math.max(1,catchupSpeed*(1-Player.stats.skills[skillId](self).base/(types.Actor.stats.level(self).current*2)) + 1*(Player.stats.skills[skillId](self).base/(types.Actor.stats.level(self).current*2)))\n\t\t--print(speedMult)\n\t\tparams.skillGain = params.skillGain * speedMult\n\tend\n\tif playerSection:get(\"enableUncapper\") then\n\t\tif Player.stats.skills[skillId](self).base >= 100 then\n\t\t--Player.stats.skills[skillId](self).progress = 1\n\t\t\t--print(Player.stats.skills[skillId](self).progress)\n\t\t\tif Player.stats.skills[skillId](self).progress >= 1 then\n\t\t\t\ttable.insert(addSkillNextFrame,{skill = skillId, levels = Player.stats.skills[skillId](self).base-99})\n\t\t\t\tPlayer.stats.skills[skillId](self).base = 99\n\t\t\t\tI.SkillProgression.skillLevelUp(skillId, I.SkillProgression.SKILL_INCREASE_SOURCES.Usage)\n\t\t\tend\n\t\tend\n\tend\nend)\n\nlocal function onUpdate(dt)\n\tfor _, t in pairs(addSkillNextFrame) do\n\t\tPlayer.stats.skills[t.skill](self).base = Player.stats.skills[t.skill](self).base + t.levels\n\t\tui.showMessage(\"\")\n\t\tif types.Actor.stats.level(self).progress < 10 then\n\t\t\tui.showMessage(\"\")\n\t\tend\n\t\t\t\n\t\tui.showMessage(\"MBSP: \"..t.skill..\" -> \"..Player.stats.skills[t.skill](self).base)\n\tend\n\taddSkillNextFrame = {}\nend\n\nreturn {\n\tengineHandlers ={ \n\t\t--onFrame = onFrame,\n\t\tonUpdate = onUpdate,\n\t}\n}\n"
  }
}