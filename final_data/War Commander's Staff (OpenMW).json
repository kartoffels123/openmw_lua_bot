{
  "folder_name": "War Commander's Staff (OpenMW)",
  "lua_files": {
    "War Commander's Staff-54981-1-1-1721075949\\War Commander Staff ENG\\WC_Staff\\scripts\\WC_staff_ACTOR.lua": "--модуль урона актерам, добавляется через глобальный скрипт\n--расчет уровна производится в зависимости от наличия огненного щита, сопротивления огню, уязвимости к огню\n--поглощение и отражение заклинаний в расчет не принимаются (типа, слишком мощная магия)\n\nlocal types = require('openmw.types')\nlocal self = require('openmw.self')\nlocal core = require('openmw.core')\nlocal ai = require('openmw.interfaces').AI\nlocal storage = require('openmw.storage')\n\nlocal doOnce = 0\nlocal AggressivePlayer\n\n\nreturn {\n    engineHandlers = {\n\t\n\tonInit = function(data) AggressivePlayer = data.AggressivePlayer end,\t--получения данных об игроке, запустившем огненный шар, для его дальнейшей атаки\n\t\n\tonUpdate = function(dt)\n\t\t\t\n\t\tif doOnce == 0 then\n\t\tlocal ID = self.recordId --для теста\n    \n\t\tlocal Fire_Shield = types.Actor.activeEffects(self):getEffect(core.magic.EFFECT_TYPE.FireShield).magnitude\n\t\tlocal Resist_Fire = types.Actor.activeEffects(self):getEffect(core.magic.EFFECT_TYPE.ResistFire).magnitude\n\t\tlocal Weakness_Fire = types.Actor.activeEffects(self):getEffect(core.magic.EFFECT_TYPE.WeaknessToFire).magnitude\n\t\t\t\t\n\t\tlocal RW_fire = Fire_Shield + Resist_Fire - Weakness_Fire  -- RW = resist or weakness\n\t\tRW_fire = ( 100 - RW_fire) / 100  --пересчет в обратные проценты\n\t\tlocal settings = storage.globalSection('SettingsWCStaff')\n\t\tlocal BaseDamage = settings:get('BaseDamage') --получения базового урона из настроек\n\t\tlocal TestMessage = settings:get('TestMessage')\n\t\tlocal DestructionLVL = types.NPC.stats.skills.destruction(AggressivePlayer).modified  --получение навыка разрушения игрока с учетом одификатора\n\t\t--print (string.format('player's DestructionLVL, %s', DestructionLVL))\n\t\tDestructionLVL = DestructionLVL / 100\n\t\tlocal damage = BaseDamage * math.max (0, RW_fire)\n\t\tlocal DependDestruction = settings:get('DependDestruction')\n\t\tif DependDestruction then damage = damage * DestructionLVL end\n\t\tlocal health = types.Actor.stats.dynamic.health(self)\n\t\thealth.current = health.current - damage\n\t\tif TestMessage then print(string.format('ID Actor %s, fire resistance %s, damage %s', ID, RW_fire, damage)) end  \n\t\t--атака на игрока\n\t\t\tif not types.Player.objectIsInstance(self) then --проверка, что актер не является игроком\n\t\t\t\tif types.Actor.isDead(self) == false then --проверка, что актер немертв\n\t\t\t\t\tif not ai.getActiveTarget('Combat') then --проверка, что НПС ни с кем не дерется\n\t\t\t\t\t--print (string.format('AggressivePlayer %s', AggressivePlayer)) \n\t\t\t\t\tai.startPackage({type = 'Combat', target = AggressivePlayer})\n\t\t\t\t\tend --конец проверки на драку\n\t\t\t\tend --конец проверки на жизнь\n\t\t\tend\n\t\tdoOnce = 1\n\t\t--урон нанесен, далее надо открепить скрипт, иначе не будет повторного урона\n\t\tcore.sendGlobalEvent('RemoveActorScript', {ActorForRemoveScript = self})\n\t\tend\n\tend, --конец onUpdate\n\t},\n\t\n\teventHandlers = { \n\t\tRemoveActorScript = RemoveActorScript\n\t}\n}",
    "War Commander's Staff-54981-1-1-1721075949\\War Commander Staff ENG\\WC_Staff\\scripts\\WC_staff_EXPL.lua": "local types = require('openmw.types')\nlocal nearby = require('openmw.nearby')\nlocal self = require('openmw.self')\nlocal core = require('openmw.core')\nlocal storage = require('openmw.storage')\n\n--local doOnce = 0\nlocal radius = 50 --начальный радиус сферы поражения (диаметр модели шара - 100 см)\nlocal stepRadiusPS = 1250\nlocal DamagedActors = {} -- = { ['@0x1'] = true} ранее для игнорирования игрока\nlocal theActor\nlocal AggressivePlayer\n\n--проверка настройки на урон игроку\nlocal function damageToPlayer()\nlocal settings = storage.globalSection('SettingsWCStaff')\n\nlocal PlayerDamaged = settings:get('PlayerDamaged')\nlocal TestMessage = settings:get('TestMessage')\n\n\tif PlayerDamaged == false then --если игрок не поражается\n\t--print(string.format('player not damaged, PlayerDamaged %s', PlayerDamaged))\n\t--в таблицу уже пораженных актеров добавляется игрок\n\tPlayerID = tostring(AggressivePlayer.id)\n\tDamagedActors[PlayerID] = true\n\telse\n\t--print(string.format('player damaged, PlayerDamaged %s', PlayerDamaged))\n\tDamagedActors = {} --таблица уже пораженных актеров пустая, и игрок будет поражен\n\tend\nend\n\n-------------\nlocal function Damage(dt)  --DT 0,015284599736333 - FPS 66.6\n\ncurrentActors = nearby.actors\n\n\tradius = radius + stepRadiusPS * dt -- + 50\n\tfor _, theActor in ipairs(currentActors) do\n\t\n\t\tif types.Actor.isDead(theActor) == false then --проверка, что цель жива\n\t\tlocal distance = (self.position - theActor.position):length() --расстояние от центра шара до актера\n\t\t--print (string.format('distance, %s, radius %s', distance, radius))\n\t\t\tif distance <= radius then  --проверка на расстояние \n\t\t\t--print (string.format('distance, %s, the Actor %s, radius %s', distance, theActor, radius))\n\t\t\t\n\t\t\t--проверка на непринадежность актера к уже поврежденным актерам\n\t\t\t\tif not DamagedActors[theActor.id] then\n\t\t\t\tif TestMessage then print (string.format('distance, %s, the Actor %s, radius %s', distance, theActor, radius)) end \n\t\t\t\tIDtoStr = tostring(theActor.id)\n\t\t\t\t--чисто визуальный заклинание wcs_explode_vis, мини-активатор wcs_explode_visactiv и сразу удаляется (setdelete 1).\n\t\t\t\tcore.sendGlobalEvent('AddVisualFire', {VisualFirePos = theActor.position}) --событие на появление активатора с ExplodeSpell\n\t\t\t\tcore.sendGlobalEvent('AddDamagingScript', {theActor = theActor}) --событие в глобальный скрипт, добавлеющее локальный скрипт для уменьшения здоровья актера\n\t\t\t\tDamagedActors[IDtoStr] = true  --добавление в таблицу уже пораженных игроков\n\t\t\t\tend\n\t\t\tend --конец проверки на расстояние\n\t\tend --конец проверки жизни\n\tend --конец for\n\nend\n----------------\nreturn {\n    engineHandlers = {\n\t\n\tonInit = function(data) \n\tAggressivePlayer = data.AggressivePlayer --получения данных об игроке, запустившем огненный шар, для его внесения в таблицу исключений поражения (в зависимости от настроек)\n\tdoOnce = 0  --при инициации скрипта, чтобы скрипт сработал и нанес урон\n\tend,\t\n\n\tonUpdate = function(dt)\n\tif doOnce == 0 then damageToPlayer() doOnce = 1 end --проверка на урон по самому себе\n\t\t\n\tDamage(dt)\n\t--print(string.format('explosion successfully added'))\n\tend, --конец onUpdate\n\t},\n\t\n\teventHandlers = { \n\tAddVisualFire = AddVisualFire, --событие для добавления активатора с заклинанием огненного взрыва на 0 для внешнего эффекта\n\tAddDamagingScript = AddDamagingScript --добавление скрипта урона к актеру-цели\n\t}\n}",
    "War Commander's Staff-54981-1-1-1721075949\\War Commander Staff ENG\\WC_Staff\\scripts\\WC_staff_GLO.lua": "--часть системы скриптов для управляемого огненного шара\nlocal world = require('openmw.world')\nlocal core = require('openmw.core')\nlocal Actor = require('openmw.types').Actor\nlocal util = require(\"openmw.util\")\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\n\nlocal FlyingBall\nlocal EndBallPos\nlocal ExplodeON = false\nlocal ExplosionPos --позиция появления взрыва\nlocal CurrentBallPos\nlocal Explosion = nil\nlocal VisualFire = nil\nlocal AggressivePlayer\nlocal saveBall\nlocal saveLight\nlocal saveExplosion\n------------------------------\n--секция настроек. прописать лучше в глобале, чтобы любой скрипт мог смотреть эти настройки; и для возможности менять настройки только на сервере\nlocal settings = storage.globalSection('SettingsWCStaff') \t\n--------\nlocal function boolSetting(key, default)\n    return {\n        key = key,\n        renderer = 'checkbox',\n        name = key,\n        description = key..'Description',\n        default = default,\n    }\nend\n-------------\nlocal function floatSetting(key, default, min, max)\n    return {\n        key = key,\n        renderer = 'number',\n        name = key,\n        description = key..'Description',\n        default = default,\n\t\targument = {\n            integer = true,\n            min = min,\n            max = max,\n         }\n    }\nend\n------------\n\nI.Settings.registerGroup({\n    key = 'SettingsWCStaff',\n    page = 'WC Staff',\n    l10n = 'WC_Staff',\n    name = 'Settings',\n    permanentStorage = true,\n    settings = {\n        boolSetting('Mod ON', true),\n        boolSetting('Need Fire Salt', true),\n        boolSetting('PlayerDamaged', true),  --игрок поражается своим же огненным шаром\n\t\tfloatSetting('ManaCost', 5, 0, 30), --стоимость маны в секунду на полет шара\n\t\tfloatSetting('ExplDiam', 25, 1, 50), --масштаб расширения взрыва\n\t\tfloatSetting('MaxDistance', 8000, 500, 15000), --максимальная дальность полета файрболла\n\t\tfloatSetting('RequiredDestruction', 50, 0, 100), --необходимый уровень разрушения для использоавния посоха\n\t\tboolSetting('DependDestruction', true),--урон по врагам зависит от прокачанности Разрушения\n\t\tfloatSetting('BaseDamage', 100, 5, 500), --базовый урон - если у цели нет модификаторов на сопротивление/уязвимость к огню и огненный щит, и у игрока Разрушение = 100\n\t\tfloatSetting('stepPerSecond', 1000, 100, 10000), --расстояние, на которое шар смещается на 1 секунду\n\t\tboolSetting('TestMessage', false)  --вывод тестовых сообщений в лог F10\n    },\n})\n\n--функция появления шара-активатора\nlocal function BallLaunched(data)\nAggressivePlayer = data.AggressivePlayer\nFlyingBall = world.createObject('WCS_ball')\nFlyingBall:teleport(AggressivePlayer.cell, data.BallStartPos)\n\nend --конец функции появления шара\n---------------------------------------\n--функция удаления соли\nlocal function SaltRemove(data)\nSalt = data.Salt\nSalt:remove(1)\nend\n---------------------------------------\n--функция взрыва и удаления шара\nlocal function BallExplode(data)\n\tif FlyingBall then\n\tCurrentBallPos = FlyingBall.position\n\tFlyingBall:remove(1)\n\tFlyingBall = nil\n\tExplosionPos = CurrentBallPos --для координаты появления взрыва\n\tEndBallPos = nil\t\n\tExplodeON = true --для подрыва шара в воздухе\n\tend\nend --конец функции удаления и взрыва шара\n------------------------------------------\n--функция управления летащим шаром\nlocal function BallTeleported(data) --получение данных о конечной точке шара из скрипта игрока через событие\nEndBallPos = data.BallEndPos\nend\n\nlocal function BallMoved(dt)\nif EndBallPos then\n    if FlyingBall then CurrentBallPos = FlyingBall.position end\n    local direction, distance = (EndBallPos - CurrentBallPos):normalize()\n    --print (string.format('ball-to-target distance, %s', distance))\n\tlocal stepPerSecond =  settings:get('stepPerSecond') --900 (15 * 60)было в оригинале от 100 до 10000, 1000 по-умолчанию, значение из настроек\n    local step = stepPerSecond * dt  \n\t--print (string.format('step, %s', step))\n    if distance > step then\n        local NewBallPos = CurrentBallPos + direction * step\n        if FlyingBall then  FlyingBall:teleport(AggressivePlayer.cell, NewBallPos) end  --Урм предложил FlyingBall:teleport(FlyingBall.cell, NewBallPos)\n    else\n        AggressivePlayer:sendEvent('BallDeleted')\n        ExplosionPos = EndBallPos \n\t\tEndBallPos = nil\n\t\tExplodeON = true --генерация сферы взрыва, раидусом 50 от исходного шара\n\t\tif TestMessage then print('the fireball reached its target and exploded') end \n\t\tif FlyingBall then FlyingBall:remove(1) end\n\t\tFlyingBall = nil\n    end\nend\nend\n------------------------------------------------------------\n--функция расширяющегося взрыва до 50 масштабов за 2 секунды, с нанесением урона\nlocal StepScale = 25 --переменная для шага масштаба, в настройки не вынесена\n\nlocal function ExpandingExplosion(dt)\n\n\tif not Explosion then  --если взрыва нет, то его сгенерировать\n\tExplosion = world.createObject('WCS_expl_ball')\n\tExplosion:teleport(AggressivePlayer.cell, ExplosionPos)\t\n\tExplosion:addScript('scripts/WC_staff_EXPL.lua', {AggressivePlayer = AggressivePlayer})\n\telse -- если взрыв существует, то начать расширение\n\n\t\tlocal ExplDiam = settings:get('ExplDiam') --получение максимального диаметра из настроек\n\t\tif Explosion.scale <= ExplDiam then --если масштаб меньше или равен заданному, то расширяем взрыв\n\t\tlocal currentScale = Explosion.scale +  StepScale * dt\n\t\t--print (string.format('Scale, %s', currentScale))\n\t\tExplosion:setScale(currentScale) \t\n\t\telse --если масштаб больше заданного, то удаляем взрыв\n\t\tExplodeON = false\n\t\tExplosion:remove(1)\n\t\tExplosion = nil\t\t\n\t\tend\n\tend --конец функции генерации либо расширения взрыва\nend --конец функции взрыва\n----------------\n--функция добавления визуального взрыва к актеру по событию из скрипта WC_staff_PLA.lua\nlocal function AddVisualFire(data)\n\tVisualFire = world.createObject('wcs_explode_visactiv'):teleport(AggressivePlayer.cell, data.VisualFirePos)\nend --конец функции генерации визуального взрыва\n------------------------------\n--функция добавления скрипта к актеру, который будет поврежден\nlocal function AddDamagingScript(data)\nlocal enemy = data.theActor\nenemy:addScript('scripts/WC_staff_ACTOR.lua', {AggressivePlayer = AggressivePlayer})\nend\n----------------------------\n--функция удаления скрипта с актера после нанесения урона, иначе урон повторно не пройдет, и вообще там будет висеть скрипт\nlocal function RemoveActorScript(data)\nlocal ActorFRS = data.ActorForRemoveScript   \n\tif ActorFRS then \n\tActorFRS:removeScript('scripts/WC_staff_ACTOR.lua')\n\tif TestMessage then print (string.format('the script has been removed from - %s', ActorFRS)) end \n\tend\nend\n----------------------------\n--функция удаления активаторов взрыва и файрболла при загрузке при наличии сохраненных данных\nlocal function RemoveActivatorOnLoad()\n\tif savedBall then\n\tsavedBall:remove(1)\n\tprint('saved fireball deleted')\n\tsaveBall = nil\n\tsavedBall = nil\n\tsaveLight = nil\n\tend\n\t\n\tif savedExplosion then\n\tsavedExplosion:remove(1)\n\tprint('saved explosion deleted')\n\tsaveExplosion = nil\n\tsavedExplosion = nil\n\tend\t\n\t\n\t--[[if savedLight then\n\tsavedLight:remove(1)\n\tprint('saved light deleted')\n\tsaveLight = nil\n\tsavedLight = nil\n\tend\t--]]\n\t\nend\n---------------------------\nreturn {\n    eventHandlers = { BallLaunched = BallLaunched, --генерация летящего шара-активатора\n\t\t\t\t\t  BallExplode = BallExplode,  --событие взрыва шара по взмаху посоха из скрипта игрока или по окнчанию маны\n\t\t\t\t\t  BallMoveCoordinates = BallTeleported,\n\t\t\t\t\t  BallDeleted = BallDeleted, --события взрыва шара глобальным скриптом, когда он долетает до цели\n\t\t\t\t\t  AddVisualFire = AddVisualFire, --событие добавления визуального эффекта огня к актерам\n\t\t\t\t\t  AddDamagingScript = AddDamagingScript,  --событие в глобальный скрипт, добавляющее локальный скрипт для уменьшения здоровья актера\n\t\t\t\t\t  SaltRemove = SaltRemove, --событие для удаления огненной соли из глобального скрипта\n\t\t\t\t\t  RemoveActorScript = RemoveActorScript, --события от скрипта актера для удаления с него скрипта, чтобы можно было повторить урон, и вообще там скрипт не висел\n\t\t\t\t\t  },  \n\n\tengineHandlers = {\n\n\tonSave = function(data)\n\t\t\n\t\tif FlyingBall then\n\t\t\tsaveBall = FlyingBall\n\t\t\t--print (string.format('saved fireball, %s', saveBall))\n\t\tend\n\t\t\n\t\tif Explosion then\n\t\t\tsaveExplosion = Explosion\n\t\tend\n\t\treturn {saveBall = saveBall, saveExplosion = saveExplosion}\n\tend, --конец onSave\n\t\n\t\n\tonLoad = function(data)\n\t\tif data.saveBall then\n\t\t\tsavedBall = data.saveBall\n\t\tend\n\t\t\n\t\tif data.saveExplosion then\n\t\t\tsavedExplosion = data.saveExplosion\n\t\tend\n\t\t\n\tend, --конец onLoad\n\t\n\tonUpdate = function(dt)\n\t\n\tRemoveActivatorOnLoad() --удаление файрболла и взрыва при загрузке\n\t\n\tTestMessage = settings:get('TestMessage')\n\t\n\t--функция движения шара от Урма\n\tBallMoved(dt)\n\n\tif ExplodeON == true then ExpandingExplosion(dt) end -- --print('EXPLOSION')\n\n\tend, --конец onUpdate\n\t}\n}",
    "War Commander's Staff-54981-1-1-1721075949\\War Commander Staff ENG\\WC_Staff\\scripts\\WC_staff_PLA.lua": "--[[скрипт для проверки взмахов посохом, и отправки контролируемого огненного шара\nGetLOS не нужен\n----------\nнажатие кнопок и сообщения доступны только из скрипта типа PLAYER - не нужно\nсоздание новых шаровых молний только из скрипта типа GLOBAL\nнужно 4 скрипта и сделать обмен данными, \nуправление движением шара из глобального скрипта, скрипт на шаре не нужен, шар будет один\n\n----\nдобавлено условие, что для работы скрипта должен быть надеты посох - перед необходимыми действиями запрашивается функция checkStaff\n\n--известная ошибка - при подъеме огненной соли шар может запуститься не сразу, а только со второго взмаха, но я перенес т строки выше\n--]]\n\nlocal ui = require('openmw.ui') --вывод сообщений -- а оно нужно, как минимум для тестов\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal nearby = require('openmw.nearby')\n--local input = require('openmw.input') --не нужен\nlocal util = require('openmw.util')\nlocal camera = require('openmw.camera')\nlocal core = require('openmw.core')\n\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\n\nlocal Actor = types.Actor\n\nlocal Shot = 0 --для проверки момента взмаха посохом\nlocal Ball = false -- для проверки состояния шара, он может быть взорван глобальным скриптом при достижении цели, а локальный скрипт продолжит передавать данные\nlocal BallEndPos\nlocal timer = 0  --для задержки удаления шара, если нет маны\n--------------------------------------------------------\n--раздел настроек\nlocal settings = storage.globalSection('SettingsWCStaff') -- storage.globalSection(sectionName)\n--страница регистрации скрипта только в скрипте игрока, сами настройки в глобальном\nI.Settings.registerPage {\n    key = 'WC Staff',\n    l10n = 'WC_Staff',\n    name = 'War Commander`s Staff',\n    description = 'WC Staff Description',\n\t}\n\n--------------------------------------------------------\n--функция проверки надетого посоха\nlocal function checkStaff()\nlocal equip = types.Actor.getEquipment(self)\n\tif equip[types.Actor.EQUIPMENT_SLOT.CarriedRight] and equip[types.Actor.EQUIPMENT_SLOT.CarriedRight].recordId == 'wcs_war_staff' then  --wcs_staff\n\treturn true\n\telse --если посох не надет\n\treturn false\n\tend\nend\n---------------------------------------------\n--функция проверки наличия огненной соли в инвентаре \nlocal function checkFSalt()\n\tif settings:get('Need Fire Salt') == true then --проверка \n\t\tlocal Salt = Actor.inventory(self):find('ingred_fire_salts_01')\n\t\tif Salt then\t\t\n\t\tif TestMessage then print ('fire salt in inventory') end\n\t\tcore.sendGlobalEvent('SaltRemove', {Salt = Salt}) -- событие в глобальный скрипт для удаления огнесоли\n\t\treturn true\n\t\telse\n\t\tif TestMessage then print ('not fire salt in inventory') end\n\t\treturn false\n\t\tend\n\telse\n\tif TestMessage then print ('fire salt is not needed') end\n\treturn true\n\tend\nend\n---------------------------------------------\n--функция добавления шара при взмахе\nlocal function AddBall()\n\t--проверка на тип камеры\n\tif camera.getMode() == camera.MODE.FirstPerson then  --если от 1го лица\n\tlocal BallStartPos = camera.getPosition() + camera.viewportToWorldVector(util.vector2(0.5, 0.5))*150 --стартовая позиция шара в 150 ед перед лицом игрока\n\t--print (string.format(\"%s\", BallStartPos))\n\tcore.sendGlobalEvent('BallLaunched', {BallStartPos=BallStartPos, AggressivePlayer = self})\n\telseif camera.getMode() == camera.MODE.ThirdPerson or camera.getMode() == camera.MODE.Preview then --если 3 лицо или\n\t\n\t--local playerPos = self.position + util.vector3(0, 0, self:getBoundingBox().halfSize.z)\n\tlocal playerAngleZ = self.rotation:getYaw() --в радианах\n\tlocal BallPosX = self.position.x + 150 * math.sin (playerAngleZ)\n\tlocal BallPosY = self.position.y + 150 * math.cos(playerAngleZ)\n\tlocal BallPosZ = self.position.z + self:getBoundingBox().halfSize.z\n\tlocal BallStartPos = util.vector3(BallPosX, BallPosY, BallPosZ)\n\tif TestMessage then print(string.format(\"3rd person starting ball position, %s\", BallStartPos)) end \n\tcore.sendGlobalEvent('BallLaunched', {BallStartPos=BallStartPos, AggressivePlayer = self})\n\telse\n\treturn false\n\tend --конец проверки типа камеры\nend --конец функции добавления шара\n----------------------------------------------\n--функция взрыва шара при втором взмахе\nlocal function ExplodeBall()\n\tif TestMessage then print('the fireball is exploded by the swing of the staff') end \n\tcore.sendGlobalEvent('BallExplode', {})  \nend \n----------------------------------------------\n--функция проверки типа камеры, работает от 1 и 3го лица ,не работает Static и Vanity\nlocal function checkCamera()\n\tif camera.getMode() == camera.MODE.FirstPerson or camera.getMode() == camera.MODE.ThirdPerson or camera.getMode() == camera.MODE.Preview then \n\treturn true\n\telse\n\treturn false\n\tend\nend\n--функция отслеживания взмаха посохом на 0, 1,2,3 для удаления шара\nlocal function checkShot()\n\tif checkStaff() == true then --проверка на надетый посох\n\t\tif types.NPC.stats.skills.destruction(self).modified > settings:get('RequiredDestruction') then--проверка на уровень Разрушения \n\t\t\t--print ('Your level of destruction is good')\n\t\t\tif checkCamera() then  --проверка на тип камеры игрока\n\t\t\t\tif Actor.stance(self) == 1 then  --проверка на позу\n\t\t\t\t\t\n\t\t\t\t\t\tif self.controls.use == 1 then\n\t\t\t\t\t\t\tif Shot == 0 then\n\t\t\t\t\t\t\tShot = 1 \n\t\t\t\t\t\t\t--ui.showMessage('staff is raised')\n\t\t\t\t\t\t\telseif Shot == 2 then\n\t\t\t\t\t\t\tShot = 3\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\n\t\t\t\t\t\telseif self.controls.use == 0 then\n\t\t\t\t\t\t\tif Shot == 1 then\n\t\t\t\t\t\t\t\tif checkFSalt() == true then\t  --проверка на наличие соли\n\t\t\t\t\t\t\t\tAddBall()\n\t\t\t\t\t\t\t\t--print ('ball launched')\n\t\t\t\t\t\t\t\tBall = true\n\t\t\t\t\t\t\t\t--Shot = 2 --при переносе сюда шар запускается при подборе соли в инвентарь\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tShot = 2  --??? исходно было тут, попытка перенести выше неудачна\n\t\t\t\t\t\t\t\telseif Shot == 3 then\n\t\t\t\t\t\t\t\tif Ball == true then --если шар появился (при наличии соли)\n\t\t\t\t\t\t\t\tExplodeBall()\n\t\t\t\t\t\t\t\tBall = false\n\t\t\t\t\t\t\t\t--Shot = 0 --при переносе сюда шар запускается при подборе соли в инвентарь\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tShot = 0  --??? исходно было тут, попытка перенести выше неудачна\n\t\t\t\t\t\t\tend\t\t\t\t\n\t\t\t\t\t\tend\t\t\t\n\t\t\t\t\t\t\n\t\t\t\tend --конец отслеживания позы\n\t\t\tend --конец проверки типа камеры\n\t\t--else --если уровень разрушения игрока меньше требуемого уровня Разрушения\n\t\t--if TestMessage then print ('Your level of destruction is too low') end --то сообщение при включенных тестовых сообщениях\n\t\tend -- конец проверки на уровнь разрушения\n\tend --конец провеки на надетый посох\nend --конец функции отслеживания удара\n--------------------------------------------------------\n--функция отслеживания состояния шара, если он будет взорван из глобального скрипта\nlocal function BallDeleted()\nBall = false\nShot = 0\nend\n--------------------------------------------------------\n--функция движения шара, запускается через onUpdate если только Ball == true; также отнимает ману у игрока, \n--отъем маны в секунду регулируется настройками от 0 до 30\nlocal function MoveBall(dt)\n\n----отъем маны у игрока\nlocal magickaCost = settings:get('ManaCost')\nlocal magicka = types.Actor.stats.dynamic.magicka(self)\n\tif magicka.current > 0 or magickaCost == 0 then\n\tmagicka.current = magicka.current - magickaCost * dt\n\t--расчет конечной точки движения шара\n\tlocal MaxDistance = settings:get('MaxDistance')\n\tlocal SightEndPos = camera.getPosition() + camera.viewportToWorldVector(util.vector2(0.5, 0.5)) * MaxDistance\n\t--print ('the fireball is flying...')\n\tlocal SightStartPos = camera.getPosition()\n\tlocal target = nearby.castRay(SightStartPos, SightEndPos, {ignore=self})\n\tlocal target = \ttarget.hitPos --target.hitObject\n\n\t\tif target then\n\t\tBallEndPos = target  \n\t\telse\n\t\tBallEndPos = SightEndPos\n\t\tend\n\tcore.sendGlobalEvent('BallMoveCoordinates', {BallEndPos = BallEndPos})\n\t\n\telseif  magickaCost > 0 then-- если стоимость полета шара больше 0\n\t\tif magicka.current <= 0 then --если маны нет\n\t\t--взрываем шар\t\t\n\t\t\tif timer < 0.1 then\n\t\t\ttimer = timer + dt\n\t\t\telse\n\t\t\tBall = false\n\t\t\tShot = 0\n\t\t\ttimer = 0\n\t\t\tif TestMessage then print('out of mana') end \n\t\t\tcore.sendGlobalEvent('BallExplode', {})\n\t\t\tend\n\t\tend\n\tend --конец проверки маны и цены полета\nend --конец функции движения шара\n----------------------------------------------------------\n\nreturn {\n    engineHandlers = {\n\n\tonUpdate = function(dt)\n\t\n\tTestMessage = settings:get('TestMessage')\n\tif settings:get('Mod ON') == false then \n\t\t--if TestMessage then print ('MOD wc_staff is OFF') end\n\treturn false end\n\t\n\tcheckShot()\n\t\n\tif Ball == true then --если шар существует, то включается функция движения шара\n\t\tMoveBall(dt)\n\tend\n\t\n\tend, --конец onUpdate\n\t},\n\t\n\teventHandlers = { \n\tBallLaunched = BallLaunched, --событие добавления летящего шара-активатора\n\tBallExplode = BallExplode, --событие взрыва и удаления летащего шара активатора по взмаху посоха\n\tBallDeleted = BallDeleted, --события взрыва шара глобальным скриптом\n\tBallMoveCoordinates = BallMoveCoordinates, --событие для передачи конечной координаты шара\n\tSaltRemove = SaltRemove, --событие для удаления огненной соли из глобального скрипта\n\t}\n}"
  }
}