{
  "folder_name": "ZdoHeadTracking - Head Tracking using TrackIR",
  "lua_files": {
    "ZdoHeadTracking-53913-1-0-1704051458\\ZdoHeadTracking\\MWSE\\mods\\ZdoHeadTracking\\config.lua": "local defaultConfig = {\n\tenable = true,\n\tdebug = false,\n\tversion = \"v1.0\",\n\n\tfile = \"D:/Games/morrowind_headtracking.txt\",\n\n\tpitch = -1,\n\tyaw = 1,\n\troll = 1,\n\tx = 0,\n\ty = 0,\n\tz = 0,\n\tmaxHeadOffset = 24,\n\n\tstepLength = 180,\n    stepHeight = 3,\n    maxRoll = 0.2\n}\n\nlocal config = mwse.loadConfig(\"ZdoHeadTracking\", defaultConfig)\nreturn config",
    "ZdoHeadTracking-53913-1-0-1704051458\\ZdoHeadTracking\\MWSE\\mods\\ZdoHeadTracking\\main.lua": "--[[\n    ZdoHeadTracking\n\n    Source code based on the code from\n    Steadicam v1.1 by Hrnchamd\n\n\tand on the OpenMW head bobbing logic written in Lua.\n]]--\n\nlocal config = require(\"ZdoHeadTracking.config\")\n\nlocal deg2rad = (1.0 / 180.0 * 3.1415)\nlocal headTrackXPitch = 0\nlocal headTrackYRoll = 0\nlocal headTrackZYaw = 0\nlocal headTrackXMove = 0\nlocal headTrackYMove = 0\nlocal headTrackZMove = 0\n\n-- Trajectory of each step is a scaled arc of 60 degrees.\nlocal halfArc = math.rad(30)\nlocal sampleArc = function(x) return 1 - math.cos(x * halfArc) end\nlocal arcHeight = sampleArc(1)\nlocal effectWeight = 0\nlocal totalMovement = 0\n\nlocal function debugLog(fmt, ...)\n\tif config.debug then\n\t\treturn mwse.log(\"[ZdoHeadTracking] \" .. fmt, ...)\n\tend\nend\n\nlocal function clampHeadTrackMove(x)\n    local maxValue = config.maxHeadOffset\n    return math.max(math.min(x, maxValue), -maxValue)\nend\n\nlocal function cameraControl(e)\n\tif not config.enable then\n\t\treturn\n\tend\n\tif e.animationController.vanityCamera then\n\t\tdebugLog(\"Vanity camera, ignore\")\n\t\treturn\n\tend\n\n\tlocal animController = e.animationController\n\tlocal dt = tes3.worldController.deltaTime\n\n\tlocal r = e.cameraTransform.rotation:toQuaternion()\n\tlocal r_matrix = e.cameraTransform.rotation:copy()\n    local rOld = r\n\n    -- TODO: check whether seeking to the beginning works instead of reopening\n    local htfile = io.open(config.file, \"rb\")\n    local htfileData = htfile:read \"*a\"\n    htfile:close();\n\n    local htfileComponents = {}\n    for w in htfileData:gmatch(\"[%d-.]+\") do\n        table.insert(htfileComponents, w)\n    end\n\n\t-- file read/write race condition protection\n    local isValid = tonumber(htfileComponents[1]) ~= nil\n    if isValid then\n        headTrackZYaw = -tonumber(htfileComponents[1]) * deg2rad\n        headTrackXPitch = tonumber(htfileComponents[2]) * deg2rad\n        headTrackYRoll = tonumber(htfileComponents[3]) * deg2rad\n        headTrackXMove = tonumber(htfileComponents[4])\n        headTrackYMove = tonumber(htfileComponents[5])\n        headTrackZMove = tonumber(htfileComponents[6])\n    end\n\n\tif config.debug then\n\t\tdebugLog(\"%s\", json.encode({headTrackZYaw, headTrackXPitch, headTrackYRoll, headTrackXMove, headTrackYMove, headTrackZMove}))\n\tend\n\n\tif config.yaw ~= 0 then\n\t\tlocal q = niQuaternion.new()\n\t\tq:fromAngleAxis(headTrackZYaw, tes3vector3.new(0, 0, 1)) --r_matrix:getUpVector())\n\t\tr = q * r\n\tend\n\n\tif config.pitch ~= 0 then\n\t\tlocal q = niQuaternion.new()\n\t\tq:fromAngleAxis(headTrackXPitch, r_matrix:getRightVector())\n\t\tr = q * r\n\tend\n\n\tif config.roll ~= 0 then\n\t\tlocal q = niQuaternion.new()\n\t\tq:fromAngleAxis(headTrackYRoll, r_matrix:getForwardVector())\n\t\tr = q * r\n\tend\n\n    -- head bobbing\n\tlocal speed = 0\n\tlocal p = tes3.mobilePlayer\n\tif p.isMovingBack or p.isMovingForward or p.isMovingLeft or p.isMovingRight then\n\t\tif tes3.mobilePlayer.isRunning then\n\t\t\tspeed = p.runSpeed\n\t\telseif tes3.mobilePlayer.isWalking then\n\t\t\tspeed = p.walkSpeed\n\t\tend\n\tend\n\n\ttotalMovement = totalMovement + speed * dt\n\tif animController.is3rdPerson then\n\t\teffectWeight = 0\n\tend\n\tif tes3.mobilePlayer.isFlying or tes3.mobilePlayer.isFalling or tes3.mobilePlayer.isJumping then\n\t\teffectWeight = math.max(0, effectWeight - dt * 5)\n\telse\n\t\teffectWeight = math.min(1, effectWeight + dt * 5)\n\tend\n\n\tlocal doubleStepLength = config.stepLength * 2\n\tlocal stepHeight = config.stepHeight;\n\tlocal maxRoll = math.rad(config.maxRoll);\n\n\tlocal doubleStepState = totalMovement / doubleStepLength\n\tdoubleStepState = doubleStepState - math.floor(doubleStepState)  -- from 0 to 1 during 2 steps\n\tlocal stepState = math.abs(doubleStepState * 4 - 2) - 1  -- from -1 to 1 on even steps and from 1 to -1 on odd steps\n\tlocal effect = sampleArc(stepState) / arcHeight  -- range from 0 to 1\n\n\t-- Smoothly reduce the effect to zero when the player stops\n\tlocal smoothedSpeed = speed\n\tlocal coef = math.min(smoothedSpeed / 300, 1) * effectWeight\n\n\tlocal zOffset = (0.5 - effect) * coef * stepHeight  -- range from -stepHeight/2 to stepHeight/2\n\tlocal roll = ((stepState > 0 and 1) or -1) * effect * coef * maxRoll  -- range from -maxRoll to maxRoll\n\n\tlocal headBobRollQ = niQuaternion.new()\n\theadBobRollQ:fromAngleAxis(roll, r_matrix:getForwardVector())\n\tr = headBobRollQ * r\n\n\tlocal tNew = e.cameraTransform.translation:copy()\n\n\tif config.x ~= 0 then\n\t\tlocal direction = r_matrix:getRightVector()\n\t\ttNew = tes3.player1stPerson.sceneNode.translation + direction:normalized() * clampHeadTrackMove(headTrackXMove) * config.x\n\tend\n\tif config.y ~= 0 then\n\t\tlocal direction = r_matrix:getForwardVector()\n\t\ttNew = tes3.player1stPerson.sceneNode.translation + direction:normalized() * clampHeadTrackMove(headTrackYMove) * config.y\n\tend\n\tif config.z ~= 0 then\n\t\tlocal direction = r_matrix:getUpVector()\n\t\ttNew = tes3.player1stPerson.sceneNode.translation + direction:normalized() * clampHeadTrackMove(headTrackZMove) * config.z\n\tend\n\n\ttNew.z = tes3.player1stPerson.sceneNode.translation.z + zOffset\n\n    e.cameraTransform.translation = tNew\n    e.cameraTransform.rotation = r:toRotation()\n\n    tes3.player1stPerson.sceneNode.rotation = rOld:toRotation()\n    --animController.groundPlaneRotation = rOld:toRotation()\n\n\ttes3.player1stPerson.sceneNode:update()\n\n\t-- Arm camera matches world camera\n\te.armCameraTransform = e.cameraTransform\n\n\tdebugLog(\"ZdoHeadTracking should be applied\")\nend\n\nlocal function initialized()\n\tmwse.log(\"ZdoHeadTracking initialized\")\n\tevent.register(tes3.event.cameraControl, cameraControl)\nend\n\nevent.register(\"initialized\", initialized)\n\nevent.register(\"modConfigReady\", function()\n\trequire(\"ZdoHeadTracking.mcm\")\nend)\n",
    "ZdoHeadTracking-53913-1-0-1704051458\\ZdoHeadTracking\\MWSE\\mods\\ZdoHeadTracking\\mcm.lua": "local config = require(\"ZdoHeadTracking.config\")\n\nlocal template = mwse.mcm.createTemplate(\"ZdoHeadTracking\")\ntemplate:saveOnClose(\"ZdoHeadTracking\", config)\n\nlocal page = template:createSideBarPage()\npage.label = \"General Settings\"\npage.description = \"ZdoHeadTracking,\" .. config.version .. \"\\nby zdo\"\npage.noScroll = false\n\nlocal category = page\n\nlocal enableButton = category:createYesNoButton()\nenableButton.label = \"Enable\"\nenableButton.description = \"Toggle to turn this mod on and off.\"\nenableButton.variable = mwse.mcm:createTableVariable{id = \"enable\", table = config}\n\ncategory:createYesNoButton({\n\tlabel=\"Debug\",\n\tdescription=\"Log values to MWSE.log. Do not enable this value for too long to avoid log growing out of control\",\n\tvariable=mwse.mcm.createTableVariable{id = \"debug\", table = config}\n})\n\ncategory:createTextField({\n\tlabel=\"File\",\n\tdescription=\"File path with head tracking values to read from\",\n\tvariable=mwse.mcm.createTableVariable{id = \"file\", table = config}\n})\n\ncategory:createDecimalSlider({\n\tlabel = \"Head tracking pitch\",\n\tdescription = \"Looking up/down. 0 to disable\",\n\tmin = -1,\n\tmax = 1,\n\tvariable = mwse.mcm:createTableVariable{id = \"pitch\", table = config}\n})\n\ncategory:createDecimalSlider({\n\tlabel = \"Head tracking yaw\",\n\tdescription = \"Looking left/right. 0 to disable\",\n\tmin = -1,\n\tmax = 1,\n\tvariable = mwse.mcm:createTableVariable{id = \"yaw\", table = config}\n})\n\ncategory:createDecimalSlider({\n\tlabel = \"Head tracking roll\",\n\tdescription = \"Turning head around forward axis\",\n\tmin = -1,\n\tmax = 1,\n\tvariable = mwse.mcm:createTableVariable{id = \"roll\", table = config}\n})\n\ncategory:createDecimalSlider({\n\tlabel = \"Head tracking offset X\",\n\tdescription = \"0 to disable\",\n\tmin = -1,\n\tmax = 1,\n\tvariable = mwse.mcm:createTableVariable{id = \"x\", table = config}\n})\n\ncategory:createDecimalSlider({\n\tlabel = \"Head tracking offset Y\",\n\tdescription = \"0 to disable\",\n\tmin = -1,\n\tmax = 1,\n\tvariable = mwse.mcm:createTableVariable{id = \"y\", table = config}\n})\n\ncategory:createDecimalSlider({\n\tlabel = \"Head tracking offset Z\",\n\tdescription = \"0 to disable\",\n\tmin = -1,\n\tmax = 1,\n\tvariable = mwse.mcm:createTableVariable{id = \"z\", table = config}\n})\n\ncategory:createDecimalSlider({\n\tlabel = \"Head tracking max offset\",\n\tdescription = \"To not get head too detached from the body\",\n\tmin = 0,\n\tmax = 100,\n\tvariable = mwse.mcm:createTableVariable{id = \"maxHeadOffset\", table = config}\n})\n\ncategory:createSlider({\n\tlabel = \"Head bobbing step length\",\n\tdescription = \"\",\n\tmin = 0,\n\tmax = 300,\n\tvariable = mwse.mcm:createTableVariable{id = \"stepLength\", table = config}\n})\n\ncategory:createDecimalSlider({\n\tlabel = \"Head bobbing step height\",\n\tdescription = \"\",\n\tmin = 0,\n\tmax = 12,\n\tvariable = mwse.mcm:createTableVariable{id = \"stepHeight\", table = config}\n})\n\ncategory:createDecimalSlider({\n\tlabel = \"Head bobbing max roll\",\n\tdescription = \"Max roll over forward axis, in degrees\",\n\tmin = 0,\n\tmax = 5,\n\tvariable = mwse.mcm:createTableVariable{id = \"maxRoll\", table = config}\n})\n\nmwse.mcm.register(template)"
  }
}