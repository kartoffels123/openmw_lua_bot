{
  "folder_name": "Weighty Charged Attacks (OpenMW Lua)",
  "lua_files": {
    "Solthas Weighty Charge Attacks-52180-1-12-1717384745\\SolWeightyChargeAttacks\\scripts\\SolWeightyChargeAttacks.lua": "local core = require('openmw.core')\nlocal ui = require('openmw.ui')\nlocal input = require('openmw.input')\nlocal self = require('openmw.self')\nlocal types = require('openmw.types')\nlocal async = require('openmw.async')\nlocal I = require(\"openmw.interfaces\")\n\n-- settings functions\nlocal function boolSetting(sKey, sDef)\n    return {\n        key = sKey,\n        renderer = 'checkbox',\n        name = sKey..'_name',\n        description = sKey..'_desc',\n        default = sDef,\n    }\nend\nlocal function numbSetting(sKey, sDef, sInt, sMin, sMax)\n    return {\n        key = sKey,\n        renderer = 'number',\n        name = sKey..'_name',\n        description = sKey..'_desc',\n        default = sDef,\n    argument = {\n      integer = sInt,\n      min = sMin,\n      max = sMax,\n    },\n    }\nend\n-- handle settings\nlocal storage = require('openmw.storage')\nI.Settings.registerPage({\n   key = 'SolWeightyChargeAttacks',\n   l10n = 'SolWeightyChargeAttacks',\n   name = 'name',\n   description = 'description',\n})\n-- default values!\nlocal enabled = true\nlocal verbose = 2\nlocal hideChargePopup = true\nlocal incRanged = true -- include ranged weapons ?\nlocal integrateParry = true\nlocal buffControl = 0 -- 0 both, 1 str only, 2 acc only\nlocal buffBase = 2\nlocal fatigueMult = 1.0\nlocal tradeOffBase = 5\nlocal doSpeedRelease = true\nlocal maxCharge = 2\nlocal buffDuration = 0.5\nI.Settings.registerGroup({\n   key = 'Settings_SolWeightyChargeAttacks',\n   page = 'SolWeightyChargeAttacks',\n   l10n = 'SolWeightyChargeAttacks',\n   name = 'group_name',\n   permanentStorage = true,\n   settings = {\n    boolSetting('enabled',enabled),\n    boolSetting('integrateParry',integrateParry),\n    numbSetting('verbose',verbose, true,0,2),\n    boolSetting('hideChargePopup',hideChargePopup),\n    boolSetting('incRanged',incRanged),\n    numbSetting('buffControl',buffControl, true,0,2),\n    numbSetting('buffBase',buffBase, false,0,10),\n    numbSetting('fatigueMult',fatigueMult, false,0,2),\n    numbSetting('tradeOffBase',tradeOffBase, false,0,20),\n    boolSetting('doSpeedRelease',doSpeedRelease),\n    numbSetting('maxCharge',maxCharge, false,1,5),\n    numbSetting('buffDuration',buffDuration, false,0.25,5),\n   },\n})\n\nlocal settingsGroup = storage.playerSection('Settings_SolWeightyChargeAttacks')\n\n-- shorthand for convenience\nlocal Weapon = types.Weapon\nlocal attributes = types.Actor.stats.attributes\nlocal skills = types.NPC.stats.skills\nlocal dynamic = types.Actor.stats.dynamic\n\n-- reduce effectiveness of hybrid stances\nlocal function hybridVal(base,mult,count)\n    return math.ceil(base*math.pow(mult,math.max(count,0)))\nend\n\n-- script config\nlocal modType = 1 --1 skill, -1 debug reset all stat modifiers\nlocal incH2H = true -- include handtohand for heavy charged attacks?\n  -- if true, must define \"weight\" and \"speed\" values for h2h in buff/debuff fncs\n\n-- and store stance idxs for indexing into tables\nlocal stanceIndex = {charge=1, release=2}\nlocal maxStance = 0\nfor _ in pairs(stanceIndex) do\n  maxStance = maxStance + 1\nend\n\n-- init to defaults\nlocal stanceBuff = {-tradeOffBase,buffBase}\nlocal stanceNames = {'',''}\n-- update\nlocal function updateSettings()\n  enabled = settingsGroup:get('enabled')\n  hideChargePopup = settingsGroup:get('hideChargePopup')\n  verbose = settingsGroup:get('verbose')\n    -- update verbose\n    if verbose == 1 then\n    stanceNames = {'STRENGTH UP', 'SKILL UP', 'CHARGE'}\n    elseif verbose == 2 then\n    stanceNames  = {'STR+', 'ACC+', 'SPD etc'}\n    end\n  integrateParry = settingsGroup:get('integrateParry')\n  incRanged = settingsGroup:get('incRanged')\n  buffControl = settingsGroup:get('buffControl')\n  buffBase = settingsGroup:get('buffBase')\n  fatigueMult = settingsGroup:get('fatigueMult')\n  tradeOffBase = settingsGroup:get('tradeOffBase')\n    -- calculate new buff vals\n    stanceBuff = {-tradeOffBase,buffBase}\n  doSpeedRelease = settingsGroup:get('doSpeedRelease')\n  maxCharge = settingsGroup:get('maxCharge')\n  buffDuration = settingsGroup:get('buffDuration')\nend\nlocal function init()\n    updateSettings()\nend\nsettingsGroup:subscribe(async:callback(updateSettings))\n\n-- stance effects \nlocal function chargeMod(modSign,modVal)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    attributes.speed(self).modifier = math.max(0,attributes.speed(self).modifier + modSign*math.ceil(0.5*modVal))\n\t-- do athletics and acrobatics with speed, but give them each half impact\n    skills.athletics(self).modifier = math.max(0,skills.athletics(self).modifier + modSign*math.ceil(0.5*modVal))\n    skills.acrobatics(self).modifier = math.max(0,skills.acrobatics(self).modifier + modSign*math.ceil(0.5*modVal))\n    attributes.agility(self).modifier = math.max(0,attributes.agility(self).modifier + modSign*modVal)\n     -- offset agility by willpower to keep max fatigue constant\n    attributes.willpower(self).damage = math.max(0,attributes.willpower(self).damage + modSign*modVal)\n  else\n    modVal = math.abs(modVal)\n    attributes.speed(self).damage = math.max(0,attributes.speed(self).damage + modSign*math.ceil(0.5*modVal))\n\t-- do athletics and acrobatics with speed, but give them each half impact\n    skills.athletics(self).damage = math.max(0,skills.athletics(self).damage + modSign*math.ceil(0.5*modVal))\n    skills.acrobatics(self).damage = math.max(0,skills.acrobatics(self).damage + modSign*math.ceil(0.5*modVal))\n    attributes.agility(self).damage = math.max(0,attributes.agility(self).damage + modSign*modVal)\n     -- offset agility by willpower to keep max fatigue constant\n    attributes.willpower(self).modifier = math.max(0,attributes.willpower(self).modifier + modSign*modVal)\n  end\nend\nlocal function releaseMod(modSign,modVal,buffType)\n  if modVal > 0 then -- if positive effect, then modifier; else damage\n    modVal = math.abs(modVal)\n    if doSpeedRelease then\n      -- if debuff speed on release\n      attributes.speed(self).damage = math.max(0,attributes.speed(self).damage + tradeOffBase*modSign*modVal)\n      -- do athletics and acrobatics with speed, but give them each half impact\n      skills.athletics(self).damage = math.max(0,skills.athletics(self).damage + tradeOffBase*modSign*modVal)\n      skills.acrobatics(self).damage = math.max(0,skills.acrobatics(self).damage + tradeOffBase*modSign*modVal)\n    end\n    --normal\n    if buffType == 1 then\n      attributes.strength(self).modifier = math.max(0,attributes.strength(self).modifier + modSign*modVal)\n       -- offset strength by willpower to keep max fatigue constant\n      attributes.willpower(self).damage = math.max(0,attributes.willpower(self).damage + modSign*modVal)\n    else\n      skills.axe(self).modifier = math.max(0,skills.axe(self).modifier + modSign*modVal)\n      skills.bluntweapon(self).modifier = math.max(0,skills.bluntweapon(self).modifier + modSign*modVal)\n      skills.handtohand(self).modifier = math.max(0,skills.handtohand(self).modifier + modSign*modVal)\n      skills.longblade(self).modifier = math.max(0,skills.longblade(self).modifier + modSign*modVal)\n      skills.marksman(self).modifier = math.max(0,skills.marksman(self).modifier + modSign*modVal)\n      skills.shortblade(self).modifier = math.max(0,skills.shortblade(self).modifier + modSign*modVal)\n      skills.spear(self).modifier = math.max(0,skills.spear(self).modifier + modSign*modVal)\n    end\n  else -- if negative effect, then damage\n    modVal = math.abs(modVal)\n    if doSpeedRelease then\n      -- if debuff speed on release\n      attributes.speed(self).modifier = math.max(0,attributes.speed(self).modifier + tradeOffBase*modSign*modVal)\n      -- do athletics and acrobatics with speed, but give them each half impact\n      skills.athletics(self).modifier = math.max(0,skills.athletics(self).modifier + tradeOffBase*modSign*modVal)\n      skills.acrobatics(self).modifier = math.max(0,skills.acrobatics(self).modifier + tradeOffBase*modSign*modVal)\n    end\n    --normal\n    if buffType == 1 then\n      attributes.strength(self).damage = math.max(0,attributes.strength(self).damage + modSign*modVal)\n       -- offset strength by willpower to keep max fatigue constant\n      attributes.willpower(self).modifier = math.max(0,attributes.willpower(self).modifier + modSign*modVal)\n    else\n      skills.axe(self).damage = math.max(0,skills.axe(self).damage + modSign*modVal)\n      skills.bluntweapon(self).damage = math.max(0,skills.bluntweapon(self).damage + modSign*modVal)\n      skills.handtohand(self).damage = math.max(0,skills.handtohand(self).damage + modSign*modVal)\n      skills.longblade(self).damage = math.max(0,skills.longblade(self).damage + modSign*modVal)\n      skills.marksman(self).damage = math.max(0,skills.marksman(self).damage + modSign*modVal)\n      skills.shortblade(self).damage = math.max(0,skills.shortblade(self).damage + modSign*modVal)\n      skills.spear(self).damage = math.max(0,skills.spear(self).damage + modSign*modVal)\n    end\n  end\nend\n\n-- init stance total tracking, used for verbose outputs, and for onSave/onLoad tracking\nlocal chargeBuffTotal = {}\nfor i=1,maxStance,1 do \n  chargeBuffTotal[i] = 0\nend\nlocal buffType = 0\n\nlocal function weaponCheck()\n  local isWeapon = false\n  if types.Actor.stance(self) == types.Actor.STANCE.Weapon then\n    local usedWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n    if (not usedWeapon) then -- handtohand\n      isWeapon = incH2H\n    else\n      if  not types.Lockpick.objectIsInstance(usedWeapon) and not types.Probe.objectIsInstance(usedWeapon) then\n        local weaponType = Weapon.record(usedWeapon).type\n        if (weaponType < 9) then -- melee weapon\n          isWeapon = true\n        elseif (weaponType <= 13) then -- ranged weapon\n          isWeapon = incRanged\n        elseif (weaponType > 13) then -- unknown weapon\n          isWeapon = true\n        end\n      end\n    end \n  end\n  return(isWeapon)\nend\n\nlocal function getChargeMod()\n  -- get relevant stats\n  local strength = attributes.strength(self).modified\n  local usedWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n  local weapWeight = 1\n  if not (not usedWeapon) then -- NOT handtohand\n  weapWeight = Weapon.record(usedWeapon).weight\n  end\n  -- setup mod\n  --local buffMod = (1 + math.sqrt(weapWeight))*(50/strength)\n  --local buffMod = (1 + math.sqrt(weapWeight))*math.max(0,(2.5-(strength/50)))\n  local buffMod = (1 + math.sqrt(weapWeight))*(100/(strength+50))\n    -- mod up as weapon weight up, with minimum\n    -- mod down as strength up\n  return(buffMod)\nend\n\nlocal function getReleaseMod(chargeTime)\n  -- get relevant stats\n  local usedWeapon = types.Actor.equipment(self, types.Actor.EQUIPMENT_SLOT.CarriedRight)\n  local weapSpeed = 1\n  local weapWeight = 1\n  if not (not usedWeapon) then -- NOT handtohand\n  weapSpeed = Weapon.record(usedWeapon).speed\n  weapWeight = Weapon.record(usedWeapon).weight\n  end\n  -- setup mod\n  local buffMod = (1 + math.sqrt(weapWeight))*math.min(maxCharge,(chargeTime*weapSpeed))--/weapSpeed\n    -- mod up as weapon weight up, with minimum\n    -- mod up as charge increases, vs weapon speed\n    -- mod up as weapon speed up?\n  return(buffMod)\nend\n\n-- save state to be removed on load\nlocal function onSave()\n    return{\n      chargeBuffTotal = chargeBuffTotal,\n\t  buffType = buffType\n    }\nend\n\nlocal function onLoad(data)\n  if data then\n    chargeBuffTotal = data.chargeBuffTotal\n\tbuffType = data.buffType\n    chargeMod(-1,chargeBuffTotal[1])\n    releaseMod(-1,chargeBuffTotal[2],buffType)\n    for i=1,maxStance,1 do\n      chargeBuffTotal[i] = 0\n    end\n  end\nend\n\nlocal weaponWeight = 0\nlocal chargeTime = 0\nlocal doBuff = false\nlocal isCharge = false -- true if trigger input action\nlocal isWeapon = false\nreturn { \n  engineHandlers = { \n    -- init settings\n    onActive = init,\n    -- save and load handling so you don't get stuck with modified stats\n    onSave = onSave,\n    onLoad = onLoad,\n    \n    onUpdate = function(dt)\n      if core.API_REVISION > 60 and I.UI.getMode() ~= nil then return end\n      if enabled then\n        local isUse = input.isActionPressed(input.ACTION.Use)\n        \n        if isUse and not isCharge then -- on first frame you hit use        \n--        if isUse and not isCharge and not types.Actor.isOnGround(self) then -- on first frame you hit use        \n          isCharge = true -- update stance\n          isWeapon = weaponCheck()\n          -- apply charge debuff\n          if isWeapon then\n            chargeTime = core.getSimulationTime() -- set timer value\n            local buffNext = hybridVal(stanceBuff[1],getChargeMod(),1)\n            chargeMod(1,buffNext)\n            chargeBuffTotal[1] = chargeBuffTotal[1] + buffNext\n            if verbose>0 and not integrateParry and not hideChargePopup then\n              ui.showMessage(stanceNames[3] .. ' ' .. tostring(chargeBuffTotal[1]))\n            end\n          end\n          \n        elseif not isUse and isCharge then -- on first frame you release use\n          isCharge = false\n          -- remove charge debuff\n          chargeMod(-1,chargeBuffTotal[1])\n          chargeBuffTotal[1] = 0\n          if isWeapon and chargeBuffTotal[2]==0 then -- only buff if unbuffed\n            chargeTime = core.getSimulationTime() - chargeTime -- get timer value\n            -- check if applying buff\n            doBuff = true\n            if integrateParry then\n              local ig = types.Actor.isOnGround(self)\n              local is = types.Actor.isSwimming(self)\n              local mf = self.controls.movement\n              local ms = self.controls.sideMovement\n              if (ig or is) and mf == -1 then -- backwards component\n                doBuff = false -- def\n              elseif (ig or is) and mf == 0 and ms ~= 0 then -- sideways only\n                doBuff = false -- agi\n              end\n            end\n      \n            if doBuff then\n              -- get release buff\n              local buffNext = hybridVal(stanceBuff[2],getReleaseMod(chargeTime),1)\n              -- fatigue cost\n              local cfat = dynamic.fatigue(self).current\n              local strength = attributes.strength(self).modified\n              local fatigueCost = math.ceil(fatigueMult*buffNext*100/(strength+50))\n              dynamic.fatigue(self).current = math.max(0,cfat - fatigueCost)\n              -- buff accuracy or strength depending on isGrounded and config val\n              if buffControl == 0 then\n                if (types.Actor.isOnGround(self) or types.Actor.isSwimming(self)) then\n                  buffType = 2 -- acc\n                else\n                  buffType = 1 -- str\n                end\n              else\n                buffType = buffControl\n              end\n              -- apply buff\n              releaseMod(1,buffNext,buffType)\n              chargeBuffTotal[2] = chargeBuffTotal[2] + buffNext\n              -- status info\n              if verbose>0 then\n                local buffMax = hybridVal(stanceBuff[2],getReleaseMod(maxCharge),1)\n                if buffType == 1 then\n                  ui.showMessage(stanceNames[1] .. ' ' .. tostring(chargeBuffTotal[2]) .. ' / ' .. tostring(buffMax))\n                else\n                  ui.showMessage(stanceNames[2] .. ' ' .. tostring(chargeBuffTotal[2]) .. ' / ' .. tostring(buffMax))\n                end\n              end\n              -- start release timer\n              async:newUnsavableSimulationTimer(\n                buffDuration,\n                function()\n                  releaseMod(-1,chargeBuffTotal[2],buffType)\n                  chargeBuffTotal[2] = 0\n                end\n              )\n            end\n          end\n        end\n      end\n    end\n  }\n}"
  }
}