{
  "folder_name": "Gentler Racemenu",
  "lua_files": {
    "Gentler_Racemenu-54142-1-05-1716520588\\scripts\\Gentler_Racemenu\\core.lua": "local self  = require('openmw.self')\nlocal types = require('openmw.types')\nlocal i_UI  = require('openmw.interfaces').UI\nlocal ui    = require('openmw.ui')\nlocal storage  = require('openmw.storage')\nlocal async    = require('openmw.async')\n\nlocal Compat = require('scripts.gentler_racemenu.data').Compat\nlocal Dt     = require('scripts.gentler_racemenu.data').Dt\nlocal Fn     = require('scripts.gentler_racemenu.func')\nlocal Mui    = require('scripts.gentler_racemenu.modui')\n\nlocal function get_val(not_table_or_func)   return not_table_or_func end\n\nFn.get_birthsigns()\nFn.get_races()\nFn.enable_compat_modules()\n\nlocal exit_check = false\n\nUiModeChanged = function(data)\n  if donechargen then\n    if data.newMode then table.insert(Dt.last3uimodes, 1, data.newMode) else table.insert(Dt.last3uimodes, 1, false) end\n    Dt.last3uimodes[4] = nil\n    if Fn.is_entering(data.newMode) then\n\t\t\tif Mui.getSetting('Migration_Mode') then return end\n      Fn.set_data_stats()\n    elseif Fn.is_exiting(data.oldMode,data.newMode) then\n      -- Request onUpdate to do an exit check, since we may be simply switching to another racemenu window.\n      Dt.exit_check = true\n    end\n  end\nend\n\nlocal function onUpdate()\n  if donechargen then\n    if not Dt.exit_check then return end\n    if Fn.is_editmode(i_UI.getMode()) then\n      switching = true\n      Dt.exit_timer = 0\n      Dt.exit_check = false\n    elseif Dt.exit_timer < 9.99 then\n      Dt.exit_timer = Dt.exit_timer + 1\n    elseif Dt.exit_timer > 9.99 then\n      Fn.set_openmw_stats()\n      Dt.exit_timer = 0\n      Dt.exit_check = false\n    end\n  elseif types.Player.isCharGenFinished(self) then\n  donechargen = true\n  end\nend\n\nlocal onInit = function()\n\tMui.loadPreset('current')\nend\nlocal onSave = function()\n\tMui.savePreset('current')\nend\nlocal onLoad = function(_)\n\tMui.loadPreset('current')\n  if not Mui.Settings_GRM_Options.section:get('Migration_Mode') then return end\n\tfor k, v in pairs(storage.playerSection(\"GRM_Migration_Data\"):asTable()) do\n\t\tDt[k] = v\n\tend\n  async:newUnsavableSimulationTimer(1, function()\n    --if not Mui.Settings_GRM_Options.section:get('Migration_Mode') then return end\n\t  i_UI.setMode('ChargenClassReview') \n\tend)\nend\n\nreturn {\n  engineHandlers = {\n    onUpdate = onUpdate,\n    onInit   = onInit  ,\n    onSave   = onSave  ,\n    onLoad   = onLoad  ,\n  },\n  eventHandlers = {\n    UiModeChanged = UiModeChanged,\n\t\tgrm_itemAdded = function(item)\n\t\t\tif types.Weapon.record(item).id == 'grm_mwbolt' then\n\t\t\t\tFn.applyMWBolt(item)\n\t\t\tend\n\t\tend,\n    grm_startMigration = function(_)\n\t\t\tFn.set_data_stats() -- dirty sandwitch, but it works\n\t\t\tlocal data = {}\n\t\t\tfor _, key in ipairs{'pc_attributes', 'pc_skills', 'pc_dynamic', 'pc_level', 'pc_spells', 'pc_factions'} do\n        data[key] = Dt[key]\n\t\t\tend\n      storage.playerSection(\"GRM_Migration_Data\"):reset(data)\n      storage.playerSection(\"GRM_Migration_Data\"):setLifeTime(storage.LIFE_TIME.Persistent)\n\t\t\ttypes.Player.sendMenuEvent(self, 'grm_saveAndQuit', {\n\t\t\t\tdescription = 'RaceMenu will open after a short delay and Migration Mode will end afterwards. Make sure you\\'ve done your desired mod changes',\n\t\t\t\tslotname = 'GRM - Migration Mode Save',\n\t\t\t})\n\t\t  --Mui.setSetting('Migration_Mode', false)\n\t\tend\n  }\n}\n",
    "Gentler_Racemenu-54142-1-05-1716520588\\scripts\\Gentler_Racemenu\\data.lua": "\n-- TOOLS\n-----------------------------------------------------------------------------------------------------------\n\nfunction DEBUG(...)\n\tif Mui.getSetting('GRM_DEBUG') then print(...) end\nend\n\nlocal function array_concat(array, ...)\n  for _, t in ipairs({...}) do\n    for _, v in ipairs(t) do table.insert(array, v) end\n  end\n  return array\nend\n\n-- COMPATIBILITY DATA\n-----------------------------------------------------------------------------------------------------------\n\nlocal Compat = {\n  swapping_mods = false,\n  MODULES = {},\n  enabled = {},\n  modules = {\n    default = {\n\t\t\tcontent_files = {},\n\t\t\tdependencies = {},\n\t\t\tapply = function() end\n\t\t},\n    new  = function(self, t)  end,\n    edit = function(self, t)  end,\n  },\n\tscripts = {}, -- array of scriptid\n\tspells = {}, -- array of spellid\n\tglobals = {}, -- table of GLOBid -> val\n}\n\n-- COMPATIBILITY MODULES\n-----------------------------------------------------------------------------------------------------------\n\n--[] Set defaults for Compat.modules and setup metatable inheritance\n\nCompat.modules.mt = {__index = Compat.modules.default}\nsetmetatable(Compat.modules, Compat.modules.mt)\n\nfunction Compat.modules:new(t)\n  if (t.name) then self[t.name] = {} else error('You can\\'t create a nameless module!') end\n  table.insert(Compat.MODULES, t.name)\n  if t['dependencies']  then self[t.name]['dependencies']  = t['dependencies']  end\n  if t['apply']         then self[t.name]['apply']         = t['apply']         end\n  if t['content_files'] then self[t.name]['content_files'] = t['content_files']\n    for _i, _filename in ipairs(t['content_files']) do\n      self[t.name]['content_files'][_i] = string.lower(_filename)\n    end\n  end  -- set inheritance\n  self[t.name].mt = {__index = self.default}\n  setmetatable(self[t.name], self[t.name].mt)\nend\n\n-- COMPATIBILITY MODULE DEFINITIONS\n-----------------------------------------------------------------------------------------------------------\nCompat.modules:new{ name ='sensiblebirthsigns',\n  content_files = {'SensibleBirthsigns.esp'},\n  apply = function()\n    array_concat(Compat.spells, {'_shadowKin'})\n\t\tarray_concat(Compat.scripts, {'grm_compat_KI_birthsign_start'})\n  end\n}\n\nCompat.modules:new{ name ='sensibleraces',\n  content_files = {'SensibleRaces.esp'},\n  apply = function()\n    array_concat(Compat.spells, {'_racialArgonian_01', '_racialBosmer_01', '_racialImperial_01', '_racialKhajiit_01'})\n\t\tarray_concat(Compat.scripts, {'grm_compat_KI_racialToggle_start'})\n\tend\n}\n\nCompat.modules:new{ name ='reincarnate',\n  content_files = {'Reincarnate - Races of Morrowind.ESP'},\n  apply = function()\n    array_concat(Compat.spells, {'racial_argonian_ability_2_perk', 'racial_khajiit_ability_1_perk', 'racial_khajiit_ability_2_perk'})\n\t\tarray_concat(Compat.scripts, {'grm_compat_racial_startup'})\n\tend\n}\n\n-- MOD DATA\n-----------------------------------------------------------------------------------------------------------\n\nlocal Dt = {\n-- Player Data\n  pc_attributes = {},\n  pc_skills = {},\n\tpc_dynamic = {},\n  pc_level = 0,\n  pc_spells = {},\n\tpc_factions = {\n\t\t-- faction_id = {rank = 0, reputation = 0, expelled = bool}\n\t},\n-- Compatibility and Engine Data\n  RACES = {},\n\tPCRACE = {\n\t\t['argonian'] = 1,\n\t\t['breton'  ] = 2,\n\t\t['dark elf'] = 3,\n\t\t['high elf'] = 4,\n\t\t['imperial'] = 5,\n\t\t['khajiit' ] = 6,\n\t\t['nord'    ] = 7,\n\t\t['orc'     ] = 8,\n\t\t['redguard'] = 9,\n\t\t['wood elf'] = 10,\n\t},\n  BIRTHSIGNS = {},\n  ATTRIBUTES = {'strength', 'intelligence', 'willpower', 'agility', 'speed', 'endurance', 'personality', 'luck'},\n  SKILLS = {\n    'acrobatics' , 'alchemy'  , 'alteration' , 'armorer'   , 'athletics' , 'axe'       , 'block'    , 'bluntweapon', 'conjuration',\n    'destruction', 'enchant'  , 'handtohand' , 'heavyarmor', 'illusion'  , 'lightarmor', 'longblade', 'marksman'   , 'mediumarmor',\n    'mercantile' , 'mysticism', 'restoration', 'security'  , 'shortblade', 'sneak'     , 'spear'    , 'speechcraft', 'unarmored'\n  },\n  specialization = {\n    COMBAT  = {'athletics' ,'block'   ,'longblade'  ,'bluntweapon','axe'       ,'spear'   ,'mediumarmor','heavyarmor' ,'armorer'},\n    MAGIC   = {'alchemy'   ,'enchant' ,'conjuration','destruction','mysticism' ,'illusion','unarmored'  ,'alteration' ,'restoration'},\n    STEALTH = {'lightarmor','marksman','sneak'      ,'handtohand' ,'shortblade','security','mercantile' ,'speechcraft','acrobatics'},\n  },\n  races = {\n    default = {\n      skills = {},\n      attributes_male = {},\n      attributes_female = {},\n      spells = {},\n      PCRace = 0\n    },\n    new  = function(self, t)  end,\n    edit   = function(self, t)  end,\n    delete = function(self, name) end,\n  },\n  birthsigns = { -- Created records follow the following pattern -> birthsigns = {name = {spells, spells2, ..etc}, name2 = {...}, ..etc}\n    default = {},\n    new  = function(self, t)  end,\n  },\n\tknown_spells = {\n    -- VANILLA\n    'resist disease_75', 'immune to poison', 'argonian breathing',\n    'magicka mult bonus_5', 'resist magicka_50', 'dragon skin',\n    'ancestor guardian', 'resist fire_75',\n    'magicka mult bonus_15', 'weakness magicka_50', 'weakness fire_50', 'weakness frost_25', 'weakness shock_25', 'resist disease_75',\n    'star of the west', 'voice of the emperor',\n    'eye of night', 'eye of fear',\n    'immune to frost', 'resist shock_50', 'woad', 'thunder fist',\n    'resist magicka_25', 'orc_beserk',\n    'resist disease_75', 'resist poison_75', 'adrenaline rush',\n    'resist disease_75', 'beast tongue',\n    -- REINCARNATE - RACES OF MORROWIND\n    'racial_altmer_ability_1' ,'racial_altmer_ability_2' ,'racial_altmer_power',\n    'racial_argonian_ability_1' ,'racial_argonian_ability_2_spell' ,'racial_argonian_power' ,'racial_argonian_ability_2_perk',\n    'racial_bosmer_ability_1' ,'racial_bosmer_ability_2' ,'racial_bosmer_power',\n    'racial_breton_ability_1' ,'racial_breton_ability_2' ,'racial_breton_power',\n    'racial_dunmer_ability_1' ,'racial_dunmer_ability_2' ,'racial_dunmer_power',\n    'racial_imperial_ability_1' ,'racial_imperial_ability_2' ,'racial_imperial_power',\n    'racial_khajiit_ability_1_spell' ,'racial_khajiit_ability_2_spell' ,'racial_khajiit_ability_3', 'racial_khajiit_power', 'racial_khajiit_ability_1_perk', 'racial_khajiit_ability_2_perk',\n    'racial_nord_ability_1' ,'racial_nord_ability_2' ,'racial_nord_power',\n    'racial_orc_ability_1' ,'racial_orc_ability_2' ,'racial_orc_power',\n    'racial_redguard_ability_1' ,'racial_redguard_ability_2' ,'racial_redguard_power',\n    -- a'Ђь\bi\"0pla, Ђь\bi || macro: append clipboard as list item\n    -- o'Ђь\bi\"0pla, Ђь\bi || macro: append clipboard as list item, in new line\n  },\n  EDITMODES = {\n    'ChargenName',\n    'ChargenClass',\n    'ChargenClassGenerate',\n    'ChargenClassPick',\n    'ChargenClassCreate',\n    'ChargenClassReview',\n    'ChargenBirth',\n    'ChargenRace',\n  },\n-- Internal Script Data\n  last3uimodes = {},\n  exit_check = false,\n  exit_timer = 0,\n}\n\n-- RACE MANIPULATION\n-----------------------------------------------------------------------------------------------------------\n\nfunction Dt.races:new(t)\n  if (t.name) then self[t.name] = {} else error('You can\\'t create a nameless race!') end\n  table.insert(Dt.RACES, t.name)\n  if t.spells then self[t.name].spells = t.spells end\n  vars = {'skills','attributes_male', 'attributes_female'}\n  for _, _var in ipairs(vars) do\n    self[t.name][_var] = t[_var]\n  end\n  table.insert(Dt.RACES, t.name)\nend\n\nfunction Dt.races:edit(t)\n  if not t.name then error('You must create a race before editing it!') end\n    if t.spells then self[t.name].spells = t.spells end\n  vars = {'skills','attributes_male', 'attributes_female'}\n  for _, _var in ipairs(vars) do\n    if t[_var] then\n      for _stat, _value in pairs(t[_var]) do\n        if t[_var][_stat] then self[t.name][_var][_stat] = t[_var][_stat] end\n      end\n    end\n  end\nend\n\n-- BIRTHSIGN MANIPULATION\n-----------------------------------------------------------------------------------------------------------\n\nfunction Dt.birthsigns:new(t)\n  if (t.id) then\n\t\t\tself[t.id] = {}\n\t\telse\n\t\t\terror('You can\\'t create a nameless birthsign!')\n\t\tend\n  if t.spells then self[t.id] = t.spells end\n  table.insert(Dt.BIRTHSIGNS, t.id)\nend\n\n-- RETURN || NEED THIS SO FILE DO THING\nreturn {Dt = Dt, Compat = Compat}\n",
    "Gentler_Racemenu-54142-1-05-1716520588\\scripts\\Gentler_Racemenu\\func.lua": "local core  = require('openmw.core')\nlocal self  = require('openmw.self')\nlocal types = require('openmw.types')\n\nlocal Dt     = require('scripts.gentler_racemenu.data').Dt\nlocal Compat = require('scripts.gentler_racemenu.data').Compat\nlocal Mui    = require('scripts.gentler_racemenu.modui')\n\n-- TOOLS\nlocal eps = 0.001\nfunction equal(a,b) return (math.abs(b - a) < eps) end\nlocal function get_val(not_table_or_func) return not_table_or_func end\nlocal function table_find(table, thing)\n  if type(thing) == 'number' then\n    for k, v in pairs(table) do\n      if equal(v, thing) then return thing end\n    end\n  else\n    for k, v in pairs(table) do\n      if v == thing then return thing end\n    end\n  end\nend\n\nfunction DEBUG(...)\n\tif Mui.getSetting('GRM_DEBUG') then print(...) end\nend\nfunction FILL(n, str) return string.rep(' ', math.max(0, n - #str)) end\nfunction STAT_Accounted(increase, fromrace, fromability)\n\tlocal message = ''\n\tlocal show = {}\n\tif fromrace    ~= 0 then table.insert(show, tostring(fromrace)..' from race stats') end\n\tif fromability ~= 0 then table.insert(show, tostring(fromability)..' from magic abilities') end\n\tif #show > 0 then\n\t\tif increase == '+' then message = 'Restored ' else message = 'Removed ' end\n\t\tmessage = message..table.concat(show, ', and ')..'.'\n\tend\n\treturn message\nend\nfunction DEBUG_TOTALSTATS()\n\tlocal attr = 0\n\tlocal skill = 0\n\tfor _, id in ipairs(Dt.ATTRIBUTES) do\n\t\tattr = attr + types.NPC.stats.attributes[id](self).base\n\tend\n\tfor _, id in ipairs(Dt.SKILLS) do\n\t\tskill = skill + types.NPC.stats.skills[id](self).base\n\tend\n\tDEBUG('Total Attribute points: '..tostring(attr)..' | Total Skill Points: '..tostring(skill))\nend\n\nfunction toTable(userdata)\n\tt = {}\n\tfor k, v in pairs(userdata) do\n\t\tt[k] = v\n\tend\n\treturn t\nend\n\n-- DEFINITIONS --\n-----------------------------------------------------------------------------------------------------------\nlocal Fn = {\n  get_birthsigns     = function() end, -- Dynamically populate Dt.birthsigns with all loaded birthsigns and their corresponding spell lists.\n\n  is_entering      = function(oldmode, newmode) end, -- return editmode if entering, nil otherwise\n  is_exiting       = function(oldmode, newmode) end, -- return editmode if exiting , nil otherwise\n\n  get_abilitymodifiers = function(kind, stat) end, -- return ability_fortify_points for kind.stat, 0 if none.\n\n  set_data_stats     = function() end,-- set all internal stats using the current gamestate\n  set_openmw_stats   = function() end,-- set the player's stats using internal data\n}\n-----------------------------------------------------------------------------------------------------------\n\n--[] Module Enabler: finds all compatible mods in load order and builds Compat.enabled accordingly\nFn.enable_compat_modules = function()\n  local to_enable = {}\n  -- Loop over all available compatibility modules, see if they need enabling and add them to the list if their dependencies are met\n  for _, _module in ipairs(Compat.MODULES) do\n    local loaded = {}\n    -- Loop over all of the module's content files, if we find any then mark module as loaded and break\n    for _, _content_file in ipairs (Compat.modules[_module].content_files) do\n      if core.contentFiles.has(_content_file) then table.insert(loaded, _module) break end\n    end\n    -- loop over all loaded modules (since they were indexed by load order this also follows said order) and make sure all their dependencies are fulfilled.\n    for _index, _ in ipairs(loaded) do\n      dependencies_fulfilled = true\n      for _, _dependency in ipairs(Compat.modules[_module].dependencies) do\n        if not table_find(to_enable, _dependency) then dependencies_fulfilled = false print('GRM - Missing module dependency.. '.._module) break end\n      end\n      if dependencies_fulfilled then table.insert(to_enable, _module) end\n    end\n  end\n  -- Enable all modules that need enabling, and add them to the enabled list for further use.\n  for _, _module in ipairs(to_enable) do\n    Compat.modules[_module].apply()\n    Compat.enabled[_module] = true\n\t\tDEBUG('Compatibility Module Enabled:', _module)\n  end\nend\n\nFn.applyMWBolt = function(mwbolt)\n  local equipment = types.Actor.getEquipment(self)\n  local pcammo = types.Actor.getEquipment(self, types.Actor.EQUIPMENT_SLOT.Ammunition)\n  equipment[types.Actor.EQUIPMENT_SLOT.Ammunition] = mwbolt\n  types.Actor.setEquipment(self, equipment)\n  equipment[types.Actor.EQUIPMENT_SLOT.Ammunition] = pcammo\n  types.Actor.setEquipment(self, equipment)\n  DEBUG('MWBolt applied.')\n  core.sendGlobalEvent('grm_removeItem', {source = self, item = mwbolt, count = 1})\nend\n\nFn.get_birthsigns = function()\n  for _, _birthsign in ipairs(types.Player.birthSigns.records) do\n    Dt.birthsigns:new{\n      id = _birthsign.id,\n      spells = _birthsign.spells\n    }\n\t\tDEBUG('Birthsign loaded:', _birthsign.name)\n  end\nend\nFn.get_races = function()\n  for _, race in ipairs(types.NPC.races.records) do\n  \tif not race.isPlayable then return end\n  \tlocal attr_male = {}\n  \tlocal attr_female = {}\n  \tfor id, _ in pairs(race.attributes) do\n  \t\tattr_male[id]   = race.attributes[id].male\n  \t  attr_female[id] = race.attributes[id].female\n  \tend\n\t\tlocal skills_with_0s = race.skills\n\t\tfor _, id in ipairs(Dt.SKILLS) do\n\t\t\tif not skills_with_0s[id] then skills_with_0s[id] = 0 end\n    end\n\t  Dt.races:new{\n  \t\tname   = race.id,\n      spells = race.spells,\n  \t\tskills = skills_with_0s,\n      attributes_male   = attr_male,\n  \t\tattributes_female = attr_female,\n  \t}\n\t\tdo local spells = {}\n\t\t\tfor _, id in ipairs(race.spells) do \n\t\t\t\tif not race.spells then \n\t\t\t\t\tprint(race.id..' has no spells') \n\t\t\t\telse \n\t\t\t\t\ttable.insert(spells, core.magic.spells.records[id].name) \n\t\t\t\tend \n\t\t\tend\n\t\t\tDEBUG('Race Loaded: '..race.name..FILL(8, race.name)..' | Spells: ['..table.concat(spells, ', ')..']')\n\t\tend\n  end\nend\n\nFn.is_editmode = function(mode)\n  for _,_editmode in ipairs(Dt.EDITMODES) do\n    if _editmode == mode then return true end\n  end\n  return false\nend\nFn.is_switching = function()\n  if Fn.is_editmode(Dt.last3uimodes[3]) then return true end\nend\n\nFn.is_entering = function(newmode)\n  if Fn.is_switching() then return false end\n  if Fn.is_editmode(newmode) then return get_val(newmode) end\nend\n\nFn.is_exiting = function(oldmode, newmode)\n  if newmode and newmode ~= 'Interface' then return false end\n  if Fn.is_editmode(oldmode) then return true end\nend\n\nFn.get_abilitymodifiers = function(kind, stat)\n    local API_Spelltype_Ability = get_val(core.magic.SPELL_TYPE.Ability)\n    local fortify = 0\n    local getmodifier = function() end\n    -- Create the appropriate 'getmodifier' check for the kind and stat being updated:\n    if   kind == 'skills'   then\n      getmodifier = function(_effect) if _effect.affectedSkill   == stat then fortify = fortify + _effect.magnitudeThisFrame end end\n    elseif kind == 'attributes' then\n      getmodifier = function(_effect) if _effect.affectedAttribute == stat then fortify = fortify + _effect.magnitudeThisFrame end end\n    end\n    for _id, _params in pairs(types.Actor.activeSpells(self)) do\n      if core.magic.spells.records[_params.id] then -- we only wanna check SPELL types, since abilities never come from enchantments\n        local spell_type = get_val(core.magic.spells.records[_params.id].type)\n        if equal(spell_type, API_Spelltype_Ability) then -- if it's not an ability, then we don't care about it\n          for _, _effect in pairs(_params.effects) do\n            getmodifier(_effect) -- Check if the effect affects [kind.stat] and if it does then add it's magnitude to fortify\n          end\n        end\n      end\n    end\n    return fortify\nend\n\nFn.set_data_stats = function(mode)\n\n  local gender = 'female'\n  if types.NPC.record(self).isMale then gender = 'male' end\n\n  local race = types.NPC.record(self).race\n\tDEBUG('Race:', types.NPC.races.record(race).name, '| Spells:', Dt.races[race].spells)\n\n  Dt.pc_level = get_val(types.Player.stats.level(self).current)\n\tDEBUG('Saved Level:', level)\n\n\tfor _, factionid in ipairs(types.NPC.getFactions(self)) do\n\t\tDt.pc_factions[factionid] = {\n\t\t  rank = types.NPC.getFactionRank(self, factionid),\n\t\t  reputation = types.NPC.getFactionReputation(self, factionid),\n\t\t\texpelled = types.NPC.isExpelled(self, factionid),\n\t\t}\n\t  DEBUG('Saved Faction Status:', factionid, '| Rank:', Dt.pc_factions[factionid].rank, '| Reputation:', Dt.pc_factions[factionid].reputation, '| Expelled?', Dt.pc_factions[factionid].expelled)\n\tend\n\n\tif not Mui.getSetting('Keep_Stats_Unchanged') then\n    DEBUG('Saving ATTRIBUTES...')\n\t  for _, _name in ipairs(Dt.ATTRIBUTES) do\n\t  \tlocal base    = types.Player.stats.attributes[_name](self).base\n\t  \tlocal race    = Dt.races[race]['attributes_'..gender][_name]\n\t  \tlocal ability = Fn.get_abilitymodifiers('attributes',_name)\n      Dt.pc_attributes[_name] = base - race - ability\n\t  \tDEBUG(_name..FILL(12, _name)..': '..base - race - ability..' || '..STAT_Accounted('-', race, ability))\n    end\n    DEBUG('Saving SKILLS...')\n    for _, _name in ipairs(Dt.SKILLS) do\n      local base    = types.Player.stats.skills[_name](self).base\n      local race    = Dt.races[race].skills[_name]\n      local ability = Fn.get_abilitymodifiers('skills',_name)\n      Dt.pc_skills[_name] = base - race - ability\n\t  \tDEBUG(_name..FILL(12, _name)..': '..base - race - ability..' || '..STAT_Accounted('-', race, ability))\n    end\n    DEBUG('Removing Class Bonuses...')\n    local API_class = types.Player.classes.record(types.Player.record(self).class)\n    Dt.pc_attributes[API_class.attributes[1]] = Dt.pc_attributes[API_class.attributes[1]] - 10\n    Dt.pc_attributes[API_class.attributes[2]] = Dt.pc_attributes[API_class.attributes[2]] - 10\n    DEBUG('Favoured Attributes reduced by 10: ['..API_class.attributes[1]..', '..API_class.attributes[2]..']')\n    for _i, _skill in ipairs(API_class.majorSkills) do\n      Dt.pc_skills[_skill] = Dt.pc_skills[_skill] - 25\n    end\n\t  DEBUG('Major skills reduced by 25: ['..table.concat(toTable(API_class.majorSkills), ', ')..']')\n    for _, _skill in ipairs(API_class.minorSkills) do\n      Dt.pc_skills[_skill] = Dt.pc_skills[_skill] - 10\n    end\n\t  DEBUG('Minor skills reduced by 10: ['..table.concat(toTable(API_class.minorSkills), ', ')..']')\n    for _, _skill in ipairs(Dt.specialization[string.upper(API_class.specialization)]) do\n      Dt.pc_skills[_skill] = Dt.pc_skills[_skill] - 5\n    end\n\t  DEBUG(string.upper(API_class.specialization)..' skills reduced by 5: ['..table.concat(Dt.specialization[string.upper(API_class.specialization)], ', ')..']')\n\telse\n    DEBUG('Saving ATTRIBUTES...')\n\t  for _, _name in ipairs(Dt.ATTRIBUTES) do\n\t  \tlocal base    = types.Player.stats.attributes[_name](self).base\n\t  \tlocal ability = Fn.get_abilitymodifiers('attributes',_name)\n      Dt.pc_attributes[_name] = base - ability\n\t  \tDEBUG(_name..FILL(12, _name)..': '..base - ability..' || '..STAT_Accounted('-', 0, ability))\n    end\n    DEBUG('Saving SKILLS...')\n    for _, _name in ipairs(Dt.SKILLS) do\n      local base    = types.Player.stats.skills[_name](self).base\n      local ability = Fn.get_abilitymodifiers('skills',_name)\n      Dt.pc_skills[_name] = base - ability\n\t  \tDEBUG(_name..FILL(12, _name)..': '..base - ability..' || '..STAT_Accounted('-', 0, ability))\n    end\n\n\tend\n\n\tlocal str_factor = types.NPC.stats.attributes.strength(self).base * 0.5\n\tlocal end_factor = types.NPC.stats.attributes.endurance(self).base * 0.5\n\tDt.pc_dynamic.health = types.Actor.stats.dynamic.health(self).base - end_factor - str_factor - Fn.get_abilitymodifiers('fortifyhealth')\n\tDEBUG('Storing HP: '..string.format(\"%.1f\", tostring(Dt.pc_dynamic.health))..' | Removed '..tostring(str_factor)..' from STR and '..tostring(end_factor)..' from END')\n  if Mui.getSetting('Force_Dynamic_Stats') then\n\t  DEBUG('Saving Dynamic Stats...')\n    local xint = types.Actor.stats.attributes.intelligence(self).modified * Fn.get_abilitymodifiers('fortifymaximummagicka')\n\t\tDt.pc_dynamic.magicka = - xint\n\t\tfor _, stat in ipairs{'health', 'magicka', 'fatigue'} do\n\t\t\tDt.pc_dynamic[stat] = types.Actor.stats.dynamic[stat](self).base - Fn.get_abilitymodifiers('fortify'..stat)\n\t\tend\n\t  DEBUG('Storing HP: '..string.format(\"%.1f\", tostring(Dt.pc_dynamic.health)))\n\t  DEBUG('Storing MP: '..string.format(\"%.1f\", tostring(Dt.pc_dynamic.magicka)))\n\t\tDEBUG('Storing FP: '..string.format(\"%.1f\", tostring(Dt.pc_dynamic.fatigue)))\n\tend\n\n  Dt.pc_spells = {}\n  for _, _spell in ipairs(types.Player.spells(self)) do -- Add all player spells\n    Dt.pc_spells[_spell.id] = _spell.id\n  end\n  local birthsign = types.Player.birthSigns.record(types.Player.getBirthSign(self))\n\tif birthsign then\n    for _, _id in ipairs(Dt.birthsigns[birthsign.id]) do\n      Dt.pc_spells[_id] = nil\n    end\n  \tdo local spells = {}\n  \t  for _, id in ipairs(Dt.birthsigns[birthsign.id]) do table.insert(spells, core.magic.spells.records[id].name) end\n    \tDEBUG('Removing Birthsign Spells: '..birthsign.name..' | Spells: ['..table.concat(spells, ', ')..']')\n    end\n\tend\n  for _, _id in ipairs(Dt.races[race].spells) do\n    Dt.pc_spells[_id] = nil\n  end\n\tdo local spells = {}\n\t  for _, id in ipairs(Dt.races[race].spells) do table.insert(spells, core.magic.spells.records[id].name) end\n  \tDEBUG('Removing Racial Spells: '..types.NPC.races.record(race).name..' | Spells: ['..table.concat(spells, ', ')..']')\n  end\n  for _, _id in ipairs(Compat.spells) do\n    Dt.pc_spells[_id] = nil\n  end\n\tdo local spells = {}\n\t  for _, id in ipairs(Compat.spells) do table.insert(spells, core.magic.spells.records[id].name) end\n  \tDEBUG('Removing Scripted Race/Birthsign Spells: ['..table.concat(spells, ', ')..']')\n  end\n\tif Mui.getSetting('Purge_Spells') then\n\t\tfor _, spellid in ipairs(Dt.known_spells) do\n\t\t\tDt.pc_spells[spellid] = nil\n\t\tend\n\t\tDEBUG('Purging all known race and birthsign spells from player list...')\n\tend\n\tdo local spells = {}\n\t  for _, id in pairs(Dt.pc_spells) do table.insert(spells, core.magic.spells.records[id].name) end\n  \tDEBUG('Saved Player Spells: ['..table.concat(spells, ', ')..']')\n  end\n\n  for _, _spell in ipairs(types.Player.spells(self)) do\n    types.Player.spells(self):remove(_spell.id)\n  end\n\tDEBUG('Clearing Player Spells... done.')\n\nend\n\nFn.set_openmw_stats = function()\n  local gender = 'female'\n  if types.Player.record(self).isMale then gender = 'male' end\n  local race = types.NPC.record(self).race\n  local newattributes = {}\n  local newskills = {}\n\tfor factionid, faction in pairs(Dt.pc_factions) do\n\t\ttypes.NPC.setFactionRank(self, factionid, faction.rank)\n\t\ttypes.NPC.setFactionReputation(self, factionid, faction.reputation)\n\t  DEBUG('Restored Faction Status:', factionid, '| Rank:', faction.rank, '| Reputation:', faction.reputation, '| Expelled?', faction.expelled)\n\tend\n\tif not Mui.getSetting('Keep_Stats_Unchanged') then\n\t\tDEBUG('Restoring ATTRIBUTES...')\n    for _name, _attribute in pairs(Dt.pc_attributes) do\n\t  \tlocal base    = Dt.pc_attributes[_name]\n\t\t\tlocal race    = Dt.races[race]['attributes_'..gender][_name]\n\t\t\tlocal ability = Fn.get_abilitymodifiers('attributes',_name)\n      newattributes[_name] = base + race + ability\n\t  \tDEBUG(_name..FILL(12, _name)..': '..base + race + ability..' || '..STAT_Accounted('+', race, ability))\n    end\n\t\tDEBUG('Restoring SKILLS...')\n    for _name, _skill in pairs(Dt.pc_skills) do\n\t  \tlocal base    = Dt.pc_skills[_name]\n\t\t\tlocal race    = Dt.races[race].skills[_name]\n\t\t\tlocal ability = Fn.get_abilitymodifiers('skills',_name)\n      newskills[_name] = base + race + ability\n\t  \tDEBUG(_name..FILL(12, _name)..': '..base + race + ability..' || '..STAT_Accounted('+', race, ability))\n\t\tend\n\t\tDEBUG('Restoring Class Bonuses...')\n    local API_class = types.Player.classes.record(types.Player.record(self).class)\n    newattributes[API_class.attributes[1]] = newattributes[API_class.attributes[1]] + 10\n    newattributes[API_class.attributes[2]] = newattributes[API_class.attributes[2]] + 10\n    DEBUG('Favoured Attributes increased by 10: ['..API_class.attributes[1]..', '..API_class.attributes[2]..']')\n    for _, _skill in ipairs(API_class.majorSkills) do\n      newskills[_skill] = newskills[_skill] + 25\n    end\n\t  DEBUG('Major skills increased by 25: ['..table.concat(toTable(API_class.majorSkills), ', ')..']')\n    for _, _skill in ipairs(API_class.minorSkills) do\n      newskills[_skill] = newskills[_skill] + 10\n    end\n\t  DEBUG('Minor skills increased by 10: ['..table.concat(toTable(API_class.minorSkills), ', ')..']')\n    for _, _skill in ipairs(Dt.specialization[string.upper(API_class.specialization)]) do\n      newskills[_skill] = newskills[_skill] + 5\n    end\n\t  DEBUG(string.upper(API_class.specialization)..' skills increased by 5: ['..table.concat(Dt.specialization[string.upper(API_class.specialization)], ', ')..']')\n\telse\n\t\tDEBUG('Restoring ATTRIBUTES...')\n    for _name, _val in pairs(Dt.pc_attributes) do\n\t\t\tlocal ability = Fn.get_abilitymodifiers('attributes',_name)\n      newattributes[_name] = _val + ability\n\t  \tDEBUG(_name..FILL(12, _name)..': '..tostring(_val)..' || '..STAT_Accounted('+', 0, ability))\n    end\n\t\tDEBUG('Restoring SKILLS...')\n    for _name, _val in pairs(Dt.pc_skills) do\n\t\t\tlocal ability = Fn.get_abilitymodifiers('skills',_name)\n      newskills[_name] = _val + ability\n\t  \tDEBUG(_name..FILL(12, _name)..': '..tostring(_val)..' || '..STAT_Accounted('+', 0, ability))\n    end\n\tend\n\n\tDEBUG('Applying ATTRIBUTES... done.')\n  for _, _name in ipairs(Dt.ATTRIBUTES) do\n    types.Player.stats.attributes[_name](self).base = get_val(newattributes[_name])\n  end\n\tDEBUG('Applying SKILLS... done.')\n  for _, _name in ipairs(Dt.SKILLS) do\n    types.Player.stats.skills[_name](self).base = get_val(newskills[_name])\n  end\n\n\tlocal str_factor = types.NPC.stats.attributes.strength(self).base * 0.5\n\tlocal end_factor = types.NPC.stats.attributes.endurance(self).base * 0.5\n\ttypes.Player.stats.dynamic.health(self).base = Dt.pc_dynamic.health + end_factor + str_factor + Fn.get_abilitymodifiers('fortifyhealth')\n  types.Player.stats.dynamic.health(self).current = types.Player.stats.dynamic.health(self).base\n\tDEBUG('Setting HP: '..string.format(\"%.1f\", tostring(Dt.pc_dynamic.health))..' | Restored '..tostring(str_factor)..' from STR and '..tostring(end_factor)..' from END')\n  if Mui.getSetting('Force_Dynamic_Stats') then\n\t  DEBUG('Restoring Dynamic Stats...')\n\t\tfor _, stat in ipairs{'health', 'magicka', 'fatigue'} do\n      types.Player.stats.dynamic[stat](self).base = get_val(Dt.pc_dynamic[stat])\n      types.Player.stats.dynamic[stat](self).current = get_val(Dt.pc_dynamic[stat])\n\t\tend\n\t  DEBUG('Setting HP: '..string.format(\"%.1f\", tostring(Dt.pc_dynamic.health)))\n\t  DEBUG('Setting MP: '..string.format(\"%.1f\", tostring(Dt.pc_dynamic.magicka)))\n\t\tDEBUG('Setting FP: '..string.format(\"%.1f\", tostring(Dt.pc_dynamic.fatigue)))\n\tend\n\n\n\tdo local spells = {}\n\t  for _, id in pairs(Dt.pc_spells) do table.insert(spells, core.magic.spells.records[id].name) end\n  \tDEBUG('Saved Player Spells: ['..table.concat(spells, ', ')..']')\n  end\n\n  for _, _id in ipairs(types.NPC.races.record(race).spells) do\n    Dt.pc_spells[_id] = _id\n  end\n\tdo local spells = {}\n\t  for _, id in ipairs(types.NPC.races.record(race).spells) do table.insert(spells, core.magic.spells.records[id].name) end\n  \tDEBUG('New Race: '..types.NPC.races.record(race).name..' | Spells: ['..table.concat(spells, ', ')..']')\n  end\n  local birthsign = types.Player.birthSigns.record(types.Player.getBirthSign(self))\n\tif birthsign then\n    for _, _id in ipairs(birthsign.spells) do\n      Dt.pc_spells[_id] = _id\n    end\n    do local spells = {}\n      for _, id in ipairs(Dt.birthsigns[birthsign.id]) do table.insert(spells, core.magic.spells.records[id].name) end\n    \tDEBUG('New Birthsign: '..birthsign.name..' | Spells: ['..table.concat(spells, ', ')..']')\n    end\n  end\n  for _spellid, _spell in pairs(Dt.pc_spells) do\n    types.Player.spells(self):add(_spellid)\n  end\n\tDEBUG('Applying Player Spells... done.')\n\t\n  types.Player.stats.level(self).current = get_val(Dt.pc_level)\n\tDEBUG('Restoring level:', Dt.pc_level)\n\n\tif Dt.PCRACE[race] then\n    core.sendGlobalEvent('grm_setGlobals', {name = 'PCRace', value = Dt.PCRACE[race]})\n\t  DEBUG('Race-based dialogue set to [ '..race..' ]')\n\tend\n\n\tif Compat.scripts ~= {} then\n  \tfor _, scriptid in ipairs(Compat.scripts) do\n  \t  core.sendGlobalEvent('grm_setGlobals', {name = scriptid, value = 1})\n  \t\tDEBUG('Starting MWScript: '..scriptid)\n  \tend\n  \tcore.sendGlobalEvent('grm_addItem', {id = 'grm_mwbolt', source = self.object, count = 1})\n\tend\n\n\tif Mui.getSetting('Respect_Caps') then\n\t\tlocal lost_attributes = 0\n\t\tlocal lost_skills = 0\n\t  for _, _name in ipairs(Dt.ATTRIBUTES) do\n\t\t\tif types.Player.stats.attributes[_name](self).base > 100 then\n        lost_attributes = lost_attributes + types.Player.stats.attributes[_name](self).base - 100\n        types.Player.stats.attributes[_name](self).base = 100\n\t\t\tend\n\t\tend\n    for _, _name in ipairs(Dt.SKILLS) do\n\t\t\tif types.Player.stats.skills[_name](self).base > 100 then\n        lost_skills = lost_skills + types.Player.stats.skills[_name](self).base - 100\n        types.Player.stats.skills[_name](self).base = 100\n\t\t\tend\n\t\tend\n\t\tDEBUG('STAT CAP - LOST ATTRIBUTES: '..tostring(lost_attributes))\n\t\tDEBUG('STAT CAP - LOST SKILLS: '..tostring(lost_skills))\n\tend\n\t\n  DEBUG_TOTALSTATS()\n\n\tif Mui.getSetting('Migration_Mode') then\n\t \tMui.setSetting('Migration_Mode', false)\n\t  Mui.savePreset('current')\n\tend\nend\n\n-- RETURN || NEED THIS SO FILE DO THING\nreturn Fn\n",
    "Gentler_Racemenu-54142-1-05-1716520588\\scripts\\Gentler_Racemenu\\menu.lua": "local menu = require('openmw.menu')\n\nreturn{\n\teventHandlers = {\n    grm_saveAndQuit = function(data)\n\t\t\tmenu.saveGame(data.description, data.slotname)\n\t\t\tmenu.quit()\n\t\tend,\n\t}\n}\n",
    "Gentler_Racemenu-54142-1-05-1716520588\\scripts\\Gentler_Racemenu\\modui.lua": "\n-- In a player script\nlocal storage  = require('openmw.storage')\nlocal settings = require('openmw.interfaces').Settings\nlocal async    = require('openmw.async')\nlocal self  = require('openmw.self')\nlocal ui       = require('openmw.ui')\nlocal i_UI  = require('openmw.interfaces').UI\n\nlocal Dt       = require('scripts.Gentler_Racemenu.data').Dt\n\nlocal function num_range(min, max, step) -- \" Why have I done this \"\n  if math.abs(step) < 0.0001 then print('GRM: step must not be between -0.0001 and 0.0001') return nil end\n  local num_range = {}\n  digits = {tostring(step):find('%.(%d*)')}\n  if not digits[3] then digits[3] = '' end\n  digits = '%.'..#tostring(digits[3])..'f'\n  for i=min, max, step do table.insert(num_range, 0 + string.format(digits, tostring(i))) end\n  return num_range\nend\n\nlocal function array_concat(array, ...)\n  for _, t in ipairs({...}) do\n    for _, v in ipairs(t) do table.insert(array, v) end\n  end\n  return array\nend\n\nlocal function makeKeyEnum(keys) local result = {} for _, key in ipairs(keys) do result[key] = true end return result end\n\nlocal function edit_args(base, changes) for k, v in pairs(changes) do base[k] = v end return base end\n\nlocal function get(svar) -- s in svar means serializable | Recursions WILL stack overflow :D\n  if type(svar)  ~= 'table' then return svar\n  else\n    local deepcopy = {}\n    for _key, _value in pairs(svar) do deepcopy[_key] = get(_value) end\n    return deepcopy\n  end\nend\n\nlocal Mui = {}\n\nMui.presets = {\n\tcustom = {}, default = {\n    Purge_Spells         = false,\n    Force_Dynamic_Stats  = false,\n\t\tKeep_Stats_Unchanged = false,\n\t\tRespect_Caps         = false,\n\t\tMigration_Mode       = false,\n\t\tGRM_DEBUG = false,\n\t}\n}\n\nMui.SKILLS_MAP = makeKeyEnum(Dt.SKILLS)\nMui.toggles = {\n}\n\nMui.settingsGroups = {}\nfunction addSettingsGroup(name)\n\tlocal groupid = \"Settings_GRM_\"..name\n\tMui[groupid] = {}\n\tstorage.playerSection(groupid):reset()\n\ttable.insert(Mui.settingsGroups, groupid)\nend\n\nsettings.registerPage {\n  key         = 'grmconfig',\n  l10n        = 'Gentler_Racemenu',\n  name        = 'Gentler Racemenu',\n  description = '',\n}\n\naddSettingsGroup('Options')\n--Mui.Settings_GRM_options.args = {\n--  Setting_Id = {l10n = 'Gentler_Racemenu', items = array_concat(), disabled = false},\n--}\nsettings.registerGroup {\n  key              = 'Settings_GRM_Options',\n  name             = 'Options',\n  page             = 'grmconfig',\n  order            = 0,\n  l10n             = 'Gentler_Racemenu',\n  permanentStorage = false,\n  settings         = {\n    {\n    key         = 'Keep_Stats_Unchanged',\n    name        = 'Keep Stats Unchanged',\n    description = 'Restore your stats as-is instead of accounting for racial and class bonuses.',\n\t\trenderer    = 'checkbox',\n\t\tdefault     = Mui.presets.default.Keep_Stats_Unchanged,\n    },{\n    key         = 'Respect_Caps',\n    name        = 'Respect Vanilla Stat Cap',\n    description = 'Clamp stats down to a max of 100 after applying race and class bonuses.\\n A message will be printed to the console with the total amount of stats lost, so you can add them back to different skills/attributes (through console commands) if you so desire.',\n\t\trenderer    = 'checkbox',\n\t\tdefault     = Mui.presets.default.Respect_Caps,\n    },{\n    key         = 'Force_Dynamic_Stats',\n    name        = 'Force MP and FP',\n    description = 'Forcefully restore Magic and Stamina.\\n On vanilla this is not necessary as they will recalculate themselves.\\n Toggle this on if you have mods that apply custom formulas.\\n HP is always restored regardless of this setting, as the vanilla formula doesn\\'t handle it properly.',\n  \trenderer    = 'checkbox',\n  \tdefault     = Mui.presets.default.Force_Dynamic_Stats,\n    },{\n    key         = 'Purge_Spells',\n    name        = 'Purge Spells',\n    description = 'Remove all race and birthsign spells known by GRM from your character\\'s spell list, instead of only the ones from your current load order.\\n Enabling this may help you if you run into compatibility issues.',\n  \trenderer    = 'checkbox',\n  \tdefault     = Mui.presets.default.Purge_Spells,\n    },{\n    key         = 'Migration_Mode',\n    name        = 'Enter Mod Migration Mode',\n    description = 'Toggling this on will prepare your character for changing race/birthsign mods:\\n 1 - Set this to yes and unpause the game.\\n 2 - After a second the game will automatically save and quit.\\n<| Go change your plugins. |>\\n 3 - Open the game and load the Migration Save\\n 4 - Stat Review will automatically pop up. Click [OK].\\n 5 - If everything went well, your charactr is migrated!\\n Check that your stats and spells are correct.\\n 5.5 - If something failed, report it on the mod page so I can look into it.',\n  \trenderer    = 'checkbox',\n  \tdefault     = Mui.presets.default.Migration_Mode,\n    },\n  },\n}\n\naddSettingsGroup('DEBUG')\nsettings.registerGroup {\n  key              = 'Settings_GRM_DEBUG',\n  name             = 'Info & Debug',\n  page             = 'grmconfig',\n  order            = 1,\n  l10n             = 'Gentler_Racemenu',\n  permanentStorage = false,\n  settings         = {\n    {\n    key         = 'GRM_DEBUG', name = 'Enable Debug Messages', renderer = 'checkbox', default = Mui.presets.default.GRM_DEBUG,\n    description = 'Print debug info to the console.\\n Toggle this on if you run into any issues, as it may help track the culprit.'\n    },\n  },\n}\n\nlocal function DEBUG(...)\n\tif Mui.getSetting('GRM_DEBUG') then print(...) end\nend\n\n--Mui.custom_groups = {\n----toggle_h2h_str = true,\n--}\n--Mui.custom = function(group, key)\n--\tif key == 'toggle_h2h_str' then\n--    local args   = Mui.Settings_GRM_physical.args\n--\t\tlocal ratio  = 'HandToHand_Strength'\n--    if Mui[group].section:get(key) then\n--      settings.updateRendererArgument(group, ratio, edit_args(args[ratio], {disabled = false}))\n--    else\n--      settings.updateRendererArgument(group, ratio, edit_args(args[ratio], {disabled = true}))\n--    end\n--  end\n--end\n\nMui.update = async:callback(function(group,key)\n\tif key == nil then print(group..': nil key') end\n  if (not group) or (not key) then return\n\telseif key == 'Migration_Mode' then\n    if Mui.Settings_GRM_Options.section:get('Migration_Mode') and i_UI.getMode() then\n      async:newUnsavableSimulationTimer(1, function()\n\t\t\t\t-- We do this to give the player some breathing room, otherwise we'd quit instantly upon clicking the button.\n\t\t\t\tif storage.playerSection('Settings_GRM_Options'):get('Migration_Mode') then self:sendEvent('grm_startMigration', true) end\n\t\t\tend)\n\t\tend\n--elseif Mui.custom_groups[key] then\n--\tMui.custom(group, key)\n  else\n--  if type(Mui[group].section:get(key)) == 'number' then\n--\t\tif Mui.getSetting(\"GRM_DEBUG\") then print(key..': '.. string.format('%.1f', Mui[group].section:get(key))) end\n--  else\n--    if Mui.getSetting(\"GRM_DEBUG\") then print(key..': '..tostring(Mui[group].section:get(key))) end\n--  end\n  end\nend)\n\nMui.GROUPS_MAP = {}\nfor _, groupid in ipairs(Mui.settingsGroups) do \n  Mui[groupid].section = storage.playerSection(groupid)\n  Mui[groupid].section:subscribe(Mui.update)\n\tfor key in pairs(Mui[groupid].section:asTable()) do \n\t\tMui.GROUPS_MAP[key] = Mui[groupid].section\n\tend\nend\n\nMui.getSetting = function(settingid)\n  return Mui.GROUPS_MAP[settingid]:get(settingid)\nend\n\nMui.setSetting = function(settingid, val)\n  Mui.GROUPS_MAP[settingid]:set(settingid, val)\nend\n\nMui.savePreset = function(name)\n  local preset = {}\n  for _, groupid in ipairs (Mui.settingsGroups) do\n\t\tfor k, v in pairs(Mui[groupid].section:asTable()) do\n\t\t  preset[k] = v\n      if Mui.getSetting(\"GRM_DEBUG\") then print('Saving... '..k..': '..tostring(v)) end\n\t\tend\n  end\n  storage.playerSection(\"GRM_Presets\"):set(name, preset)\n  storage.playerSection(\"GRM_Presets\"):setLifeTime(storage.LIFE_TIME.Persistent)\nend\nMui.loadPreset = function(name)\n\tlocal target_as_table = storage.playerSection(\"GRM_Presets\"):asTable()[name]\n\tif target_as_table == nil then print(\"[Loading defaults]\") target_as_table = Mui.presets.default end\n  for _, groupid in ipairs(Mui.settingsGroups) do \n  \tfor k, v in pairs (Mui[groupid].section:asTable()) do\n\t\t\tif target_as_table[k] ~= nil then\n        Mui[groupid].section:set(k, target_as_table[k])\n\t\t\t\tDEBUG('GRM - Loading ['..name..'] | '..k..' -> '..tostring(target_as_table[k]))\n\t\t  end\n  \tend\n  end\nend\n\nreturn Mui\n",
    "Gentler_Racemenu-54142-1-05-1716520588\\scripts\\Gentler_Racemenu\\setGlobals.lua": "local world = require('openmw.world')\nlocal types = require('openmw.types')\n\nreturn {\n  eventHandlers = {\n    grm_setGlobals = function(data)\n      world.mwscript.getGlobalVariables()[data.name] = data.value\n    end,\n\t\tgrm_addItem = function(data) -- data = {source = obj, id = str, count = int} | if count is not provided then 1 object is added.\n\t\t\tlocal item = world.createObject(data.id, data.count)\n\t\t\titem:moveInto(types.Actor.inventory(data.source))\n\t\t\tdata.source:sendEvent('grm_itemAdded', item)\n\t\tend,\n\t\tgrm_removeItem = function(data) -- data = {item = obj, count = int} | if count is not provided then the entire stack is removed\n\t\t\tdata.item:remove(data.count)\n\t\t\tdata.source:sendEvent('grm_itemRemoved', data.item)\n\t\tend,\n  }\n}\n"
  }
}