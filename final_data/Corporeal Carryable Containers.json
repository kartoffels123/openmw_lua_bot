{
  "folder_name": "Corporeal Carryable Containers",
  "lua_files": {
    "Corporeal Carryable Containers-53772-1-02-1706715770\\Corporeal-Carryable-Containers-master\\scripts\\Corporeal-Carryable-Containers\\ccc_global.lua": "local types = require(\"openmw.types\")\nlocal world = require(\"openmw.world\")\nlocal acti = require(\"openmw.interfaces\").Activation\nlocal util = require(\"openmw.util\")\nlocal I = require(\"openmw.interfaces\")\nlocal async = require(\"openmw.async\")\nlocal core = require(\"openmw.core\")\n\n-- Here, we will keep track of all the items that relate to containers.\n\n-- When a container misc item is activated, the real container will be moved in, and activated.\n\n---\n-- Once it is closed(game is unpaused), we check if the weight is correct.\n\nlocal obScr = \"nolore\"\nlocal playerSneaking = false\nlocal extractGold = true\nlocal UseBaseWeight = true\n---\nif (core.API_REVISION < 51) then\n    error(\"Corporeal Carryable Containers requires a newer version of OpenMW. Please update.\")\nend\n-- Should be compatible with tabletop alchemy.\nlocal function updateUBW(val) UseBaseWeight = val end\nlocal function updateExtractGold(val) extractGold = val end\nlocal ccc_conttypes = nil\nlocal ccc_data = {}\n\nlocal function addContainerCollection(actor)\n    local inv = types.Actor.inventory(actor)\n    for index, value in ipairs(ccc_conttypes) do\n        I.CCC_cont.createContItemInstance(value.itemRecId, inv)\n    end\nend\nlocal function getPlayer()\n    for i, ref in ipairs(world.activeActors) do\n        if (ref.type == types.Player) then return ref end\n    end\nend\nlocal itemInstanceLast = 1000\nlocal function moveGlobalSetter(zval, player)\n\nend\nlocal function onItemActive(item)\n    -- When items are dropped, their ID is changed since the item is cloned when dropped via gui.\n    -- So, we must check the items and update the item table.\n\n    -- We can't set a unique ID, so the best thing may be to have a unique value int on each individual container item.\nend\n\nlocal function createContItemInstance(baseRecordId, targetInv)\n    local newContId = nil\n    for index, value in ipairs(ccc_conttypes) do\n        if (value.itemRecId == baseRecordId) then\n            newContId = value.contRecId\n        end\n    end\n    if (newContId == nil) then\n        error(\"Error, container ID not found\")\n        return\n    end\n    local baseRecord = types.Miscellaneous.record(baseRecordId)\n    local miscitem = {\n        name = baseRecord.name,\n        weight = baseRecord.weight,\n        value = itemInstanceLast,\n        icon = baseRecord.icon,\n        model = baseRecord.model,\n        mwscript = obScr\n    }\n    local ret = types.Miscellaneous.createRecordDraft(miscitem)\n    local record = world.createRecord(ret)\n\n    async:newUnsavableSimulationTimer(0.1, function()\n        local newItem = world.createObject(record.id)\n        local newCont = world.createObject(newContId)\n        async:newUnsavableSimulationTimer(0.1, function()\n            newCont:teleport(\"ToddTest\", util.vector3(0, 0, 0))\n            newItem:moveInto(targetInv)\n            async:newUnsavableSimulationTimer(0.1, function()\n                I.CCC_cont.updateCCCData(newItem, newCont, targetInv)\n            end)\n        end)\n    end)\n    itemInstanceLast = itemInstanceLast + 1\nend\nlocal function createContItemInstanceEvent(data)\n    createContItemInstance(data.baseRecordId, data.targetInv)\nend\nlocal function addContType(contModel, contIcon, contName, contBaseWeight,\n                           contRecId)\n    -- contRecId is the record ID of the actual contaner we'll use\n    if (UseBaseWeight == false) then contBaseWeight = 0 end\n    local newRecord\n    local itemRecordId = nil\n    for index, rec in ipairs(types.Miscellaneous.records) do\n        if (rec.weight == contBaseWeight and rec.name == contName and\n                rec.model:lower() == contModel:lower() and rec.icon:lower() ==\n                contIcon:lower()) then\n            newRecord = rec\n            itemRecordId = rec.id\n            break\n        else\n        end\n    end\n    if (newRecord == nil) then -- Didn't find a record that matches all the criteria, need to make a new one.\n        local miscitem = {\n            name = contName,\n            weight = contBaseWeight,\n            value = 1000,\n            icon = contIcon,\n            model = contModel,\n            mwscript = obScr\n        }\n        local ret = types.Miscellaneous.createRecordDraft(miscitem)\n        local record = world.createRecord(ret)\n        itemRecordId = record.id\n    end\n    local tableItem = {\n        model = contModel,\n        icon = contIcon,\n        baseName = contName,\n        baseWeight = contBaseWeight,\n        contRecId = contRecId,\n        itemRecId = itemRecordId\n    }\n    table.insert(ccc_conttypes, tableItem)\nend\n\nlocal function addContTypes()\n    -- if (ccc_conttypes == {} or ccc_conttypes == nil) then\n    ccc_conttypes = {}\n    addContType(\"meshes\\\\o\\\\Contain_chest_small_02.NIF\", \"icons\\\\ccc\\\\chest_small.tga\",\n        \"Small Chest\", 1, \"chest_small_02\")\n    addContType(\"meshes\\\\o\\\\Contain_De_Chest_01.NIF\", \"icons\\\\ccc\\\\chest_big.tga\",\n        \"Large Chest\", 5, \"de_r_chest_01\")\n    addContType(\"meshes\\\\o\\\\Contain_crate_02.NIF\", \"icons\\\\ccc\\\\crate.png\", \"Crate\", 5,\n        \"crate_02\")\n    addContType(\"meshes\\\\o\\\\Contain_Com_Sack_02.NIF\", \"icons\\\\ccc\\\\sack02.tga\", \"Sack\", 0,\n        \"com_sack_02\")\n    if core.contentFiles.has(\"oaab_data.esm\") then\n        addContType(\"meshes\\\\OAAB\\\\m\\\\misc_keyring.nif\", \"icons\\\\oaab\\\\m\\\\misc_keyring.tga\", \"Keyring\", 0,\n            \"chest_small_02\")\n    end\n    --  end\nend\n\nlocal weightMultiplier = 1\n\nlocal function calculateWeight(containerOb)\n    -- Will include an object's base weight here in the future.\n    local baseWeight = 0\n    if (UseBaseWeight) then\n        for index, value in ipairs(ccc_conttypes) do\n            if (value.contRecId == containerOb.recordId) then\n                baseWeight = value.baseWeight\n            end\n        end\n    end\n    return math.ceil((types.Container.encumbrance(containerOb) + baseWeight) *\n        weightMultiplier)\nend\nlocal function updateCCCData(itemOb, containerOb, parentInv, newName)\n    -- This function replaces a record with one with the correct weight, and saves that data to the CCCData table.\n    -- ContainerOb is the container that is actually accessed. ParentOb is the container that itemOb is contained in, if it's in a container.\n    -- If we are renaming, then update name as well with newName\n    local parentCont = itemOb.parentContainer\n    if parentCont then\n        parentInv = types.Actor.inventory(parentCont)\n    end\n    local name = types.Miscellaneous.record(itemOb).name\n    if (newName ~= nil) then name = newName end\n    local oldRecord = types.Miscellaneous.record(itemOb)\n    local newData = {\n        containerId = containerOb.id,\n        itemId = itemOb.id,\n        value = oldRecord.value,\n        icon = oldRecord.icon\n    }\n    local weight = calculateWeight(containerOb)\n    local newRecord = nil\n    if (oldRecord.weight == weight and oldRecord.name == name) then\n        newRecord = oldRecord\n    else -- Need to replace with a new record\n        for index, rec in ipairs(types.Miscellaneous.records) do\n            if (rec.weight == weight and rec.name == name and\n                    rec.model == oldRecord.model and\n                    rec.icon == oldRecord.icon and rec.value == oldRecord.value) then\n                newRecord = rec\n                break\n            end\n        end\n        if (newRecord == nil) then -- Didn't find a record that matches all the criteria, need to make a new one.\n            local miscitem = {\n                name = name,\n                weight = weight,\n                value = oldRecord.value,\n                icon = oldRecord.icon,\n                model = oldRecord.model,\n                mwscript = obScr\n            }\n            local ret = types.Miscellaneous.createRecordDraft(miscitem)\n            newRecord = world.createRecord(ret)\n        end\n    end\n    if (newRecord ~= oldRecord and parentInv == nil) then\n        local newItem = world.createObject(newRecord.id)\n        newItem:teleport(itemOb.cell, itemOb.position, itemOb.rotation)\n        if itemOb.count > 0 then\n            itemOb:remove()\n        end\n    elseif (newRecord ~= oldRecord and parentInv ~= nil) then\n        local newItem = world.createObject(newRecord.id)\n        newItem:moveInto(parentInv)\n        --   if itemOb.count > 0 then\n        itemOb:remove()\n\n        --end\n    end\n    for index, data in ipairs(ccc_data) do\n        if (data.containerId == newData.containerId) then\n            table.remove(ccc_data, index)\n            break\n        end\n    end\n    table.insert(ccc_data, newData)\nend\n\nlocal function getContainersNearbyPlayer()\n    local player = getPlayer()\n    local carriedIds = {}\n    for index, item in ipairs(player.cell:getAll(types.Miscellaneous)) do\n        for i, dataItem in ipairs(ccc_data) do\n            if item.type.record(item).icon == dataItem.icon and\n                item.type.record(item).value == dataItem.value then\n                table.insert(carriedIds, dataItem.containerId)\n            end\n        end\n    end\n\n    if (#carriedIds == 0) then return {} end\n    local ret = {}\n    local ttItems = world.getCellByName(\"ToddTest\"):getAll(types.Container)\n    for index, cont in ipairs(ttItems) do\n        for indx, contId in ipairs(carriedIds) do\n            if (contId == cont.id) then table.insert(ret, cont) end\n        end\n    end\n    return ret\nend\nlocal function getContainersCarriedByPlayer()\n    local carriedIds = {}\n    for i, dataItem in ipairs(ccc_data) do\n        local playInv = types.Actor.inventory(getPlayer()):getAll(\n            types.Miscellaneous)\n        for index, item in ipairs(playInv) do\n            if item.type.record(item).icon == dataItem.icon and\n                item.type.record(item).value == dataItem.value then\n                table.insert(carriedIds, dataItem.containerId)\n            end\n        end\n    end\n    if (#carriedIds == 0) then return {} end\n    local ret = {}\n    local ttItems = world.getCellByName(\"ToddTest\"):getAll(types.Container)\n    for index, cont in ipairs(ttItems) do\n        for indx, contId in ipairs(carriedIds) do\n            if (contId == cont.id) then table.insert(ret, cont) end\n        end\n    end\n    return ret\nend\nlocal goldMovementData = {}\nlocal function MoveGoldToPlayer()\n    goldMovementData = {}\n    for index, value in ipairs(getContainersCarriedByPlayer()) do\n        local goldItem = types.Container.content(value):find(\"gold_001\")\n        if goldItem then\n            table.insert(goldMovementData,\n                { count = goldItem.count, id = value.id })\n            goldItem:moveInto(types.Actor.inventory(getPlayer()))\n        end\n    end\nend\nlocal function MoveGoldBack()\n    for index, data in ipairs(goldMovementData) do\n        local ttItems = world.getCellByName(\"ToddTest\"):getAll(types.Container)\n        for index, cont in ipairs(ttItems) do\n            if (cont.id == data.id) then\n                local playerGold = types.Actor.inventory(getPlayer()):find(\n                    \"gold_001\")\n                if (playerGold and data.count) then\n                    if (playerGold.count > data.count) then\n                        playerGold:split(data.count):moveInto(types.Container\n                            .content(cont))\n                    else\n                        playerGold:moveInto(types.Container.content(cont))\n                    end\n                end\n            end\n        end\n    end\nend\nlocal function itemCarriedByPlayer(itemId, ignoreOwnInv)\n    if (types.Actor.inventory(getPlayer()):find(itemId)) then return true end\n    for index, value in ipairs(getContainersCarriedByPlayer()) do\n        if (types.Container.content(value):find(itemId)) then return true end\n    end\n    return false\nend\nlocal function onSave()\n    return {\n        ccc_data = ccc_data,\n        itemInstanceLast = itemInstanceLast,\n        UseBaseWeight = UseBaseWeight,\n        extractGold = extractGold\n    }\nend\nlocal function onLoad(data)\n    if not data then return end\n    ccc_data = data.ccc_data\n    UseBaseWeight = data.UseBaseWeight\n    itemInstanceLast = data.itemInstanceLast\n    extractGold = data.extractGold\n    if world.players[1] and not ccc_conttypes then\n        addContTypes()\n    end\nend\nlocal function onPlayerAdded(plr)\n    addContTypes()\nend\n\nlocal activatedContainer = nil\nlocal activatedItem = nil\nlocal needToActivate = false\nlocal player = nil\nlocal openingCont = nil\nlocal function openContinInv(data)\n    local contVal = data.value\n    player = getPlayer()\n    local bridgeItem = data.bridgeItem\n    local realItem = nil\n    bridgeItem:remove()\n\n    for index, dataItem in ipairs(ccc_data) do\n        if (dataItem.value == contVal) then\n            for k, item in ipairs(types.Actor.inventory(player):getAll(\n                types.Miscellaneous)) do\n                if item.type.record(item).icon == dataItem.icon and\n                    item.type.record(item).value == contVal then\n                    realItem = item\n                end\n            end\n            if (realItem == nil) then\n                print(\"Item not found\")\n                return false\n            end\n            -- Then this is a CCC container object, activate it and do the thing\n            local ttItems = world.getCellByName(\"ToddTest\"):getAll(\n                types.Container)\n\n            for index, value in ipairs(ttItems) do\n                if (value.id == dataItem.containerId) then\n                    activatedContainer = value\n                    activatedItem = realItem\n                    openingCont = types.Actor.inventory(player)\n                    break\n                end\n            end\n\n            return false\n        end\n    end\nend\nlocal function activateMisc(object, actor)\n    for index, dataItem in ipairs(ccc_data) do\n        if (dataItem.value == object.type.record(object).value and dataItem.icon ==\n                object.type.record(object).icon) then\n            -- Then this is a CCC container object, activate it and do the thing\n            if (playerSneaking) then\n                actor:sendEvent(\"CCCstartRename\", {\n                    object = object,\n                    data = dataItem,\n                    currentName = types.Miscellaneous.record(object).name\n                })\n                return false\n            end\n            local ttItems = world.getCellByName(\"ToddTest\"):getAll(\n                types.Container)\n\n            for index, value in ipairs(ttItems) do\n                if (value.id == dataItem.containerId) then\n                    player = actor\n                    world.players[1]:sendEvent(\"openContainerInv\", value)\n                    -- value:teleport(actor.cell, util.vector3(actor.position.x, actor.position.y, -9000))\n                    activatedContainer = value\n                    activatedItem = object\n                    return false\n                end\n            end\n\n            return false\n        end\n    end\nend\nlocal function updateClosedCont()\n    if not activatedItem then return end\n\n    if activatedItem.parentContainer and activatedItem.parentContainer ~= getPlayer() then\n        activatedItem:moveInto(getPlayer())\n    end\n    updateCCCData(activatedItem, activatedContainer)\nend\nlocal delay = 0\nlocal activatingActor = nil\nlocal function onUpdate(dt)\n    if activatingActor ~= nil and delay > 10 then\n        MoveGoldBack()\n        activatingActor = nil\n    elseif delay > 0 then\n        delay = delay + 1\n    end\nend\nlocal function activateLockable(door, player)\n    if types.Lockable.isLocked(door) or types.Lockable.getTrapSpell(door) then\n        local key = types.Lockable.getKeyRecord(door)\n        if key and itemCarriedByPlayer(key.id) then\n            if types.Lockable.getTrapSpell(door) then\n                player:sendEvent(\"CCC_PlaySound\", \"Disarm Trap\")\n            end\n            types.Lockable.setTrapSpell(door)\n            types.Lockable.unlock(door)\n            player:sendEvent(\"CCC_Message\", key.name .. \" \" .. core.getGMST(\"sKeyUsed\"))\n        end\n    end\nend\nlocal function activateActor(npc, player)\n    if (types.Actor.stats.dynamic.health(npc).current > 0 and extractGold) then\n        activatingActor = npc\n        MoveGoldToPlayer()\n        delay = 1\n    end\nend\nacti.addHandlerForType(types.Miscellaneous, activateMisc)\nacti.addHandlerForType(types.NPC, activateActor)\nacti.addHandlerForType(types.Creature, activateActor)\nacti.addHandlerForType(types.Door, activateLockable)\nacti.addHandlerForType(types.Container, activateLockable)\nI.ItemUsage.addHandlerForType(types.Miscellaneous, activateMisc)\n\nlocal function onInit()\n    -- crate\n    -- com chest\n    -- rich chest\n    -- basket\nend\nlocal function getTypes() return ccc_conttypes end\nlocal function renameContainer(data)\n    local newName = data.newName\n    local newCont = nil\n    local val = 0\n    local object = data.object\n    for index, data in ipairs(ccc_data) do\n        if (data.value == types.Miscellaneous.record(object).value and\n                types.Miscellaneous.record(object).icon == data.icon) then\n            for x, cont in ipairs(world.getCellByName(\"ToddTest\"):getAll(\n                types.Container)) do\n                if (cont.id == data.containerId) then\n                    newCont = cont\n                    val = data.value\n                    break\n                end\n            end\n            break\n        end\n    end\n    if (newCont ~= nil) then\n        updateCCCData(object, newCont, types.Actor.inventory(getPlayer()),\n            newName)\n    end\nend\nlocal function emergencyItemExtraction()\n    local ttItems = world.getCellByName(\"ToddTest\"):getAll(types.Container)\n    local player = getPlayer()\n    local count = 0\n    for index, cont in ipairs(ttItems) do\n        if not cont.contentFile then\n            for k, item in ipairs(types.Container.inventory(cont):getAll()) do\n                count = count + item.count\n                item:moveInto(player)\n            end\n        end\n    end\n\n    player:sendEvent(\"CCC_Message\", tostring(count) .. \" item extracted from containers\")\nend\nlocal function CCCSneakUpdate(val) playerSneaking = val end\nreturn {\n    interfaceName = \"CCC_cont\",\n    interface = {\n        version = 1,\n        updateCCCData = updateCCCData,\n        calculateWeight = calculateWeight,\n        createContItemInstance = createContItemInstance,\n        getTypes = getTypes,\n        moveGlobalSetter = moveGlobalSetter,\n        itemCarriedByPlayer = itemCarriedByPlayer,\n        getContainersCarriedByPlayer = getContainersCarriedByPlayer,\n        getContainersNearbyPlayer = getContainersNearbyPlayer,\n    },\n    engineHandlers = {\n        onInit = onInit,\n        onLoad = onLoad,\n        onSave = onSave,\n        onItemActive = onItemActive,\n        onUpdate = onUpdate,\n        onPlayerAdded = onPlayerAdded\n    },\n    eventHandlers = {\n        renameContainer = renameContainer,\n        openContinInv = openContinInv,\n        CCCSneakUpdate = CCCSneakUpdate,\n        addContainerCollection = addContainerCollection,\n        updateUBW = updateUBW,\n        updateExtractGold = updateExtractGold,\n        emergencyItemExtraction = emergencyItemExtraction,\n        updateClosedCont = updateClosedCont\n    }\n}\n",
    "Corporeal Carryable Containers-53772-1-02-1706715770\\Corporeal-Carryable-Containers-master\\scripts\\Corporeal-Carryable-Containers\\ccc_npc.lua": "local types = require(\"openmw.types\")\nlocal core = require(\"openmw.core\")\nlocal self = require(\"openmw.self\")\nlocal itemAdded = false\nlocal function onActive()\n    local class = types.NPC.record(self).class\n    if(itemAdded) then\n        return\n    end\n    if(class == \"trader service\") then\n       core.sendGlobalEvent(\"addContainerCollection\",self) \n\n    end\n    itemAdded = true\nend\n\nlocal function onLoad(data)\nitemAdded = data.itemAdded\nend\nlocal function onSave()\nreturn {itemAdded = itemAdded}\n\nend\n\nreturn {\n    engineHandlers = {onActive = onActive, onSave = onSave, onLoad = onLoad },\n   -- eventHandlers = {CCCstartRename = CCCstartRename,}\n}",
    "Corporeal Carryable Containers-53772-1-02-1706715770\\Corporeal-Carryable-Containers-master\\scripts\\Corporeal-Carryable-Containers\\ccc_player.lua": "local types = require(\"openmw.types\")\nlocal core = require(\"openmw.core\")\nlocal self = require(\"openmw.self\")\nlocal ui = require(\"openmw.ui\")\nlocal async = require(\"openmw.async\")\nlocal util = require(\"openmw.util\")\nlocal I = require(\"openmw.interfaces\")\nlocal storage = require(\"openmw.storage\")\nlocal ambient = require('openmw.ambient')\n\nlocal function onFrame(dt)\n\nend\n\nif (core.API_REVISION < 51) then\n    I.Settings.registerPage {\n        key = \"SettingsCorporealCarryableContainers\",\n        l10n = \"AshlanderArchitect\",\n        name = \"CC Containers\",\n        description = \"Corporeal Carryable Containers requires a newer version of OpenMW. Please update.\"\n    }\n    error(\"Corporeal Carryable Containers requires a newer version of OpenMW. Please update.\")\nend\nlocal oldName = nil\nI.Settings.registerPage {\n    key = \"SettingsCorporealCarryableContainers\",\n    l10n = \"AshlanderArchitect\",\n    name = \"CC Containers\",\n    description = \"Corporeal Carryable Containers\"\n}\n\nI.Settings.registerGroup {\n    key = \"SettingsCorporealCarryableContainers\",\n    page = \"SettingsCorporealCarryableContainers\",\n    l10n = \"AshlanderArchitect\",\n    name = \"Corporeal Carryable Containers\",\n    description = \"Corporeal Carryable Containers\",\n    permanentStorage = false,\n    settings = {\n        {\n            key = \"UseBaseWeight\",\n            renderer = \"checkbox\",\n            name = \"Include Base Weight\",\n            description =\n            \"If enabled, Carryable container will have the item's base weight(the weight of the container itself) included in the weight calculation.\",\n\n            default = true\n        },\n        {\n            key = \"extractGold\",\n            renderer = \"checkbox\",\n            name = \"Extract Gold\",\n            description =\n            \"If enabled, any gold in containers when be moved into the player's inventory when talking to someone. The amount that was in the container will be returned when the game is unpaused, if the player still has that much. If the player already had gold in their inventory, that will be used last.\",\n\n            default = true\n        },\n        {\n            key = \"emergencyItemExtraction\",\n            renderer = \"checkbox\",\n            name = \"Emergency Item Extraction\",\n            description =\n            \"Toggle this to move all items from the item storage to your inventory. This is intended for use in the case where the mod is broken or corrupted. Do not click this unless you are sure it is the only option.\",\n\n            default = true\n        },\n    }\n}\n\nlocal playerSettings = storage.playerSection(\"SettingsCorporealCarryableContainers\")\nplayerSettings:subscribe(async:callback(function(section, key)\n    if key then\n        if (key == \"UseBaseWeight\") then\n            core.sendGlobalEvent(\"updateUBW\", playerSettings:get(\"UseBaseWeight\"))\n        elseif (key == \"extractGold\") then\n            core.sendGlobalEvent(\"updateExtractGold\", playerSettings:get(\"extractGold\"))\n        elseif key == \"emergencyItemExtraction\" then\n            core.sendGlobalEvent(\"emergencyItemExtraction\")\n        end\n    end\nend))\nlocal function lerp(x, x1, x2, y1, y2)\n    return y1 + (x - x1) * ((y2 - y1) / (x2 - x1))\nend\nlocal function calculateTextScale()\n    local screenSize = ui.screenSize()\n    local width = screenSize.x\n    local scale = lerp(width, 1280, 2560, 1.3, 1.8)\n    return scale\nend\nlocal function boxedTextEditContent(text, callback)\n    return {\n        type = ui.TYPE.Container,\n        content = ui.content {\n            {\n                template = I.MWUI.templates.box,\n                props = {\n                    anchor = util.vector2(0, -0.5),\n                    size = util.vector2(400, 10),\n                },\n                content = ui.content {\n                    {\n                        type = ui.TYPE.TextEdit,\n                        template = I.MWUI.templates.textEditLine,\n                        events = { textChanged = callback },\n                        props = {\n                            text = text,\n                            size = util.vector2(400, 30),\n                            textAlignH = 15,\n                            textSize = 25 * calculateTextScale(),\n                            align = ui.ALIGNMENT.Center,\n                        }\n                    }\n                }\n            }\n        }\n    }\nend\nlocal function textContent(text)\n    return {\n        type = ui.TYPE.Text,\n        template = I.MWUI.templates.textHeader,\n        props = {\n            text = tostring(text),\n            textSize = 10 * calculateTextScale(),\n            arrange = ui.ALIGNMENT.Start,\n            align = ui.ALIGNMENT.Start\n        }\n    }\nend\nlocal function boxedTextContent(text, callback)\n    return {\n        type = ui.TYPE.Container,\n        content = ui.content {\n            {\n                template = I.MWUI.templates.box,\n                props = {\n                    anchor = util.vector2(0, -0.5)\n                },\n                content = ui.content {\n                    {\n                        type = ui.TYPE.Text,\n                        template = I.MWUI.templates.textNormal,\n                        events = { mouseClick = callback },\n                        props = {\n                            text = text,\n                            textSize = 15 * calculateTextScale(),\n                            align = ui.ALIGNMENT.Center\n                        }\n                    }\n                }\n            }\n        }\n    }\nend\n\nlocal function renderTextInput(textLines, existingText, editCallback, OKCallback, OKText)\n    if (OKText == nil) then\n        OKText = \"OK\"\n    end\n    local vertical = 50\n    local horizontal = (ui.screenSize().x / 2) - 400\n\n    local vertical = 0\n    local horizontal = ui.screenSize().x / 2 - 25\n    local vertical = vertical + ui.screenSize().y / 2 + 100\n\n    local content = {}\n    for _, text in ipairs(textLines) do\n        table.insert(content, textContent(text))\n    end\n    local textEdit = boxedTextEditContent(existingText, async:callback(editCallback))\n    local okButton = boxedTextContent(OKText, async:callback(OKCallback))\n    table.insert(content, textEdit)\n    table.insert(content, okButton)\n\n    return ui.create {\n        layer = \"Windows\",\n        template = I.MWUI.templates.boxTransparentThick,\n        props = {\n            -- relativePosition = v2(0.65, 0.8),\n            --  anchor = v2(-1, -2),\n            position = util.vector2(horizontal, vertical),\n            vertical = false,\n            relativeSize = util.vector2(0.1, 0.1),\n            arrange = ui.ALIGNMENT.Center\n        },\n        content = ui.content {\n            {\n                type = ui.TYPE.Flex,\n                content = ui.content(content),\n                props = {\n                    horizontal = false,\n                    align = ui.ALIGNMENT.Center,\n                    arrange = ui.ALIGNMENT.Center,\n                    size = util.vector2(400, 10),\n                }\n            }\n        }\n    }\nend\nlocal renameWin = nil\nlocal winText = \"\"\nlocal function textChanged(tx)\n    winText = tx\nend\nlocal activeObject = nil\nlocal function buttonClick()\n    renameWin:destroy()\n    if (oldName == winText or winText == \"\") then\n        return\n    end\n    core.sendGlobalEvent(\"renameContainer\", { newName = winText, object = activeObject })\n    ui.showMessage(\"You renamed the container.\")\n    I.UI.setMode()\n    activeObject = nil\n    winText = \"\"\nend\nlocal function createWindow(text)\n    return renderTextInput(\n        { \"\", \"\",\n            \"What would you like this container to be named?\" }, text, textChanged, buttonClick)\nend\n\nlocal function CCCstartRename(data)\n    local object = data.object\n    I.UI.setMode(\"Interface\", { windows = {} })\n    local cccData = data.data\n    activeObject = object\n    local currentName = data.currentName\n    oldName = currentName\n    winText = currentName\n    renameWin = createWindow(currentName)\nend\nlocal wasSneaking = false\nlocal function onUpdate(dt)\n    local isSneaking = self.controls.sneak\n    if (isSneaking ~= wasSneaking) then\n        core.sendGlobalEvent(\"CCCSneakUpdate\", isSneaking)\n    end\n    wasSneaking = isSneaking\nend\nlocal function splitString(inputString)\n    local result = {}\n    local currentItem = \"\"\n    local insideQuotes = false\n\n    for i = 1, #inputString do\n        local char = inputString:sub(i, i)\n\n        if char == \"'\" or char == '\"' then\n            insideQuotes = not insideQuotes\n            currentItem = currentItem .. char\n        elseif char == \" \" and not insideQuotes then\n            if currentItem ~= \"\" then\n                table.insert(result, currentItem)\n                currentItem = \"\"\n            end\n        else\n            currentItem = currentItem .. char\n        end\n    end\n\n    if currentItem ~= \"\" then\n        table.insert(result, currentItem)\n    end\n\n    -- Check if the last item is a number and remove it along with the space in front\n    local lastItem = result[#result]\n    local lastItemNumber = tonumber(lastItem)\n    local wholeStringMinusLastNumber = inputString\n    if lastItemNumber then\n        table.remove(result)\n        wholeStringMinusLastNumber = inputString:sub(1, #inputString - #lastItem - 1)\n    end\n\n    return result, lastItemNumber, wholeStringMinusLastNumber\nend\nlocal function onConsoleCommand(mode, cmd, selectedObject)\n    local cmdSpl = splitString(cmd)\n    if (cmdSpl[1] == \"renamec\") then\n        local name = string.sub(cmd, string.len(cmdSpl[1]) + 2) --this variable contains the command string, minus the first word and the space after it. --this variable contains the command string, minus the first word and the space after it. --this variable contains the command string, minus the first word and the space after it. --this variable contains the command string, minus the first word and the space after it. --this variable contains the command string, minus the first word and the space after it.\n        core.sendGlobalEvent(\"renameContainer\", { newName = name, object = selectedObject })\n    end\nend\nlocal openedContainer\nlocal function openContainerInv(obj)\n    I.UI.setMode(\"Container\", { target = obj })\n    openedContainer = obj\nend\nreturn {\n    engineHandlers = { onConsoleCommand = onConsoleCommand, onConsume = onConsume, onUpdate = onUpdate },\n    eventHandlers = {\n        CCCstartRename   = CCCstartRename,\n        openContainerInv = openContainerInv,\n        CCC_Message      = function(message)\n            ui.showMessage(message)\n        end,\n        CCC_PlaySound    = function(sound)\n            ambient.playSound(sound)\n        end,\n        UiModeChanged    = function(data)\n            if data.oldMode == \"Container\" and openedContainer then\n                -- I.UI.setMode(\"Interface\", { windows = {} })\n                core.sendGlobalEvent(\"updateClosedCont\")\n                openedContainer = nil\n            end\n        end\n    }\n}\n"
  }
}