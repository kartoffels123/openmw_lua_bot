{
  "folder_name": "MouseWheel Control KeyBinding for OpenMW",
  "lua_files": {
    "Mousewheel-Control-KeyBinding-55201-1-0-0-1725815689\\Mousewheel-Control-KeyBinding\\Scripts\\ScrollHotKeyCombo\\menu.lua": "\nlocal input = require('openmw.input')\nlocal async = require('openmw.async')\nlocal ui = require('openmw.ui')\nlocal I = require('openmw.interfaces')\nlocal util = require('openmw.util')\nlocal v2 = util.vector2\n\nlocal function myFunction(value, set)\n    local name = \"No Key Set\"\n    -- Retrieve existing keybindings\n    if value then\n        name = input.getKeyName(value)\n    end\n\n    -- Debug print to check values\n    --print(\"myFunction called with value:\", value)\n    --print(\"Computed name:\", name)\n\n    return {\n        template = I.MWUI.templates.box,\n\n        content = ui.content {\n            {\n                template = I.MWUI.templates.padding,\n                props = {\n                    anchor = v2(0.3, 0),\n                },\n                content = ui.content {\n                    {\n                        template = I.MWUI.templates.textEditLine,\n                        events = {\n                            keyPress = async:callback(function(e)\n                                if e.code == input.KEY.Escape then return end\n\n                                set(e.code)  -- Update the setting with the new key code\n                            end),\n                        },\n                        props = {\n                            text = name,\n\t\t\t\t\t\t\t--textColor = util.color.rgb(50, 0, 0),\n\t\t\t\t\t\t\ttextAlignH = ui.ALIGNMENT.End,\n                        },\n                    },\n                },\n            },\n        },\n    }\nend\n\n\nI.Settings.registerRenderer(\"nitroInputKeySelection\", myFunction)\n\n\n\n--[[\nI.Settings.registerRenderer(\"nitroInputKeySelection\", function(value, set)\n    -- Debug print to check if this function is called\n    --print(\"Renderer function called with value:\", value)\n\n    return myFunction(value, set)\nend)\n]]--",
    "Mousewheel-Control-KeyBinding-55201-1-0-0-1725815689\\Mousewheel-Control-KeyBinding\\Scripts\\ScrollHotKeyCombo\\modInfo.lua": "--[[\n\nMod: Scroll HotKey\nAuthor: Nitro\n\n--]]\n\nreturn {\n\tname = \"ScrollHotKeyCombo\",\n\tversion = \"1.0.0\"\n}\n",
    "Mousewheel-Control-KeyBinding-55201-1-0-0-1725815689\\Mousewheel-Control-KeyBinding\\Scripts\\ScrollHotKeyCombo\\player.lua": "--[[\n\nMod: Scrollable Weapons and Spells\nAuthor:Nitro\n\n--]]\n\nlocal aux_util = require(\"openmw_aux.util\")\nlocal core = require(\"openmw.core\")\nlocal self = require(\"openmw.self\")\nlocal storage = require(\"openmw.storage\")\nlocal types = require(\"openmw.types\")\nlocal ui = require(\"openmw.ui\")\nlocal ambient = require(\"openmw.ambient\")\nlocal input = require(\"openmw.input\")\n\nlocal modInfo = require(\"Scripts.ScrollHotKeyCombo.modInfo\")\n\nlocal playerSettings = storage.playerSection(\"SettingsPlayer\" .. modInfo.name)\nlocal userInterfaceSettings = storage.playerSection(\"SettingsPlayer\" .. modInfo.name .. \"UI\")\nlocal controlsSettings = storage.playerSection(\"SettingsPlayer\" .. modInfo.name .. \"Controls\")\nlocal gameplaySettings = storage.playerSection(\"SettingsPlayer\" .. modInfo.name .. \"Gameplay\")\n\nlocal Actor = types.Actor\nlocal Armor = types.Armor\nlocal Item = types.Item\nlocal Weapon = types.Weapon\nlocal Clothing = types.Clothing\nlocal Book = types.Book\nlocal SLOT_CARRIED_RIGHT = Actor.EQUIPMENT_SLOT.CarriedRight\n\n\nlocal weaponHotKeyPressed = false\nlocal spellHotKeyPressed = false\n\nlocal debug = true\nlocal function d_message(msg)\n\tif not debug then return end\n\n\tui.showMessage(tostring(msg))\nend\n\nlocal function d_print(fname, msg)\n\tif not debug then return end\n\n\tif fname == nil then\n\t\tfname = \"\\x1b[35mnil\"\n\tend\n\n\tif msg == nil then\n\t\tmsg = \"\\x1b[35mnil\"\n\tend\n\n\tprint(\"\\n\\t\\x1b[33;3m\" .. tostring(fname) .. \"\\n\\t\\t\\x1b[33;3m\" .. tostring(msg) .. \"\\n\\x1b[39m\")\nend\n\nlocal WEAPON_TYPES_TWO_HANDED = {\n\t[Weapon.TYPE.LongBladeTwoHand] = true,\n\t[Weapon.TYPE.BluntTwoClose] = true,\n\t[Weapon.TYPE.BluntTwoWide] = true,\n\t[Weapon.TYPE.SpearTwoWide] = true,\n\t[Weapon.TYPE.AxeTwoHand] = true,\n\t[Weapon.TYPE.MarksmanBow] = true,\n\t[Weapon.TYPE.MarksmanCrossbow] = true,\n}\n\nlocal trinkets = {\n\t[Clothing.TYPE.Amulet] = true,\n\t[Clothing.TYPE.Ring] = true,\n}\n\nlocal WEAPON_SOUNDS = {\n    [Weapon.TYPE.AxeOneHand] = \"Item Weapon Blunt Up\",\n    [Weapon.TYPE.AxeTwoHand] = \"Item Weapon Blunt Up\",\n    [Weapon.TYPE.BluntOneHand] = \"Item Weapon Blunt Up\",\n    [Weapon.TYPE.BluntTwoClose] = \"Item Weapon Blunt Up\",\n    [Weapon.TYPE.BluntTwoWide] = \"Item Weapon Blunt Up\",\n    [Weapon.TYPE.LongBladeOneHand] = \"Item Weapon Longblade Up\",\n    [Weapon.TYPE.LongBladeTwoHand] = \"Item Weapon Longblade Up\",\n    [Weapon.TYPE.MarksmanBow] = \"Item Weapon Bow Up\",\n    [Weapon.TYPE.MarksmanCrossbow] = \"Item Weapon Bow Up\",\n    [Weapon.TYPE.MarksmanThrown] = \"Item Weapon Blunt Up\",\n    [Weapon.TYPE.ShortBladeOneHand] = \"Item Weapon Shortblade Up\",\n    [Weapon.TYPE.SpearTwoWide] = \"Item Weapon Spear Up\",\n}\n\nlocal function isTrinket(clothing)\n\treturn (clothing)\n\t\tand (Clothing.objectIsInstance(clothing))\n\t\tand (trinkets[Clothing.record(clothing).type])\nend\n\nlocal function isScroll(book)\n\treturn (book)\n\t\tand (Book.objectIsInstance(book))\nend\n\nlocal function message(msg, _)\n\tif (userInterfaceSettings:get(\"showMessages\")) then ui.showMessage(msg) end\nend\n\n--Function which returns the weapon id when provided a weapon object\nlocal function weapID(weapon)\n\tif weapon and Weapon.objectIsInstance(weapon) then -- not sure what this really does\n    return Weapon.record(weapon).id -- Use the weapon's unique ID\n\tend\nend\n\nlocal function spellID(spell)\n\tif spell and spell.type then\n\t\treturn spell.id\n\tend\nend\n\nlocal function enchantedID(enchantedItem)\n\t--enchantedItem should be of the form: item.type.records[item.recordId].enchant\n\treturn core.magic.enchantments.records[enchantedItem]\nend\n\nlocal function getEnchantment(id) --\n    return core.magic.enchantments.records[id]\nend\n\n\n--Finds the enchantment\nlocal function FindEnchantment(item)\n\t--Added or item.type == 0 for spells\n\t--Added or item.type == 5 for powers\n    if (item == nil or item.type == nil or item.type == 0 or item.type == 5 or item.type.records[item.recordId] == nil or item.type.records[item.recordId].enchant == nil or item.type.records[item.recordId].enchant == \"\") then\n        return nil\n    end\n    return getEnchantment(item.type.records[item.recordId].enchant)\nend\n\n--my new sorting function:\nlocal function sortWeapons(weaponListToSort, sortDirection, debug)\n\t-- Step 1: Create a new table with weapon names and their corresponding objects\n\tlocal weaponsWithNames = {}\n\tlocal getSort = sortDirection\n\tfor _, weapon in pairs(weaponListToSort) do\n\t\tlocal weaponName = Weapon.record(weapon).name\n\t\ttable.insert(weaponsWithNames, { weapon = weapon, name = weaponName })\n\tend\n\n\t-- Step 2: Define a comparison function for sorting\n\tlocal function compareWeapons(a, b)\n\t\tif getSort == 'descend' or getSort == 2 then --User input of either ascend or 1 or nil returns alphabetical sort\n\t\t\treturn a.name > b.name\n\t\telse\n\t\t\treturn a.name < b.name\n\t\tend\n\tend\n\n\t-- Step 3: Sort the table based on weapon names\n\ttable.sort(weaponsWithNames, compareWeapons)\n\n\t-- Step 4: Extract the sorted weapon objects if needed\n\tlocal sortedWeapons = {}\n\tfor i, weaponData in ipairs(weaponsWithNames) do\n\t\ttable.insert(sortedWeapons, weaponData.weapon)\n\tend\n\n\tif debug then\n\t\t-- Print sorted weapon names for verification\n\t\tfor i, weapon in ipairs(sortedWeapons) do\n\t\t\tprint(\"Sorted Weapon:\", Weapon.record(weapon).name)\n\t\tend\n\tend\n\n\treturn sortedWeapons\nend\n\nlocal function equip(slot, object)\n    local equipment = Actor.equipment(self)\n    equipment[slot] = object\n    Actor.setEquipment(self, equipment)\n\t--the following line plays the proper sound when weapon is equipped\n\tambient.playSound(WEAPON_SOUNDS[Weapon.record(object).type])\nend\n\nlocal function equipSpell(object, debug)\n\t--local mySpell = object\n\t--non valid object types return 0!!\n\tif debug then\n\t\tprint(\"object:\", object, \"type:\", object.type ,\"record:\", (object.type ~= 0) and object.type.record(object))\n\t\tprint(types[tostring(object.type)]) --returns nil if not a valid object.type\n\tend\n\n\tlocal record = types[tostring(object.type)] and types[tostring(object.type)].record(object) or nil\n\n\tif (record and record.enchant) then\n\t\tActor.setSelectedEnchantedItem(self, object)\n\telse\n\t\t--running into an issue where I cannot setSelectedSpell when an echanteditem is selected..\n\t\tActor.setSelectedSpell(self, object)\n\tend\nend\n\nlocal function NextItem(itemList, getCurrent, equipItem, isSpell, debug)\n    local currentItem, currentEnchItem = getCurrent()\n    local foundEquipped = false\n    local repeatItems = {}\n\tlocal prevItem\n\n    if debug then\n        print(\"Current item:\", currentItem and currentItem or currentEnchItem)\n    end\n\n    if not itemList then return end\n    for _, item in pairs(itemList) do\n        local key = isSpell and tostring(item) or weapID(item)\n\t\tif debug then\n\t\t\tprint(\"Current key:\", key)\n\t\tend\n        if foundEquipped then\n            if not repeatItems[key] then\n\t\t\t\tif debug then\n\t\t\t\t\tprint(\"Attempting to Equip Item...\", key)\n\t\t\t\t\tprint(\"enchID:\", FindEnchantment(prevItem), \"item.type:\", item.type)\n\t\t\t\tend\n\t\t\t\tif isSpell and FindEnchantment(prevItem) ~= nil and (item.type == 0 or item.type == 5) then --item.type = 0 means its a spell. \n\t\t\t\t\tActor.clearSelectedCastable(self)\n\t\t\t\t\tequipItem(item)\n\t\t\t\t\treturn\n\t\t\t\telse\n\t\t\t\t\tequipItem(item)\n\t\t\t\t\treturn\n\t\t\t\tend\n            end\n        elseif key == (isSpell and tostring(currentItem) or weapID(currentItem)) or key == (isSpell and tostring(currentEnchItem) or weapID(currentItem)) then\n            foundEquipped = true\n\t\t\tprevItem = item\n\t\t\t--print(\"PreviousItemType:\",prevItem.type)\n        end\n        repeatItems[key] = true\n    end\n\n    for _, item in pairs(itemList) do\n        local key = isSpell and tostring(item) or weapID(item)\n        if repeatItems[key] then\n\t\t\tif isSpell then\n\t\t\t\tActor.clearSelectedCastable(self)\n\t\t\t\tequipItem(item)\n\t\t\t\treturn\n\t\t\telse\n\t\t\t\tequipItem(item)\n\t\t\t\treturn\n\t\t\tend\n        end\n    end\nend\n\nlocal function NextSpell(spellList, debug)\n    local getCurrentSpell = function() return Actor.getSelectedSpell(self), Actor.getSelectedEnchantedItem(self) end\n    local equipMySpell = function(spell) equipSpell(spell) end\n    NextItem(spellList, getCurrentSpell, equipMySpell, true, debug)\nend\n\nlocal function NextWeapon(meleeWeapons, debug)\n    local getCurrentWeapon = function() return Actor.equipment(self)[SLOT_CARRIED_RIGHT] end\n    local equipWeapon = function(weapon) equip(SLOT_CARRIED_RIGHT, weapon) end\n    NextItem(meleeWeapons, getCurrentWeapon, equipWeapon, false, debug)\nend\n\n--Function that sorts all weapons obtained from player and filters out arrows\nlocal function getNonArrowWeapons(weaponList, debug)\n\t\t-- Color codes for formatting\n\t\tlocal colorReset = \"\\x1b[0m\"\n\t\tlocal colorIndex = \"\\x1b[33m\"  -- Yellow for index\n\t\tlocal colorObject = \"\\x1b[35m\" -- Purple for object\n\t\tlocal colorType = \"\\x1b[36m\"   -- Cyan for type\n\t\tlocal nonArrows = {}\n\t\tlocal ldebug\n\t\tif debug then\n\t\t\tldebug = true\n\t\telse\n\t\t\tldebug = false\n\t\tend\n\t\tfor i, weapon in ipairs(weaponList) do\n\t\t\tlocal weaponRecord = Weapon.record(weapon)\n\t\t\tlocal weaponType = weaponRecord and weaponRecord.type or \"Unknown\"\n\t\t\tlocal weapon_ID = weaponRecord.id\n\t\t\t--Weapon type 12 is arrows\n\t\t\tif weaponType ~= 12 then\n\t\t\t\tif ldebug then\n\t\t\t\t\tprint(colorIndex .. \"[\" .. i .. \"]\" .. colorReset .. \" = \" .. colorObject .. tostring(weapon) .. colorReset .. \" (\" .. colorType .. Weapon.record(weapon).name .. colorReset .. \"), \" \n\t\t\t\t\t\t\t\t.. Weapon.record(weapon).type .. \" || \" .. weapon_ID)\n\t\t\t\tend\n\t\t\t\tnonArrows[i] = weapon\n\t\t\tend\n\t\tend\n\treturn nonArrows\nend\n\nlocal function getEnchantItems(object, filterFunc)\n\tlocal enchItems = {}\n\tfor k, v in pairs(object) do  --object[k] == v; k is just the index when used in this context\n\t\tlocal mytype = v.type\n\t\tif mytype then\n\t\t\tlocal recordType = types[tostring(mytype)] -- may be able to get away with just straight passing myType to record(v) need to test\n\t\t\tif (recordType == Armor or recordType == Clothing or recordType == Weapon or recordType == types.Book) then\n\t\t\t\tlocal record = recordType.record(v)\n\t\t\t\tlocal ench = record.enchant and\tcore.magic.enchantments.records[record.enchant] or \"No Enchantment\"\n\t\t\t\t--print(\"\\nID:\",record.id,\"\\nNAME:\", record.name, \"\\nEnchant:\", record.enchant,\n\t\t\t\t\t--\"\\ngetEnchantment:\", ench, \"\\nEnchantment Type:\", ench.type)\n\t\t\t\tif ench.type == core.magic.ENCHANTMENT_TYPE.CastOnUse or ench.type == core.magic.ENCHANTMENT_TYPE.CastOnce then\n\t\t\t\t\tlocal enchName = record.name\n\t\t\t\t\tif not filterFunc or filterFunc(v)then\n\t\t\t\t\t\ttable.insert(enchItems, {obj = v, name = enchName})\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\ttable.sort(enchItems, function(a, b) return a.name < b.name end)\n    -- Remove the 'name' field after sorting\n    -- Flatten the table to only include objects\n    local flattenedItems = {}\n    for _, item in ipairs(enchItems) do\n        --print(\"FlattenedItems:\",item.obj)\n\t\ttable.insert(flattenedItems, item.obj)\n    end\n\n    return flattenedItems\nend\n\nlocal function getSpellsAndPowers(totalSpells)\n\tif totalSpells == nil then return end\n\tlocal allSpells = totalSpells\n\tlocal spells = {}\n\tlocal powers = {}\n\t-- Assume allSpells is a table containing the actor's spells\n\tfor _, spell in pairs(allSpells) do\n\t\tif spell.type == core.magic.SPELL_TYPE.Spell then\n\t\t\ttable.insert(spells, spell)\n\t\telseif spell.type == core.magic.SPELL_TYPE.Power then\n\t\t\ttable.insert(powers, spell)\n\t\tend\n\tend\n\n\t-- Sort spells and powers based on their name\n\ttable.sort(spells, function(a, b) return a.name < b.name end)\n\ttable.sort(powers, function(a, b) return a.name < b.name end)\n\n\treturn spells, powers\nend\n\nlocal function reverseTable(t)\n    local reversed = {}\n    for i = #t, 1, -1 do\n        table.insert(reversed, t[i])\n    end\n    return reversed\nend\n\nlocal function onKeyPress(key)\n\t--need to set up a few logicals to pickup the weapon, spell, or enchanted item hotkey.\n\t--can extend the hot key to differentiate between scrolls, enchanted items, spells\n\t--can add option to disregard non-ring or neck piece items\n\t--Need to have option to have Default Behavior, e.g. 1 hotkey for all spells, powers, and enchanted items\n\tlocal WEAPSCROLL_HOTKEY = controlsSettings:get(\"nextWeaponHotKey\")\n\tlocal SPELLSCROLL_HOTKEY = controlsSettings:get(\"nextSpellHotKey\")\n\tif (not playerSettings:get(\"modEnable\")) or ((key.code ~= WEAPSCROLL_HOTKEY) and (key.code ~= SPELLSCROLL_HOTKEY)) or core.isWorldPaused()  then return end\n\n\tif  (key.code == WEAPSCROLL_HOTKEY) then\n\t\tweaponHotKeyPressed = true\n\tend\n\tif (key.code == SPELLSCROLL_HOTKEY) then\n\t\tspellHotKeyPressed = true\n\tend\n\nend\n\nlocal function onKeyRelease(key)\n    local WEAPSCROLL_HOTKEY = controlsSettings:get(\"nextWeaponHotKey\")\n\tlocal SPELLSCROLL_HOTKEY = controlsSettings:get(\"nextSpellHotKey\")\n\tif (not playerSettings:get(\"modEnable\")) or ((key.code ~= WEAPSCROLL_HOTKEY) and (key.code ~= SPELLSCROLL_HOTKEY)) or core.isWorldPaused() then return end\n\n\tif key.code == WEAPSCROLL_HOTKEY then\n\t\tweaponHotKeyPressed = false\n\telseif key.code == SPELLSCROLL_HOTKEY then\n\t\tspellHotKeyPressed = false\n\tend\nend\n\nlocal function onMouseWheel(vertical, horizontal)\n\tlocal vert = vertical\n\n\tif weaponHotKeyPressed and not input.isActionPressed(input.ACTION.Use) then\n\t\tlocal weaponList = Actor.inventory(self):getAll(Weapon)\n\t\tlocal myWeapons = getNonArrowWeapons(weaponList)\n\t\tlocal test = false\n\n        if vert > 0 then\n\t\t\tlocal fwdSortedWeapons = sortWeapons(myWeapons, _, test) or \"noDataYet\"\n            NextWeapon(fwdSortedWeapons, test) -- Call your function to switch to the next weapon\n        elseif vert < 0 then\n\t\t\tlocal revSortedWeapons = sortWeapons(myWeapons, 2, test) or \"noDataYet\"\n            NextWeapon(revSortedWeapons, test) -- Call your function to switch to the previous weapon\n        end\n    end\n\n\tif spellHotKeyPressed and not input.isActionPressed(input.ACTION.Use) then\n\t\tlocal allSpells = Actor.spells(self)\n\t\tlocal spells, powers = getSpellsAndPowers(allSpells)\n\t\tlocal invItems = Actor.inventory(self):getAll()\n\t\tlocal enchantedItemsFromInv = getEnchantItems(invItems)\n\t\tlocal enchantedTrinkets = getEnchantItems(invItems, isTrinket)\n\t\tlocal noScrolls = getEnchantItems(invItems, function(item) return not isScroll(item) end)\n\t\tlocal combinedList = {}\n\t\tlocal EnchantState = gameplaySettings:get(\"enchantSelect\")\n\t\tlocal trinketState = gameplaySettings:get(\"trinketsOnly\")\n\t\tlocal scrollState = gameplaySettings:get(\"excludeScrolls\")\n\n\t\t--Logic that combines powers, spells and enchanted items\n\t\tif powers ~= nil and gameplaySettings:get(\"powerSelect\") then\n\t\t\tfor _, power in pairs(powers) do\n\t\t\t\ttable.insert(combinedList, power)\n\t\t\tend\n\t\tend\n\t\tif spells ~= nil and gameplaySettings:get(\"spellSelect\") then\n\t\t\tfor _, spell in pairs(spells) do\n\t\t\t\ttable.insert(combinedList, spell)\n\t\t\tend\n\t\tend\n\n\t\tif EnchantState and scrollState and not trinketState then\n\t\t\t-- Copy elements from enchantedItemsFromInv to combined\n\t\t\tfor _, item in pairs(noScrolls) do\n\t\t\t\ttable.insert(combinedList, item)\n\t\t\tend\n\t\telseif EnchantState and trinketState then\n\t\t\tfor _, item in pairs(enchantedTrinkets) do\n\t\t\t\t--print(item)\n\t\t\t\ttable.insert(combinedList, item)\n\t\t\tend\n\t\telseif EnchantState and not trinketState then\n\t\t\tfor _, item in pairs(enchantedItemsFromInv) do\n\t\t\t\ttable.insert(combinedList, item)\n\t\t\tend\n\t\tend\n\n\t\tlocal rev = reverseTable(combinedList)\n        if vert > 0 then\n\t\t\t--NextSpell is working, need to adopt it to enchanted items\n\t\t\tNextSpell(combinedList)\n        elseif vert < 0 then\n\t\t\t--pass reversed list of spells to NextSpell\n\t\t\tNextSpell(rev)\n        end\n    end\nend\n\nreturn {\n\tengineHandlers = {\n\t\tonKeyPress = onKeyPress,\n\t\tonKeyRelease = onKeyRelease,\n\t\tonMouseWheel = onMouseWheel,\n\t}\n}\n",
    "Mousewheel-Control-KeyBinding-55201-1-0-0-1725815689\\Mousewheel-Control-KeyBinding\\Scripts\\ScrollHotKeyCombo\\settings.lua": "--[[\n\nMod: MultiKeyCombo\nAuthor: Nitro\n\n--]]\n\nlocal async = require(\"openmw.async\")\nlocal core = require(\"openmw.core\")\nlocal I = require(\"openmw.interfaces\")\nlocal input = require(\"openmw.input\")\nlocal ui = require(\"openmw.ui\")\n\nlocal modInfo = require(\"Scripts.ScrollHotKeyCombo.modInfo\")\n\nlocal pageDescription = \"By Nitro\\nv\" .. modInfo.version .. \"\\n\\nScrollable Magick and weapons. This mod allows\" ..\n\t\t\t\t\t\t\" mousewheel + KeyBind to scroll through weapons and spells.\" ..\n\t\t\t\t\t\t\" The keybinds are userdefined, and there are several options to specify which spells to include in the spell selection.\"\nlocal modEnableDescription = \"This enables the mod or disables it.\"\nlocal showMessagesDescription = \"Enables UI messages to be shown for any cases which require it. (Currently none)\"\nlocal weaponHotkeyDescription = \"This is the key to bind to a scrollable mousewheel input (e.g. key + MouseWheelUp) for weapon selection\"\nlocal spellHotkeyDescription = \"This is the key to bind to a scrollable mousewheel input (e.g. key + MouseWheelUp) for spell selection\"\nlocal spellSelectDescription = \"Include spells in spell selection:\"\nlocal powerSelectDescription = \"Include powers in spell selection:\"\nlocal EnchItemSelectDescription = \"Include Enchanted Items in Spell selection:\"\nlocal trinketsOnlyDescription = \"This will limit the scrolled magic enchanted items to rings and amulets ONLY\"\nlocal spellScrollDescription = \"This will exclude Spell Scrolls from the Spell List\"\n\nlocal function setting(key, renderer, argument, name, description, default)\n\treturn {\n\t\tkey = key,\n\t\trenderer = renderer,\n\t\targument = argument,\n\t\tname = name,\n\t\tdescription = description,\n\t\tdefault = default,\n\t}\nend\n\nI.Settings.registerPage {\n\tkey = modInfo.name,\n\tl10n = modInfo.name,\n\tname = \"Mousewheel-Control-Keybinds\",\n\tdescription = pageDescription\n}\n\nI.Settings.registerGroup {\n\tkey = \"SettingsPlayer\" .. modInfo.name,\n\tpage = modInfo.name,\n\torder = 0,\n\tl10n = modInfo.name,\n\tname = \"General\",\n\tpermanentStorage = false,\n\tsettings = {\n\t\tsetting(\"modEnable\", \"checkbox\", {}, \"Enable Mod\", modEnableDescription, true),\n\t}\n}\n\nI.Settings.registerGroup {\n\tkey = \"SettingsPlayer\" .. modInfo.name .. \"UI\",\n\tpage = modInfo.name,\n\torder = 1,\n\tl10n = modInfo.name,\n\tname = \"UI\",\n\tpermanentStorage = false,\n\tsettings = {\n\t\tsetting(\"showMessages\", \"checkbox\", {}, \"Show Messages\", showMessagesDescription, true),\n\t}\n}\n\nI.Settings.registerGroup {\n\tkey = \"SettingsPlayer\" .. modInfo.name .. \"Controls\",\n\tpage = modInfo.name,\n\torder = 2,\n\tl10n = modInfo.name,\n\tname = \"Controls\",\n\tpermanentStorage = false,\n\tsettings = {\n\t\tsetting(\"nextWeaponHotKey\", \"nitroInputKeySelection\", {}, \"Weapon Scroll Key\", weaponHotkeyDescription, input.KEY.X),\n\t\tsetting(\"nextSpellHotKey\", \"nitroInputKeySelection\", {}, \"Spell Scroll Key\", spellHotkeyDescription, input.KEY.Z),\n\t}\n}\n\n\n-- No need to even show this setting in 0.48\nif (core.API_REVISION >= 31) then\n\tI.Settings.registerGroup {\n\t\tkey = \"SettingsPlayer\" .. modInfo.name .. \"Gameplay\",\n\t\tpage = modInfo.name,\n\t\torder = 3,\n\t\tl10n = modInfo.name,\n\t\tname = \"Gameplay\",\n\t\tpermanentStorage = false,\n\t\tdescription = \"The default behavior is to allow scrolling of powers, spells and enchanted items equivalent to base game.\",\n\t\tsettings = {\n\t\t\tsetting(\"powerSelect\", \"checkbox\", {}, \"Powers\", powerSelectDescription, true),\n\t\t\tsetting(\"spellSelect\", \"checkbox\", {}, \"Spells\", spellSelectDescription, true),\n\t\t\tsetting(\"enchantSelect\", \"checkbox\", {}, \"Enchanted Items\", EnchItemSelectDescription, true),\n\t\t\tsetting(\"trinketsOnly\", \"checkbox\", {}, \"Limit enchanted item scrolling\", trinketsOnlyDescription, false),\n\t\t\tsetting(\"excludeScrolls\", \"checkbox\", {}, \"Exclude Spell Scrolls\", spellScrollDescription, false),\n\t\t}\n\t}\nend\n\n--[[ for _, actionInfo in ipairs(actions) do\n\t--print(actionInfo)\n\tinput.registerAction(actionInfo)\nend ]]\n\nprint(\"[\" .. modInfo.name .. \"] Initialized v\" .. modInfo.version)\n"
  }
}