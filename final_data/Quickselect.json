{
  "folder_name": "Quickselect",
  "lua_files": {
    "Quickselect-54587-1-0-2-1715456104\\scripts\\QuickSelect\\ci_favorite_storage.lua": "local core = require(\"openmw.core\")\n\nlocal self = require(\"openmw.self\")\nlocal types = require('openmw.types')\nlocal nearby = require('openmw.nearby')\nlocal camera = require('openmw.camera')\nlocal util = require('openmw.util')\nlocal async = require('openmw.async')\nlocal storage = require('openmw.storage')\nlocal I = require('openmw.interfaces')\n\nlocal settings = storage.playerSection(\"SettingsQuickSelect\")\n\nlocal utility = require(\"scripts.QuickSelect.qs_utility\")\nlocal storedItems\n\nlocal function getFavoriteItems()\n    if not storedItems then\n        storedItems = {}\n        for i = 1, 30, 1 do\n            storedItems[i] = { num = i, item = nil }\n        end\n    end\n    return storedItems\nend\nlocal function getFavoriteItemData(slot)\n    getFavoriteItems()\n    return storedItems[slot]\nend\nlocal function deleteStoredItemData(slot)\n    getFavoriteItems()\n    storedItems[slot].spell     = nil\n    storedItems[slot].spellType = nil\n    storedItems[slot].enchantId = nil\n    storedItems[slot].itemId    = nil\n    storedItems[slot].item      = nil\nend\nlocal function saveStoredItemData(id, slot)\n    getFavoriteItems()\n    --print(id, slot)\n    deleteStoredItemData(slot   )\n    storedItems[slot].item      = id\nend\nlocal function saveStoredSpellData(spellId, spellType, slot)\n    getFavoriteItems()\n    deleteStoredItemData(slot   )\n    storedItems[slot].spellType = spellType\n    storedItems[slot].spell     = spellId\nend\nlocal function saveStoredEnchantData(enchantId, itemId, slot)\n    getFavoriteItems()\n    deleteStoredItemData(slot   )\n    storedItems[slot].spellType = \"Enchant\"\n    storedItems[slot].enchantId = enchantId\n    storedItems[slot].itemId    = itemId\nend\nlocal function findItem(id)\n    for index, value in ipairs(types.Actor.inventory(self)) do\n\n    end\nend\nlocal function isSlotEquipped(slot)\n    local item = getFavoriteItemData(slot)\n    if item then\n        if item.spell and not item.enchantId then\n            local spell = types.Actor.getSelectedSpell(self)\n            if not spell then return false end\n            return spell.id == item.spell\n        elseif item.enchantId then\n            --print(\"enchant:\", slot)\n            local equip = types.Actor.getSelectedEnchantedItem(self)\n            if not equip then return false end\n            local realItem = types.Actor.inventory(self):find(item.itemId)\n            if not realItem then return false end\n\n            return types.Actor.getSelectedEnchantedItem(self).recordId == realItem.recordId\n        elseif item.item then\n            local equip = types.Actor.equipment(self)\n            local realItem = types.Actor.inventory(self):find(item.item)\n            if not realItem then return false end\n            local slot = utility.findSlot(realItem)\n            if not slot then\n                return false\n            end\n            return equip[slot] == realItem\n        end\n    end\n    return false\nend\nlocal function getEquipped(item)\n    local equip = types.Actor.equipment(self)\n    for index, value in pairs(equip) do\n        if value == item then\n            \n            return index\n        end\n    end\n    return nil\nend\nlocal function equipSlot(slot)\n    local item = getFavoriteItemData(slot)\n    if item then\n        if item.spell and not item.enchantId then\n            types.Actor.clearSelectedCastable(self)\n            types.Actor.setSelectedSpell(self, item.spell)\n\n            async:newUnsavableSimulationTimer(0.3, function()\n                if types.Actor.getStance(self) ~= types.Actor.STANCE.Spell then\n                    types.Actor.setStance(self, types.Actor.STANCE.Spell)\n                end\n            end)\n        elseif item.enchantId then\n            local equip = types.Actor.equipment(self)\n            local realItem = types.Actor.inventory(self):find(item.itemId)\n            if not realItem then return end\n            types.Actor.setSelectedEnchantedItem(self, realItem)\n\n            async:newUnsavableSimulationTimer(0.1, function()\n                if types.Actor.getStance(self) ~= types.Actor.STANCE.Spell then\n                    types.Actor.setStance(self, types.Actor.STANCE.Spell)\n                end\n            end)\n        elseif item.item then\n            local realItem = types.Actor.inventory(self):find(item.item)\n            if not realItem then return end\n            local equipped = getEquipped(realItem)\n            if not equipped then\n                core.sendGlobalEvent('UseItem', { object = realItem, actor = self })\n\n                if realItem.type == types.Weapon or realItem.type == types.Lockpick or realItem.type == types.Probe then\n                    async:newUnsavableSimulationTimer(0.1, function()\n                        if types.Actor.getStance(self) ~= types.Actor.STANCE.Weapon then\n                            types.Actor.setStance(self, types.Actor.STANCE.Weapon)\n                        end\n                    end)\n                end\n            elseif settings:get(\"unEquipOnHotkey\") then\n                local equip = types.Actor.equipment(self)\n                equip[equipped] = nil\n\n                types.Actor.setEquipment(self, equip)\n            end\n        end\n    end\n\n    async:newUnsavableSimulationTimer(0.1, function()\n        I.QuickSelect_Hotbar.drawHotbar()\n    end)\nend\nreturn {\n\n    interfaceName = \"QuickSelect_Storage\",\n    interface = {\n        saveStoredItemData    = saveStoredItemData,\n        getFavoriteItemData   = getFavoriteItemData,\n        getFavoriteItems      = getFavoriteItems,\n        saveStoredSpellData   = saveStoredSpellData,\n        equipSlot             = equipSlot,\n        saveStoredEnchantData = saveStoredEnchantData,\n        isSlotEquipped        = isSlotEquipped,\n        deleteStoredItemData = deleteStoredItemData,\n    },\n    engineHandlers = {\n        onSave = function()\n            return { storedItems = storedItems }\n        end,\n        onLoad = function(data)\n            storedItems = data.storedItems\n        end,\n    }\n}\n",
    "Quickselect-54587-1-0-2-1715456104\\scripts\\QuickSelect\\ci_icon_render.lua": "local ui = require(\"openmw.ui\")\nlocal I = require(\"openmw.interfaces\")\n\nlocal v2 = require(\"openmw.util\").vector2\nlocal util = require(\"openmw.util\")\nlocal cam = require(\"openmw.interfaces\").Camera\nlocal core = require(\"openmw.core\")\nlocal self = require(\"openmw.self\")\nlocal nearby = require(\"openmw.nearby\")\nlocal types = require(\"openmw.types\")\nlocal Camera = require(\"openmw.camera\")\nlocal camera = require(\"openmw.camera\")\nlocal input = require(\"openmw.input\")\nlocal async = require(\"openmw.async\")\nlocal storage = require(\"openmw.storage\")\nlocal function getIconSize()\n    return 40\nend\nlocal savedTextures = {}\nlocal function textContent(text)\n    return {\n        type = ui.TYPE.Text,\n        template = I.MWUI.templates.textHeader,\n        props = {\n            text = tostring(text),\n            textSize = 10 * 1,\n            arrange = ui.ALIGNMENT.Start,\n            align = ui.ALIGNMENT.Start\n        }\n    }\nend\nlocal function imageContent(resource, half)\n    local size = getIconSize()\n    local opacity = 1\n    if half then\n        opacity = 0.5\n    end\n    local size2 = size\n    if half then\n        size2 = size2 / 2\n    end\n    return {\n        type = ui.TYPE.Image,\n        props = {\n            resource = resource,\n            size = util.vector2(size, size2),\n            alpha = opacity\n            -- relativeSize = util.vector2(1,1)\n        }\n    }\nend\nlocal function getTexture(path)\n    if not savedTextures[path] and path then\n        savedTextures[path] = ui.texture({ path = path })\n    end\n    return savedTextures[path]\nend\nlocal function formatNumber(num)\n    local threshold = 1000\n    local millionThreshold = 1000000\n\n    if num >= millionThreshold then\n        local formattedNum = math.floor(num / millionThreshold)\n        return string.format(\"%dm\", formattedNum)\n    elseif num >= threshold then\n        local formattedNum = math.floor(num / threshold)\n        return string.format(\"%dk\", formattedNum)\n    else\n        return tostring(num)\n    end\nend\nlocal function FindEnchant(item)\n    if not item or not item.id then\n        return nil\n    end\n    if item.enchant then\n        return item.enchant\n    end\n    if (item == nil or item.type == nil or item.type.records[item.recordId] == nil or item.type.records[item.recordId].enchant == nil or item.type.records[item.recordId].enchant == \"\") then\n        return nil\n    end\n    return item.type.records[item.recordId].enchant\nend\n\nlocal function getItemIcon(item, half, selected)\n    local itemIcon = nil\n\n    local selectionResource\n    local drawFavoriteStar = true\n    selectionResource = getTexture(\"icons\\\\quickselect\\\\selected.tga\")\n    local magicIcon = FindEnchant(item) and FindEnchant(item) ~= \"\" and getTexture(\"textures\\\\menu_icon_magic_mini.dds\")\n    local text = \"\"\n    if item and item.type then\n        local record = item.type.records[item.recordId]\n        if not record then\n            --print(\"No record for \" .. item.recordId)\n        else\n            --print(record.icon)\n        end\n        if item.count > 1 then\n            text = formatNumber(item.count)\n        end\n\n        itemIcon = getTexture(record.icon)\n    end\n\n    local selectedContent = {}\n    if selected then\n        selectedContent = imageContent(selectionResource)\n    end\n    local context = ui.content {\n        selectedContent,\n        imageContent(magicIcon, half),\n        imageContent(itemIcon, half),\n        textContent(tostring(text))\n    }\n\n    return context\nend\nlocal function getSpellIcon(iconPath, half, selected)\n    local itemIcon = nil\n\n    local selectionResource\n    local drawFavoriteStar = true\n    selectionResource = getTexture(\"icons\\\\quickselect\\\\selected.tga\")\n    local pendingText = getTexture(\"icons\\\\buying.tga\")\n\n    local selectedContent = {}\n    if selected then\n        selectedContent = imageContent(selectionResource)\n    end\n    itemIcon = getTexture(iconPath)\n\n    local context = ui.content {\n        imageContent(itemIcon, half),\n        selectedContent,\n    }\n\n    return context\nend\nlocal function getEmptyIcon(half, num, selected,useNumber)\n    local selectionResource\n    local drawFavoriteStar = true\n    selectionResource = getTexture(\"icons\\\\quickselect\\\\selected.tga\")\n\n    local selectedContent = {}\n    if selected then\n        selectedContent = imageContent(selectionResource)\n    end\n    local text = \"\"\n    if useNumber then\n        text = tostring(num)\n    end\n    \n    return ui.content {\n        selectedContent,\n        {\n            type = ui.TYPE.Text,\n            template = I.MWUI.templates.textNormal,\n            props = {\n                text = text,\n                textSize = 20 * 1,\n                relativePosition = util.vector2(0.5, 0.5),\n                anchor = util.vector2(0.5, 0.5),\n                arrange = ui.ALIGNMENT.Center,\n                align = ui.ALIGNMENT.Center,\n            },\n            num = num,\n            events = {\n                --          mouseMove = async:callback(mouseMove),\n            },\n        }\n    }\nend\n\nreturn {\n    interfaceName = \"Controller_Icon_QS\",\n    interface = {\n        version = 1,\n        getItemIcon = getItemIcon,\n        getSpellIcon = getSpellIcon,\n        getEmptyIcon = getEmptyIcon,\n    },\n    eventHandlers = {\n    },\n    engineHandlers = {\n    }\n}\n",
    "Quickselect-54587-1-0-2-1715456104\\scripts\\QuickSelect\\ci_tooltipgen.lua": "local types = require(\"openmw.types\")\nlocal self = require(\"openmw.self\")\nlocal core = require(\"openmw.core\")\nlocal I = require(\"openmw.interfaces\")\nlocal function getWeaponTooltipType(record)\n    local type = record.type\n    local wt = types.Weapon.TYPE\n    local thanded = \", \" .. core.getGMST(\"sTwoHanded\")\n    local ohanded = \", \" .. core.getGMST(\"sOneHanded\")\n    if type == wt.Arrow or type == wt.Bolt or type == wt.MarksmanCrossbow or type == wt.MarksmanThrown or type == wt.MarksmanBow then\n        return core.getGMST(\"sSkillMarksman\")\n    elseif type == wt.AxeOneHand then\n        return core.getGMST(\"sSkillAxe\") .. ohanded\n    elseif type == wt.AxeTwoHand then\n        return core.getGMST(\"sSkillAxe\") .. thanded\n    elseif type == wt.BluntOneHand then\n        return core.getGMST(\"sSkillBluntweapon\") .. ohanded\n    elseif type == wt.BluntTwoClose or type == wt.BluntTwoWide then\n        return core.getGMST(\"sSkillBluntweapon\") .. thanded\n    elseif type == wt.LongBladeOneHand then\n        return core.getGMST(\"sSkillLongblade\") .. ohanded\n    elseif type == wt.LongBladeTwoHand then\n        return core.getGMST(\"sSkillLongblade\") .. thanded\n    elseif type == wt.ShortBladeOneHand then\n        return core.getGMST(\"sSkillShortblade\") .. ohanded\n    elseif type == wt.SpearTwoWide then\n        return core.getGMST(\"sSkillSpear\") .. thanded\n    else\n        return \"Unhandled weapon type\"\n    end\nend\nlocal function genMagicTooltips(list, spellRecord, item)\n    local name = spellRecord.name\n\n    table.insert(list,name)\n    for index, value in ipairs(spellRecord.effects) do\n        local range = nil\n        if value.range == core.magic.RANGE.Self then\n            range = core.getGMST(\"sRangeSelf\")\n        elseif value.range == core.magic.RANGE.Target then\n            range = core.getGMST(\"sRangeTarget\")\n        elseif value.range == core.magic.RANGE.Touch then\n            range = core.getGMST(\"sRangeTouch\")\n        end\n        local name = value.effect.name\n        if value.affectedAttribute then\n            name = name .. \" \" .. value.affectedAttribute\n        elseif value.affectedSkill then\n            name = name .. \" \" .. value.affectedSkill\n        end\n        local line\n        if item and item.type == types.Potion then\n            range = \"\"\n        else\n            range = \" on \" .. range\n        end\n        if item and item.type == types.Ingredient then\n            line = string.format(\"%s\", name)\n        elseif value.magnitudeMin == value.magnitudeMax then\n            line = string.format(\"%s %g pts for %g secs%s\", name, value.magnitudeMax, value.duration, range)\n        else\n            line = string.format(\"%s %g to %g pts for %g secs%s\", name, value.magnitudeMin, value.magnitudeMax,\n                value.duration, range)\n        end\n\n        table.insert(list, { text = \"   \" .. line, icon = value.effect.icon })\n    end\nend\n\nlocal function getItemNormalizedHealth(itemData, maxCondition)\n    if itemData.condition == 0 or not itemData.condition then\n        return 0.0\n    else\n        return itemData.condition / tonumber(maxCondition)\n    end\nend\nlocal useSoulgemRebalance = false\n\nlocal function getConditionValues(item)\n    local maxCondition = 0\n    if record.health then\n        maxCondition = record.health\n    elseif record.maxCondition then\n        maxCondition = record.maxCondition\n    end\n    local itemData = types.Item.itemData(item)\n    local norm = getItemNormalizedHealth(itemData, maxCondition)\nend\nlocal function getConditionLine(item)\n    local line = nil\n    local currentCondition = types.Item.itemData(item).condition\n    if item.type == types.Light then\n    elseif item.type == types.Armor or item.type == types.Weapon then\n        local maxCondition = item.type.records[item.recordId].health\n        line = \"Condition: \" .. tostring(math.floor(currentCondition or maxCondition)) .. \"\\\\\" .. tostring(maxCondition)\n    elseif item.type == types.Lockpick or item.type == types.Probe then\n        local maxCondition = item.type.records[item.recordId].maxCondition\n        line               = \"Uses: \" .. tostring(currentCondition or maxCondition)\n    end\n    return line\nend\nlocal function getItemValue(item, ignoreCondition)\n    local record = item.type.records[item.recordId]\n    local value = record.value\n    local maxCondition = 0\n    if record.health then\n        maxCondition = record.health\n    elseif record.maxCondition then\n        maxCondition = record.maxCondition\n    end\n    local itemData = types.Item.itemData(item)\n    if itemData and itemData.condition and not ignoreCondition then\n        value = value * getItemNormalizedHealth(itemData, maxCondition)\n    end\n    if item.type == types.Miscellaneous then\n        local soul = types.Miscellaneous.getSoul(item)\n        if soul and types.Creature.record(soul) then\n            local soulValue = types.Creature.record(soul).soulValue\n            if useSoulgemRebalance then\n                local soulValueNum = 0.0001 * soulValue ^ 3 + 2 * soulValue\n\n                -- Check if the item is Azura's star\n                if item.recordId == \"misc_soulgem_azura\" then\n                    value = value + soulValueNum\n                else\n                    value = soulValueNum\n                end\n            else\n                value = value * soulValue\n            end\n        end\n    end\n    return math.floor(value)\nend\nlocal function getArmorType(armor)\n    if armor.type ~= types.Armor and not armor.baseArmor then\n        error(\"Not Armor\")\n    end\n    local record = nil\n    if armor.baseArmor then --A record was supplied, not a gameObject\n        record = armor\n    else\n        record = types.Armor.record(armor)\n    end\n    local epsilon = 0.0005;\n    local lightMultiplier = core.getGMST(\"fLightMaxMod\") + epsilon\n    local medMultiplier = core.getGMST(\"fMedMaxMod\") + epsilon\n    local armorGMSTs = {\n        [types.Armor.TYPE.Boots] = \"iBootsWeight\",\n        [types.Armor.TYPE.Cuirass] = \"iCuirassWeight\",\n        [types.Armor.TYPE.Greaves] = \"iGreavesWeight\",\n        [types.Armor.TYPE.Shield] = \"iShieldWeight\",\n        [types.Armor.TYPE.LBracer] = \"iGauntletWeight\",\n        [types.Armor.TYPE.RBracer] = \"iGauntletWeight\",\n        [types.Armor.TYPE.RPauldron] = \"iPauldronWeight\",\n        [types.Armor.TYPE.LPauldron] = \"iPauldronWeight\",\n        [types.Armor.TYPE.Helmet] = \"iHelmWeight\",\n        [types.Armor.TYPE.LGauntlet] = \"iGauntletWeight\",\n        [types.Armor.TYPE.RGauntlet] = \"iGauntletWeight\",\n    }\n    local armorType = record.type\n    local weight = record.weight\n    local armorTypeWeight = math.floor(core.getGMST(armorGMSTs[armorType]))\n\n    if weight <= armorTypeWeight * lightMultiplier then\n        return \"Light\"\n    elseif weight <= armorTypeWeight * medMultiplier then\n        return \"Medium\"\n    else\n        return \"Heavy\"\n    end\nend\nlocal function genToolTips(item)\n    local list = {}\n    if item.spell and not item.spell.recordId then\n        genMagicTooltips(list, item.spell, nil)\n        return list\n    elseif item.spell and item.spell.recordId then\n        item = item.spell\n    end\n    if not item.type then\n        return {}\n    end\n    local record = item.type.records[item.recordId]\n    local name = record.name\n    if item.type == types.Miscellaneous and types.Miscellaneous.getSoul(item) then\n        local soulName = types.Creature.record(types.Miscellaneous.getSoul(item)).name\n        name = name .. \" (\" .. soulName .. \")\"\n    end\n    if item.count > 1 then\n        name = name .. \" (\" .. tostring(item.count) .. \")\"\n    end\n    table.insert(list, name)\n    if item.type == types.Weapon then\n        local weaponType = getWeaponTooltipType(record)\n        table.insert(list, weaponType)\n        if weaponType == core.getGMST(\"sSkillMarksman\") then\n            table.insert(list,\n                string.format(core.getGMST(\"sAttack\") .. \": %g - %g\", types.Weapon.records[item.recordId].chopMinDamage,\n                    types.Weapon.records[item.recordId].chopMaxDamage))\n        else\n            table.insert(list,\n                string.format(core.getGMST(\"sChop\") .. \": %g - %g\", types.Weapon.records[item.recordId].chopMinDamage,\n                    types.Weapon.records[item.recordId].chopMaxDamage))\n            table.insert(list,\n                string.format(core.getGMST(\"sSlash\") .. \": %g - %g\", types.Weapon.records[item.recordId].slashMinDamage,\n                    types.Weapon.records[item.recordId].slashMaxDamage))\n            table.insert(list,\n                string.format(core.getGMST(\"sThrust\") .. \": %g - %g\", types.Weapon.records[item.recordId].thrustMinDamage,\n                    types.Weapon.records[item.recordId].thrustMaxDamage))\n        end\n    end\n    local conditionLine = getConditionLine(item)\n    if conditionLine then\n        table.insert(list, conditionLine)\n    end\n    if item.type == types.Armor then\n        local weightType = getArmorType(item)\n        table.insert(list,\n            core.getGMST(\"sWeight\") .. \": \" .. tostring(math.floor(record.weight)) .. \" (\" .. weightType .. \")\")\n        local armorSkillType = weightType:lower() .. \"armor\"\n        local rating = types.Armor.records[item.recordId].baseArmor * (types.NPC.stats.skills[armorSkillType](self).modified / 30)\n        table.insert(list, core.getGMST(\"sArmorRating\") .. \": \" .. tostring(math.floor(rating)))\n    elseif record.weight > 0 then\n        local weight = record.weight\n        local formattedWeight = tostring(math.floor(weight))\n\n        if weight % 1 ~= 0 then\n            formattedWeight = formattedWeight .. string.format(\"%.1f\", weight % 1):sub(2)\n        end\n        table.insert(list, core.getGMST(\"sWeight\") .. \": \" .. formattedWeight)\n    end\n    local value = getItemValue(item)\n    if value > 0 then\n        table.insert(list, core.getGMST(\"sValue\") .. \": \" .. tostring(value))\n    end\n    local spacing = \"   \"\n    if record.enchant ~= \"\" and record.enchant ~= nil then\n        local enchant = core.magic.enchantments.records[record.enchant]\n        if enchant.type == core.magic.ENCHANTMENT_TYPE.CastOnStrike then\n            table.insert(list, core.getGMST(\"sItemCastWhenStrikes\"))\n        elseif enchant.type == core.magic.ENCHANTMENT_TYPE.CastOnUse then\n            table.insert(list, core.getGMST(\"sItemCastWhenUsed\"))\n        elseif enchant.type == core.magic.ENCHANTMENT_TYPE.CastOnce then\n            table.insert(list, core.getGMST(\"sItemCastOnce\"))\n        elseif enchant.type == core.magic.ENCHANTMENT_TYPE.ConstantEffect then\n            table.insert(list, core.getGMST(\"sItemCastConstant\"))\n        end\n        genMagicTooltips(list, enchant, item)\n    elseif item.type == types.Potion or item.type == types.Ingredient then\n        genMagicTooltips(list, record, item)\n    end\n    return list\nend\nreturn { genToolTips = genToolTips, getItemValue = getItemValue, getItemNormalizedHealth = getItemNormalizedHealth }\n",
    "Quickselect-54587-1-0-2-1715456104\\scripts\\QuickSelect\\MessageBox.lua": "local ui = require(\"openmw.ui\")\nlocal util = require(\"openmw.util\")\nlocal async = require(\"openmw.async\")\nlocal I = require(\"openmw.interfaces\")\nlocal storage = require(\"openmw.storage\")\nlocal self = require(\"openmw.self\")\n--usage: smenu = require(\"scripts.zackutils.MessageBox\")\nlocal playerSettings = storage.playerSection(\"MessageBoxData\")\nlocal winCreated\n\nlocal winName \nlocal function padString(str, length)\n    if true == true then\n        return str\n    end\n    local strLength = string.len(str)\n\n    if strLength >= length then\n        return str -- No need to pad if the string is already longer or equal to the desired length\n    end\n\n    local padding = length - strLength                   -- Calculate the number of spaces needed\n    local paddedString = str .. string.rep(\" \", padding) -- Concatenate the string with the required number of spaces\n\n    return paddedString\nend\nlocal function focusLoss()\n\nend\nlocal function textContent(text, template, color)\n    local tsize = 15\n    if not color then\n        template = I.MWUI.templates.textNormal\n        color = template.props.textColor\n    elseif color == \"red\" then\n        template = I.MWUI.templates.textNormal\n        color = util.color.rgba(5, 0, 0, 1)\n    else\n        template = I.MWUI.templates.textHeader\n        color = template.props.textColor\n        --  tsize = 20\n    end\n\n    return {\n        type = ui.TYPE.Text,\n        template = template,\n        props = {\n            text = tostring(text),\n            textSize = tsize,\n            arrange = ui.ALIGNMENT.Center,\n            align = ui.ALIGNMENT.Center,\n            textColor = color\n        }\n    }\nend\nlocal function mouseClick(mouseEvent, data)\n    if not data.props.selected then return end\n    winCreated:destroy()\n    --I.UI.setMode(nil)\n    self:sendEvent(\"ButtonClicked\",{name = winName,text = data.props.text})\nend\nlocal function mouseMove(mouseEvent,data)\n--make the button lit up when moused over\n\nend\nlocal function renderListItem(text, font, selected)\n    local resources = ui.content {\n        textContent(padString(text, 30), nil, font)\n    }\n    if not font then font = \"white\" end\n    local itemIcon = nil\n    local rowCountX = 1\n    local template = I.MWUI.templates.boxTransparent\n    if not selected then\n        template = I.MWUI.templates.padding\n    end\n    return {\n        type = ui.TYPE.Container,\n        props = {\n            size = util.vector2(30, 30 * rowCountX),\n            autoSize = true,\n            selected = selected,\n            text = text,\n        },\n        events = {\n            mousePress = async:callback(mouseClick),\n            mouseMove = async:callback(mouseMove),\n            focusLoss =  async:callback(focusLoss),\n        },\n        content = ui.content {\n            {\n                template = template,\n                alignment = ui.ALIGNMENT.Center,\n                content = resources\n            }\n        }\n    }\nend\nlocal function showMessageBox(winName, textLines, buttons)\n    if not buttons then\n        buttons = { \"OK\" }\n    end\n    local contents = {}\n    local table_contents = {} -- Table to hold the generated items\n    for index, text in ipairs(textLines) do\n        local content = {} -- Create a new table for each value of x\n\n        table.insert(content, renderListItem(text, nil, false))\n        table.insert(contents, content)\n    end\n    local buttonContent = {} -- Create a new table for each value of x\n    for index, text in ipairs(buttons) do\n        table.insert(buttonContent, renderListItem(text, nil, true))\n    end\n    if (#contents == 0) then\n        error(\"No content items\")\n    end\n\n    for index, contentx in ipairs(contents) do----print the actual text lines\n        local item = {\n            type = ui.TYPE.Flex,\n            content = ui.content(contentx),\n            props = {\n                horizontal = false,\n                arrange = ui.ALIGNMENT.Center,\n                align = ui.ALIGNMENT.Center,\n                autoSize = true\n            }\n        }\n        table.insert(table_contents, item)\n    end\n\n    local itemx = {--This contains the buttons, so that they can be arranged horizontally at the bottom\n        type = ui.TYPE.Flex,\n        content = ui.content(buttonContent),\n        props = {\n            --size = util.vector2(450, 30),\n            horizontal = false,\n            arrange = ui.ALIGNMENT.Center,\n            align = ui.ALIGNMENT.Center,\n            autoSize = true\n        }\n    }\n    table.insert(table_contents, itemx)\n\n    local itemK = {--This includes the top text, and the botton buttons.\n        type = ui.TYPE.Flex,\n        content = ui.content(table_contents),\n        props = {\n           -- size = util.vector2(450, 300),\n            horizontal = false,\n            vertical = true,\n            arrange = ui.ALIGNMENT.Center,\n            align = ui.ALIGNMENT.Center,\n            autoSize = true\n        },\n    }\n    I.UI.setMode('Interface', { windows = {} })\n    local xui = ui.create {--This is the window itself.\n        layer = \"Windows\",\n        template = I.MWUI.templates.boxTransparent,\n        events = {\n            focusLoss = async:callback(focusLoss),\n        },\n        props = {\n            -- relativePosition = v2(0.65, 0.8),\n            anchor = util.vector2(0.5, 0.5),\n            relativePosition = util.vector2(0.5, 0.5),\n            arrange = ui.ALIGNMENT.Center,\n            align = ui.ALIGNMENT.Center,\n            autoSize = true,\n            vertical = true,\n        },\n        content = ui.content({itemK})\n    }\n    xui.layout.props.xui = xui\n    winCreated = xui\n    --I.ZU_UIManager.storeUI(\"MessageBox\", xui)\n    return xui\nend\n\nreturn { drawMenuList = drawMenuList, showMessageBox = showMessageBox }\n",
    "Quickselect-54587-1-0-2-1715456104\\scripts\\QuickSelect\\qs_hotbar.lua": "local core = require(\"openmw.core\")\n\nlocal self = require(\"openmw.self\")\nlocal types = require('openmw.types')\nlocal nearby = require('openmw.nearby')\nlocal storage = require('openmw.storage')\nlocal async = require('openmw.async')\nlocal input = require('openmw.input')\nlocal util = require('openmw.util')\nlocal ui = require('openmw.ui')\nlocal I = require('openmw.interfaces')\n\nlocal settings = storage.playerSection(\"SettingsQuickSelect\")\nlocal tooltipData = require(\"scripts.QuickSelect.ci_tooltipgen\")\nlocal utility = require(\"scripts.QuickSelect.qs_utility\")\nlocal hotBarElement\nlocal tooltipElement\nlocal num = 1\nlocal enableHotbar = false       --True if we are showing the hotbar\n\nlocal pickSlotMode = false       --True if we are picking a slot for saving\n\nlocal controllerPickMode = false --True if we are picking a slot for equipping OR saving\n\nlocal selectedNum = 1\nlocal function startPickingMode()\n    enableHotbar = true\n    controllerPickMode = true\n    I.QuickSelect_Hotbar.drawHotbar()\n    if settings:get(\"pauseWhenSelecting\") then\n        I.UI.setMode(\"LevelUp\", { windows = {} })\n    end\nend\nlocal function endPickingMode()\n    enableHotbar = false\n    pickSlotMode = false\n    controllerPickMode = false\n    I.UI.setMode()\n    I.QuickSelect_Hotbar.drawHotbar()\nend\n\nlocal function getToolTipPos()\n    local setting = settings:get(\"hotBarOnTop\")\n    if setting then\n        return utility.itemWindowLocs.BottomCenter\n    else\n        return utility.itemWindowLocs.TopCenter\n    end\nend\nlocal function drawToolTip()\n    if true then\n     --   return\n    end\n    local inv = types.Actor.inventory(self):getAll()\n    local offset = I.QuickSelect.getSelectedPage() * 10\n    local data = I.QuickSelect_Storage.getFavoriteItemData(selectedNum + offset)\n\n    local item\n    local effect\n    local icon\n    local spell\n    if data.item then\n        item = types.Actor.inventory(self):find(data.item)\n    elseif data.itemId then\n        item = types.Actor.inventory(self):find(data.itemId)\n    elseif data.spell  then\n        if data.spellType:lower() == \"spell\" then\n            spell = types.Actor.spells(self)[data.spell]\n            if spell then\n                spell = spell.id\n            end\n        elseif data.spellType:lower() == \"enchant\" then\n            local enchant = utility.getEnchantment(data.enchantId)\n            if enchant then\n                spell = enchant\n            end\n        end\n    end\n\n    if item then\n        tooltipElement = utility.drawListMenu(tooltipData.genToolTips(item),\n        getToolTipPos(), nil, \"HUD\")\n        -- ui.showMessage(\"Mouse moving over icon\" .. data.item.recordId)\n    elseif spell then\n        local spellRecord = core.magic.spells.records[spell]\n\n        tooltipElement = utility.drawListMenu(tooltipData.genToolTips({ spell = spellRecord }),\n        getToolTipPos(), nil, \"HUD\")\n    end\nend\nlocal function createHotbarItem(item, xicon, num, data, half)\n    local icon\n    local isEquipped = I.QuickSelect_Storage.isSlotEquipped(num)\n    local sizeX = utility.iconSize\n    local sizeY = utility.iconSize\n    local drawNumber = settings:get(\"showNumbersForEmptySlots\")\n    local offset = I.QuickSelect.getSelectedPage() * 10\n    local selected = (num) == (selectedNum + offset)\n    if half then\n        sizeY = sizeY / 2\n    end\n    if item and not xicon then\n        icon = I.Controller_Icon_QS.getItemIcon(item, half, selected)\n    elseif xicon then\n        icon = I.Controller_Icon_QS.getSpellIcon(xicon, half, selected)\n    elseif num then\n        icon = I.Controller_Icon_QS.getEmptyIcon(half, num, selected, drawNumber)\n    end\n    local boxedIcon = utility.renderItemBoxed(icon, util.vector2(sizeX * 1.5, sizeY * 1.5), nil,\n        util.vector2(0.5, 0.5),\n        { item = item, num = num, data = data })\n    local paddingTemplate = I.MWUI.templates.padding\n    if isEquipped then\n        paddingTemplate = I.MWUI.templates.borders\n    end\n    local padding = utility.renderItemBoxed(ui.content { boxedIcon },\n        util.vector2(sizeX * 2, sizeY * 2),\n        paddingTemplate, util.vector2(0.5, 0.5))\n    return padding\nend\nlocal function getHotbarItems(half)\n    local items = {}\n    local inv = types.Actor.inventory(self):getAll()\n    local count = num + 10\n    while num < count do\n        local data = I.QuickSelect_Storage.getFavoriteItemData(num)\n\n        local item\n        local effect\n        local icon\n        if data.item then\n            item = types.Actor.inventory(self):find(data.item)\n        elseif data.spell or data.enchantId then\n            if data.spellType:lower() == \"spell\" then\n                local spell = types.Actor.spells(self)[data.spell]\n                if spell then\n                    effect = spell.effects[1]\n                    icon = effect.effect.icon\n                    --    --print(\"Spell\" .. data.spell)\n                end\n            elseif data.spellType:lower() == \"enchant\" then\n                local enchant = utility.getEnchantment(data.enchantId)\n                if enchant then\n                    effect = enchant.effects[1]\n                    icon = effect.effect.icon\n                end\n            end\n        end\n        table.insert(items, createHotbarItem(item, icon, num, data, half))\n        num = num + 1\n    end\n    return items\nend\nlocal function drawHotbar()\n    if hotBarElement then\n        hotBarElement:destroy()\n    end\n    if tooltipElement then\n        tooltipElement:destroy()\n        tooltipElement = nil\n    end\n    if not enableHotbar then\n        return\n    end\n    local xContent         = {}\n    local content          = {}\n    num                    = 1 + (10 * I.QuickSelect.getSelectedPage())\n    --local trainerRow = renderItemBoxed({}, util.vector2((160 * scale) * 7, 400 * scale),\n    ---    I.MWUI.templates.padding)\n    local showExtraHotbars = settings:get(\"previewOtherHotbars\")\n    if showExtraHotbars then\n        if I.QuickSelect.getSelectedPage() > 0 then\n            num = 1 + (10 * (I.QuickSelect.getSelectedPage() - 1))\n            table.insert(content,\n                utility.renderItemBoxed(utility.flexedItems(getHotbarItems(true), true, util.vector2(0.5, 0.5)),\n                    utility.scaledVector2(600, 100),\n                    I.MWUI.templates.padding,\n                    util.vector2(0.5, 0.5)))\n        end\n    end\n    table.insert(content,\n        utility.renderItemBoxed(utility.flexedItems(getHotbarItems(), true, util.vector2(0.5, 0.5)),\n            utility.scaledVector2(800, 80),\n            I.MWUI.templates.padding,\n            util.vector2(0.5, 0.5)))\n    if showExtraHotbars then\n        if I.QuickSelect.getSelectedPage() < 2 then\n            table.insert(content,\n                utility.renderItemBoxed(utility.flexedItems(getHotbarItems(true), true, util.vector2(0.5, 0.5)),\n                    utility.scaledVector2(900, 100),\n                    I.MWUI.templates.padding,\n                    util.vector2(0.5, 0.5)))\n        end\n    end\n    content = ui.content(content)\n\n    local anchor = util.vector2(0.5, 1)\n    local relativePosition = util.vector2(0.5, 1)\n    if settings:get(\"hotBarOnTop\") then\n        anchor = util.vector2(0.5, 0)\n        relativePosition = util.vector2(0.5, 0)\n    end\n    if controllerPickMode then\n        drawToolTip()\n    end\n    hotBarElement = ui.create {\n        layer = \"HUD\",\n        template = I.MWUI.templates.padding\n        ,\n        props = {\n            anchor = anchor,\n            relativePosition = relativePosition,\n            arrange = ui.ALIGNMENT.Center,\n            align = ui.ALIGNMENT.Center,\n        },\n        content = ui.content {\n            {\n                type = ui.TYPE.Flex,\n                content = content,\n                props = {\n                    horizontal = false,\n                    align = ui.ALIGNMENT.Center,\n                    arrange = ui.ALIGNMENT.Center,\n                    size = util.vector2(380, 40),\n                }\n            }\n        }\n    }\nend\nlocal data\nlocal function selectSlot(item, spell, enchant)\n    enableHotbar = true\n    pickSlotMode = true\n    controllerPickMode = true\n    -- print(item,spell,enchant)\n    data = { item = item, spell = spell, enchant = enchant }\n    drawHotbar()\nend\nlocal function saveSlot()\n    if pickSlotMode then\n        local selectedSlot = selectedNum + (I.QuickSelect.getSelectedPage() * 10)\n        if data.item and not data.enchant then\n            I.QuickSelect_Storage.saveStoredItemData(data.item, selectedSlot)\n        elseif data.spell then\n            I.QuickSelect_Storage.saveStoredSpellData(data.spell, \"Spell\", selectedSlot)\n        elseif data.enchant then\n            I.QuickSelect_Storage.saveStoredEnchantData(data.enchant, data.item, selectedSlot)\n        end\n        enableHotbar = false\n        pickSlotMode = false\n        data = nil\n    end\nend\nlocal function UiModeChanged(data)\n    if data.newMode then\n        if controllerPickMode and not settings:get(\"persistMode\") then\n            if settings:get(\"pauseWhenSelecting\") and data.newMode == \"LevelUp\" then\n                return\n            end\n            controllerPickMode = false\n            pickSlotMode = false\n            enableHotbar = false\n            drawHotbar()\n        elseif settings:get(\"persistMode\") then\n            enableHotbar = true\n            drawHotbar()\n        end\n    end\nend\nlocal function selectNextOrPrevHotBar(dir)\n    if dir == \"next\" then\n        if not enableHotbar then\n            return\n        end\n        local num = I.QuickSelect.getSelectedPage() + 1\n        if num > 2 then\n            num = 0\n        end\n        I.QuickSelect.setSelectedPage(num)\n        I.QuickSelect_Hotbar.drawHotbar()\n    elseif dir == \"prev\" then\n        local num = I.QuickSelect.getSelectedPage() - 1\n        if num < 0 then\n            num = 2\n        end\n        I.QuickSelect.setSelectedPage(num)\n\n        I.QuickSelect_Hotbar.drawHotbar()\n    end\nend\nlocal function selectNextOrPrevHotKey(dir)\n    if dir == \"next\" then\n        if not enableHotbar or not controllerPickMode then\n            startPickingMode()\n            return\n        end\n        selectedNum = selectedNum + 1\n        if selectedNum > 10 then\n            selectedNum = 1\n        end\n        I.QuickSelect_Hotbar.drawHotbar()\n    elseif dir == \"prev\" then\n        if not enableHotbar or not controllerPickMode then\n            startPickingMode()\n            return\n        end\n        selectedNum = selectedNum - 1\n        if selectedNum < 1 then\n            selectedNum = 10\n        end\n        I.QuickSelect_Hotbar.drawHotbar()\n    end\nend\nlocal function getNextKey()\n    local status = settings:get(\"barSelectionMode\")\n    if status == \"-/= Keys\" then\n        return \"=\"\n    elseif status == \"[/] Keys\" then\n        return \"[\"\n    end\nend\nlocal function getPrevKey()\n    local status = settings:get(\"barSelectionMode\")\n    if status == \"-/= Keys\" then\n        return \"-\"\n    elseif status == \"[/] Keys\" then\n        return \"]\"\n    end\nend\nreturn {\n    --I.QuickSelect_Hotbar.drawHotbar()\n    interfaceName = \"QuickSelect_Hotbar\",\n    interface = {\n        drawHotbar = drawHotbar,\n        selectSlot = selectSlot,\n    },\n    eventHandlers = {\n        UiModeChanged = UiModeChanged,\n    },\n    engineHandlers = {\n        onLoad = function()\n            if settings:get(\"persistMode\") then\n                enableHotbar = true\n                drawHotbar()\n            end\n        end,\n        onKeyPress = function(key)\n            if core.isWorldPaused() and not controllerPickMode then\n                return\n            end\n            local char = key.symbol\n            if not char then\n                return\n            end\n            local nextKey = getNextKey()\n            local prevKey = getPrevKey()\n            if nextKey and char == nextKey then\n                selectNextOrPrevHotBar(\"next\")\n            elseif prevKey and char == prevKey then\n                selectNextOrPrevHotBar(\"prev\")\n            end\n            if settings:get(\"useArrowKeys\") then\n                if key.code == input.KEY.RightArrow then\n                    selectNextOrPrevHotKey(\"next\")\n                elseif key.code == input.KEY.LeftArrow then\n                    selectNextOrPrevHotKey(\"prev\")\n                elseif key.code == input.KEY.UpArrow then\n                    if not enableHotbar then\n                        return\n                    end\n                    selectNextOrPrevHotBar(\"prev\")\n                elseif key.code == input.KEY.DownArrow then\n                    if not enableHotbar then\n                        return\n                    end\n                    selectNextOrPrevHotBar(\"next\")\n                elseif key.code == input.KEY.Enter then\n                    if not enableHotbar then\n                        return\n                    end\n                    if pickSlotMode then\n                        saveSlot()\n                        I.QuickSelect_Hotbar.drawHotbar()\n                        return\n                    end\n                    --  print(\"EQUP ME\"  )\n                    I.QuickSelect_Storage.equipSlot(selectedNum + (I.QuickSelect.getSelectedPage() * 10))\n                    endPickingMode()\n                end\n            end\n        end,\n        onControllerButtonPress = function(btn)\n            if core.isWorldPaused() and not controllerPickMode then\n                return\n            end\n            if btn == input.CONTROLLER_BUTTON.LeftShoulder or btn == input.CONTROLLER_BUTTON.DPadLeft then\n                selectNextOrPrevHotKey(\"prev\")\n            elseif btn == input.CONTROLLER_BUTTON.RightShoulder or btn == input.CONTROLLER_BUTTON.DPadRight then\n                selectNextOrPrevHotKey(\"next\")\n            elseif btn == input.CONTROLLER_BUTTON.DPadDown and controllerPickMode then\n                selectNextOrPrevHotBar(\"next\")\n                --  print(\"down\")\n            elseif btn == input.CONTROLLER_BUTTON.DPadUp and controllerPickMode then\n                if not enableHotbar then\n                    return\n                end\n                selectNextOrPrevHotBar(\"prev\")\n            elseif btn == input.CONTROLLER_BUTTON.A and controllerPickMode then\n                if not enableHotbar then\n                    return\n                end\n                if pickSlotMode then\n                    saveSlot()\n                    I.QuickSelect_Hotbar.drawHotbar()\n                    return\n                end\n                --  print(\"EQUP ME\"  )\n                I.QuickSelect_Storage.equipSlot(selectedNum + (I.QuickSelect.getSelectedPage() * 10))\n                endPickingMode()\n            elseif btn == input.CONTROLLER_BUTTON.B then\n                if enableHotbar then\n                    endPickingMode()\n                end\n            end\n        end\n    }\n}\n",
    "Quickselect-54587-1-0-2-1715456104\\scripts\\QuickSelect\\qs_settings.lua": "local core = require(\"openmw.core\")\n\nlocal self = require(\"openmw.self\")\nlocal types = require('openmw.types')\nlocal nearby = require('openmw.nearby')\nlocal storage = require('openmw.storage')\nlocal async = require('openmw.async')\nlocal util = require('openmw.util')\nlocal ui = require('openmw.ui')\nlocal I = require('openmw.interfaces')\n\nlocal settings = storage.playerSection(\"SettingsQuickSelect\")\n\nI.Settings.registerPage {\n    key = \"SettingsQuickSelect\",\n    l10n = \"SettingsQuickSelect\",\n    name = \"QuickSelect\",\n    description = \"These settings allow you to modify the behavior of the Quickselect bar.\"\n}\nI.Settings.registerGroup {\n    key = \"SettingsQuickSelect\",\n    page = \"SettingsQuickSelect\",\n    l10n = \"SettingsQuickSelect\",\n    name = \"Main Settings\",\n    permanentStorage = true,\ndescription = [[\n    These settings allow you to modify the behavior of the Quickselect bar.\n\n    It allows for up to 3 separate hotbars, and you can select an item with 1-10, or use the arrow keys(when enabled), or the DPad on a controller to pick a slot.\n\n    You should unbind the normal quick items before enabling this mod.\n    ]],\n    settings = {\n        {\n            key = \"previewOtherHotbars\",\n            renderer = \"checkbox\",\n            name = \"Show Next and Previous Hotbars\",\n            description =\n            \"If enabled, a preview of the next and previous hotbars will be shown above and below the current hotbar.\",\n            default = false\n        },\n        {\n            key = \"persistMode\",\n            renderer = \"checkbox\",\n            name = \"Show Hotbar at all times\",\n            description =\n            \"If enabled, the hotbar will be visible at any time. If disabled, the hotbar will only be visible a hotkey is being selected, then will close when one is selected.\",\n            default = true\n        },\n        {\n            key = \"unEquipOnHotkey\",\n            renderer = \"checkbox\",\n            name = \"Unequip when selecting equipped items\",\n            description =\n            \"If enabled, selecting an item that is already equipped will unequip it. If disabled, selecting an item that is already equipped will do nothing.\",\n            default = true\n        },\n        {\n            key = \"showNumbersForEmptySlots\",\n            renderer = \"checkbox\",\n            name = \"Show numbers for empty slots\",\n            description =\n            \"If enabled, empty slots will show a number indicating the slot number. If disabled, empty slots will be blank.\",\n            default = true\n        },\n        {\n            key = \"pauseWhenSelecting\",\n            renderer = \"checkbox\",\n            name = \"Pause While Selecting\",\n            description =\n            \"If enabled, the game will pause while selecting a slot on the hotbar. If disabled, the game will continue.\",\n            default = false\n        },\n        {\n            key = \"useArrowKeys\",\n            renderer = \"checkbox\",\n            name = \"Use Arrow Keys for Selection\",\n            description =\n            \"If enabled, you can use the arrow keys on your keyboard as if they were a DPad.\",\n            default = false\n        },\n        {\n            key = \"hotBarOnTop\",\n            renderer = \"checkbox\",\n            name = \"Set Hotbar on Top\",\n            description =\n            \"If enabled, the hotbar will be displayed at the top.\",\n            default = false\n        },\n        {\n            key = \"barSelectionMode\",\n            renderer = \"select\",\n            name = \"Bar Selection Key\",\n            default = \"Shift Modifier\",\n            description = \"The keys used to select a different hotbar. If Shift Modifier is used, shift+1-3 will select the corresponding hotbar. If -/= Keys is used, - and = will select the previous and next hotbars. If [/] Keys is used, [ and ] will select the previous and next hotbars.\\n\\nThe described keys should be unbound in the settings if you'd like to use them. The same applies to the DPad.\",\n            argument = {\n                disabled = false,\n                l10n = \"AshlanderArchitectButtons\",\n                items = { \"Shift Modifier\", \"-/= Keys\", \"[/] Keys\" },\n            },\n        },\n    },\n\n}\nsettings:get(\"unEquipOnHotkey\")\nreturn settings",
    "Quickselect-54587-1-0-2-1715456104\\scripts\\QuickSelect\\qs_utility.lua": "local ui = require(\"openmw.ui\")\nlocal util = require(\"openmw.util\")\nlocal async = require(\"openmw.async\")\nlocal I = require(\"openmw.interfaces\")\nlocal storage = require(\"openmw.storage\")\nlocal self = require(\"openmw.self\")\nlocal types = require(\"openmw.types\")\nlocal core = require(\"openmw.core\")\n\nlocal itemWindowLocs = {\n    TopLeft = { wx = 0, wy = 0, align = ui.ALIGNMENT.Start, anchor = nil },\n    TopRight = { wx = 1, wy = 0, align = ui.ALIGNMENT.End, anchor = util.vector2(1, 0) },\n    Right = { wx = 1, wy = 0.5, align = ui.ALIGNMENT.End, anchor = util.vector2(1, 0.5) },\n    Left = { wx = 0, wy = 0.5, align = ui.ALIGNMENT.Start, anchor = util.vector2(0, 0.5) },\n    BottomLeft = { wx = 0, wy = 1, align = ui.ALIGNMENT.End, anchor = util.vector2(0, 1) },\n    BottomRight = { wx = 1, wy = 1, align = ui.ALIGNMENT.Start, anchor = util.vector2(1, 1) },\n    BottomCenter = { wx = 0.5, wy = 1, align = ui.ALIGNMENT.End, anchor = util.vector2(0.5, 1) },\n    TopCenter = { wx = 0.5, wy = 0, align = ui.ALIGNMENT.End, anchor = util.vector2(0.5, 0) },\n    Disabled = { disabled = true }\n}\nlocal function lerp(x, x1, x2, y1, y2)\n    return y1 + (x - x1) * ((y2 - y1) / (x2 - x1))\nend\n\nlocal function getEnchantment(id) --\n    if not id then\n        return end\n    return core.magic.enchantments.records[id]\nend\nlocal function FindEnchantment(item)\n    if (item == nil or item.type == nil or item.type.records[item.recordId] == nil or item.type.records[item.recordId].enchant == nil or item.type.records[item.recordId].enchant == \"\") then\n        return nil\n    end\n    return getEnchantment(item.type.records[item.recordId].enchant)\nend\nlocal function calculateTextScale()\n    local screenSize = ui.screenSize()\n    local width = screenSize.x\n    local scale = lerp(width, 1280, 2560, 1.3, 1.8)\n    return scale\nend\n\nlocal scale = 0.8\nlocal iconSize = 30\n\nlocal function imageContent(resource, size)\n    if (size == nil) then\n        size = iconSize\n    end\n\n    return {\n        type = ui.TYPE.Image,\n        props = {\n            resource = resource,\n            size = util.vector2(size, size)\n            -- relativeSize = util.vector2(1,1)\n        }\n    }\nend\n\nlocal function renderItemWithIcon(item, bold, icon)\n    local resource = ui.texture { -- texture in the top left corner of the atlas\n        path = icon\n    }\n    return {\n        type = ui.TYPE.Container,\n        template = I.MWUI.templates.boxSolid,\n        content = ui.content {\n            {\n                template = I.MWUI.templates.padding,\n                alignment = ui.ALIGNMENT.Center,\n                content = ui.content {\n                    imageContent(resource, calculateTextScale() * 10),\n                    {\n                        type = ui.TYPE.Text,\n                        template = I.MWUI.templates.textNormal,\n                        props = {\n                            anchor = util.vector2(0, 0),\n                            text = item,\n                            textSize = 10 * calculateTextScale(),\n                            arrange = ui.ALIGNMENT.Center\n                        }\n                    }\n                }\n            }\n        }\n    }\nend\nlocal function scaledVector2(x, y)\n    return util.vector2(x * scale, y * scale)\nend\nlocal function renderItemX(item, bold, fontSize)\n    if not fontSize then\n        fontSize = 10\n    end\n    fontSize = fontSize * calculateTextScale()\n    return {\n        type = ui.TYPE.Container,\n        content = ui.content {\n            {\n                template = I.MWUI.templates.padding,\n                alignment = ui.ALIGNMENT.Center,\n                content = ui.content {\n                    {\n                        type = ui.TYPE.Text,\n                        template = I.MWUI.templates.textNormal,\n                        props = {\n                            text = item,\n                            textSize = fontSize,\n                            arrange = ui.ALIGNMENT.Center\n                        }\n                    }\n                }\n            }\n        }\n    }\nend\nlocal function renderItemChoiceX(itemList, horizontal, vertical, align, anchor, layer, fontSize)\n    local content = {}\n    for _, item in ipairs(itemList) do\n        if type(item) == \"string\" then\n            local itemLayout = renderItemX(item, nil, fontSize)\n            itemLayout.template = I.MWUI.templates.padding\n            table.insert(content, itemLayout)\n        elseif type(item) == \"table\" then\n            local text = item.text\n            local icon = item.icon\n            local itemLayout = renderItemWithIcon(text, false, icon)\n            itemLayout.template = I.MWUI.templates.padding\n            table.insert(content, itemLayout)\n        end\n    end\n    return ui.create {\n        layer = layer or \"InventoryWindow\",\n        template = I.MWUI.templates.boxSolid,\n        props = {\n            -- relativePosition = util.vector2(0.65, 0.8),\n            anchor = anchor,\n            relativePosition = util.vector2(horizontal, vertical),\n            arrange = align,\n            align = align,\n        },\n        content = ui.content {\n            {\n                type = ui.TYPE.Flex,\n                content = ui.content(content),\n                props = {\n                    vertical = true,\n\n                    arrange = ui.ALIGNMENT.Center,\n                    align = align,\n                }\n            }\n        }\n    }\nend\nlocal function drawListMenu(buttonTable, winLoc, prevWindow, layer, fontSize, extraContent)\n    if (prevWindow) then\n        prevWindow:destroy()\n        prevWindow = nil\n    end\n    local wx = 0\n    local wy = 0\n    local align = nil\n    local anchor = nil\n    local config = itemWindowLocs[winLoc] or winLoc\n\n    if not config or config.disabled then\n        -- Handle the disabled case\n        return\n    else\n        wx = config.wx\n        wy = config.wy\n        align = config.align\n        anchor = config.anchor\n        -- Now, use wx, wy, align, and anchor as needed\n    end\n    return renderItemChoiceX(buttonTable, wx, wy, align, anchor, layer, fontSize)\nend\nlocal function renderItemBold(item, bold, id, tooltipData, isSpell, spellData,events)\n    if not id then id = item end\n    local textTemplate = I.MWUI.templates.textNormal\n    if  bold or (spellData and spellData.bold )then\n        textTemplate = I.MWUI.templates.textHeader\n    end\n\n    return {\n        id = \"renderItemBold\",\n        type = ui.TYPE.Container,\n        tooltipData = tooltipData,\n        props = {\n            --  anchor = util.vector2(-1,0),\n            align = ui.ALIGNMENT.Center,\n            relativePosition = util.vector2(0.5, 0.5),\n            arrange = ui.ALIGNMENT.Center,\n        },\n        content = ui.content {\n            {\n                template = I.MWUI.templates.padding,\n                alignment = ui.ALIGNMENT.Center,\n                content = ui.content {\n                    {\n                        type = ui.TYPE.Text,\n                        template = textTemplate,\n                        props = {\n                            text = item,\n                            textSize = 20 * scale,\n                            relativePosition = util.vector2(0.5, 0.5),\n                            arrange = ui.ALIGNMENT.Center,\n                            align = ui.ALIGNMENT.Center,\n                            spellData = spellData,\n                        },\n                        events = events,\n                    }\n                }\n            }\n        }\n    }\nend\n\n\nlocal function flexedItems(content, horizontal,anchor)\n    if not horizontal then\n        horizontal = false\n    end\n    return ui.content {\n        {\n            id = \"flexeditems\",\n            type = ui.TYPE.Flex,\n            content = ui.content(content),\n            events = {\n                --    mouseMove = async:callback(mouseMove),\n            },\n            props = {\n                horizontal = horizontal,\n                align = ui.ALIGNMENT.Center,\n                arrange = ui.ALIGNMENT.Center,\n                --     size = util.vector2(100, 100),\n                autosize = true,\n                relativePosition = anchor,\n                anchor = anchor\n            }\n        }\n    }\nend\n\nlocal function renderItemBoxed(content, size, itemTemplate, relativePosition, data,events)\n    local text\n\n    if data then\n      \n    end\n    if not size then\n        size = scaledVector2(100, 100)\n    end\n    if not itemTemplate then\n        itemTemplate = I.MWUI.templates.borders\n    end\n\n\n    return {\n        id = \"itemBoxed\",\n        type = ui.TYPE.Container,\n        --    events = {},\n        template = itemTemplate,\n        content = ui.content {\n            {\n                props = {\n                    size = size,\n                    relativePosition = relativePosition\n                },\n                content = content\n            },\n        },\n        data = data,\n        props = {\n            relativePosition = relativePosition,\n            anchor = relativePosition\n        },\n        events = events,\n    }\nend\nreturn {\n    imageContent = imageContent,\n    scaledVector2 = scaledVector2,\n    renderItemX = renderItemX,\n    renderItemChoiceX = renderItemChoiceX,  \n    drawListMenu = drawListMenu,\n    renderItemBoxed = renderItemBoxed,\n    renderItemWithIcon = renderItemWithIcon,\n    renderItemBold = renderItemBold,\n    getEnchantment = getEnchantment,\n    FindEnchantment = FindEnchantment,\n    calculateTextScale = calculateTextScale,\n    scale = scale,\n    iconSize = iconSize,\n    flexedItems = flexedItems,\n    itemWindowLocs = itemWindowLocs,\n    findSlot = function (item)\n        if (item == nil) then\n            return\n        end\n        --Finds a equipment slot for an inventory item, if it has one,\n        if item.type == types.Armor then\n            if (types.Armor.records[item.recordId].type == types.Armor.TYPE.RGauntlet) then\n                return types.Actor.EQUIPMENT_SLOT.RightGauntlet\n            elseif (types.Armor.records[item.recordId].type == types.Armor.TYPE.LGauntlet) then\n                return types.Actor.EQUIPMENT_SLOT.LeftGauntlet\n            elseif (types.Armor.records[item.recordId].type == types.Armor.TYPE.Boots) then\n                return types.Actor.EQUIPMENT_SLOT.Boots\n            elseif (types.Armor.records[item.recordId].type == types.Armor.TYPE.Cuirass) then\n                return types.Actor.EQUIPMENT_SLOT.Cuirass\n            elseif (types.Armor.records[item.recordId].type == types.Armor.TYPE.Greaves) then\n                return types.Actor.EQUIPMENT_SLOT.Greaves\n            elseif (types.Armor.records[item.recordId].type == types.Armor.TYPE.LBracer) then\n                return types.Actor.EQUIPMENT_SLOT.LeftGauntlet\n            elseif (types.Armor.records[item.recordId].type == types.Armor.TYPE.RBracer) then\n                return types.Actor.EQUIPMENT_SLOT.RightGauntlet\n            elseif (types.Armor.records[item.recordId].type == types.Armor.TYPE.RPauldron) then\n                return types.Actor.EQUIPMENT_SLOT.RightPauldron\n            elseif (types.Armor.records[item.recordId].type == types.Armor.TYPE.LPauldron) then\n                return types.Actor.EQUIPMENT_SLOT.LeftPauldron\n            elseif (types.Armor.records[item.recordId].type == types.Armor.TYPE.RPauldron) then\n                return types.Actor.EQUIPMENT_SLOT.RightPauldron\n            elseif (types.Armor.records[item.recordId].type == types.Armor.TYPE.Helmet) then\n                return types.Actor.EQUIPMENT_SLOT.Helmet\n            elseif (types.Armor.records[item.recordId].type == types.Armor.TYPE.Shield) then\n                return types.Actor.EQUIPMENT_SLOT.CarriedLeft\n            end\n        elseif item.type == types.Clothing then\n            if (types.Clothing.records[item.recordId].type == types.Clothing.TYPE.Amulet) then\n                return types.Actor.EQUIPMENT_SLOT.Amulet\n            elseif (types.Clothing.records[item.recordId].type == types.Clothing.TYPE.Belt) then\n                return types.Actor.EQUIPMENT_SLOT.Belt\n            elseif (types.Clothing.records[item.recordId].type == types.Clothing.TYPE.LGlove) then\n                return types.Actor.EQUIPMENT_SLOT.LeftGauntlet\n            elseif (types.Clothing.records[item.recordId].type == types.Clothing.TYPE.RGlove) then\n                return types.Actor.EQUIPMENT_SLOT.RightGauntlet\n            elseif (types.Clothing.records[item.recordId].type == types.Clothing.TYPE.Ring) then\n                return types.Actor.EQUIPMENT_SLOT.RightRing\n            elseif (types.Clothing.records[item.recordId].type == types.Clothing.TYPE.Skirt) then\n                return types.Actor.EQUIPMENT_SLOT.Skirt\n            elseif (types.Clothing.records[item.recordId].type == types.Clothing.TYPE.Shirt) then\n                return types.Actor.EQUIPMENT_SLOT.Shirt\n            elseif (types.Clothing.records[item.recordId].type == types.Clothing.TYPE.Shoes) then\n                return types.Actor.EQUIPMENT_SLOT.Boots\n            elseif (types.Clothing.records[item.recordId].type == types.Clothing.TYPE.Robe) then\n                return types.Actor.EQUIPMENT_SLOT.Robe\n            elseif (types.Clothing.records[item.recordId].type == types.Clothing.TYPE.Pants) then\n                return types.Actor.EQUIPMENT_SLOT.Pants\n            end\n        elseif item.type == types.Weapon then\n            if (item.type.records[item.recordId].type == types.Weapon.TYPE.Arrow or item.type.records[item.recordId].type == types.Weapon.TYPE.Bolt) then\n                return types.Actor.EQUIPMENT_SLOT.Ammunition\n            end\n            return types.Actor.EQUIPMENT_SLOT.CarriedRight\n        elseif item.type == types.Light then\n            return types.Actor.EQUIPMENT_SLOT.CarriedLeft\n        end\n        -- --print(\"Couldn't find slot for \" .. item.recordId)\n        return nil\n    end}",
    "Quickselect-54587-1-0-2-1715456104\\scripts\\QuickSelect\\QuickSelect_P.lua": "local core = require(\"openmw.core\")\n\nlocal self = require(\"openmw.self\")\nlocal types = require('openmw.types')\nlocal nearby = require('openmw.nearby')\nlocal camera = require('openmw.camera')\nlocal util = require('openmw.util')\nlocal ui = require('openmw.ui')\nlocal input = require('openmw.input')\nlocal I = require('openmw.interfaces')\nlocal settings = require(\"scripts.QuickSelect.qs_settings\")\nlocal function getIconSize()\n    return 40\nend\nlocal selectedPage = 0\nlocal function getIconSizeGrow()\n    local ret = 20\n    return (40) + ret * 0.25\nend\nlocal function createHotbarItem(item, spell)\n    local icon = I.Controller_Icon_QS.getItemIcon(item)\n    local boxedIcon = { --box around the titem\n        type = ui.TYPE.Container,\n        props = {\n            size = util.vector2(getIconSize(), getIconSize()),\n        },\n        events = {\n        },\n        content = {\n            {\n                template = I.MWUI.templates.boxSolid,\n                alignment = ui.ALIGNMENT.Center,\n                content = icon\n            }\n        }\n    }\n    return boxedIcon\nend\nlocal function getHotbarItems()\n    local items = {}\n    for index, value in ipairs(types.Actor.inventory(self):getAll()) do\n        if index < 10 then\n            table.insert(items, createHotbarItem(value))\n        end\n    end\n    return items\nend\nlocal function drawHotbar()\n    I.QuickSelect_Win1.drawQuickSelect()\n    if true then\n        return\n    end\n    local items = getHotbarItems()\n    local itemFlex = {\n        type = ui.TYPE.Flex,\n        layer = \"HUD\",\n        content = items,\n        props = {\n            size = util.vector2(450, 300),\n            horizontal = false,\n            vertical = false,\n            arrange = ui.ALIGNMENT.Start,\n            align = ui.ALIGNMENT.Center,\n            autoSize = true\n        },\n    }\n    local pos = 0\n    for index, value in ipairs(items) do\n        pos = pos + 0.1\n    end\n    ui.create {\n        layer = \"HUD\",\n        template = I.MWUI.templates.boxSolid,\n        events = {\n        },\n        props = {\n            anchor = util.vector2(0.5, 0.5),\n            relativePosition = util.vector2(pos, .1),\n            arrange = ui.ALIGNMENT.Center,\n            align = ui.ALIGNMENT.Center,\n            autoSize = false,\n            vertical = true,\n            size = util.vector2(450, 300),\n        },\n        content = itemFlex\n    }\nend\n\nlocal function onInputAction(action)\n    if action >= input.ACTION.QuickKey1 and action <= input.ACTION.QuickKey9 then\n        local slot = action - input.ACTION.QuickKey1 + 1\n        if slot then\n            if slot > 0 and slot < 4 and input.isShiftPressed() then\n                selectedPage = slot - 1\n                I.QuickSelect_Hotbar.drawHotbar()\n                return\n            end\n            I.QuickSelect_Storage.equipSlot(slot + (selectedPage * 10))\n            I.QuickSelect_Hotbar.drawHotbar()\n        end\n    end\nend\nreturn {\n\n    interfaceName = \"QuickSelect\",\n    interface = {\n        drawHotbar = drawHotbar,\n        getSelectedPage = function()\n            return selectedPage\n        end,\n        setSelectedPage = function(num)\n             selectedPage = num\n        end,\n    },\n    engineHandlers = {\n        onInputAction = onInputAction,\n        onLoad = function()\n            -- I.QuickSelect_Hotbar.drawHotbar()\n        end\n    }\n}\n",
    "Quickselect-54587-1-0-2-1715456104\\scripts\\QuickSelect\\select_items_win1.lua": "local I = require(\"openmw.interfaces\")\nlocal ambient = require('openmw.ambient')\nlocal async = require(\"openmw.async\")\nlocal core = require(\"openmw.core\")\nlocal self = require(\"openmw.self\")\nlocal ui = require(\"openmw.ui\")\nlocal util = require(\"openmw.util\")\nlocal types = require(\"openmw.types\")\nlocal input = require(\"openmw.input\")\n\nlocal utility = require(\"scripts.QuickSelect.qs_utility\")\nlocal tooltipData = require(\"scripts.QuickSelect.ci_tooltipgen\")\nlocal messageBoxUtil = require(\"scripts.QuickSelect.messagebox\")\nlocal QuickSelectWindow\nlocal hoveredOverId\nlocal spellMode = false\nlocal columnsAndRows = {}\nlocal selectedCol = 1\nlocal selectedRow = 1\nlocal startOffset =0\nlocal maxCount = 0\nlocal num = 1\nlocal scale = 0.8\nlocal tooltip\nlocal lis = {}\n\nlocal slotToSave\n\nlocal function mouseMove(mouseEvent, data)\n    if tooltip then\n        tooltip:destroy()\n        tooltip = nil\n    end\n    if data.data.item then\n        tooltip = utility.drawListMenu(tooltipData.genToolTips(data.data.item),\n            utility.itemWindowLocs.BottomCenter, nil, \"HUD\")\n        -- ui.showMessage(\"Mouse moving over icon\" .. data.item.recordId)\n    elseif data.data.data.spell then\n        local spellRecord = core.magic.spells.records[data.data.data.spell]\n        --print(data.data.data.spell)\n        tooltip = utility.drawListMenu(tooltipData.genToolTips({ spell = spellRecord }),\n            utility.itemWindowLocs.BottomCenter, nil, \"HUD\")\n    end\nend\nlocal function mouseClick(mouseEvent, data)\n    local id = data.id\n    if data.props.spellData or data.spellData then\n        local spell = data.props.spellData\n\n        if not spell.id then\n            ----print(\"no id\")\n        end\n        if spell.enchant then\n            I.QuickSelect_Storage.saveStoredEnchantData(spell.enchant, spell.id, slotToSave)\n         --   ui.showMessage(\"Saved enchant to slot \" .. slotToSave)\n        else\n            I.QuickSelect_Storage.saveStoredSpellData(spell.id, \"Spell\", slotToSave)\n\n          --  ui.showMessage(\"Saved spell to slot \" .. slotToSave)\n        end\n        if QuickSelectWindow then\n            QuickSelectWindow:destroy()\n            QuickSelectWindow = nil\n        end\n        if tooltip then\n            tooltip:destroy()\n            tooltip = nil\n        end\n        I.UI.setMode()\n        slotToSave = nil\n        return\n    else\n    end\n    if tooltip then\n        tooltip:destroy()\n        tooltip = nil\n    end\n    if data.data then\n        if not slotToSave then\n            messageBoxUtil.showMessageBox(nil, { core.getGMST(\"sQuickMenu1\") },\n                { core.getGMST(\"sQuickMenu2\"), core.getGMST(\"sQuickMenu3\"), core.getGMST(\"sQuickMenu4\"), core.getGMST(\n                    \"sCancel\") })\n            -- ui.showMessage(\"Mouse moving over icon\" .. data.item.recordId)\n            if QuickSelectWindow then\n                QuickSelectWindow:destroy()\n                QuickSelectWindow = nil\n            end\n            if tooltip then\n                tooltip:destroy()\n                tooltip = nil\n            end\n            slotToSave = data.data.num\n        elseif data.data.item then\n            I.QuickSelect_Storage.saveStoredItemData(data.data.item.recordId, slotToSave)\n            if QuickSelectWindow then\n                QuickSelectWindow:destroy()\n                QuickSelectWindow = nil\n            end\n            if tooltip then\n                tooltip:destroy()\n                tooltip = nil\n            end\n            I.UI.setMode()\n            slotToSave = nil\n        end\n    end\nend\nlocal function mouseMoveButton(event, data)\n\n    if not QuickSelectWindow.layout.content[1].content[3].content[1].content[1].content then\n        return\n    end\n    local sdata = data.props.spellData\n\n    if tooltip then\n        tooltip:destroy()\n        tooltip = nil\n    end\n    if sdata.id and sdata.enchant then\n        local item = types.Actor.inventory(self):find(sdata.id)\n        tooltip = utility.drawListMenu(tooltipData.genToolTips(item),\n            utility.itemWindowLocs.BottomCenter, nil, \"HUD\")\n        -- ui.showMessage(\"Mouse moving over icon\" .. data.item.recordId)\n    elseif sdata.id then\n        local spellRecord = core.magic.spells.records[sdata.id]\n        --print(data.data.data.spell)\n        tooltip = utility.drawListMenu(tooltipData.genToolTips({ spell = spellRecord }),\n            utility.itemWindowLocs.BottomCenter, nil, \"HUD\")\n    end\n    for index, value in ipairs(QuickSelectWindow.layout.content[1].content[3].content[1].content[1].content) do\n        local sdata = QuickSelectWindow.layout.content[1].content[3].content[1].content[1].content[index].content[1].content[1].props.spellData\n        if not sdata or not sdata.bold then\n        QuickSelectWindow.layout.content[1].content[3].content[1].content[1].content[index].content[1].content[1].template =\n            I.MWUI.templates.textNormal\n        end\n    end\n    data.template = I.MWUI.templates.textHeader\n\n    QuickSelectWindow:update()\nend\nlocal function renderButton(text)\n    local itemTemplate\n    itemTemplate = I.MWUI.templates.borders\n\n    return {\n        type = ui.TYPE.Container,\n        --  events = {},\n        template = itemTemplate,\n        content = ui.content { utility.renderItemBold(text) },\n    }\nend\nlocal function getSkillBase(skillID, actor)\n    return types.NPC.stats.skills[skillID:lower()](actor).base\nend\nlocal function createItemIcon(item, spell, num)\n    local icon\n    if item and not spell then\n        icon = I.Controller_Icon_QS.getItemIcon(item)\n    else\n        return {}\n    end\n    local boxedIcon = utility.renderItemBoxed(icon, util.vector2(utility.iconSize * 1.5, utility.iconSize * 1.5), nil,\n        util.vector2(0.5, 0.5),\n        { item = item, num = num } ,{\n            mouseMove = async:callback(mouseMove),\n            mouseClick = async:callback(mouseClick),\n        })\n    local padding = utility.renderItemBoxed(ui.content { boxedIcon },\n        util.vector2(utility.iconSize * 1.5, utility.iconSize * 1.5),\n        I.MWUI.templates.padding)\n    return padding\nend\nlocal function getItemRow()\n    local items = {}\n    local inv = types.Actor.inventory(self):getAll()\n    local count = num + 10\n\n    maxCount = #inv\n    while num < count do\n        table.insert(items, createItemIcon(inv[num], nil, num))\n        num = num + 1\n    end\n    return items\nend\nlocal function createHotbarItem(item, xicon, num, data)\n    local icon\n    if item and not xicon then\n        icon = I.Controller_Icon_QS.getItemIcon(item)\n    elseif xicon then\n        icon = I.Controller_Icon_QS.getSpellIcon(xicon)\n    elseif num then\n        icon = ui.content {\n            {\n                type = ui.TYPE.Text,\n                template = I.MWUI.templates.textNormal,\n                props = {\n                    text = tostring(num),\n                    textSize = 20 * scale,\n                    relativePosition = util.vector2(0.5, 0.5),\n                    anchor = util.vector2(0.5, 0.5),\n                    arrange = ui.ALIGNMENT.Center,\n                    align = ui.ALIGNMENT.Center,\n                },\n                item = item,\n                num = num,\n                events = {\n                    --          mouseMove = async:callback(mouseMove),\n                },\n            }\n        }\n    end\n    local boxedIcon = utility.renderItemBoxed(icon, util.vector2(utility.iconSize * 1.5, utility.iconSize * 1.5), nil,\n        util.vector2(0.5, 0.5),\n        { item = item, num = num, data = data }, {\n            mouseMove = async:callback(mouseMove),\n            mouseClick = async:callback(mouseClick),\n        })\n    local padding = utility.renderItemBoxed(ui.content { boxedIcon }, util.vector2(utility.iconSize * 2, utility.iconSize * 2),\n        I.MWUI.templates.padding)\n    return padding\nend\nlocal function getHotbarItems()\n    local items = {}\n    local inv = types.Actor.inventory(self):getAll()\n    local count = num + 10\n    while num < count do\n        local data = I.QuickSelect_Storage.getFavoriteItemData(num)\n        local item\n        local effect\n        local icon\n        if data.item then\n            item = types.Actor.inventory(self):find(data.item)\n        elseif data.spell or data.enchantId or (data.spellType and data.spellType:lower() == \"enchant\") then\n            if data.spellType:lower() == \"spell\" then\n                local spell = types.Actor.spells(self)[data.spell]\n                if spell then\n                    effect = spell.effects[1]\n                    icon = effect.effect.icon\n                    --    ----print(\"Spell\" .. data.spell)\n                end\n            elseif data.spellType:lower() == \"enchant\" then\n                local enchant = utility.getEnchantment(data.enchantId)\n                if enchant then\n                    effect = enchant.effects[1]\n                    icon = effect.effect.icon\n                end\n                item = types.Actor.inventory(self):find(data.itemId)\n               -- print(item)\n            elseif data.itemId then\n                item = types.Actor.inventory(self):find(data.itemId)\n            end\n        end\n        table.insert(items, createHotbarItem(item, icon, num, data))\n        num = num + 1\n    end\n    return items\nend\nlocal function drawItemSelect()\n    if QuickSelectWindow then\n        QuickSelectWindow:destroy()\n    end\n    local xContent = {}\n    local content  = {}\n    num            = 1 + startOffset\n    --Draw search menu\n\n    table.insert(content, utility.renderItemBold(core.getGMST(\"sQuickMenu6\")))\n    table.insert(content, utility.renderItemBold(\"(Use mouse wheel to scroll)\", nil, nil, nil, true))\n\n    table.insert(content,\n        utility.renderItemBoxed(utility.flexedItems(getItemRow(), true), utility.scaledVector2(900, 100),\n            I.MWUI.templates.padding,\n            util.vector2(0.5, 0.5)))\n    table.insert(content,\n        utility.renderItemBoxed(utility.flexedItems(getItemRow(), true), utility.scaledVector2(900, 100),\n            I.MWUI.templates.padding,\n            util.vector2(0.5, 0.5)))\n    table.insert(content,\n        utility.renderItemBoxed(utility.flexedItems(getItemRow(), true), utility.scaledVector2(900, 100),\n            I.MWUI.templates.padding,\n            util.vector2(0.5, 0.5)))\n    table.insert(content,\n        utility.renderItemBoxed(utility.flexedItems(getItemRow(), true), utility.scaledVector2(900, 100),\n            I.MWUI.templates.padding,\n            util.vector2(0.5, 0.5)))\n    table.insert(content,\n        utility.renderItemBoxed(utility.flexedItems(getItemRow(), true), utility.scaledVector2(900, 100),\n            I.MWUI.templates.padding,\n            util.vector2(0.5, 0.5)))\n    table.insert(content,\n        utility.renderItemBoxed(utility.flexedItems(getItemRow(), true), utility.scaledVector2(900, 100),\n            I.MWUI.templates.padding,\n            util.vector2(0.5, 0.5)))\n            \n    --rcontent = flexedItems(content,false)\n    --   table.insert(content,flexedItems(lis, true))\n    -- table.insert(content, imageContent(resource, size))\n    content = ui.content(content)\n    QuickSelectWindow = ui.create {\n        layer = \"Windows\",\n        template = I.MWUI.templates.boxTransparentThick\n        ,\n        props = {\n            anchor = util.vector2(0.5, 0.5),\n            relativePosition = util.vector2(0.5, 0.5),\n            arrange = ui.ALIGNMENT.Center,\n            align = ui.ALIGNMENT.Center,\n        },\n        content = ui.content {\n            {\n                type = ui.TYPE.Flex,\n                content = content,\n                props = {\n                    horizontal = false,\n                    align = ui.ALIGNMENT.Center,\n                    arrange = ui.ALIGNMENT.Center,\n                    --    size = util.vector2(0, 0),\n                }\n            }\n        }\n    }\nend\nlocal function getAllEnchantments(actorInv, onlyCastable)\n    local ret = {}\n    for index, value in ipairs(actorInv:getAll()) do\n        local ench = utility.FindEnchantment(value)\n        if (ench and not onlyCastable) then\n            table.insert(ret, { enchantment = ench, item = value })\n        elseif ench and onlyCastable and (ench.type == core.magic.ENCHANTMENT_TYPE.CastOnUse or ench.type == core.magic.ENCHANTMENT_TYPE.CastOnce) then\n            table.insert(ret, { enchantment = ench, item = value })\n        end\n    end\n    return ret\nend\nlocal function compareNames(a, b)\n    return a.name < b.name\nend\n\nlocal function drawSpellSelect()\n    if QuickSelectWindow then\n        QuickSelectWindow:destroy()\n    end\n    local xContent = {}\n    local content  = {}\n    num            = 1\n    --local trainerRow = utility.renderItemBoxed({}, util.vector2((160 * scale) * 7, 400 * scale),\n    ---    I.MWUI.templates.padding)\n\n    table.insert(content, utility.renderItemBold(core.getGMST(\"sMagicSelectTitle\")))\n    table.insert(content, utility.renderItemBold(\"(Use mouse wheel to scroll)\", nil, nil, nil, true))\n    local spellsAndIds = {}\n    local spellList = {}\n    table.insert(spellsAndIds, {name = \" Spells:\", type = \"\" ,bold = true})\n    for index, spell in ipairs(types.Actor.spells(self)) do\n        if spell.type == core.magic.SPELL_TYPE.Power or spell.type == core.magic.SPELL_TYPE.Spell then\n            table.insert(spellList, { id = spell.id, name = spell.name, type = \"Spell\" })\n        end\n    end\n    table.sort(spellList, compareNames)\n    for index, value in ipairs(spellList) do\n        table.insert(spellsAndIds, value)\n    end\n    local enchL = getAllEnchantments(types.Actor.inventory(self), true)\n    table.insert(spellsAndIds, {name = \"Enchantments:\", type = \"\" ,bold = true})\n  \n    local enchantList = {}\n    for index, ench in ipairs(enchL) do\n        if index> startOffset then\n        table.insert(enchantList,\n            { id = ench.item.recordId, name = ench.item.type.record(ench.item).name, type = \"Enchant\", enchant = ench\n            .item.type.record(ench.item).enchant })\n        ----print(\"ench nane\" .. ench.item.type.record(ench.item).name)\n        end\n    end\n    table.sort(enchantList, compareNames)\n    for index, value in ipairs(enchantList) do\n        table.insert(spellsAndIds, value)\n    end\n    maxCount = #spellsAndIds\n    for i = 1, 30, 1 do\n        if spellsAndIds[i + startOffset] then\n            table.insert(xContent, utility.renderItemBold(spellsAndIds[i + startOffset].name, nil, nil, nil, true, spellsAndIds[i + startOffset],{\n                mouseMove = async:callback(mouseMoveButton),\n                mousePress = async:callback(mouseClick)\n            }))\n        end\n    end\n    table.insert(content,\n        utility.renderItemBoxed(utility.flexedItems(xContent, false), utility.scaledVector2(400, 800), I.MWUI.templates.borders,\n            util.vector2(0.5, 0.5)))\n    content = ui.content(content)\n    QuickSelectWindow = ui.create {\n        layer = \"Windows\",\n        template = I.MWUI.templates.boxTransparentThick\n        ,\n        props = {\n            anchor = util.vector2(0.5, 0.5),\n            relativePosition = util.vector2(0.5, 0.5),\n            arrange = ui.ALIGNMENT.Center,\n            align = ui.ALIGNMENT.Center,\n        },\n        content = ui.content {\n            {\n                type = ui.TYPE.Flex,\n                content = content,\n                props = {\n                    horizontal = false,\n                    align = ui.ALIGNMENT.Center,\n                    arrange = ui.ALIGNMENT.Center,\n                    --    size = util.vector2(0, 0),\n                }\n            }\n        }\n    }\nend\nlocal function drawQuickSelect()\n    if QuickSelectWindow then\n        QuickSelectWindow:destroy()\n    end\n    local xContent = {}\n    local content  = {}\n    num            = 1\n    --local trainerRow = utility.renderItemBoxed({}, util.vector2((160 * scale) * 7, 400 * scale),\n    ---    I.MWUI.templates.padding)\n\n    table.insert(content, utility.renderItemBold(core.getGMST(\"sQuickMenuTitle\")))\n    table.insert(content, utility.renderItemBold(core.getGMST(\"sQuickMenuInstruc\")))\n\n    table.insert(content,\n        utility.renderItemBoxed(utility.flexedItems(getHotbarItems(), true), utility.scaledVector2(900, 100),\n            I.MWUI.templates.padding,\n            util.vector2(0.5, 0.5)))\n    table.insert(content,\n        utility.renderItemBoxed(utility.flexedItems(getHotbarItems(), true), utility.scaledVector2(900, 100),\n            I.MWUI.templates.padding,\n            util.vector2(0.5, 0.5)))\n    table.insert(content,\n        utility.renderItemBoxed(utility.flexedItems(getHotbarItems(), true), utility.scaledVector2(900, 100),\n            I.MWUI.templates.padding,\n            util.vector2(0.5, 0.5)))\n\n    content = ui.content(content)\n    QuickSelectWindow = ui.create {\n        layer = \"Windows\",\n        template = I.MWUI.templates.boxTransparentThick\n        ,\n        props = {\n            anchor = util.vector2(0.5, 0.5),\n            relativePosition = util.vector2(0.5, 0.5),\n            arrange = ui.ALIGNMENT.Center,\n            align = ui.ALIGNMENT.Center,\n        },\n        content = ui.content {\n            {\n                type = ui.TYPE.Flex,\n                content = content,\n                props = {\n                    horizontal = false,\n                    align = ui.ALIGNMENT.Center,\n                    arrange = ui.ALIGNMENT.Center,\n                    --    size = util.vector2(0, 0),\n                }\n            }\n        }\n    }\nend\n\nlocal function openQuickSelect()\n    --I.UI.setMode(\"Interface\", { windows = {} })\n    drawQuickSelect()\nend\n\nlocal function UiModeChanged(data)\n    if not data.newMode then\n        if QuickSelectWindow then\n            QuickSelectWindow:destroy()\n            QuickSelectWindow = nil\n        end\n        if tooltip then\n            tooltip:destroy()\n            tooltip = nil\n        end\n        I.QuickSelect_Hotbar.drawHotbar()\n        slotToSave = nil\n    end\nend\n\nlocal function onKeyPress(key)\n    if not QuickSelectWindow then return end\n\n    local nextCol = selectedCol\n    local nextRow = selectedRow\n    if key.code == input.KEY.LeftArrow then\n        nextCol = nextCol - 1\n    elseif key.code == input.KEY.RightArrow then\n        nextCol = nextCol + 1\n    elseif key.code == input.KEY.DownArrow then\n        nextRow = nextRow + 1\n    elseif key.code == input.KEY.UpArrow then\n        nextRow = nextRow - 1\n    end\n    if not columnsAndRows[nextCol] or not columnsAndRows[nextCol][nextRow] then\n\n    else\n        hoveredOverId = columnsAndRows[nextCol][nextRow]\n        selectedCol = nextCol\n        selectedRow = nextRow\n        drawQuickSelect()\n    end\nend\nlocal function onControllerButtonPress(id)\n    if not QuickSelectWindow then return end\n\n    local nextCol = selectedCol\n    local nextRow = selectedRow\n    if id == input.CONTROLLER_BUTTON.DPadLeft then\n        nextCol = nextCol - 1\n    elseif id == input.CONTROLLER_BUTTON.DPadRight then\n        nextCol = nextCol + 1\n    elseif id == input.CONTROLLER_BUTTON.DPadDown then\n        nextRow = nextRow + 1\n    elseif id == input.CONTROLLER_BUTTON.DPadUp then\n        nextRow = nextRow - 1\n    end\n    if not columnsAndRows[nextCol] or not columnsAndRows[nextCol][nextRow] then\n\n    else\n        hoveredOverId = columnsAndRows[nextCol][nextRow]\n        selectedCol = nextCol\n        selectedRow = nextRow\n        drawQuickSelect()\n    end\nend\nI.UI.registerWindow(I.UI.WINDOW.QuickKeys, drawQuickSelect, function() --\n    if QuickSelectWindow then\n        QuickSelectWindow:destroy()\n        QuickSelectWindow = nil\n    end\n    if tooltip then\n        tooltip:destroy()\n        tooltip = nil\n    end\nend)\nlocal function ButtonClicked(data)\n    local text = data.text\n    num = 1\n    if text == core.getGMST(\"sQuickMenu2\") then\n        spellMode = false\n        drawItemSelect()\n    elseif text == core.getGMST(\"sQuickMenu3\") then\n        spellMode = true\n        drawSpellSelect()\n    elseif text == core.getGMST(\"sQuickMenu4\") then\n--delete\n        I.QuickSelect_Storage.deleteStoredItemData(slotToSave)\n        if QuickSelectWindow then\n            QuickSelectWindow:destroy()\n            QuickSelectWindow = nil\n        end\n        I.UI.setMode()\n    elseif text == core.getGMST(\n        \"sCancel\") then\n        if QuickSelectWindow then\n            QuickSelectWindow:destroy()\n            QuickSelectWindow = nil\n        end\n        I.UI.setMode()\n    end\nend\nreturn {\n\n    interfaceName = \"QuickSelect_Win1\",\n    interface = {\n        drawQuickSelect = drawQuickSelect,\n        openQuickSelect = openQuickSelect,\n        getQuickSelectWindow = function()\n            return QuickSelectWindow\n        end,\n    },\n    eventHandlers = {\n        UiModeChanged = UiModeChanged,\n        drawQuickSelect = drawQuickSelect,\n        openQuickSelect = openQuickSelect,\n        ButtonClicked = ButtonClicked,\n    },\n    engineHandlers = {\n        onKeyPress = onKeyPress,\n        onControllerButtonPress = onControllerButtonPress,\n        onMouseWheel = function (vert)\n            if not QuickSelectWindow then return end\n            local modifer = 10      \n\n            if spellMode then\n                modifer = 1\n            end\n            if vert > 0 then\n                startOffset = startOffset - modifer\n            elseif startOffset + modifer < maxCount  then\n                startOffset = startOffset + modifer\n            end\n            --print(startOffset)\n            if startOffset < 0 then\n                startOffset = 0\n            end\n            if spellMode then\n                drawSpellSelect()\n            else\n                drawItemSelect()\n            end\n        end\n    }\n}\n"
  }
}