{
  "folder_name": "Perfect Placement",
  "lua_files": {
    "Perfect Placement OpenMW Beta-46562-2-2beta4-1715465265\\scripts\\PerfectPlacement\\config.lua": "--[[\n    Mod: Perfect Placement OpenMW\n    Author: Hrnchamd\n    Version: 2.2beta\n]]--\n\nlocal async = require('openmw.async')\nlocal storage = require('openmw.storage')\nlocal ui = require('openmw.ui')\nlocal util = require('openmw.util')\n\nlocal options = storage.playerSection('Settings/PerfectPlacement/Options')\nlocal keybinds = storage.playerSection('Settings/PerfectPlacement/Keybinds')\nlocal config = {}\n\nlocal function updateConfig()\n\tconfig.options = options:asTable()\n\tconfig.options.snapN = 90 / tonumber(config.options.snapN:sub(5))\n    config.options.snapQuantizer = (0.5 / config.options.snapN) * math.pi\n\tconfig.keybinds = keybinds:asTable()\nend\nupdateConfig()\noptions:subscribe(async:callback(updateConfig))\nkeybinds:subscribe(async:callback(updateConfig))\n\nreturn config",
    "Perfect Placement OpenMW Beta-46562-2-2beta4-1715465265\\scripts\\PerfectPlacement\\global.lua": "--[[\n\tMod: Perfect Placement OpenMW\n\tAuthor: Hrnchamd\n\tVersion: 2.2beta\n]]--\n\nlocal async = require('openmw.async')\nlocal core = require('openmw.core')\nlocal util = require('openmw.util')\n\nlocal itemSound = require('scripts.PerfectPlacement.itemSound')\n\nlocal movement = nil\nlocal currentObj = nil\n\nreturn {\n\teventHandlers = {\n\t\t[\"PerfectPlacement:Begin\"] = function(e)\n\t\t\tcurrentObj = e.activeObj\n\t\t\tcore.sound.playSound3d(itemSound.getPickupSound(e.activeObj), e.activeObj)\n\t\tend,\n\t\t[\"PerfectPlacement:Move\"] = function(e)\n\t\t\tif currentObj then\n\t\t\t\tmovement = { activeObj = e.activeObj, position = e.newPosition, rotation = e.newRotation }\n\t\t\tend\n\t\tend,\n\t\t[\"PerfectPlacement:Drop\"] = function(e)\n\t\t\tif currentObj then\n\t\t\t\tmovement = { activeObj = e.activeObj, position = e.newPosition, rotation = e.newRotation }\n\t\t\tend\n\t\tend,\n\t\t[\"PerfectPlacement:End\"] = function(e)\n\t\t\tcurrentObj = nil\n\t\t\tcore.sound.playSound3d(itemSound.getDropSound(e.activeObj), e.activeObj)\n\t\tend,\n\t},\n\tengineHandlers = {\n\t\tonUpdate = function(dt)\n\t\t\tif movement then\n\t\t\t\tmovement.activeObj:teleport(movement.activeObj.cell, movement.position, movement.rotation)\n\n\t\t\t\t-- Workaround for rotation issues in 0.49dev.\n\t\t\t\t-- Issue: Certain rotations are converted to NaN and cause an object to disappear.\n\t\t\t\t-- Check if new rotation produces NaNs and reset rotation if required.\n\t\t\t\tlocal check = movement.activeObj.rotation * util.vector3(0, 0, 0)\n\t\t\t\tif check.x ~= check.x then -- isNaN\n\t\t\t\t\tmovement.rotation = util.transform.identity\n\t\t\t\telse\n\t\t\t\t\tmovement = nil\n\t\t\t\tend\n\t\t\tend\n\t\tend,\n\t\tonActivate = function(object, actor)\n\t\t\t-- Cancel movement to prevent object duplication, and notify player script.\n\t\t\tif object == currentObj then\n\t\t\t\tcurrentObj = nil\n\t\t\t\tmovement = nil\n\t\t\t\tactor:sendEvent(\"PerfectPlacement:ObjRemoved\", {})\n\t\t\tend\n\t\tend\n\t}\n}",
    "Perfect Placement OpenMW Beta-46562-2-2beta4-1715465265\\scripts\\PerfectPlacement\\gui.lua": "--[[\n    Mod: Perfect Placement OpenMW\n    Author: Hrnchamd\n    Version: 2.2beta\n]]--\n\nlocal core = require('openmw.core')\nlocal input = require('openmw.input')\nlocal I = require('openmw.interfaces')\nlocal ui = require('openmw.ui')\nlocal util = require('openmw.util')\n\nlocal l10n = core.l10n('PerfectPlacement')\n\n-- Key guide window\n\nlocal flexSpacer = {\n\tprops = { size = util.vector2(16, 0) },\n}\nlocal textSpacer = {\n\tprops = { size = util.vector2(0, 16) },\n}\n\nlocal function makeLabel()\n\treturn { template = I.MWUI.templates.textNormal, props = {} }\nend\n\nlocal labelsLayout = {\n\tname = 'LabelColumn',\n\ttype = ui.TYPE.Flex,\n\tprops = { autoSize = true, size = util.vector2(250, 0) },\n\t--external = { grow = 0.75 },\n\tcontent = ui.content {\n\t\tmakeLabel(), textSpacer,\n\t\tmakeLabel(), textSpacer,\n\t\tmakeLabel(), textSpacer,\n\t\tmakeLabel(), textSpacer,\n\t\tmakeLabel(), textSpacer,\n\t\tmakeLabel(), textSpacer,\n\t\tmakeLabel(), textSpacer,\n\t}\n}\n\nlocal bindingsLayout = {\n\tname = 'BindingColumn',\n\ttype = ui.TYPE.Flex,\n\t--external = { grow = 0.25 },\n\tprops = { autoSize = true, size = util.vector2(100, 0), arrange = ui.ALIGNMENT.End },\n\tcontent = ui.content {\n\t\tmakeLabel(), textSpacer,\n\t\tmakeLabel(), textSpacer,\n\t\tmakeLabel(), textSpacer,\n\t\tmakeLabel(), textSpacer,\n\t\tmakeLabel(), textSpacer,\n\t\tmakeLabel(), textSpacer,\n\t\tmakeLabel(), textSpacer,\n\t}\n}\n\nlocal controlsGuideLayout = {\n\tlayer = 'HUD',\n\tname = 'PlacementControlsGuide',\n    type = ui.TYPE.Container,\n    props = {\n        relativePosition = util.vector2(0.02, 0.04),\n\t},\n\tcontent = ui.content {\n\t\t{\n\t\t\ttype = ui.TYPE.Image,\n\t\t\tprops = {\n\t\t\t\trelativeSize = util.vector2(1, 1),\n\t\t\t\tsize = util.vector2(395, 235),\n\t\t\t\tresource = ui.texture { path = 'white' },\n\t\t\t\tcolor = util.color.rgb(0, 0, 0),\n\t\t\t\talpha = 0.8,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname = 'Table',\n\t\t\ttype = ui.TYPE.Flex,\n\t\t\tprops = {\n\t\t\t\thorizontal = true,\n\t\t\t\tposition = util.vector2(0, 12),\n\t\t\t},\n\t\t\tcontent = ui.content {\n\t\t\t\tflexSpacer,\n\t\t\t\tlabelsLayout,\n\t\t\t\tbindingsLayout,\n\t\t\t\tflexSpacer,\n\t\t\t},\n\t\t},\n\t},\n}\n\n\nlocal menu\n\nlocal function hideGuide()\n\tif menu then\n\t\tmenu:destroy()\n\t\tmenu = nil\n\tend\nend\n\nlocal function setLine(n, label, verb, binding)\n\tlocal i = 2 * n - 1\n\tlabelsLayout.content[i].props.text = label\n\tbindingsLayout.content[i].props.text = verb .. input.getKeyName(binding)\nend\n\nlocal function showGuide(config)\n\tif not menu then\n\t\tmenu = ui.create(controlsGuideLayout)\n\tend\n\t\n    setLine(1, l10n('RotateItem'), l10n('HoldPrefix'), config.keybindRotate)\n    setLine(2, l10n('VerticalMode'), '', config.keybindVertical)\n    setLine(3, l10n('MatchLast'), l10n('HoldPrefix'), config.keybindVertical)\n    setLine(4, l10n('OrientToSurface'), '', config.keybindSurfaceAlign)\n    setLine(5, l10n('SnapRotation'), '', config.keybindSnap)\n    setLine(6, l10n('DropItem'), '', config.keybindPlace)\n    setLine(7, l10n('HangItem'), input.getKeyName(config.keybindRotate) .. ' + ', config.keybindPlace)\n\n\tmenu:update()\nend\n\nreturn {\n\thideGuide = hideGuide,\n\tshowGuide = showGuide,\n}",
    "Perfect Placement OpenMW Beta-46562-2-2beta4-1715465265\\scripts\\PerfectPlacement\\itemSound.lua": "-- Item pickup/drop sound courtesy of https://gitlab.com/zackhasacat\n-- This may be replaced when it is merged into OpenMW.\n\nlocal types = require('openmw.types')\nlocal core = require('openmw.core')\n---\n-- `openmw_aux.core` defines utility functions for objects.\n-- Implementation can be found in `resources/vfs/openmw_aux/core.lua`.\n-- @module core\n-- @usage local auxCore = require('openmw_aux.core')\nlocal aux_core = {}\n\nlocal SKILL = types.NPC.stats.skills\n\nlocal armorSkillString = {[SKILL.heavyarmor] = \"Heavy\",[SKILL.mediumarmor] = \"Medium\", [SKILL.lightarmor] = \"Light\"}\n---\n-- Checks if the provided armor is Heavy, Medium, or Light. Errors if invaid object supplied.\n-- @function [parent=#core] getArmorType\n-- @param openmw.core#GameObject armor Either a gameObject or a armor record.\n-- @return openmw.core#SKILL  The skill for this armor\nfunction aux_core.getArmorType(armor)\n\n    if armor.type ~= types.Armor and not armor.baseArmor then\n        error(\"Not Armor\")\n    end\n    local record = nil\n    if armor.baseArmor then--A record was supplied, not a gameObject\n        record = armor\n    else\n        record = types.Armor.record(armor)\n    end\n    local epsilon = 0.0005;\n    local lightMultiplier = core.getGMST(\"fLightMaxMod\") + epsilon\n    local medMultiplier = core.getGMST(\"fMedMaxMod\") + epsilon\n    local armorGMSTs = {\n        [types.Armor.TYPE.Boots] = \"iBootsWeight\",\n        [types.Armor.TYPE.Cuirass] = \"iCuirassWeight\",\n        [types.Armor.TYPE.Greaves] = \"iGreavesWeight\",\n        [types.Armor.TYPE.Shield] = \"iShieldWeight\",\n        [types.Armor.TYPE.LBracer] = \"iGauntletWeight\",\n        [types.Armor.TYPE.RBracer] = \"iGauntletWeight\",\n        [types.Armor.TYPE.RPauldron] = \"iPauldronWeight\",\n        [types.Armor.TYPE.LPauldron] = \"iPauldronWeight\",\n        [types.Armor.TYPE.Helmet] = \"iHelmWeight\",\n        [types.Armor.TYPE.LGauntlet] = \"iGauntletWeight\",\n        [types.Armor.TYPE.RGauntlet] = \"iGauntletWeight\",\n    }\n    local armorType = record.type\n    local weight = record.weight\n    local armorTypeWeight = math.floor(core.getGMST(armorGMSTs[armorType]))\n\n    if weight <= armorTypeWeight * lightMultiplier then\n        return SKILL.lightarmor\n    elseif weight <= armorTypeWeight * medMultiplier then\n        return SKILL.mediumarmor\n    else\n        return SKILL.heavyarmor\n    end\nend\n\nlocal weaponType = types.Weapon.TYPE\nlocal weaponSound = {\n    [weaponType.BluntOneHand] = \"Weapon Blunt\",\n    [weaponType.BluntTwoClose] = \"Weapon Blunt\",\n    [weaponType.BluntTwoWide] = \"Weapon Blunt\",\n    [weaponType.MarksmanThrown] = \"Weapon Blunt\",\n    [weaponType.Arrow] = \"Ammo\",\n    [weaponType.Bolt] = \"Ammo\",\n    [weaponType.SpearTwoWide] = \"Weapon Spear\",\n    [weaponType.MarksmanBow] = \"Weapon Bow\",\n    [weaponType.MarksmanCrossbow] = \"Weapon Crossbow\",\n    [weaponType.AxeOneHand] = \"Weapon Blunt\",\n    [weaponType.AxeTwoHand] = \"Weapon Blunt\",\n    [weaponType.ShortBladeOneHand] = \"Weapon Shortblade\",\n    [weaponType.LongBladeOneHand] = \"Weapon Longblade\",\n    [weaponType.LongBladeTwoHand] = \"Weapon Longblade\",\n}\nlocal goldIds = { gold_001 = true, gold_005 = true, gold_010 = true, gold_025 = true, gold_100 = true }\nlocal function getItemSound(object)\n    local type = object.type\n    if object.type.baseType ~= types.Item or not object then\n        error(\"Invalid object supplied\")\n    end\n    local record = object.type.record(object)\n    local soundName = tostring(type) -- .. \" Up\"\n    if type == types.Armor then\n        soundName = \"Armor \" .. armorSkillString[aux_core.getArmorType(object)]\n    elseif type == types.Clothing then\n        soundName = \"Clothes\"\n        if record.type == types.Clothing.TYPE.Ring then\n            soundName = \"Ring\"\n        end\n    elseif type == types.Light or type == types.Miscellaneous then\n        if goldIds[object.recordId] then\n            soundName = \"Gold\"\n        else\n            soundName = \"Misc\"\n        end\n    elseif type == types.Weapon then\n        soundName = weaponSound[record.type]\n    end\n    return soundName\nend\n\n\n---\n-- Get the sound that should be played when this item is dropped.\n-- @function [parent=#core] getDropSound\n-- @param openmw.core#GameObject item\n-- @return #string\nfunction aux_core.getDropSound(item)\n    local soundName = getItemSound(item)\n    return string.format(\"Item %s Down\", soundName)\nend\n\n---\n-- Get the sound that should be played when this item is picked up.\n-- @function [parent=#core] getPickupSound\n-- @param openmw.core#GameObject item\n-- @return #string\nfunction aux_core.getPickupSound(item)\n    local soundName = getItemSound(item)\n    return string.format(\"Item %s Up\", soundName)\nend\n\nreturn aux_core\n",
    "Perfect Placement OpenMW Beta-46562-2-2beta4-1715465265\\scripts\\PerfectPlacement\\orient.lua": "--[[\n    Ground orientation functions, OpenMW port\n\n    Source: Just Drop It by Merlord\n    Used with permission.\n]]--\n\nlocal util = require('openmw.util')\nlocal ui = require('openmw.ui')\n\nlocal this = {}\n\n-- Different steepness limits than Just Drop It.\n-- The limit should still demonstrate the need to change to vertical mode.\nlocal maxSteepnessFlat = 65\nlocal maxSteepnessTall = 5\n\nlocal function mutableVec3(v)\n\treturn { x = v.x, y = v.y, z = v.z }\nend\n\nlocal function transformToAngles(t)\n\tlocal x, y, z\n\tlocal forward = t * util.vector3(0, 1, 0)\n\tlocal up = t * util.vector3(0, 0, 1)\n\tforward = forward:normalize()\n\tup = up:normalize()\n\ty = -math.asin(up.x)\n\tx = math.atan2(up.y, up.z)\n\tlocal fz = (util.transform.rotateY(-y) * util.transform.rotateX(-x)) * forward\n\tz = math.atan2(fz.x, fz.y)\n\n\t--z, y, x = t:getAnglesZYX() -- broken in 0.49 dev\n\treturn { x = x, y = y, z = z }\nend\n\nfunction this.rotationDifference(vec1, vec2)\n    vec1 = vec1:normalize()\n    vec2 = vec2:normalize()\n\n    local axis = vec1:cross(vec2)\n    local norm = axis:length()\n    if norm < 1e-5 then\n        return util.vector3(0, 0, 0)\n    end\n\n    local angle = math.asin(norm)\n    if vec1:dot(vec2) < 0 then\n        angle = math.pi - angle\n    end\n\n    axis = axis:normalize()\n\n    local m = util.transform.rotate(angle, axis) -- OpenMW edit\n\treturn transformToAngles(m)\nend\n\nlocal function isTall(ref)\n    local bb = ref:getBoundingBox() -- OpenMW edit\n    local width = bb.halfSize.x * 2\n    local depth = bb.halfSize.y * 2\n    local height = bb.halfSize.z * 2\n    return height > depth or height > width\nend\n\nlocal function getMaxSteepness(ref)\n    return math.rad(isTall(ref) and maxSteepnessTall or maxSteepnessFlat)\nend\n\nfunction this.orientRef(ref, orientation, rayResult)\n    local UP = util.vector3(0, 0, 1)\n    local maxSteepness = getMaxSteepness(ref)\n    local newOrientation = mutableVec3(this.rotationDifference(UP, rayResult.hitNormal))\n\n    newOrientation.x = util.clamp(newOrientation.x, -maxSteepness, maxSteepness)\n    newOrientation.y = util.clamp(newOrientation.y, -maxSteepness, maxSteepness)\n    newOrientation.z = orientation.z\n    return newOrientation\nend\n\nreturn this\n",
    "Perfect Placement OpenMW Beta-46562-2-2beta4-1715465265\\scripts\\PerfectPlacement\\player.lua": "--[[\n    Mod: Perfect Placement OpenMW\n    Author: Hrnchamd\n    Version: 2.2beta\n]]--\n\nlocal async = require('openmw.async')\nlocal camera = require('openmw.camera')\nlocal core = require('openmw.core')\nlocal nearby = require('openmw.nearby')\nlocal input = require('openmw.input')\nlocal player = require('openmw.self')\nlocal storage = require('openmw.storage')\nlocal types = require('openmw.types')\nlocal ui = require('openmw.ui')\nlocal util = require('openmw.util')\n\nlocal itemSound = require('scripts.PerfectPlacement.itemSound')\nlocal gui = require('scripts.PerfectPlacement.gui')\nlocal orientModule = require('scripts.PerfectPlacement.orient')\nlocal config = require('scripts.PerfectPlacement.config')\nlocal l10n = core.l10n('PerfectPlacement')\n\nlocal this = {\n    maxReach = 1.2,\n    holdKeyTime = 0.75,\n    rotateMode = false,\n    snapMode = false,\n    verticalMode = 0,\n    freezeAlign = false,\n    groundAlign = config.options.initialGroundAlign,\n    wallAlign = config.options.initialWallAlign\n}\n\nlocal placeableTypes = {\n    [types.Apparatus] = true,\n    [types.Armor] = true,\n    [types.Book] = true,\n    [types.Clothing] = true,\n    [types.Ingredient] = true,\n    [types.Light] = true,\n    [types.Lockpick] = true,\n    [types.Miscellaneous] = true,\n    [types.Potion] = true,\n    [types.Probe] = true,\n    [types.Repair] = true,\n    [types.Weapon] = true,\n}\n\nlocal const_epsilon = 0.001\n\n\n\nlocal function mutableVec3(v)\n\treturn { x = v.x, y = v.y, z = v.z }\nend\n\nlocal function transformToAngles(t)\n\tlocal x, y, z\n\n\t--z, y, x = t:getAnglesZYX() -- Broken in OpenMW\n\n\t-- Temporary replacement code\n\tlocal forward = t * util.vector3(0, 1, 0)\n\tlocal up = t * util.vector3(0, 0, 1)\n\tforward = forward:normalize()\n\tup = up:normalize()\n\n\tif math.abs(up.z) < 1e-5 then\n\t\tx = -0.5 * math.pi\n\t\ty = math.atan2(-up.x, -up.y)\n\telse\n\t\tx = math.atan2(up.y, up.z)\n\t\ty = -math.asin(up.x)\n\tend\n\tlocal fz = (util.transform.rotateY(-y) * util.transform.rotateX(-x)) * forward\n\tz = math.atan2(fz.x, fz.y)\n\n\treturn { x = x, y = y, z = z }\nend\n\nlocal function transformFromAngles(t)\n\treturn util.transform.rotateX(t.x) * util.transform.rotateY(t.y) * util.transform.rotateZ(t.z)\nend\n\nlocal function showAngles(prefix, a)\n\tui.showMessage(string.format(\"%s X %0.3f Y %0.3f Z %0.3f\", prefix, a.x, a.y, a.z))\nend\n\nlocal function castRenderingRayInclLandscape(from, to, opt)\n\t-- Workaround for castRenderingRay not working with landscape geometry.\n\tlocal result = nearby.castRenderingRay(from, to, opt)\n\tif result.hit or not player.cell.isExterior then\n\t\treturn result\n\tend\n\t\n\tlocal optLandscape = { collisionType = nearby.COLLISION_TYPE.HeightMap }\n\tif opt then\n\t\toptLandscape.ignore = opt.ignore\n\tend\n\t\n\tresult = nearby.castRay(from, to, optLandscape)\n\tif result.hit and result.hitObject == nil then\n\t\treturn result\n\tend\n\n\treturn { hit = false }\nend\n\nlocal function cancelableTimer(delay, func)\n\tlocal data = {}\n\tasync:newUnsavableSimulationTimer(delay, function()\n\t\tif not data.cancel then func() end\n\tend)\n\treturn data\nend\n\nlocal function cancelPlayerTurning()\n\tplayer.controls.yawChange = 0\n\tplayer.controls.pitchChange = 0\nend\n\nlocal function castActivationRay()\n\tlocal v = camera.viewportToWorldVector(util.vector2(0.5, 0.5))\n\tlocal dist = core.getGMST(\"iMaxActivateDist\")\n\tlocal pos = camera.getPosition()\n\treturn nearby.castRenderingRay(pos, pos + v * dist)\nend\n\nlocal endPlacement, endPlacementWithReset -- local functions\n\n-- Set rotation frame and effective height for vertical modes.\nlocal function setVerticalMode(n)\n\tlocal half_pi = 0.5 * math.pi\n    local prevHeight = this.height\n    this.orientation.x = -half_pi\n    this.orientation.y = player.rotation:getYaw()\n\t\n    if (n == 1) then\n        this.orientation.z = 0\n        this.height = -this.boundMin.y\n    elseif (n == 2) then\n        this.orientation.z = -half_pi\n        this.height = -this.boundMin.x\n    elseif (n == 3) then\n        this.orientation.z = math.pi\n        this.height = this.boundMax.y\n    elseif (n == 4) then\n        this.orientation.z = half_pi\n        this.height = this.boundMax.x\n    end\n\n    this.newPosition = this.activeObj.position + util.vector3(0, 0, this.height - prevHeight)\n\tthis.newRotation = transformFromAngles(this.orientation)\n\tcore.sendGlobalEvent(\"PerfectPlacement:Move\", this)\nend\n\n-- Match vertical mode from an orientation.\nlocal function matchVerticalMode(orient, boundMin, boundMax)\n    local absOriX = math.abs(orient.x)\n    if (absOriX > 1.55 and absOriX < 1.59) then\n        local k = math.floor(0.5 + orient.z / (0.5 * math.pi))\n        if (k == 0 or k == 4) then\n            this.verticalMode = 1\n            this.height = -boundMin.y\n        elseif (k == -1 or k == 3) then\n            this.verticalMode = 2\n            this.height = -boundMin.x\n        elseif (k == -2 or k == 2) then\n            this.verticalMode = 3\n            this.height = boundMax.y\n        elseif (k == -3 or k == 1) then\n            this.verticalMode = 4\n            this.height = boundMax.x\n        end\n    else\n        this.verticalMode = 0\n        this.height = -boundMin.z\n    end\nend\n\n-- Called to confirm final placement, drops item to ground if not attaching to wall.\nlocal function finalPlacement()\n\t-- Read back possibly quantized rotation.\n\tthis.orientation = transformToAngles(this.activeObj.rotation)\n    this.lastItemOri = this.orientation\n\n    if (not this.wallMount and not this.rotateMode) then\n        -- Match vertical mode to get correct object height after arbitrary rotations.\n        matchVerticalMode(this.orientation, this.boundMin, this.boundMax)\n\n        -- Drop to ground.\n        local from = this.activeObj.position + util.vector3(0, 0, -this.height + const_epsilon)\n\t\tlocal to = from + util.vector3(0, 0, -4096)\n        local ray = castRenderingRayInclLandscape(from, to, { ignore = this.activeObj })\n\n        if (ray.hit) then\n            if (this.verticalMode == 0 and this.groundAlign and not this.freezeAlign) then\n                this.orientation = orientModule.orientRef(this.activeObj, this.orientation, ray)\n            end\n\n\t\t\t-- Global event data to send.\n\t\t\tlocal data = {\n\t\t\t\tactiveObj = this.activeObj,\n\t\t\t\tnewPosition = ray.hitPos + util.vector3(0, 0, this.height + const_epsilon),\n\t\t\t\tnewRotation = transformFromAngles(this.orientation)\n\t\t\t}\n\t\t\t--showAngles(\"drop before\", this.orientation)\n\t\t\t--showAngles(\"drop after\", transformToAngles(data.newRotation))\n\t\n\t\t\t-- Place object at final position.\n\t\t\tcore.sendGlobalEvent(\"PerfectPlacement:Drop\", data)\n        end\n\tend\n    \n\tcore.sendGlobalEvent(\"PerfectPlacement:End\", this)\n    endPlacement()\nend\n\n-- Copy orientation event handler.\nlocal function copyLastOri()\n    if (this.lastItemOri) then\n        this.orientation = mutableVec3(this.lastItemOri)\n        this.freezeAlign = true\n        matchVerticalMode(this.orientation, this.boundMin, this.boundMax)\n    end\nend\n\n-- On grabbing / dropping an item.\nlocal function activatePlacement()\n    local targetRay = castActivationRay()\n\tlocal target = targetRay.hitObject\n\n    -- Do not operate in menu mode and during attacking/casting (no OpenMW anim support yet).\n    if core.isWorldPaused() then\n        return\n    end\n    \n    if (this.activeObj) then\n        -- Drop item.\n        finalPlacement()\n    elseif (target) then\n        -- Filter by allowed object type.\n        if (not placeableTypes[target.type]) then\n            return\n        end\n\t\tif target.type == types.Light and not types.Light.record(target).isCarriable then\n\t\t\treturn\n\t\tend\n        -- Ownership test.\n\t\tlocal owner = target.owner\n        if (owner.recordId or owner.factionId) then\n            if (owner.factionId and types.NPC.getFactionRank(player, owner.factionId) >= owner.factionRank and not types.NPC.isExpelled(player, owner.factionId)) then\n                -- Player has sufficient faction rank.\n            else\n                ui.showMessage(l10n(\"OwnedItem\"))\n                return\n            end\n        end\n\n        -- Put those hands away.\n\t\tif types.Actor.getStance(player) ~= types.Actor.STANCE.Nothing then\n\t\t\ttypes.Actor.setStance(player, types.Actor.STANCE.Nothing)\n\t\tend\n\n        -- Calculate effective bounds including scale.\n\t\tlocal orientation = transformToAngles(target.rotation)\n\t\t--showAngles(\"activatePlacement\", orientation)\n\t\tlocal bbox = target:getBoundingBox()\n        this.boundMin = bbox.center - bbox.halfSize\n        this.boundMax = bbox.center + bbox.halfSize\n        matchVerticalMode(orientation, this.boundMin, this.boundMax)\n\n        -- Get exact ray to selection point, relative to 1st person camera.\n        local eye = camera.getPosition()\n        local basePos = target.position - util.vector3(0, 0, this.height)\n\n        -- Check if item is attached to a wall.\n        if (this.verticalMode ~= 0) then\n            local attachRay = util.vector3(math.sin(orientation.y), math.cos(orientation.y), 0)\n            local attachPos = util.vector3(basePos.x + -this.boundMin.z * attachRay.x, basePos.y + -this.boundMin.z * attachRay.y, basePos.z)\n\t\t\tlocal from = attachPos + attachRay * -0.5\n\t\t\tlocal to = attachPos + attachRay * 0.5\n            local wallRay = nearby.castRenderingRay(from, to, { ignore = target })\n\n            if (wallRay.hit) then\n                -- Adjust basePos to be on the model edge that is touching the wall.\n                basePos = attachPos\n            end\n        end\n\n        this.rayDir = camera.getViewTransform() * basePos\n\n        -- Save initial placement.\n        this.itemInitialPos = target.position\n        this.itemInitialRot = target.rotation\n        this.playerLastOri = transformToAngles(player.rotation)\n        this.orientation = orientation\n        this.freezeAlign = false\n\n        this.activeObj = target\n\t\tcore.sendGlobalEvent(\"PerfectPlacement:Begin\", this)\n        --#tes3ui.suppressTooltip(true)\n        \n        if (config.options.showGuide) then\n            gui.showGuide(config.keybinds)\n        end\n    end\nend\n\n-- Called every simulation frame to reposition the item.\nlocal function onFrame(deltaTime)\n\tif core.isWorldPaused() then return end\n\tif not this.activeObj then return end\n\t\n    -- Stop if player takes the object.\n    if (this.objRemoved or this.activeObj.cell == nil) then\n        endPlacement()\n\t\tthis.objRemoved = nil\n        return\n    -- Check for cell change.\n    elseif (not this.activeObj.cell:isInSameSpace(player)) then\n        ui.showMessage(l10n(\"CannotMoveBetweenCells\"))\n        endPlacementWithReset()\n        return\n    -- Drop item if player readies combat or casts a spell.\n    elseif (types.Player.stance(player) ~= types.Player.STANCE.Nothing) then\n        finalPlacement()\n        return\n    end\n\n    -- Cast ray along initial pickup direction rotated by the 1st person camera.\n    local eye = camera.getPosition()\n    local rayDir = camera.getViewTransform():inverse() * this.rayDir - eye\n    local ray = castRenderingRayInclLandscape(eye, eye + rayDir:normalize() * 800, { ignore = this.activeObj })\n\tlocal hitT = ray.hit and (ray.hitPos - eye):length() / rayDir:length()\n    \n    -- Limit holding distance to a maxReach * initial distance.\n    local pos\n    if (ray.hit and hitT <= this.maxReach) then\n        pos = ray.hitPos\n    else\n        pos = eye + rayDir * this.maxReach\n    end\n    -- Add epsilon to ensure the intersection is not inside the model during to floating point precision.\n    pos = pos + util.vector3(0, 0, const_epsilon)\n\n    -- Item orientation handling.\n    this.wallMount = false\n    if (this.verticalMode == 0) then\n        if (not this.freezeAlign) then\n            -- Ground mode. Check if item is directly touching something.\n            if (ray.hit and hitT <= this.maxReach and this.groundAlign) then\n                -- Orient item to match placement.\n                this.orientation = orientModule.orientRef(this.activeObj, this.orientation, ray)\n            else\n                -- Remove any tilt rotation, in an animated manner.\n                local ease = math.max(0.5, 1 - 20 * deltaTime)\n                this.orientation.x = ease * this.orientation.x\n                this.orientation.y = ease * this.orientation.y\n                if (math.abs(this.orientation.x) < 0.02) then\n                    this.orientation.x = 0\n                end\n                if (math.abs(this.orientation.y) < 0.02) then\n                    this.orientation.y = 0\n                end\n            end\n        end\n    else\n        -- Vertical mode. Check if the bottom of the model is close to other geometry.\n        local clearance = math.max(2, -this.boundMin.z)\n        rayDir = util.vector3(clearance * math.sin(this.orientation.y), clearance * math.cos(this.orientation.y), 0)\n\t\tlocal from = pos + rayDir * -const_epsilon\n        ray = castRenderingRayInclLandscape(from, from + rayDir * 2, { ignore = this.activeObj })\n\t\thitT = ray.hit and (ray.hitPos - from):length() / clearance\n        \n        if (ray.hit and hitT < 1) then\n            -- Place at minimum distance outside wall, and optionally align rotation with normal.\n            pos = ray.hitPos - rayDir\n            if (this.wallAlign and math.abs(ray.hitNormal.z) < 0.2) then\n                this.orientation.y = math.atan2(-ray.hitNormal.x, -ray.hitNormal.y)\n            end\n            this.wallMount = true\n        end\n    end\n\n    -- Find drop position for shadow spot.\n\t--[[\n    local dropPos = pos\n    ray = castRenderingRayInclLandscape(pos, pos + util.vector3(0, 0, -2048), { ignore = this.activeObj })\n    if (ray.hit) then\n        dropPos = ray.hitPos\n    end\n\t]]--\n\n    -- Get object centre from base point\n    pos = pos + util.vector3(0, 0, this.height)\n\n    -- Incrementally rotate the same amount as the player, to keep relative alignment with player.\n\tlocal playerCurrentOri = transformToAngles(player.rotation)\n    local d_theta = playerCurrentOri.z - this.playerLastOri.z\n    this.playerLastOri = playerCurrentOri\n\n    if (this.rotateMode) then\n\t\t-- View rotation freeze. Use custom input handling.\n\t\tcancelPlayerTurning()\n\t\tlocal controllerMoveX = 2 * input.getAxisValue(input.CONTROLLER_AXIS.LookLeftRight)\n\t\tlocal horizontalMove = controllerMoveX ~= 0 and controllerMoveX or input.getMouseMoveX()\n        d_theta = 0.001 * config.options.sensitivity * horizontalMove\n    end\n\n    -- Apply rotation.\n    if (this.verticalMode == 0) then\n        -- Ground plane rotation.\n        this.orientation.z = util.normalizeAngle(this.orientation.z + d_theta)\n    elseif (this.wallMount and this.rotateMode) then\n        -- Wall mount rotation.\n        this.orientation.z = util.normalizeAngle(this.orientation.z + d_theta)\n    else\n        -- Vertical rotation.\n        this.orientation.y = util.normalizeAngle(this.orientation.y + d_theta)\n    end\n\n    -- Rotation snap.\n    local orient = mutableVec3(this.orientation)\n    if (this.snapMode) then\n        local quantizer = config.options.snapQuantizer\n        if (this.verticalMode == 0 or this.wallMount) then\n            orient.z = quantizer * math.floor(0.5 + orient.z / quantizer)\n        else\n            orient.y = quantizer * math.floor(0.5 + orient.y / quantizer)\n        end\n    end\n\n    -- Update item.\n\tthis.newPosition = pos\n\tthis.newRotation = transformFromAngles(orient)\n\t--showAngles(\"orient\", orient)\n\tcore.sendGlobalEvent(\"PerfectPlacement:Move\", this)\nend\n\n-- Clean up placement.\nendPlacement = function()\n\tif (this.verticalHoldTimer) then\n\t\tthis.verticalHoldTimer.cancel = true\n\t\tthis.verticalHoldTimer = nil\n\tend\n    \n\tcore.sendGlobalEvent(\"PerfectPlacement:End\", this)\n    --#tes3ui.suppressTooltip(false)\n    \n    -- this.snapMode is persistent\n    -- this.groundAlign is persistent\n    -- this.wallAlign is persistent\n    this.activeObj = nil\n    this.rotateMode = nil\n    this.verticalMode = 0\n    \n\tgui.hideGuide()\nend\n\nendPlacementWithReset = function ()\n\t-- Global event data to send.\n\tlocal data = {\n\t\tactiveObj = this.activeObj,\n\t\tnewPosition = this.itemInitialPos,\n\t\tnewRotation = this.itemInitialRot\n\t}\n\t-- Restore original item position.\n\tcore.sendGlobalEvent(\"PerfectPlacement:Drop\", data)\n\n\tendPlacement()\nend\n\n-- End placement on load game. this.activeObj would be invalid after load.\nlocal function onLoad(e)\n    if (this.activeObj) then\n        endPlacement()\n    end\nend\n\n-- Input\n\nlocal function registerTrigger(key, name)\n\tinput.registerTrigger({ key = key, l10n = 'PerfectPlacement', name = name, description = name })\nend\n\nregisterTrigger('PerfectPlacement/Place', 'GrabDropItem')\nregisterTrigger('PerfectPlacement/RotateMode', 'RotateItem')\nregisterTrigger('PerfectPlacement/SnapMode', 'SnapRotation')\nregisterTrigger('PerfectPlacement/VerticalMode', 'VerticalMode')\nregisterTrigger('PerfectPlacement/SurfaceAlignMode', 'OrientToSurface')\nregisterTrigger('PerfectPlacement/RotateMode/Release', 'RotateItem')\nregisterTrigger('PerfectPlacement/VerticalMode/Release', 'VerticalMode')\n\ninput.registerTriggerHandler('PerfectPlacement/Place', async:callback(activatePlacement))\ninput.registerTriggerHandler('PerfectPlacement/RotateMode', async:callback(function()\n\tif (not this.activeObj) then return end\n\n\tthis.rotateMode = true\nend))\ninput.registerTriggerHandler('PerfectPlacement/SnapMode', async:callback(function()\n\tif (not this.activeObj) then return end\n\n\tthis.snapMode = not this.snapMode\nend))\ninput.registerTriggerHandler('PerfectPlacement/VerticalMode', async:callback(function()\n\tif (not this.activeObj) then return end\n\n\tthis.verticalHoldTimer = cancelableTimer(this.holdKeyTime, copyLastOri)\n\n\tif (this.verticalMode == 0) then\n\t\tthis.verticalMode = 1\n\t\tsetVerticalMode(this.verticalMode)\n\telse\n\t\tthis.orientation.x = 0\n\t\tthis.orientation.y = 0\n\t\tthis.orientation.z = transformToAngles(player.rotation).z\n\t\tthis.height = -this.boundMin.z\n\t\tthis.verticalMode = 0\n\tend\nend))\ninput.registerTriggerHandler('PerfectPlacement/SurfaceAlignMode', async:callback(function()\n\tif (not this.activeObj) then return end\n\n\tif (this.verticalMode == 0) then\n\t\tthis.groundAlign = not this.groundAlign\n\telse\n\t\tthis.wallAlign = not this.wallAlign\n\tend\nend))\ninput.registerTriggerHandler('PerfectPlacement/RotateMode/Release', async:callback(function()\n\tif (not this.activeObj) then return end\n\n\tthis.rotateMode = false\nend))\ninput.registerTriggerHandler('PerfectPlacement/VerticalMode/Release', async:callback(function()\n\tif (not this.activeObj) then return end\n\n\tif (this.verticalHoldTimer) then\n\t\tthis.verticalHoldTimer.cancel = true\n\tend\nend))\n\n-- Manual dispatch here because access to the keybinds are required to display them/set defaults.\nlocal function onKeyPress(e)\n\tlocal code, keybinds = e.code, config.keybinds\n\n\tif (code == keybinds.keybindPlace) then\n\t\tinput.activateTrigger('PerfectPlacement/Place')\n    elseif (code == keybinds.keybindRotate) then\n\t\tinput.activateTrigger('PerfectPlacement/RotateMode')\n\telseif (code == keybinds.keybindSnap) then\n\t\tinput.activateTrigger('PerfectPlacement/SnapMode')\n    elseif (code == keybinds.keybindVertical) then\n\t\tinput.activateTrigger('PerfectPlacement/VerticalMode')\n\telseif (code == keybinds.keybindSurfaceAlign) then\n\t\tinput.activateTrigger('PerfectPlacement/SurfaceAlignMode')\n    end\nend\n\nlocal function onKeyRelease(e)\n\tlocal code, keybinds = e.code, config.keybinds\n\n    if (code == keybinds.keybindRotate) then\n\t\tinput.activateTrigger('PerfectPlacement/RotateMode/Release')\n    elseif (code == keybinds.keybindVertical) then\n\t\tinput.activateTrigger('PerfectPlacement/VerticalMode/Release')\n\tend\nend\n\n\n\nreturn {\n\teventHandlers = {\n\t\t[\"PerfectPlacement:ObjRemoved\"] = function(e)\n\t\t\tthis.objRemoved = true\n\t\tend\n\t},\n    engineHandlers = {\n\t\tonKeyPress = onKeyPress,\n\t\tonKeyRelease = onKeyRelease,\n\t\tonLoad = onLoad,\n\t\tonFrame = onFrame,\n    }\n}",
    "Perfect Placement OpenMW Beta-46562-2-2beta4-1715465265\\scripts\\PerfectPlacement\\settings.lua": "--[[\n    Mod: Perfect Placement OpenMW\n    Author: Hrnchamd\n    Version: 2.2beta\n]]--\n\nlocal async = require('openmw.async')\nlocal core = require('openmw.core')\nlocal input = require('openmw.input')\nlocal I = require('openmw.interfaces')\nlocal ui = require('openmw.ui')\n\nlocal l10n = core.l10n('PerfectPlacement')\nlocal versionString = \"2.2beta\"\n\n-- inputKeySelection by Pharis\nI.Settings.registerRenderer('PerfectPlacement/inputKeySelection', function(value, set)\n\tlocal name = 'No Key Set'\n\tif value then\n\t\tname = input.getKeyName(value)\n\tend\n\treturn {\n\t\ttemplate = I.MWUI.templates.box,\n\t\tcontent = ui.content {\n\t\t\t{\n\t\t\t\ttemplate = I.MWUI.templates.padding,\n\t\t\t\tcontent = ui.content {\n\t\t\t\t\t{\n\t\t\t\t\t\ttemplate = I.MWUI.templates.textEditLine,\n\t\t\t\t\t\tprops = {\n\t\t\t\t\t\t\ttext = name,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tevents = {\n\t\t\t\t\t\t\tkeyPress = async:callback(function(e)\n\t\t\t\t\t\t\t\tif e.code == input.KEY.Escape then return end\n\t\t\t\t\t\t\t\tset(e.code)\n\t\t\t\t\t\t\tend),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\nend)\n\n-- Settings page\nI.Settings.registerPage {\n    key = 'PerfectPlacement',\n    l10n = 'PerfectPlacement',\n    name = 'ConfigTitle',\n    description = l10n('ConfigSummary'):gsub('%%{version}', versionString),\n}\nI.Settings.registerGroup {\n    key = 'Settings/PerfectPlacement/Options',\n    page = 'PerfectPlacement',\n    l10n = 'PerfectPlacement',\n    name = 'ConfigCategoryOptions',\n    permanentStorage = true,\n    settings = {\n        {\n            key = 'showGuide',\n            renderer = 'checkbox',\n            name = 'ConfigDisplayGuide',\n            default = true,\n        },\n        {\n            key = 'initialGroundAlign',\n            renderer = 'checkbox',\n            name = 'ConfigOrientToGround',\n            default = true,\n        },\n        {\n            key = 'initialWallAlign',\n            renderer = 'checkbox',\n            name = 'ConfigOrientToWalls',\n            default = true,\n        },\n        {\n            key = 'sensitivity',\n            renderer = 'number',\n            name = 'ConfigRotateSensitivity',\n\t\t\tinteger = true,\n\t\t\tmin = 5,\n\t\t\tmax = 50,\n            default = 15,\n        },\n        {\n            key = 'snapN',\n            renderer = 'select',\n            name = 'ConfigSnapRotationTo',\n\t\t\targument = {\n\t\t\t\tl10n = 'PerfectPlacement',\n\t\t\t\titems = { 'Snap15', 'Snap30', 'Snap45', 'Snap90' },\n\t\t\t},\n            default = 'Snap90',\n        },\n    },\n}\nI.Settings.registerGroup {\n    key = 'Settings/PerfectPlacement/Keybinds',\n    page = 'PerfectPlacement',\n    l10n = 'PerfectPlacement',\n    name = 'ConfigCategoryKeybinds',\n    permanentStorage = true,\n    settings = {\n        {\n            key = 'keybindPlace',\n            renderer = 'PerfectPlacement/inputKeySelection',\n            name = 'GrabDropItem',\n            default = input.KEY.G,\n        },\n        {\n            key = 'keybindRotate',\n            renderer = 'PerfectPlacement/inputKeySelection',\n            name = 'RotateItem',\n            default = input.KEY.LeftShift,\n        },\n        {\n            key = 'keybindVertical',\n            renderer = 'PerfectPlacement/inputKeySelection',\n            name = 'VerticalMode',\n            default = input.KEY.LeftAlt,\n        },\n        {\n            key = 'keybindSurfaceAlign',\n            renderer = 'PerfectPlacement/inputKeySelection',\n            name = 'OrientToSurface',\n            default = input.KEY.Slash,\n        },\n        {\n            key = 'keybindSnap',\n            renderer = 'PerfectPlacement/inputKeySelection',\n            name = 'SnapRotation',\n            default = input.KEY.RightShift,\n        },\n    },\n}\n",
    "Perfect Placement-46562-2-1-1630362018\\MWSE\\mods\\hrnchamd\\perfectplacement\\main.lua": "--[[\n    Mod: Perfect Placement\n    Author: Hrnchamd\n    Version: 2.1\n]]--\n\nlocal orientModule = require(\"hrnchamd.perfectplacement.orient\")\nlocal i18n = mwse.loadTranslations(\"hrnchamd.perfectplacement\")\n\nlocal configId = \"Perfect Placement\"\nlocal configDefault = {\n    keybind = 34,\n    keybindRotate = 42,\n    keybindSnap = 54,\n    keybindVertical = 56,\n    keybindWallAlign = 53,\n    sensitivity = 15,\n    showGuide = true,\n    initialGroundAlign = true,\n    initialWallAlign = true,\n    snapN = 1\n}\nlocal config = mwse.loadConfig(configId, configDefault)\n\nlocal this = {\n    maxReach = 1.2,\n    holdKeyTime = 0.75,\n    rotateMode = false,\n    snapMode = false,\n    verticalMode = 0,\n    freezeAlign = false,\n    groundAlign = config.initialGroundAlign,\n    wallAlign = config.initialWallAlign\n}\n\nlocal const_epsilon = 0.001\nlocal shadow_offset = 0.05\n\nlocal placeableTypes = {\n    [tes3.objectType.alchemy] = true,\n    [tes3.objectType.ammunition] = true,\n    [tes3.objectType.apparatus] = true,\n    [tes3.objectType.armor] = true,\n    [tes3.objectType.book] = true,\n    [tes3.objectType.clothing] = true,\n    [tes3.objectType.ingredient] = true,\n    [tes3.objectType.light] = true,\n    [tes3.objectType.lockpick] = true,\n    [tes3.objectType.miscItem] = true,\n    [tes3.objectType.probe] = true,\n    [tes3.objectType.repairItem] = true,\n    [tes3.objectType.weapon] = true,\n}\n\nlocal endPlacement -- local function\n\nlocal function wrapRadians(x)\n    return x % (2 * math.pi)\nend\n\nlocal function getKeybindName(scancode)\n    return tes3.findGMST(tes3.gmst.sKeyName_00 + scancode).value\nend\n\n-- Show keybind help overlay.\nlocal function showGuide()\n    local menu = tes3ui.findHelpLayerMenu(this.id_guide)\n    \n    if (menu) then\n        menu.visible = true\n        menu:updateLayout()\n        return\n    end\n\n    menu = tes3ui.createHelpLayerMenu{ id = this.id_guide, fixedFrame = true }\n    menu:destroyChildren()\n    menu.disabled = true\n    menu.absolutePosAlignX = 0.02\n    menu.absolutePosAlignY = 0.04\n    menu.color = {0, 0, 0}\n    menu.alpha = 0.8\n    menu.width = 330\n    menu.autoWidth = false\n    menu.autoHeight = true\n    menu.paddingAllSides = 12\n    menu.paddingLeft = 16\n    menu.paddingRight = 16\n    menu.flowDirection = \"top_to_bottom\"\n\n    local function addLine(line, verb, scancode)\n        local row = menu:createBlock{}\n        row.widthProportional = 1.0\n        row.autoHeight = true\n        row.borderTop = 9\n        row.borderBottom = 9\n        local text = row:createLabel{ text = line }\n        local bind = row:createLabel{ text = verb .. getKeybindName(scancode) }\n        bind.absolutePosAlignX = 1.0\n    end\n    \n    addLine(i18n(\"RotateItem\"), i18n(\"HoldPrefix\"), config.keybindRotate)\n    addLine(i18n(\"VerticalMode\"), \"\", config.keybindVertical)\n    addLine(i18n(\"MatchLast\"), i18n(\"HoldPrefix\"), config.keybindVertical)\n    addLine(i18n(\"OrientToSurface\"), \"\", config.keybindWallAlign)\n    addLine(i18n(\"SnapRotation\"), \"\", config.keybindSnap)\n    addLine(i18n(\"DropItem\"), \"\", config.keybind)\n\n    menu:updateLayout()\nend\n\n-- Set rotation frame and effective height for vertical modes.\nlocal function setVerticalMode(n)\n    local prevHeight = this.height\n    local orient = this.orientation\n    orient.x = -0.5 * math.pi\n    orient.y = tes3.player.orientation.z\n\n    if (n == 1) then\n        orient.z = 0\n        this.height = -this.boundMin.y\n    elseif (n == 2) then\n        orient.z = -0.5 * math.pi\n        this.height = -this.boundMin.x\n    elseif (n == 3) then\n        orient.z = math.pi\n        this.height = this.boundMax.y\n    elseif (n == 4) then\n        orient.z = 0.5 * math.pi\n        this.height = this.boundMax.x\n    end\n\n    this.active.position = this.active.position + tes3vector3.new(0, 0, this.height - prevHeight)\nend\n\n-- Match vertical mode from an orientation.\nlocal function matchVerticalMode(orient, boundMin, boundMax)\n    local absOriX = math.abs(orient.x)\n    if (absOriX > 1.55 and absOriX < 1.59) then\n        local k = math.floor(0.5 + orient.z / (0.5 * math.pi))\n        if (k == 0 or k == 4) then\n            this.verticalMode = 1\n            this.height = -boundMin.y\n        elseif (k == -1 or k == 3) then\n            this.verticalMode = 2\n            this.height = -boundMin.x\n        elseif (k == -2 or k == 2) then\n            this.verticalMode = 3\n            this.height = boundMax.y\n        elseif (k == -3 or k == 1) then\n            this.verticalMode = 4\n            this.height = boundMax.x\n        end\n    else\n        this.verticalMode = 0\n        this.height = -boundMin.z\n    end\nend\n\n-- Called to confirm final placement, drops item to ground if not attaching to wall.\nlocal function finalPlacement()\n    this.shadow_model.appCulled = true\n    this.lastItemOri = this.active.orientation:copy()\n\n    if (not this.wallMount and not this.rotateMode) then\n        -- Match vertical mode to get correct object height after arbitrary rotations.\n        matchVerticalMode(this.orientation, this.boundMin, this.boundMax)\n\n        -- Drop to ground.\n        this.active.sceneNode.appCulled = true\n        local from = this.active.position + tes3vector3.new(0, 0, -this.height + const_epsilon)\n        local rayhit = tes3.rayTest{ position = from, direction = tes3vector3.new(0, 0, -1), returnNormal = true }\n        this.active.sceneNode.appCulled = false\n\n        if (rayhit) then\n            this.active.position = rayhit.intersection + tes3vector3.new(0, 0, this.height + const_epsilon)\n\n            if (this.verticalMode == 0 and this.groundAlign and not this.freezeAlign) then\n                orientModule.orientRef(this.active, rayhit)\n            end\n        end\n    end\n    \n    tes3.playItemPickupSound{ item = this.active.object, pickup = false }\n    endPlacement()\nend\n\n-- Called every simulation frame to reposition the item.\nlocal function simulatePlacement(e)\n    -- Stop if player takes the object.\n    if (this.active.deleted) then\n        endPlacement()\n        return\n    -- Check for glitches.\n    elseif (this.active.sceneNode == nil) then\n        tes3.messageBox{ message = i18n(\"ItemLocationLost\") }\n        this.active.position = this.itemInitialPos\n        this.active.orientation = this.itemInitialOri\n        endPlacement()\n        return\n    -- Drop item if player readies combat or casts a spell.\n    elseif (tes3.mobilePlayer.weaponReady or tes3.mobilePlayer.castReady or tes3.mobilePlayer.actionData.animationAttackState > 1) then\n        finalPlacement()\n        return\n    end\n\n    -- Cast ray along initial pickup direction rotated by the 1st person camera.\n    this.shadow_model.appCulled = true\n    this.active.sceneNode.appCulled = true\n    local ray = tes3.worldController.armCamera.cameraRoot.worldTransform.rotation * this.ray\n    local eye = tes3.getPlayerEyePosition()\n    local rayhit = tes3.rayTest{ position = eye, direction = ray, maxDistance = 800, returnNormal = true }\n    \n    -- Limit holding distance to a maxReach * initial distance.\n    local pos\n    if (rayhit and rayhit.distance <= this.maxReach) then\n        pos = rayhit.intersection:copy()\n    else\n        pos = eye + ray * this.maxReach\n    end\n    -- Add epsilon to ensure the intersection is not inside the model during to floating point precision.\n    pos.z = pos.z + const_epsilon\n\n    -- Item orientation handling.\n    this.wallMount = false\n    if (this.verticalMode == 0) then\n        if (not this.freezeAlign) then\n            -- Ground mode. Check if item is directly touching something.\n            if (rayhit and rayhit.distance <= this.maxReach and this.groundAlign) then\n                -- Orient item to match placement.\n                this.orientation = orientModule.orientRef(this.active, rayhit)\n            else\n                -- Remove any tilt rotation, in an animated manner.\n                local ease = math.max(0.5, 1 - 20 * e.delta)\n                this.orientation.x = ease * this.orientation.x\n                this.orientation.y = ease * this.orientation.y\n                if (math.abs(this.orientation.x) < 0.02) then\n                    this.orientation.x = 0\n                end\n                if (math.abs(this.orientation.y) < 0.02) then\n                    this.orientation.y = 0\n                end\n            end\n        end\n    else\n        -- Vertical mode. Check if the bottom of the model is close to other geometry.\n        local clearance = math.max(2, -this.boundMin.z)\n        ray = tes3vector3.new(clearance * math.sin(this.orientation.y), clearance * math.cos(this.orientation.y), 0)\n        rayhit = tes3.rayTest{ position = pos + ray * -const_epsilon, direction = ray, maxDistance = 2, returnNormal = true }\n        \n        if (rayhit and rayhit.distance < 1) then\n            -- Place at minimum distance outside wall, and optionally align rotation with normal.\n            pos = rayhit.intersection - ray\n            if (this.wallAlign and math.abs(rayhit.normal.z) < 0.2) then\n                this.orientation.y = math.atan2(-rayhit.normal.x, -rayhit.normal.y)\n            end\n            this.wallMount = true\n        end\n    end\n\n    -- Find drop position for shadow spot.\n    local dropPos = pos:copy()\n    rayhit = tes3.rayTest{ position = pos, direction = tes3vector3.new(0, 0, -1) }\n    if (rayhit) then\n        dropPos = rayhit.intersection:copy()\n    end\n\n    -- Get object centre from base point\n    pos.z = pos.z + this.height\n\n    -- Incrementally rotate the same amount as the player, to keep relative alignment with player.\n    local d_theta = tes3.player.orientation.z - this.playerLastOri.z\n    this.playerLastOri = tes3.player.orientation:copy()\n    if (this.rotateMode) then\n        -- Use inputController, as the player orientation is locked.\n        d_theta = 0.001 * config.sensitivity * tes3.worldController.inputController.mouseState.x\n    end\n\n    -- Apply rotation.\n    if (this.verticalMode == 0) then\n        -- Ground plane rotation.\n        this.orientation.z = wrapRadians(this.orientation.z + d_theta)\n    elseif (this.wallMount and this.rotateMode) then\n        -- Wall mount rotation.\n        this.orientation.z = wrapRadians(this.orientation.z + d_theta)\n    else\n        -- Vertical rotation.\n        this.orientation.y = wrapRadians(this.orientation.y + d_theta)\n    end\n\n    -- Rotation snap.\n    local orient = this.orientation:copy()\n    if (this.snapMode) then\n        local quantizer = (0.5 / config.snapN) * math.pi\n        if (this.verticalMode == 0 or this.wallAlign) then\n            orient.z = quantizer * math.floor(0.5 + orient.z / quantizer)\n        else\n            orient.y = quantizer * math.floor(0.5 + orient.y / quantizer)\n        end\n    end\n\n    -- Update item and shadow spot.\n    this.active.sceneNode.appCulled = false\n    this.active.position = pos\n    this.active.orientation = orient\n    this.shadow_model.appCulled = false\n    this.shadow_model.translation = dropPos\n    this.shadow_model:propagatePositionChange()\nend\n\n-- activate event while holding an item.\nlocal function onActivate(e)\n    -- Prevent player from activating anything.\n    return (e.activator ~= tes3.player)\nend\n\n-- cellChanged event handler.\nlocal function cellChanged(e)\n    -- To avoid problems, reset item if moving in or out of an interior cell.\n    if (this.active.cell.isInterior or e.cell.isInterior) then\n        tes3.messageBox{ message = i18n(\"CannotMoveBetweenCells\") }\n        this.active.position = this.itemInitialPos\n        this.active.orientation = this.itemInitialOri\n        endPlacement()\n    end\nend\n\n-- Copy orientation event handler.\nlocal function copyLastOri()\n    if (this.lastItemOri) then\n        this.orientation = this.lastItemOri:copy()\n        this.freezeAlign = true\n        matchVerticalMode(this.orientation, this.boundMin, this.boundMax)\n    end\nend\n\n-- On grabbing / dropping an item.\nlocal function activatePlacement(e)\n    local target = tes3.getPlayerTarget()\n\n    -- Do not operate in menu mode and during attacking/casting.\n    if (tes3.menuMode() or tes3.mobilePlayer.actionData.animationAttackState > 1) then\n        return\n    end\n    \n    if (this.active) then\n        -- Drop item.\n        finalPlacement()\n    elseif (target) then\n        -- Filter by allowed object type.\n        if (not placeableTypes[target.object.objectType]) then\n            return\n        end\n        -- Ownership test.\n        local itemdata = target.attachments.variables\n        if (itemdata and itemdata.owner) then\n            local owner = itemdata.owner\n            if (owner.objectType == tes3.objectType.faction and owner.playerJoined and owner.playerRank >= itemdata.requirement) then\n                -- Player has sufficient faction rank.\n            else\n                tes3.messageBox{ message = i18n(\"OwnedItem\") }\n                return\n            end\n        end\n        -- Workaround to avoid dupe-on-load bug when moving non-persistent refs into another cell.\n        if (target.sourceMod and not target.cell.isInterior) then\n            tes3.messageBox{ message = i18n(\"MustPickUpDropItem\") }\n            return\n        end\n\n        -- Put those hands away.\n        if (tes3.mobilePlayer.weaponReady) then\n            tes3.mobilePlayer.weaponReady = false\n        elseif (tes3.mobilePlayer.castReady) then\n            tes3.mobilePlayer.castReady = false\n        end\n\n        -- Calculate effective bounds including scale.\n        this.boundMin = target.object.boundingBox.min * target.scale\n        this.boundMax = target.object.boundingBox.max * target.scale\n        matchVerticalMode(target.orientation, this.boundMin, this.boundMax)\n\n        -- Get exact ray to selection point, relative to 1st person camera.\n        local eye = tes3.getPlayerEyePosition()\n        local basePos = target.position - tes3vector3.new(0, 0, this.height)\n\n        -- Check if item is attached to a wall.\n        if (this.verticalMode ~= 0) then\n            local attachRay = tes3vector3.new(math.sin(target.orientation.y), math.cos(target.orientation.y), 0)\n            local attachPos = tes3vector3.new(basePos.x + -this.boundMin.z * attachRay.x, basePos.y + -this.boundMin.z * attachRay.y, basePos.z)\n            local rayhit = tes3.rayTest{ position = attachPos + attachRay * -0.5, direction = attachRay, maxDistance = 1, ignore = {target} }\n\n            if (rayhit and rayhit.distance < 1) then\n                -- Adjust basePos to be on the model edge that is touching the wall.\n                basePos = attachPos\n            end\n        end\n\n        this.ray = tes3.worldController.armCamera.cameraRoot.worldTransform.rotation:transpose() * (basePos - eye)\n\n        -- Save initial placement.\n        this.playerLastOri = tes3.player.orientation:copy()\n        this.itemInitialPos = target.position:copy()\n        this.itemInitialOri = target.orientation:copy()\n        this.orientation = target.orientation:copy()\n        this.freezeAlign = false\n\n        this.active = target\n        tes3.playItemPickupSound{ item = target.object }\n\n        -- Add shadow spot to scene.\n        tes3.dataHandler.worldObjectRoot:attachChild(this.shadow_model)\n        this.shadow_model.appCulled = false\n        this.shadow_model.translation = basePos + tes3vector3.new(0, 0, shadow_offset)\n        this.shadow_model:propagatePositionChange()\n\n        event.register(\"simulate\", simulatePlacement)\n        event.register(\"activate\", onActivate)\n        event.register(\"cellChanged\", cellChanged)\n        tes3ui.suppressTooltip(true)\n        \n        if (config.showGuide) then\n            showGuide()\n        end\n    end\nend\n\n-- Clean up placement.\nendPlacement = function()\n    if (this.matchTimer) then\n        this.matchTimer:cancel()\n    end\n    \n    event.unregister(\"simulate\", simulatePlacement)\n    event.unregister(\"activate\", onActivate)\n    event.unregister(\"cellChanged\", cellChanged)\n    tes3ui.suppressTooltip(false)\n    \n    -- this.snapMode is persistent\n    -- this.groundAlign is persistent\n    -- this.wallAlign is persistent\n    this.active = nil\n    this.rotateMode = nil\n    this.verticalMode = 0\n    this.shadow_model.appCulled = true\n    tes3.mobilePlayer.mouseLookDisabled = false\n    \n    local menu = tes3ui.findHelpLayerMenu(this.id_guide)\n    if (menu) then\n        menu:destroy()\n    end\nend\n\n-- End placement on load game. this.active would be invalid after load.\nlocal function onLoad(e)\n    if (this.active) then\n        endPlacement()\n    end\nend\n\nlocal function modeKeyDown(e)\n    if (e.keyCode == config.keybind) then\n        activatePlacement(e)\n    elseif (this.active) then\n        if (e.keyCode == config.keybindRotate) then\n            this.rotateMode = true\n            tes3.mobilePlayer.mouseLookDisabled = true\n        elseif (e.keyCode == config.keybindSnap) then\n            this.snapMode = not this.snapMode\n        elseif (e.keyCode == config.keybindVertical) then\n            this.matchTimer = timer.start({ duration = this.holdKeyTime, callback = copyLastOri })            \n\n            if (this.verticalMode == 0) then\n                this.verticalMode = 1\n                setVerticalMode(this.verticalMode)\n            else\n                this.orientation = tes3.player.orientation:copy()\n                this.height = -this.boundMin.z\n                this.verticalMode = 0\n            end\n        elseif (e.keyCode == config.keybindWallAlign) then\n            if (this.verticalMode == 0) then\n                this.groundAlign = not this.groundAlign\n            else\n                this.wallAlign = not this.wallAlign\n            end\n        end\n    end\nend\n\nlocal function modeKeyUp(e)\n    if (this.active) then\n        if (e.keyCode == config.keybindVertical) then\n            this.matchTimer:cancel()\n        elseif (e.keyCode == config.keybindRotate) then\n            this.rotateMode = false\n            tes3.mobilePlayer.mouseLookDisabled = false\n        end\n    end\nend\n\nlocal function onConfigUpdate()\n    -- Update align mode\n    this.groundAlign = config.initialGroundAlign\n    this.wallAlign = config.initialWallAlign\n\n    -- Update keybinds\n    local menu = tes3ui.findHelpLayerMenu(this.id_guide)\n    if (menu) then\n        menu:destroy()\n        showGuide()\n    end\nend\n\nlocal function onInitialized(mod)\n    local w = tes3.worldController.weatherController\n    this.shadow_model = tes3.loadMesh(\"hrn/shadow.nif\")\n\n    this.id_guide = tes3ui.registerID(\"ObjectPlacement:GuideMenu\")\n    event.register(\"load\", onLoad)\n    event.register(\"keyDown\", modeKeyDown)\n    event.register(\"keyUp\", modeKeyUp)\nend\n\nevent.register(\"initialized\", onInitialized)\n\n\n\n-- ModConfig\n\nlocal modConfig = require(\"hrnchamd.perfectplacement.mcm\")\nmodConfig.modVersion = \"2.1\"\nmodConfig.configId = configId\nmodConfig.config = config\nmodConfig.i18n = i18n\nmodConfig.onConfigUpdate = onConfigUpdate\n\nlocal function registerModConfig()\n    mwse.registerModConfig(\"Perfect Placement\", modConfig)\nend\n\nevent.register(\"modConfigReady\", registerModConfig)\nmwse.log(\"[Perfect Placement] Loaded successfully.\")\n",
    "Perfect Placement-46562-2-1-1630362018\\MWSE\\mods\\hrnchamd\\perfectplacement\\mcm.lua": "local this = {}\n\nlocal textOnOff = { [false] = \"Off\", [true] = \"On\" }\nlocal configSpacing = 17\n\nlocal function createConfigSliderPackage(params)\n    local horizontalBlock = params.parent:createBlock({})\n    horizontalBlock.flowDirection = \"left_to_right\"\n    horizontalBlock.widthProportional = 1.0\n    horizontalBlock.height = 30\n    horizontalBlock.borderBottom = configSpacing\n\n    local label = horizontalBlock:createLabel({ text = params.label })\n    label.absolutePosAlignY = 0.5\n    label.minWidth = 300\n\n    local key = params.key\n    local value = this.config[key] or params.default or 0\n    \n    local sliderLabel = horizontalBlock:createLabel({ text = tostring(value) })\n    sliderLabel.absolutePosAlignY = 0.5\n    sliderLabel.minWidth = 30\n\n    local range = params.max - params.min\n\n    local slider = horizontalBlock:createSlider({ current = value - params.min, max = range, step = params.step, jump = params.jump })\n    slider.absolutePosAlignY = 0.5\n    slider.width = 300\n    slider:register(\"PartScrollBar_changed\", function(e)\n        this.config[key] = slider:getPropertyInt(\"PartScrollBar_current\") + params.min\n        sliderLabel.text = this.config[key]\n        if (params.onUpdate) then\n            params.onUpdate(e)\n        end\n    end)\n\n    return { block = horizontalBlock, label = label, sliderLabel = sliderLabel, slider = slider }\nend\n\nlocal function createOnOffOption(params)\n    local block = params.parent:createBlock{}\n    block.widthProportional = 1.0\n    block.autoHeight = true\n    block.borderBottom = configSpacing\n\n    local label = block:createLabel{ text = params.label }\n    label.absolutePosAlignY = 0.5\n    label.minWidth = 300\n\n    local key = params.key\n    local button = block:createButton{ text = textOnOff[this.config[key]] }\n    button:register(\"mouseClick\", function(e)\n        this.config[key] = not this.config[key]\n        e.source.text = textOnOff[this.config[key]]\n        e.source:getTopLevelMenu():updateLayout()\n    end)\nend\n\nlocal function snapOption(e, n)\n    this.config.snapN = n\n    \n    for i, button in ipairs(this.snapButtons) do\n        if (i == n) then\n            -- Active state\n            this.snapButtons[i].widget.state = 4\n        else\n            -- Normal state\n            this.snapButtons[i].widget.state = 1\n        end\n    end\n\n    this.pane:updateLayout()\nend\n\nlocal function createSnapOption(parent, n, label)\n    local button = parent:createButton{ text = label }\n    button:register(\"mouseClick\", function(e) snapOption(e, n) end)\n    if (n == this.config.snapN) then\n        -- Active state\n        button.widget.state = 4\n    end\n    this.snapButtons[n] = button\nend\n\nlocal function getKeybindName(scancode)\n    return tes3.findGMST(tes3.gmst.sKeyName_00 + scancode).value\nend\n\nlocal function keybindDown(e)\n    if (this.binder) then\n        -- If keycode not ESC\n        if (e.keyCode ~= 1) then\n            this.config[this.binder.configKey] = e.keyCode\n            this.binder.button.text = getKeybindName(e.keyCode)\n            this.onConfigUpdate()\n        end\n        this.binder.button.widget.state = 1\n        this.binder = nil\n        this.pane:updateLayout()\n    end\n    \n    event.unregister(\"keyDown\", keybindDown)\nend\n\nlocal function keybindClick(e, configKey)\n    local alreadyRegistered = false\n    if (this.binder) then\n        this.binder.button.widget.state = 1\n        alreadyRegistered = true\n    end\n    \n    this.binder = { button = e.source, configKey = configKey }\n    e.source.widget.state = 4\n    this.pane:updateLayout()\n\n    if (not alreadyRegistered) then\n        event.register(\"keyDown\", keybindDown)\n    end\nend\n\nlocal function createKeybind(parent, label, configKey)\n    local block = parent:createBlock{}\n    block.widthProportional = 1.0\n    block.autoHeight = true\n    block.borderBottom = 16\n    local keybindLabel = block:createLabel{ text = label }\n    keybindLabel.absolutePosAlignY = 0.5\n    keybindLabel.minWidth = 300\n    local button = block:createButton{ text = getKeybindName(this.config[configKey]) }\n    button:register(\"mouseClick\", function(e) keybindClick(e, configKey) end)\nend\n\nfunction this.onCreate(parent)\n    local i18n = this.i18n\n    local pane = parent:createThinBorder{}\n    pane.widthProportional = 1.0\n    pane.heightProportional = 1.0\n    pane.paddingAllSides = 12\n    pane.flowDirection = \"top_to_bottom\"\n    this.pane = pane\n\n    local subhead1 = pane:createLabel{ text = \"quis nostrum exercitationem ullam corporis suscipit laboriosam\" }\n    subhead1.font = 2\n\n    local header = pane:createLabel{ text = i18n(\"ConfigTitle\", { version = this.modVersion }) }\n    header.color = tes3ui.getPalette(\"header_color\")\n    header.borderAllSides = 12\n\n    local subhead2 = pane:createLabel{ text = \"sed quia consequuntur magni dolores eos\" }\n    subhead2.font = 2\n    subhead2.borderBottom = 12\n\n    local summary = pane:createLabel{ text = i18n(\"ConfigSummary\") }\n    summary.borderBottom = 40\n\n    createOnOffOption{\n        parent = pane,\n        label = i18n(\"ConfigDisplayGuide\"),\n        key = \"showGuide\"\n    }\n\n    createOnOffOption{\n        parent = pane,\n        label = i18n(\"ConfigOrientToGround\"),\n        key = \"initialGroundAlign\"\n    }\n\n    createOnOffOption{\n        parent = pane,\n        label = i18n(\"ConfigOrientToWalls\"),\n        key = \"initialWallAlign\"\n    }\n\n    createConfigSliderPackage{\n        parent = pane,\n        label = i18n(\"ConfigRotateSensitivity\"),\n        key = \"sensitivity\",\n        min = 5,\n        max = 50,\n        step = 1,\n        jump = 2\n    }\n    \n    local optionSnap = pane:createBlock{}\n    optionSnap.widthProportional = 1.0\n    optionSnap.autoHeight = true\n    optionSnap.borderBottom = configSpacing\n    local optionSnapLabel = optionSnap:createLabel{ text = i18n(\"ConfigSnapRotationTo\") }\n    optionSnapLabel.absolutePosAlignY = 0.5\n    optionSnapLabel.minWidth = 300\n    local optionSnap2 = optionSnap:createBlock{}\n    optionSnap2.autoWidth = true\n    optionSnap2.autoHeight = true\n    \n    this.snapButtons = {}\n    createSnapOption(optionSnap2, 1, i18n(\"ConfigSnapDegrees\", { d = 90 }))\n    createSnapOption(optionSnap2, 2, i18n(\"ConfigSnapDegrees\", { d = 45 }))\n    createSnapOption(optionSnap2, 3, i18n(\"ConfigSnapDegrees\", { d = 30 }))\n    createSnapOption(optionSnap2, 4, i18n(\"ConfigSnapDegrees\", { d = 15 }))\n    \n    createKeybind(pane, i18n(\"GrabDropItem\"), \"keybind\")\n    createKeybind(pane, i18n(\"RotateItem\"), \"keybindRotate\")\n    createKeybind(pane, i18n(\"VerticalMode\"), \"keybindVertical\")\n    createKeybind(pane, i18n(\"OrientToSurface\"), \"keybindWallAlign\")\n    createKeybind(pane, i18n(\"SnapRotation\"), \"keybindSnap\")\n\n    pane:updateLayout()\nend\n\nfunction this.onClose(container)\n    if (this.binder) then\n        this.binder = nil\n        event.unregister(\"keyDown\", keybindDown)\n    end\n    \n    mwse.saveConfig(this.configId, this.config)\n    this.onConfigUpdate()\nend\n\nreturn this",
    "Perfect Placement-46562-2-1-1630362018\\MWSE\\mods\\hrnchamd\\perfectplacement\\orient.lua": "--[[\n    Ground orientation functions\n\n    Source: Just Drop It by Merlord\n    Used with permission.\n]]--\n\nlocal this = {}\n\n-- Different steepness limits than Just Drop It.\n-- The limit should still demonstrate the need to change to vertical mode.\nlocal maxSteepnessFlat = 65\nlocal maxSteepnessTall = 5\n\nfunction this.rotationDifference(vec1, vec2)\n    vec1 = vec1:normalized()\n    vec2 = vec2:normalized()\n\n    local axis = vec1:cross(vec2)\n    local norm = axis:length()\n    if norm < 1e-5 then\n        return tes3vector3.new(0, 0, 0)\n    end\n\n    local angle = math.asin(norm)\n    if vec1:dot(vec2) < 0 then\n        angle = math.pi - angle\n    end\n\n    axis:normalize()\n\n    local m = tes3matrix33.new()\n    m:toRotation(-angle, axis.x, axis.y, axis.z)\n    return m:toEulerXYZ()\nend\n\nlocal function isTall(ref)\n    local bb = ref.object.boundingBox\n    local width = bb.max.x - bb.min.x\n    local depth = bb.max.y - bb.min.y\n    local height = bb.max.z - bb.min.z\n    return height > depth or height > width\nend\n\nlocal function getMaxSteepness(ref)\n    return math.rad(isTall(ref) and maxSteepnessTall or maxSteepnessFlat)\nend\n\nfunction this.positionRef(ref, rayResult)\n    if not rayResult then\n        --This only happens when the ref is\n        --beyond the edge of the active cells\n        return false\n    end\n    local bb = ref.object.boundingBox\n    local newZ = rayResult.intersection.z - bb.min.z\n    ref.position = {ref.position.x, ref.position.y, newZ}\nend\n\nfunction this.orientRef(ref, rayResult)\n    local UP = tes3vector3.new(0, 0, 1)\n    local maxSteepness = getMaxSteepness(ref)\n    local newOrientation = this.rotationDifference(UP, rayResult.normal)\n\n    newOrientation.x = math.clamp(newOrientation.x, -maxSteepness, maxSteepness)\n    newOrientation.y = math.clamp(newOrientation.y, -maxSteepness, maxSteepness)\n    newOrientation.z = ref.orientation.z\n\n    ref.orientation = newOrientation\n    return newOrientation\nend\n\nfunction this.getGroundBelowRef(ref)\n    local offset = -ref.object.boundingBox.min.z + 5\n    local rayOri = tes3vector3.new(ref.position.x, ref.position.y, ref.position.z + offset)\n\n    local result = tes3.rayTest{\n        position = rayOri,\n        direction = {0, 0, -1},\n        maxDistance = 800,\n        ignore = {ref},\n        returnNormal = true,\n        useBackTriangles = false,\n    }\n\n    if not result then --look up instead\n        result = tes3.rayTest{\n            position = rayOri,\n            direction = {0, 0, 1},\n            maxDistance = 800,\n            ignore = {ref},\n            returnNormal = true,\n            useBackTriangles = true,\n        }\n    end\n\n    return result\nend\n\nfunction this.orientRefToGround(ref)\n    local result = this.getGroundBelowRef(ref)\n    if result then\n        this.positionRef(ref, result)\n        this.orientRef(ref, result)\n    end\nend\n\nreturn this\n",
    "Perfect Placement-46562-2-1-1630362018\\MWSE\\mods\\hrnchamd\\perfectplacement\\i18n\\eng.lua": "return {\n    [\"RotateItem\"] = \"Rotate item\",\n    [\"VerticalMode\"] = \"Vertical mode cycle\",\n    [\"MatchLast\"] = \"Match last placed item\",\n    [\"OrientToSurface\"] = \"Orient to surface toggle\",\n    [\"SnapRotation\"] = \"Snap rotation toggle\",\n    [\"GrabDropItem\"] = \"Grab / drop item\",\n    [\"DropItem\"] = \"Drop item\",\n    [\"HoldPrefix\"] = \"Hold \",\n\n    [\"ItemLocationLost\"] = \"Item location was lost. Placement reset.\",\n    [\"CannotMoveBetweenCells\"] = \"You cannot move items between cells. Placement reset.\",\n    [\"OwnedItem\"] = \"This item is owned by someone.\",\n    [\"MustPickUpDropItem\"] = \"You must pick up and drop this item first.\",\n\n    [\"ConfigTitle\"] = \"Perfect Placement - from Sun's Reach Laboratorum\\nversion %{version}\",\n    [\"ConfigSummary\"] = \"In first person view, use the [Grab / drop item] key on an item to manipulate it.\",\n    [\"ConfigDisplayGuide\"] = \"Display keybind guide\",\n    [\"ConfigOrientToGround\"] = \"Orient to ground by default\",\n    [\"ConfigOrientToWalls\"] = \"Orient to walls by default\",\n    [\"ConfigRotateSensitivity\"] = \"Rotate mode sensitivity\",\n    [\"ConfigSnapRotationTo\"] = \"Snap rotation mode to nearest\",\n    [\"ConfigSnapDegrees\"] = \"%{d} deg\",\n}"
  }
}