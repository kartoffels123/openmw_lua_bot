{
  "folder_name": "No More Indifferent Actors To Combats (OpenMW)",
  "lua_files": {
    "No More Indifferent Actors To Combats-54711-1-4-1720645195\\scripts\\actors_reaction\\actor_react.lua": "ï»¿local util = require(\"openmw.util\")\nlocal types = require(\"openmw.types\")\nlocal Actor = types.Actor\nlocal nearby = require(\"openmw.nearby\")\nlocal aux_util = require(\"openmw_aux.util\")\nlocal core = require(\"openmw.core\")\nlocal self = require(\"openmw.self\")\nlocal ai = require(\"openmw.interfaces\").AI\n\nlocal async = require(\"openmw.async\")\n\n-- Blacklist to exclude some actors from the scope of this mod.\n-- By default i put the common wildlife creatures.\n-- You can modify this list as you want (you must use the ID of the actor, in lowercase).\nlocal blacklistedActors = {\n\t[\"alit\"] = true,\n\t[\"alit_blighted\"] = true,\n\t[\"alit_diseased\"] = true,\n\t[\"bm_bear_black\"] = true,\n\t[\"bm_bear_brown\"] = true,\n\t[\"bm_frost_boar\"] = true,\n\t[\"bm_wolf_grey\"] = true,\n\t[\"bm_wolf_grey_lvl_1\"] = true,\n\t[\"bm_wolf_red\"] = true,\n\t[\"cliff racer\"] = true,\n\t[\"cliff racer_blighted\"] = true,\n\t[\"cliff racer_diseased\"] = true,\n\t[\"dreugh\"] = true,\n\t[\"guar\"] = true,\n\t[\"guar_feral\"] = true,\n\t[\"guar_pack\"] = true,\n\t[\"kagouti\"] = true,\n\t[\"kagouti_mating\"] = true,\n\t[\"kagouti_blighted\"] = true,\n\t[\"kagouti_diseased\"] = true,\n\t[\"kwama forager\"] = true,\n\t[\"kwama forager blighted\"] = true,\n\t[\"kwama warrior\"] = true,\n\t[\"kwama warrior blighted\"] = true,\n\t[\"kwama warrior shurdan\"] = true,\n\t[\"kwama worker\"] = true,\n\t[\"kwama worker entrance\"] = true,\n\t[\"kwama worker blighted\"] = true,\n\t[\"kwama worker diseased\"] = true,\n\t[\"mudcrab\"] = true,\n\t[\"mudcrab-diseased\"] = true,\n\t[\"mudcrab_hrmudcrabnest\"] = true,\n\t[\"netch_betty\"] = true,\n\t[\"netch_betty_ranched\"] = true,\n\t[\"netch_bull\"] = true,\n\t[\"netch_bull_ranched\"] = true,\n\t[\"nix-hound\"] = true,\n\t[\"nix-hound blighted\"] = true,\n\t[\"rat\"] = true,\n\t[\"rat_cave_fgrh\"] = true,\n\t[\"rat_cave_fgt\"] = true,\n\t[\"rat_blighted\"] = true,\n\t[\"rat_diseased\"] = true,\n\t[\"rat_plague\"] = true,\n\t[\"rat_plague_hall1\"] = true,\n\t[\"rat_plague_hall1a\"] = true,\n\t[\"scrib\"] = true,\n\t[\"scrib blighted\"] = true,\n\t[\"scrib diseased\"] = true,\n\t[\"shalk\"] = true,\n\t[\"shalk_blighted\"] = true,\n\t[\"shalk_diseased\"] = true,\n\t[\"slaughterfish\"] = true,\n\t[\"slaughterfish_small\"] = true,\n}\n\nlocal combatDist\nlocal preTarget\nlocal target_\nlocal targetPos\nlocal goBack, goingBack\nlocal newPos\nlocal startPosition\nlocal actorSpeed = Actor.stats.attributes.speed(self).base\n\nlocal function onSave()\n    return {\n        T = target_,\n        GB = goBack,\n        GoiB = goingBack,\n        NP = newPos,\n        SP = startPosition,\n    }\nend\n\nlocal function onLoad(data)\n\tif data then\n\t\ttarget_ = data.T\n\t\tgoBack = data.GB\n\t\tgoingBack = data.GoiB\n\t\tnewPos = data.NP\n\t\tstartPosition = data.SP\n    \n\t-- correction for old mod versions \"corrupted\" save \n\t\tif data.T == nil then\n\t\t\tif data.SP == nil then\n\t\t\t\tstartPosition = self.position\n\t\t\tend\n\t\t\tif Actor.stats.ai.hello(self).modifier < -500 then\n\t\t\t\ttarget_ = self\n\t\t\tend\n\t\telseif Actor.stats.ai.hello(self).modifier < -1500 then\n\t\t\tActor.stats.ai.hello(self).modifier = Actor.stats.ai.hello(self).modifier + 1000\n\t\t\tActor.stats.attributes.speed(self).modifier = Actor.stats.attributes.speed(self).modifier - actorSpeed\n\t\tend\n\telseif Actor.stats.ai.hello(self).modifier < -500 then\n\t\ttarget_ = self\n\t\tstartPosition = self.position\n\tend\nend\n\nlocal function resetTarget()\n\tif goBack then -- (if actor is going back, i let him 10 more seconds...)\n\t\tgoBack = nil\n\t\tnewPos = nil\n\telse\n\t\ttarget_ = nil\n\t\tai.removePackages(\"Travel\")\n\t\tActor.stats.ai.hello(self).modifier = Actor.stats.ai.hello(self).modifier + 1000\n\t\tActor.stats.attributes.speed(self).modifier = Actor.stats.attributes.speed(self).modifier - actorSpeed\n\t\tgoingBack = nil\n\tend\nend\n\nlocal function TargetTest()\n\tif target_ then\n\t\tasync:newUnsavableSimulationTimer(10, resetTarget) -- every 10s i remove this mod Travel package\n\t\tasync:newUnsavableSimulationTimer(10.1, TargetTest)\n\telse\n\t\tasync:newUnsavableSimulationTimer(1, TargetTest)\n\tend\nend\n\n--local function print_()\n--\tif self.recordId == \"fargoth\"\n--\t or self.recordId == \"indrele rathryon\"\n--\t  or self.recordId == \"vodunius nuccius\"\n--\t   or self.recordId == \"eldafire\"\n--\t    or self.recordId == \"teleri helvi\"\n--\t     or self.recordId == \"darvame hleran\"\n--\t     or self.recordId == \"maurrie aurmine\"\n--\t      or self.recordId == \"imperial guard\" then\n--\t\tprint(self.recordId)\n--\t\tif ai.getActivePackage() then\n--\t\t\tprint(ai.getActivePackage())\n--\t\t\tprint(ai.getActivePackage().type)\n--\t\tend\n--\tend\n--\tasync:newUnsavableSimulationTimer(1, print_)\n--end\n\nasync:newUnsavableSimulationTimer(1, TargetTest)\n--async:newUnsavableSimulationTimer(1, print_)\n\nreturn {\n    engineHandlers = {\n\t\tonLoad = onLoad,\n\t\tonSave = onSave\n    },\n    eventHandlers = {\n        combat_detected = function(e)\n\t\t\n\t\t\tif blacklistedActors[self.recordId]\n\t\t\t or e.aggr.id == self.id or e.vict.id == self.id or Actor.isDead(self)\n\t\t\t or (ai.getActivePackage() ~= nil and ai.getActivePackage().type ~= \"Wander\"\n\t\t\t  and ai.getActivePackage().type ~= \"Unknown\"\n\t\t\t  and (ai.getActivePackage().type ~= \"Travel\" or target_ == nil)) -- (\"or actor has active package other than \"Wander\", \"Unknown\" or this mod \"Travel\" \")\n\t\t\t or goingBack == 1 -- or actor is going back\n\t\t\t or not Actor.isInActorsProcessingRange(e.vict) then -- or defensor isn't in the scene (aggressor is treated below...)\n\t\t\t\treturn\n\t\t\tend\n\t\t\t\n\t\t\tcombatDist = (self.position - e.aggr.position):length() -- distance to the aggressor\n\t\t\t-- Prevention of an undesirable situation\n\t\t\t-- (actor reacts next to the victim despite the fact aggressor is not around):\n\t\t\tif combatDist > 1638 then return end\n\t\t\t\n\t\t\tvictDist = (self.position - e.vict.position):length()\n\t\t\tif victDist < combatDist then\n\t\t\t\tcombatDist = victDist\n\t\t\t\tpreTarget = e.vict\n\t\t\telse\n\t\t\t\tpreTarget = e.aggr\n\t\t\tend\n\t\t\tif combatDist > 1638 -- this combatDist variable is the distance to the nearest of the 2 opponents\n\t\t\t or (target_ and e.aggr ~= target_ and e.vict ~= target_ -- \"or if this is another fight\n\t\t\t  and combatDist + 500 > (self.position - target_.position):length()) then -- but it is not enough close\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t--to change my business with the first one, then...\"\n\t\t\t\t\treturn\n\t\t\tend\n\t\t\t-- Now we know that this actor checks all the conditions, and is going to be moved by this mod\n\n\t\t\tif target_ == nil then\n\t\t\t\t-- an actor don't say hello next to a combat:\n\t\t\t\tActor.stats.ai.hello(self).modifier = Actor.stats.ai.hello(self).modifier - 1000\n\t\t\t\t-- walking (Travel) x 2 to simulate the alarming situation:\n\t\t\t\tActor.stats.attributes.speed(self).modifier = Actor.stats.attributes.speed(self).modifier + actorSpeed\n\t\t\t\tif newPos == nil then\n\t\t\t\t\tstartPosition = self.position\n\t\t\t\t\tnewPos = 1\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\ttarget_ = preTarget\n\n\t\t\tif startPosition == nil then -- correction for old mod versions \"corrupted\" save\n\t\t\t    startPosition = self.position\n\t\t\t    newPos = 1\n\t\t\tend\n\t\t\tif (self.position - startPosition):length() > 4000 then -- \"if actor has moved too far, then...\"\n\t\t\t\tgoBack, goingBack = 1, 1\n\t\t\t\ttargetPos = startPosition\n\t\t\telseif combatDist > 500 then\n\t\t\t\ttargetPos = target_.position\n\t\t\telse -- \"i'm too close from the fight, so...\"\n\t\t\t\ttargetPos = util.vector3(2 * self.position.x - target_.position.x, -- \"...i'm going to\n\t\t\t\t\t\t\t\t\t\t2 * self.position.y - target_.position.y, -- walk away from\n\t\t\t\t\t\t\t\t\t\t2 * self.position.z - target_.position.z) -- the target/fight\"\n\t\t\tend\n\t\t\t\n\t\t\tai.startPackage({\n\t\t\t\ttype = 'Travel',\n\t\t\t\tdestPosition = targetPos,\n\t\t\t\tcancelOther = false,\n\t\t\t\t--isRepeat = true\n\t\t\t})\n        end\n    }\n}\n",
    "No More Indifferent Actors To Combats-54711-1-4-1720645195\\scripts\\actors_reaction\\combat_detection.lua": "local self = require(\"openmw.self\")\nlocal ai = require(\"openmw.interfaces\").AI\nlocal types = require(\"openmw.types\")\nlocal async = require(\"openmw.async\")\n\nlocal nearby = require(\"openmw.nearby\")\n\nlocal activeTarget\n\nlocal function combatDetect()\n\n    async:newUnsavableSimulationTimer(1, combatDetect)\n\n    if types.Actor.stats.dynamic.health(self).current < 1 then\n        return\n    end\n\n\tactiveTarget = ai.getActiveTarget(\"Combat\")\n\n    if activeTarget then\n\t\tfor _, actor in pairs(nearby.actors) do\n\t\t\tactor:sendEvent(\"combat_detected\", {\n\t\t\t\taggr = self, -- the \"aggressor\"\n\t\t\t\tvict = activeTarget, -- the \"victim\"\n\t\t\t})\n\t\tend\n    end\n    \nend\n\nasync:newUnsavableSimulationTimer(1, combatDetect)\n"
  }
}