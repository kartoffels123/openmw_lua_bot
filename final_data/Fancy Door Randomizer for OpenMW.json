{
  "folder_name": "Fancy Door Randomizer for OpenMW",
  "lua_files": {
    "Fancy Door Randomizer v0.9.1-53455-0-9-1-1710167599\\Fancy Door Randomizer\\scripts\\fancy_door_randomizer\\config.lua": "local advTable = require(\"scripts.fancy_door_randomizer.utils.table\")\nlocal stringLib = require(\"scripts.fancy_door_randomizer.utils.string\")\n\n---@class fdr.config\nlocal this = {}\n\nlocal delimiter = \".\"\n\nthis.storageName = \"Settings_fancy_door_randomizer_by_diject\"\n\nthis.prefix = \"fdr_by_diject_\"\n\nthis.version = 1\n\nthis.modes = {\"nearestMode\", \"simpleMode\"}\n\n---@class fdr.configData\nthis.default = {\n    enabled = false,\n    chance = 25,\n    mode = this.modes[1],\n    radius = 2,\n    interval = 24,\n    exitDoor = true,\n    swap = true,\n    allowLockedExit = true,\n    unlockLockedExit = true,\n    untrapExit = false,\n    saveOnFailure = true,\n    inToEx = {\n        toInToEx = true,\n        toInToIn = false,\n        toExToEx = false,\n        toExToIn = false,\n    },\n    inToIn = {\n        toInToEx = false,\n        toInToIn = true,\n        toExToEx = false,\n        toExToIn = false,\n    },\n    exToEx = {\n        toInToEx = false,\n        toInToIn = false,\n        toExToEx = true,\n        toExToIn = false,\n    },\n    exToIn = {\n        toInToEx = false,\n        toInToIn = false,\n        toExToEx = false,\n        toExToIn = true,\n    },\n}\n\n---@type fdr.configData\nthis.data = advTable.deepcopy(this.default)\n\nfunction this.loadData(data)\n    if not data then return end\n    advTable.applyChanges(this.data, data)\nend\n\nfunction this.setValueByString(val, str)\n    local var = this.data\n    local lastName\n    local prevVar\n    for _, varName in ipairs(stringLib.split(str, delimiter)) do\n        if var[varName] ~= nil then\n            lastName = varName\n            prevVar = var\n            var = var[lastName]\n        else\n            return false\n        end\n    end\n    if lastName then\n        if prevVar ~= nil then\n            prevVar[lastName] = val\n        else\n            var[lastName] = val\n        end\n        return true\n    end\n    return false\nend\n\nfunction this.getValueByString(str)\n    local var = this.data\n    for _, varName in pairs(stringLib.split(str, delimiter)) do\n        if var[varName] ~= nil then\n            var = var[varName]\n        else\n            return nil\n        end\n    end\n    return var\nend\n\nfunction this.loadPlayerSettings(storageTable)\n    for name, val in pairs(storageTable) do\n        this.setValueByString(val, name)\n    end\nend\n\nfunction this.getDoorConfigTable(isDoorExterior, isDestinationExterior)\n    local posExterior = isDoorExterior\n    local destExterior = isDestinationExterior\n    if posExterior and destExterior then\n        return this.data.exToEx\n    elseif posExterior and not destExterior then\n        return this.data.exToIn\n    elseif not posExterior and destExterior then\n        return this.data.inToEx\n    elseif not posExterior and not destExterior then\n        return this.data.inToIn\n    end\nend\n\nreturn this",
    "Fancy Door Randomizer v0.9.1-53455-0-9-1-1710167599\\Fancy Door Randomizer\\scripts\\fancy_door_randomizer\\door.lua": "local world = require('openmw.world')\nlocal Door = require('openmw.types').Door\nlocal Lockable = require('openmw.types').Lockable\n\nlocal stringLib = require(\"scripts.fancy_door_randomizer.utils.string\")\n\nlocal this = {}\n\nthis.forbiddenDoorIds = {\n    [\"chargen customs door\"] = true,\n    [\"chargen door captain\"] = true,\n    [\"chargen door exit\"] = true,\n    [\"chargen door hall\"] = true,\n    [\"chargen exit door\"] = true,\n    [\"chargen_cabindoor\"] = true,\n    [\"chargen_ship_trapdoor\"] = true,\n    [\"chargen_shipdoor\"] = true,\n    [\"chargendoorjournal\"] = true,\n}\n\n---@type fdr.doorDB\nthis.storage = nil\n\nfunction this.init(storage)\n    this.storage = storage\nend\n\nfunction this.isExterior(cell)\n    if cell.isExterior or cell:hasTag(\"QuasiExterior\") then\n        return true\n    end\n    return false\nend\n\nlocal function isValidPosition(position)\n    local pos = position\n    return not (pos == nil or (pos.x == 0 and pos.y == 0 and pos.z == 0))\nend\n\n---@param doorData fdr.doorDB\nlocal function fillStorageFromCell(cell, doorData, storage, config)\n    local excludeLocked = not config.data.allowLockedExit\n    for _, door in pairs(cell:getAll(Door)) do\n        local storageData = storage.getData(door.id)\n        if Door.isTeleport(door) and not this.forbiddenDoorIds[door.recordId] and isValidPosition(Door.destPosition(door)) and\n                door.enabled and not (excludeLocked and Lockable.isLocked(door)) and\n                not (storageData and storageData.timestamp + config.data.interval * 3600 > world.getGameTime()) then\n            local posExterior = this.isExterior(door.cell)\n            local destExterior = this.isExterior(Door.destCell(door))\n            if posExterior and destExterior then\n                table.insert(doorData.ExToEx, door)\n            elseif posExterior and not destExterior then\n                table.insert(doorData.ExToIn, door)\n            elseif not posExterior and destExterior then\n                table.insert(doorData.InToEx, door)\n            elseif not posExterior and not destExterior then\n                table.insert(doorData.InToIn, door)\n            end\n        end\n    end\nend\n\n---@param storage fdr.doorDataStorage\nfunction this.fingDoors(storage, config)\n    ---@class fdr.doorDB\n    local out = {InToIn = {}, InToEx = {}, ExToIn = {}, ExToEx = {}}\n    for _, cell in pairs(world.cells) do\n        fillStorageFromCell(cell, out, storage, config)\n    end\n    return out\nend\n\nlocal function findInteriorCells(cell, cellTable, depth)\n    if not depth then depth = 20 end\n    if depth <= 0 then return end\n    for _, door in pairs(cell:getAll(Door)) do\n        if Door.isTeleport(door) then\n            local dest = Door.destCell(door)\n            local cellName = stringLib.getCellName(dest)\n            if not this.isExterior(dest) and not cellTable[cellName] then\n                cellTable[cellName] = dest\n                findInteriorCells(dest, cellTable, depth - 1)\n            end\n        end\n    end\nend\n\nlocal function getExteriorCell(cell, depth, list)\n    if this.isExterior(cell) then\n        return cell\n    else\n        if not depth then depth = 20 end\n        if not list then list = {} end\n        if depth <= 0 then return nil end\n        local res\n        for _, door in pairs(cell:getAll(Door)) do\n            if Door.isTeleport(door) then\n                local dest = Door.destCell(door)\n                local cellName = stringLib.getCellName(dest)\n                if not list[cellName] then\n                    list[cellName] = true\n                    res = getExteriorCell(dest, depth - 1, list)\n                    if res then break end\n                end\n            end\n        end\n        return res\n    end\nend\n\n---@return fdr.doorDB|nil\nfunction this.findDoorsInRange(cell, range, storage, config)\n    ---@class fdr.doorDB\n    local out = {InToIn = {}, InToEx = {}, ExToIn = {}, ExToEx = {}}\n    cell = getExteriorCell(cell)\n    if not cell then return end\n    local cellTable = {}\n    for x = cell.gridX - range, cell.gridX + range do\n        for y = cell.gridY - range, cell.gridY + range do\n            local cl = world.getExteriorCell(x, y)\n            if cl then\n                local cellName = stringLib.getCellName(cl)\n                cellTable[cellName] = cl\n                findInteriorCells(cl, cellTable)\n            end\n        end\n    end\n    for name, cl in pairs(cellTable) do\n        fillStorageFromCell(cl, out, storage, config)\n    end\n    return out\nend\n\nfunction this.getDoorList(door, array)\n    local posExterior = this.isExterior(door.cell)\n    local destExterior = this.isExterior(Door.destCell(door))\n    if posExterior and destExterior then\n        return array.ExToEx\n    elseif posExterior and not destExterior then\n        return array.ExToIn\n    elseif not posExterior and destExterior then\n        return array.InToEx\n    elseif not posExterior and not destExterior then\n        return array.InToIn\n    end\nend\n\nfunction this.getDistance(vec1, vec2)\n    return math.sqrt((vec1.x - vec2.x) ^ 2 + (vec1.y - vec2.y) ^ 2 + (vec1.z - vec2.z) ^ 2)\nend\n\nfunction this.getBackDoor(door)\n    if Door.objectIsInstance(door) and Door.isTeleport(door) and not this.forbiddenDoorIds[door.recordId] then\n        local cell = Door.destCell(door)\n        if not cell then return end\n        local nearestDoor = nil\n        local distance = math.huge\n        local doorDestPos = Door.destPosition(door)\n        for _, cdoor in pairs(cell:getAll(Door)) do\n            if Door.isTeleport(cdoor) then\n                local distBetween = this.getDistance(doorDestPos, cdoor.position)\n                if Door.isTeleport(cdoor) and not this.forbiddenDoorIds[cdoor.recordId] and distBetween < distance then\n                    distance = distBetween\n                    nearestDoor = cdoor\n                end\n            end\n        end\n        return nearestDoor\n    end\nend\n\nreturn this",
    "Fancy Door Randomizer v0.9.1-53455-0-9-1-1710167599\\Fancy Door Randomizer\\scripts\\fancy_door_randomizer\\main.lua": "local doorLib = require(\"scripts.fancy_door_randomizer.door\")\nlocal storage = require(\"scripts.fancy_door_randomizer.storage\")\n\nlocal Door = require('openmw.types').Door\nlocal Lockable = require('openmw.types').Lockable\nlocal Activation = require('openmw.interfaces').Activation\nlocal async = require('openmw.async')\nlocal core = require('openmw.core')\nlocal world = require('openmw.world')\n\nlocal config = require(\"scripts.fancy_door_randomizer.config\")\nlocal configData = config.data\n\nlocal doorsData = nil\n\nlocal function onInit()\n    math.randomseed(os.time())\n    doorLib.init(storage)\n    doorsData = doorLib.fingDoors(storage, config)\nend\n\nlocal function onSave()\n    return {storage = storage.data, config = config.data}\nend\n\nlocal function updateSettings()\n    async:newUnsavableSimulationTimer(0.5, function()\n        if #world.players > 0 then\n            world.players[1]:sendEvent(\"fdrbd_updateSettings\", {configData = config.data})\n        else\n            updateSettings()\n        end\n    end)\nend\n\nlocal function onLoad(data)\n    storage.data = data.storage or {}\n    config.loadData(data.config or {})\n    updateSettings()\n    doorLib.init(storage)\n    doorsData = doorLib.fingDoors(storage, config)\nend\n\nlocal function onNewGame()\n    updateSettings()\nend\n\nlocal function chooseDoorByConfigData(doorData, doorConfig)\n    local table = {}\n    local number = 0\n    for name, val in pairs(doorConfig) do\n        if val then\n            local varName = name:sub(3)\n            if doorData[varName] then\n                number = number + #doorData[varName]\n                table[varName] = number\n            end\n        end\n    end\n    if number > 0 then\n        local rnd = math.random(1, number)\n        for name, num in pairs(table) do\n            if rnd <= num then\n                return doorData[name][1 + num - rnd]\n            end\n        end\n    end\nend\n\nlocal function chooseNewDoor(door)\n    local doorConfig = config.getDoorConfigTable(doorLib.isExterior(door.cell), doorLib.isExterior(Door.destCell(door)))\n    if not doorConfig then return end\n    if configData.mode == config.modes[1] then\n        ---@type fdr.doorDB|nil\n        local db = doorLib.findDoorsInRange(door.cell, configData.radius, storage, config)\n        if not db then return end\n        return chooseDoorByConfigData(db, doorConfig)\n    elseif configData.mode == config.modes[2] then\n        local newDoor\n        for i = 1, 20 do\n            local dr = chooseDoorByConfigData(doorsData, doorConfig)\n            if not dr then goto continue end\n            local bdr = doorLib.getBackDoor(dr)\n            if not bdr then goto continue end\n            if config.data.allowLockedExit or not Lockable.isLocked(dr) then\n                newDoor = dr\n                break\n            end\n            ::continue::\n        end\n        return newDoor\n    end\nend\n\nlocal function changeDoorDestinationAndTeleport(old, new, actor)\n    local pos = Door.destPosition(new)\n    local rot = Door.destRotation(new)\n    local cell = Door.destCell(new)\n    storage.setData(old.id, pos, rot, cell)\n    if configData.swap then\n        storage.setData(new.id, Door.destPosition(old), Door.destRotation(old), Door.destCell(old))\n    end\n    if configData.exitDoor then\n        local toMainDoor = doorLib.getBackDoor(old)\n        local targetDoor = doorLib.getBackDoor(new)\n        if config.data.unlockLockedExit then\n            async:newUnsavableSimulationTimer(2, function()\n                Lockable.unlock(targetDoor)\n            end)\n        end\n        if config.data.untrapExit then\n            async:newUnsavableSimulationTimer(2, function()\n                Lockable.setTrapSpell(targetDoor, nil)\n            end)\n        end\n        storage.setData(targetDoor.id, Door.destPosition(toMainDoor), Door.destRotation(toMainDoor), Door.destCell(toMainDoor))\n        if configData.swap then\n            storage.setData(toMainDoor.id, Door.destPosition(targetDoor), Door.destRotation(targetDoor), Door.destCell(targetDoor))\n        end\n    end\n    actor:teleport(cell, pos, {onGround = true, rotation = rot})\nend\n\nActivation.addHandlerForType(Door,\n    async:callback(function(door, actor)\n        if configData.enabled and Door.isTeleport(door) and not Lockable.isLocked(door) and not Lockable.getTrapSpell(door) and\n                not doorLib.forbiddenDoorIds[door.recordId] then\n            local storageData = storage.getData(door.id)\n            local timeExpired = storageData and storageData.timestamp + configData.interval * 3600 < world.getGameTime()\n            if storageData and not timeExpired then\n                actor:teleport(storageData.cell, storageData.pos, {onGround = true, rotation = storageData.rotAngle})\n                -- return false\n            else\n                local success = configData.chance * 0.01 >= math.random()\n                if success then\n                    local newDestinationDoor = chooseNewDoor(door)\n                    if not newDestinationDoor then return end\n                    changeDoorDestinationAndTeleport(door, newDestinationDoor, actor)\n                    -- return false\n                elseif configData.saveOnFailure then\n                    storage.setData(door.id, Door.destPosition(door), Door.destRotation(door), Door.destCell(door))\n                    if configData.exitDoor then\n                        local toMainDoor = doorLib.getBackDoor(door)\n                        storage.setData(toMainDoor.id, Door.destPosition(toMainDoor), Door.destRotation(toMainDoor), Door.destCell(toMainDoor))\n                    end\n                end\n            end\n        end\n    end)\n)\n\nlocal function loadConfigData(data)\n    config.loadData(data)\nend\n\nreturn {\n    engineHandlers = {\n        onInit = async:callback(onInit),\n        onSave = async:callback(onSave),\n        onLoad = async:callback(onLoad),\n        onNewGame = async:callback(onNewGame),\n    },\n    eventHandlers = {\n        fdrbd_loadConfigData = async:callback(loadConfigData),\n    },\n}",
    "Fancy Door Randomizer v0.9.1-53455-0-9-1-1710167599\\Fancy Door Randomizer\\scripts\\fancy_door_randomizer\\settings.lua": "local storage = require(\"openmw.storage\")\nlocal async = require(\"openmw.async\")\nlocal I = require(\"openmw.interfaces\")\nlocal core = require('openmw.core')\nlocal ui = require('openmw.ui')\nlocal util = require('openmw.util')\n\nlocal config = require(\"scripts.fancy_door_randomizer.config\")\n\nlocal l10nName = \"fancy_door_randomizer\"\n\nlocal randomizationModes = config.modes\n\n---@class fdr.settings.boolSetting\n---@field key string\n---@field name string l10n\n---@field description string|nil l10n\n---@field default boolean|nil\n---@field trueLabel string|nil\n---@field falseLabel string|nil\n---@field disabled boolean|nil\n\n---@class fdr.settings.numberSetting\n---@field key string\n---@field name string l10n\n---@field description string|nil l10n\n---@field default number|nil\n---@field min number|nil\n---@field max number|nil\n---@field integer boolean|nil\n---@field disabled boolean|nil\n\n---@class fdr.settings.textSetting\n---@field name string l10n\n---@field description string|nil l10n\n---@field disabled boolean|nil\n\n---@param args fdr.settings.boolSetting\nlocal function boolSetting(args)\n    return {\n        key = args.key,\n        renderer = \"checkbox\",\n        name = args.name,\n        description = args.description,\n        default = args.default or false,\n        trueLabel = args.trueLabel,\n        falseLabel = args.falseLabel,\n        disabled = args.disabled,\n    }\nend\n\n---@param args fdr.settings.numberSetting\nlocal function numberSetting(args)\n    local data = {\n        key = args.key,\n        renderer = \"number\",\n        name = args.name,\n        description = args.description,\n        default = args.default or 0,\n        min = args.min,\n        max = args.max,\n        integer = args.integer,\n        disabled = args.disabled,\n    }\n    return data\nend\n\n---@param args fdr.settings.textSetting\nlocal function textSetting(args)\n    return {\n        renderer = \"textLine\",\n        name = args.name,\n        description = args.description,\n        disabled = args.disabled,\n    }\nend\n\nlocal function selectSetting(args)\n    return {\n        renderer = \"fdrbd_select\",\n        key = args.key,\n        name = args.name,\n        description = args.description,\n        items = args.items,\n        l10n = args.l10n or l10nName,\n        default = args.default or args.items[1],\n        disabled = args.disabled or false,\n    }\nend\n\n--#####################################################################\n\nlocal storageName = config.storageName\nI.Settings.registerPage({\n    key = storageName,\n    l10n = l10nName,\n    name = \"modName\",\n    description = \"modDescription\",\n})\n\nI.Settings.registerGroup({\n    key = storageName,\n    page = storageName,\n    l10n = l10nName,\n    name = \"mainSettings\",\n    permanentStorage = false,\n    order = 0,\n    settings = {\n        boolSetting({key = \"enabled\", name = \"enabled\", default = config.default.enabled}),\n        numberSetting({key = \"chance\", name = \"chance\", default = config.default.chance}),\n        selectSetting({key = \"mode\", name = \"mode\", items = randomizationModes, default = config.default.mode}),\n        numberSetting({key = \"radius\", name = \"radius\", default = config.default.radius}),\n        numberSetting({key = \"interval\", name = \"interval\", default = config.default.interval}),\n        boolSetting({key = \"saveOnFailure\", name = \"saveOnFailure\", default = config.default.saveOnFailure}),\n        boolSetting({key = \"exitDoor\", name = \"exitDoor\", default = config.default.exitDoor}),\n        boolSetting({key = \"allowLockedExit\", name = \"allowLockedExit\", default = config.default.allowLockedExit}),\n        boolSetting({key = \"unlockLockedExit\", name = \"unlockLockedExit\", default = config.default.unlockLockedExit}),\n        boolSetting({key = \"untrapExit\", name = \"untrapExit\", default = config.default.untrapExit}),\n    },\n})\n\nI.Settings.registerGroup({\n    key = storageName..\"_inToEx\",\n    page = storageName,\n    l10n = l10nName,\n    name = \"inToEx\",\n    permanentStorage = false,\n    order = 1,\n    settings = {\n        boolSetting({key = \"inToEx.toInToEx\", name = \"toInToEx\", default = config.default.inToEx.toInToEx}),\n        boolSetting({key = \"inToEx.toInToIn\", name = \"toInToIn\", default = config.default.inToEx.toInToIn}),\n        boolSetting({key = \"inToEx.toExToEx\", name = \"toExToEx\", default = config.default.inToEx.toExToEx}),\n        boolSetting({key = \"inToEx.toExToIn\", name = \"toExToIn\", default = config.default.inToEx.toExToIn}),\n    },\n})\n\nI.Settings.registerGroup({\n    key = storageName..\"_inToIn\",\n    page = storageName,\n    l10n = l10nName,\n    name = \"inToIn\",\n    permanentStorage = false,\n    order = 2,\n    settings = {\n        boolSetting({key = \"inToIn.toInToEx\", name = \"toInToEx\", default = config.default.inToIn.toInToEx}),\n        boolSetting({key = \"inToIn.toInToIn\", name = \"toInToIn\", default = config.default.inToIn.toInToIn}),\n        boolSetting({key = \"inToIn.toExToEx\", name = \"toExToEx\", default = config.default.inToIn.toExToEx}),\n        boolSetting({key = \"inToIn.toExToIn\", name = \"toExToIn\", default = config.default.inToIn.toExToIn}),\n    },\n})\n\nI.Settings.registerGroup({\n    key = storageName..\"_exToEx\",\n    page = storageName,\n    l10n = l10nName,\n    name = \"exToEx\",\n    permanentStorage = false,\n    order = 3,\n    settings = {\n        boolSetting({key = \"exToEx.toInToEx\", name = \"toInToEx\", default = config.default.exToEx.toInToEx}),\n        boolSetting({key = \"exToEx.toInToIn\", name = \"toInToIn\", default = config.default.exToEx.toInToIn}),\n        boolSetting({key = \"exToEx.toExToEx\", name = \"toExToEx\", default = config.default.exToEx.toExToEx}),\n        boolSetting({key = \"exToEx.toExToIn\", name = \"toExToIn\", default = config.default.exToEx.toExToIn}),\n    },\n})\n\nI.Settings.registerGroup({\n    key = storageName..\"_exToIn\",\n    page = storageName,\n    l10n = l10nName,\n    name = \"exToIn\",\n    permanentStorage = false,\n    order = 4,\n    settings = {\n        boolSetting({key = \"exToIn.toInToEx\", name = \"toInToEx\", default = config.default.exToIn.toInToEx}),\n        boolSetting({key = \"exToIn.toInToIn\", name = \"toInToIn\", default = config.default.exToIn.toInToIn}),\n        boolSetting({key = \"exToIn.toExToEx\", name = \"toExToEx\", default = config.default.exToIn.toExToEx}),\n        boolSetting({key = \"exToIn.toExToIn\", name = \"toExToIn\", default = config.default.exToIn.toExToIn}),\n    },\n})\n\nI.Settings.updateRendererArgument(storageName, \"chance\", {min = 0, max = 100})\nI.Settings.updateRendererArgument(storageName, \"interval\", {min = 0, max = 999999999, integer = true})\nI.Settings.updateRendererArgument(storageName, \"radius\", {min = 1, max = 100, integer = true})\n\nlocal mainStorage = storage.playerSection(storageName)\n\nlocal function updateConfig()\n    config.loadPlayerSettings(storage.playerSection(storageName):asTable())\n    config.loadPlayerSettings(storage.playerSection(storageName..\"_inToEx\"):asTable())\n    config.loadPlayerSettings(storage.playerSection(storageName..\"_inToIn\"):asTable())\n    config.loadPlayerSettings(storage.playerSection(storageName..\"_exToEx\"):asTable())\n    config.loadPlayerSettings(storage.playerSection(storageName..\"_exToIn\"):asTable())\n    core.sendGlobalEvent(\"fdrbd_loadConfigData\", config.data)\nend\n\nlocal function updateMainSettings()\n    local mode = mainStorage:get(\"mode\")\n    I.Settings.updateRendererArgument(storageName, \"radius\", {disabled = mode ~= \"nearestMode\", min = 1, max = 100, integer = true})\n    local exitDoor = mainStorage:get(\"exitDoor\")\n    I.Settings.updateRendererArgument(storageName, \"allowLockedExit\", {disabled = not exitDoor})\n    I.Settings.updateRendererArgument(storageName, \"unlockLockedExit\", {disabled = not exitDoor})\n    updateConfig()\nend\n\nupdateMainSettings()\n\nmainStorage:subscribe(async:callback(updateMainSettings))\nstorage.playerSection(storageName..\"_inToEx\"):subscribe(async:callback(updateConfig))\nstorage.playerSection(storageName..\"_inToIn\"):subscribe(async:callback(updateConfig))\nstorage.playerSection(storageName..\"_exToEx\"):subscribe(async:callback(updateConfig))\nstorage.playerSection(storageName..\"_exToIn\"):subscribe(async:callback(updateConfig))",
    "Fancy Door Randomizer v0.9.1-53455-0-9-1-1710167599\\Fancy Door Randomizer\\scripts\\fancy_door_randomizer\\storage.lua": "local world = require('openmw.world')\nlocal util = require('openmw.util')\n\n---@class fdr.doorDataStorage\nlocal this = {}\n\n---@class vector3\n---@field x number\n---@field y number\n---@field z number\n\n---@class cellData\n---@field name string\n---@field gridX integer\n---@field gridY integer\n\n---@class fdr.doorStorageObject\n---@field pos vector3\n---@field rotAngle number\n---@field cell cellData\n---@field timestamp integer\n\n---@type table<string, fdr.doorStorageObject>\nthis.data = {}\n\nfunction this.getRawData(doorId)\n    return this.data[doorId]\nend\n\n---@return fdr.doorStorageObject|nil\nfunction this.getData(doorId)\n    local data = this.data[doorId]\n    if data then\n        local cell = data.cell.name == \"\" and world.getExteriorCell(data.cell.gridX, data.cell.gridY) or world.getCellByName(data.cell.name)\n        local pos = util.vector3(data.pos.x, data.pos.y, data.pos.z)\n        local rot = util.transform.rotateZ(data.rotAngle)\n        local timestamp = data.timestamp\n        return {cell = cell, pos = pos, rotAngle = rot, timestamp = timestamp}\n    end\n    return nil\nend\n\n---@param doorId string\n---@param pos vector3\n---@param rotAngle number\n---@param cell cellData\n---@param timestamp integer\nfunction this.setRawData(doorId, pos, rotAngle, cell, timestamp)\n    ---@type fdr.doorStorageObject\n    local data = {cell = cell, pos = pos, rotAngle = rotAngle, timestamp = timestamp}\n    this.data[doorId] = data\nend\n\nfunction this.setData(doorId, pos, rot, cell)\n    ---@type fdr.doorStorageObject\n    local data = {cell = {name = cell.name, gridX = cell.gridX, gridY = cell.gridY}, pos = {x = pos.x, y = pos.y, z = pos.z},\n        rotAngle = rot:getYaw(), timestamp = world.getGameTime()}\n    this.data[doorId] = data\nend\n\nfunction this.clearData(doorId)\n    this.data[doorId] = nil\nend\n\nreturn this",
    "Fancy Door Randomizer v0.9.1-53455-0-9-1-1710167599\\Fancy Door Randomizer\\scripts\\fancy_door_randomizer\\local\\player.lua": "local storage = require('openmw.storage')\nlocal async = require('openmw.async')\n\nlocal localConfigLib = require(\"scripts.fancy_door_randomizer.config\")\nlocal storageName = localConfigLib.storageName\n\nreturn {\n    eventHandlers = {\n        fdrbd_updateSettings = async:callback(function(data)\n            local configData = data.configData\n            if not configData then return end\n            localConfigLib.data = configData\n            local function filStorage(storageSection)\n                for name, val in pairs(storageSection:asTable()) do\n                    local confVal = localConfigLib.getValueByString(name)\n                    if confVal ~= nil and confVal ~= val then\n                        storageSection:set(name, confVal)\n                    end\n                end\n            end\n            filStorage(storage.playerSection(storageName))\n            filStorage(storage.playerSection(storageName..\"_inToEx\"))\n            filStorage(storage.playerSection(storageName..\"_inToIn\"))\n            filStorage(storage.playerSection(storageName..\"_exToEx\"))\n            filStorage(storage.playerSection(storageName..\"_exToIn\"))\n            require(\"scripts.fancy_door_randomizer.settings\")\n        end),\n    },\n}",
    "Fancy Door Randomizer v0.9.1-53455-0-9-1-1710167599\\Fancy Door Randomizer\\scripts\\fancy_door_randomizer\\renderers\\select.lua": "local I = require(\"openmw.interfaces\")\nlocal core = require('openmw.core')\nlocal ui = require('openmw.ui')\nlocal async = require(\"openmw.async\")\n\nlocal config = require(\"scripts.fancy_door_randomizer.config\")\n\nlocal l10nName = \"fancy_door_randomizer\"\n\nlocal randomizationModes = config.modes\n\nlocal function disable(disabled, layout)\n    if disabled then\n        return {\n            template = I.MWUI.templates.disabled,\n            content = ui.content {\n                layout,\n            },\n        }\n    else\n        return layout\n    end\nend\n\nlocal function paddedBox(layout)\n    return {\n        template = I.MWUI.templates.box,\n        content = ui.content {\n            {\n                template = I.MWUI.templates.padding,\n                content = ui.content { layout },\n            },\n        }\n    }\nend\n\nI.Settings.registerRenderer('fdrbd_select', function(value, set, argument)\n    local default = {\n        disabled = false,\n        l10n = l10nName,\n        items = randomizationModes,\n    }\n    if not argument then\n        argument = default\n    end\n    local l10n = core.l10n(argument.l10n)\n    local index = nil\n    local itemCount = 0\n    for i, item in ipairs(argument.items) do\n        itemCount = itemCount + 1\n        if item == value then\n            index = i\n        end\n    end\n    if not index then return {} end\n    local label = l10n(value)\n    local body = {\n        type = ui.TYPE.Flex,\n        props = {\n            horizontal = true,\n            arrange = ui.ALIGNMENT.Center,\n        },\n        content = ui.content {\n            { template = I.MWUI.templates.interval },\n            {\n                template = I.MWUI.templates.textNormal,\n                props = {\n                    text = label,\n                },\n                external = {\n                    grow = 1,\n                },\n                events = {\n                    mouseClick = async:callback(function()\n                        index = (index) % itemCount + 1\n                        set(argument.items[index])\n                    end),\n                },\n            },\n            { template = I.MWUI.templates.interval },\n        },\n    }\n    return disable(argument.disabled, paddedBox(body))\nend)",
    "Fancy Door Randomizer v0.9.1-53455-0-9-1-1710167599\\Fancy Door Randomizer\\scripts\\fancy_door_randomizer\\utils\\string.lua": "local this = {}\n\nfunction this.getCellName(cell)\n    if cell.name ~= \"\" then\n        return cell.name\n    else\n        return tostring(cell.gridX)..\", \"..tostring(cell.gridY)\n    end\nend\n\n-- https://stackoverflow.com/questions/1426954/split-string-in-lua\nfunction this.split(str, separator)\n    local tb={}\n    for s in string.gmatch(str, \"([^\"..separator..\"]+)\") do\n            table.insert(tb, s)\n    end\n    return tb\nend\n\nreturn this",
    "Fancy Door Randomizer v0.9.1-53455-0-9-1-1710167599\\Fancy Door Randomizer\\scripts\\fancy_door_randomizer\\utils\\table.lua": "local this = {}\n\nfunction this.deepcopy(orig)\n    local orig_type = type(orig)\n    local copy\n    if orig_type == 'table' then\n        copy = {}\n        for orig_key, orig_value in next, orig, nil do\n            copy[this.deepcopy(orig_key)] = this.deepcopy(orig_value)\n        end\n        setmetatable(copy, this.deepcopy(getmetatable(orig)))\n    else\n        copy = orig\n    end\n    return copy\nend\n\nfunction this.copy(orig)\n    local out = {}\n    for i, val in pairs(orig) do\n        if type(val) == \"userdata\" or type(val) == \"table\" then\n            out[i] = this.copy(val)\n        else\n            out[i] = val\n        end\n    end\n    return out\nend\n\nfunction this.addMissing(toTable, fromTable)\n    for label, val in pairs(fromTable) do\n        if type(val) == \"table\" then\n            if toTable[label] == nil then\n                toTable[label] = this.deepcopy(val)\n            else\n                if type(toTable[label]) ~= \"table\" then toTable[label] = {} end\n                this.addMissing(toTable[label], val)\n            end\n        elseif toTable[label] == nil then\n            toTable[label] = val\n        end\n    end\nend\n\nfunction this.applyChanges(toTable, fromTable)\n    for label, val in pairs(fromTable) do\n        if type(val) == \"table\" then\n            if toTable[label] == nil then\n                toTable[label] = this.deepcopy(val)\n            else\n                if type(toTable[label]) ~= \"table\" then toTable[label] = {} end\n                this.applyChanges(toTable[label], val)\n            end\n        else\n            toTable[label] = val\n        end\n    end\nend\n\n---@param to table\n---@param from table|nil\nfunction this.addTableValuesToTable(to, from)\n    if not to then return end\n    for _, val in pairs(from or {}) do\n        table.insert(to, val)\n    end\nend\n\nreturn this"
  }
}